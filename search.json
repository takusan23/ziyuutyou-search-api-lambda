[{"title":"データプラン弱者集合。PWAでオフラインに対応させる","link":"/posts/akashic_engine_pwa_cache/","markdown":"\r\n今月はあんまりモバイルデータ使ってないですね。\r\n\r\n# 本題\r\nPWAのキャッシュ機能でオフラインでも見れるサイトができたので書きたいと思います。  \r\n\r\n今回は**Akashic Engine**で作ったゲームをPWAに対応させてオフラインでも遊べるようにしたいと思います。  \r\n別にAkashic Engineじゃなくても良いですが\r\n\r\nちなみにこのサイトはnuxt.jsにPWA関係を任せているので特に何もせずに動いてます。\r\n\r\n\r\n*PWA+Cacheでモバイルデータを節約するぞ*\r\n\r\nPWAが何をするのかは各自で調べてください（え\r\n\r\n# 今回使うサイトは\r\n- ソースコード\r\n    - https://github.com/takusan23/AkashicEngine-FlappyBird\r\n- Netlifyに公開した完成品はこちら\r\n    - https://game-akashic-bird.negitoro.dev/\r\n    - PWAのインストールボタンが出てくるはず。\r\n\r\nこれ。前のブログのおまけで使ってたやつ[^1]\r\n\r\n# 用意するもの\r\n- PWA化したいサイトのソース\r\n    - htmlとか画像とかjsとかな\r\n- PWA化したときのアイコン\r\n    - 192x192の大きさと512x512の大きさが必要らしいです。\r\n- Webサーバー建てる拡張機能。別にこれ以外でも良い\r\n    - https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=ja\r\n- やる気。諦めないぞというお気持ち\r\n    - PWA厳しい\r\n- 今回はNetlifyで公開する\r\n    - GitHub Pagesだと話が変わってくると思う。\r\n\r\n# HTMLを用意する\r\nもうすでにhtmlを持ってる方は良いです。  \r\n今回私はAkashic EngineをHTML形式に書き出さないといけないので以下を実行\r\n\r\n```console\r\nakashic export html --bundle --magnify --minify --output export\r\n```\r\n\r\n`--minify`を指定して必要なファイルを極限まで減らします。\r\n\r\nこれでHTMLを用意できました。  \r\n![Imgur](https://imgur.com/f4QhGBO.png)\r\n\r\n**あとは生成されたHTMLファイルの`<title>`を書き換えて名前を変えましょう**\r\n\r\n# ServiceWorker\r\n~~Hello, Worker~~  \r\n\r\n## sw.jsを置く\r\nindex.htmlのあるところに`sw.js`を作成します。  \r\n中身はとりあえず空のままでいいです。\r\n\r\n## iconsフォルダを置く\r\n`sw.js`と同じ感じで同じ場所に`icons`フォルダを作成します。  \r\n中には、`192x192`の大きさのアイコン画像と`512x512`の大きさのアイコン画像を入れます。  \r\n名前はそれぞれ以下のようにします。\r\n- `icon_192.png`\r\n- `icon_512.png`\r\n\r\n## manifest.jsonを置く\r\n`sw.js`と同じ感じで同じ場所に`manifest.json`を作成します。  \r\nそして以下の内容を入れます\r\n\r\n```json\r\n{\r\n    \"name\": \"Akashic Engine Flappy Bird\",\r\n    \"short_name\": \"Akashic Bird\",\r\n    \"icons\": [\r\n        {\r\n            \"src\": \"/icons/icon_192.png\",\r\n            \"sizes\": \"192x192\",\r\n            \"type\": \"image/png\"\r\n        },\r\n        {\r\n            \"src\": \"/icons/icon_512.png\",\r\n            \"sizes\": \"512x512\",\r\n            \"type\": \"image/png\"\r\n        }\r\n    ],\r\n    \"start_url\": \"/index.html\",\r\n    \"display\": \"standalone\",\r\n    \"background_color\": \"#FFFFFF\",\r\n    \"theme_color\": \"#FFFFFF\"\r\n}\r\n```\r\n\r\n最低限、\r\n- `name`\r\n    - なまえ\r\n- `short_name`\r\n    - アプリ一覧で表示される名前\r\n\r\nを書き換えればいいと思います。\r\n\r\n## ServiceWorker登録\r\n`index.html`を開きます。  \r\n開いたら、head内に以下のように書きます。  \r\nよくわからない場合は`<title>`の下辺りに書いておけばいいと思います。\r\n\r\n```html\r\n<!-- ウェブアプリマニフェストの読み込み -->\r\n<link rel=\"manifest\" href=\"manifest.json\">\r\n<!-- さーびすわーかー -->\r\n<script>\r\n    if (\"serviceWorker\" in navigator) {\r\n        navigator.serviceWorker\r\n            .register(\"sw.js\")\r\n            .then(() => console.log(\"registered service worker!\"));\r\n    }\r\n</script>\r\n```\r\n\r\n# ここまででできたファイル\r\n`image`フォルダ以外はみんなあるよね？  \r\n![Imgur](https://imgur.com/ffmuHM6.png)\r\n\r\n# sw.jsを書く\r\nsw.js白紙だとインストールのためのバナー（ホーム画面に {アプリ名} を追加）すら出ない模様。  \r\n\r\n## キャッシュしなければいけないファイルを並べる\r\nここでファイル名を間違えるとキャッシュ取得諦めるのでちゃんと書きましょう。先生が生徒の名前間違えないようにするみたいな感じで\r\n\r\n```js\r\n// キャッシュしないといけないファイルを列挙する。間違えないように\r\nconst CACHE_LIST = [\r\n    \"/icons/icon_192.png\",\r\n    \"/icons/icon_512.png\",\r\n    \"/image/play.png\",\r\n    \"/image/result.png\",\r\n    \"/image/title.png\",\r\n    \"/image/tori.png\",\r\n    \"index.html\",\r\n    \"manifest.json\",\r\n    \"/\"\r\n]\r\n```\r\n\r\n## キャッシュに付ける名前\r\n多分識別に使うと思います。同じ名前だったら取得しない、名前が変わっていたら再度取り直すみたいな感じだと思います。  \r\n\r\nキャッシュ取得し直したい場合はここの値を変えることで再度取り直してくれます。\r\n\r\n```js\r\n// バージョンの名前。識別に使う\r\nconst VERSION_NAME = 'bird_20200627' // ここの値が変わるとキャッシュを再登録するっぽい？\r\n```\r\n\r\n## `install` イベント\r\nコピペで行けると思います。\r\n```js\r\n// インストール時に\r\nself.addEventListener('install', event => {\r\n    console.log('インストールするぞ')\r\n    event.waitUntil(\r\n        caches.open(VERSION_NAME).then(cache => {\r\n            return cache.addAll(CACHE_LIST) // キャッシュ登録\r\n        }).catch(err => { console.log(err) }) // えらー\r\n    )\r\n})\r\n```\r\n\r\n## リクエスト横取り\r\nインターネットに画像リクエストしよー  \r\n↓  \r\nServiceWorkerが検知  \r\n↓  \r\nキャッシュがあればキャッシュを返す\r\n\r\nこれを書きます。\r\n\r\n```js\r\n// リクエストを横取りする\r\nself.addEventListener('fetch', event => {\r\n    // キャッシュの内容に置き換える\r\n    event.respondWith(\r\n        caches.match(event.request).then(function (response) {\r\n            return response || fetch(event.request);\r\n        })\r\n    );\r\n})\r\n```\r\n\r\n## 古いキャッシュを消す\r\n**キャッシュに付ける名前**の項目で、キャッシュを再度取り直してくれますなど言いましたが、これ勝手には消してくれないので消してくれるコードです。\r\n\r\n```js\r\n// 古いキャッシュを消す。\r\nself.addEventListener('activate', function (event) {\r\n    event.waitUntil(\r\n        caches.keys().then(function (cacheNames) {\r\n            return Promise.all(\r\n                cacheNames.filter(function (cacheName) {\r\n                    return cacheName !== VERSION_NAME;\r\n                }).map(function (cacheName) {\r\n                    return caches.delete(cacheName);\r\n                })\r\n            );\r\n        })\r\n    );\r\n});\r\n```\r\n\r\n# ここまでのsw.js\r\n\r\n```js\r\n// キャッシュしないといけないファイルを列挙する。間違えないように\r\nconst CACHE_LIST = [\r\n    \"/icons/icon_192.png\",\r\n    \"/icons/icon_512.png\",\r\n    \"/image/play.png\",\r\n    \"/image/result.png\",\r\n    \"/image/title.png\",\r\n    \"/image/tori.png\",\r\n    \"index.html\",\r\n    \"manifest.json\",\r\n    \"/\"\r\n]\r\n\r\n// バージョンの名前。識別に使う\r\nconst VERSION_NAME = 'bird_20200627' // ここの値が変わるとキャッシュを再登録するっぽい？\r\n\r\n// インストール時に\r\nself.addEventListener('install', event => {\r\n    console.log('インストールするぞ')\r\n    event.waitUntil(\r\n        caches.open(VERSION_NAME).then(cache => {\r\n            return cache.addAll(CACHE_LIST) // キャッシュ登録\r\n        }).catch(err => { console.log(err) }) // えらー\r\n    )\r\n})\r\n\r\n// リクエストを横取りする\r\nself.addEventListener('fetch', event => {\r\n    // キャッシュの内容に置き換える\r\n    event.respondWith(\r\n        caches.match(event.request).then(function (response) {\r\n            return response || fetch(event.request);\r\n        })\r\n    );\r\n})\r\n\r\n// 古いキャッシュを消す。\r\nself.addEventListener('activate', function (event) {\r\n    event.waitUntil(\r\n        caches.keys().then(function (cacheNames) {\r\n            return Promise.all(\r\n                cacheNames.filter(function (cacheName) {\r\n                    return cacheName !== VERSION_NAME;\r\n                }).map(function (cacheName) {\r\n                    return caches.delete(cacheName);\r\n                })\r\n            );\r\n        })\r\n    );\r\n});\r\n```\r\n\r\n# Web Server for Chrome を開いて\r\n`CHOOSE FOLDER`を押して、`index.html`のあるフォルダを指定します。  \r\nそしたら`Web Server`のスイッチを押して起動させます。 \r\n\r\n起動できたら、`http://127.0.0.1`から始まるURLが`Web Server URL(s)`の下に表示されるので押します。するとWebページが表示されるようになるんですね～\r\n\r\nそしたらWebページを開いた状態で`F12`おして`Application`タブを押します。\r\n\r\nその中から`Cache Storage`を探して、キャッシュが取得できてるか確認しましょう。\r\n\r\n![Imgur](https://i.imgur.com/PWEuyxl.png)\r\n\r\nこのように登録されていれば完成です。おめ！\r\n\r\nちなみに：本当なら`index.html`をブラウザで開くだけで見れるわけですが、Service Workerを動かすためにはURLが `https`で始まるか`localhost（127.0.0.1）`で始まる必要があるようです。  \r\nだから**Web Server for Chrome**を利用する必要があったのですね。\r\n\r\n# 本当にオフラインで動くの？\r\n\r\n`Service Worker`を押して、`Offline`にチャックを入れます。  \r\n入れた後に再読み込みしても表示されている場合は動いてます。\r\n\r\n![Imgur](https://i.imgur.com/Bjjxnvm.png)\r\n\r\n# Netlifyで公開\r\nもう一回タイトル見てください。データプラン弱者がなんとかとか書いてあります。そうスマホで見れないと意味がないんですよ。\r\n\r\nというわけでNetlifyで公開します。  \r\nアカウントは各自作成してください。この記事に辿り着くってことはそれなりの知識があるはずです。  \r\n\r\n## Netlify Drop\r\nなんか`index.html`なんかが入ったフォルダをブラウザに投げるだけで公開できるらしい。\r\n\r\nというわけで`index.html sw.js manifest.json`もろもろ入ってるフォルダをNetlifyのサイトに投げましょう。この方法ならGitHubを経由すること無く公開できます。\r\n\r\n![Imgur](https://i.imgur.com/wCFDJiW.png)\r\n\r\n## Site Settings > Change site name からURLを変更\r\n`https:// {自由に決められる} .netlify.app`の自由に決められるの部分なら、自由に変更可能です。\r\n\r\n![Imgur](https://i.imgur.com/911F4E7.png)\r\n\r\n自分の持ってるドメインを設定する場合は前に書きました→ [Google Domainsでドメイン買った](/posts/domain_katta)\r\n\r\n以上です。  \r\n今回できたサイトはこちら。→ https://game-akashic-bird.negitoro.dev/\r\n# おわりに\r\nところで今の所通信制限かかったことは無いと思われ\r\n\r\n![Imgur](https://i.imgur.com/q8X1FOT.png)\r\n\r\n# 参考にしました\r\nhttps://qiita.com/masanarih0ri/items/0845f312cff5c8d0ec60  \r\nhttps://www.simicart.com/blog/pwa-offline/  \r\n\r\n[^1]:Nuxt.jsでHTML貼るのってどうすりゃいいんだ？"},{"title":"Android 11 のデバイスコントロールAPIを試す","link":"/posts/android11_devicecontrol/","markdown":"\r\nAndroid 11 Beta きたぞおおおおおおおおお   \r\n🥳←これすき\r\n\r\n# 追記：2020/06/13\r\nGoogle Payが使えないと言いました。が、Suicaで電車に乗れたので多分**おｻｲﾌｹｰﾀｲ**アプリでは対応していない**NFC Pay**あたりが使えないんだと思います。  \r\nFelica使う系は多分行けるんじゃないですかね？\r\n\r\nあとスライダー(RangeTemplate)動いたのでそれも\r\n\r\n# 本題\r\nAndroid 11 Beta 1 来ました。  \r\nわたし的に楽しみにしてる機能は\r\n- Device Control API (正式名称しらん)\r\n    - 証明のON/OFFとか明るさスライダーなど\r\n    - Quick Settings のスマートホーム版\r\n    - **スマートホームなんて金かかるからやらないと思う（よって使わない）**\r\n- Dynamic Intent Filter\r\n- Wi-Fi経由のADB\r\n    - カスROMには前からあるって？\r\n    - 公式で対応なんですよ！！！\r\n- Bubble\r\n    - **他のアプリに重ねて表示**が年々厳しくなってるので（最近、設定アプリの上に表示できなくなった）代替。\r\n    - ポップアップ再生の代替にはならなそう。あくまでメッセージアプリ向けなのかな。\r\n\r\n## Android 11 Beta入れようとしている各位\r\nGoogle Pay 使えなくなるらしいよ。DP4の段階では使えたんだけどまた使えなくなった。  \r\n![Imgur](https://imgur.com/r914HON.png)  \r\nSuica使えるんかな？  \r\n\r\n# Device Control API を試す\r\n**スマートホームなんてする予定なけど**せっかくBeta版の登場と一緒にAPIが文書化されてるので試しに追加してみる。\r\n\r\n[ドキュメント](https://developer.android.com/preview/features/device-control)\r\n\r\n# 環境\r\n|なまえ|あたい|\r\n|---|---|\r\n|言語|Kotlin|\r\n|Android|11 Beta 1|\r\n|端末|Pixel 3 XL|\r\n\r\n## Android R Betaの環境を揃えます。\r\nSDK Manager開いて、SDK Platformsタブを押して、**Android 10.0+(R)**にチェックを入れて**Apply**押してダウンロードしましょう。\r\n\r\n# build.gradle\r\n## バージョン\r\n```gradle\r\nandroid {\r\n    compileSdkVersion 30\r\n    buildToolsVersion \"29.0.3\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.devicecontrolstest\"\r\n        minSdkVersion 30\r\n        targetSdkVersion 30\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`compileSdkVersion 30`と`targetSdkVersion 30`になってればいいと思います。多分\r\n\r\n## ライブラリいれる\r\nドキュメントがRxJava入れてることを前提にしているので私も入れます。  \r\nRxJavaなんて使ったことないんだけどね。\r\n```gradle\r\ndependencies {\r\n    implementation 'org.reactivestreams:reactive-streams:1.0.3'\r\n    implementation 'io.reactivex.rxjava2:rxjava:2.2.0'\r\n}\r\n```\r\n\r\n# AndroidManifest書く\r\nおまじないです。\r\n```xml\r\n<service\r\n    android:name=\".DeviceControlsService\"\r\n    android:label=\"@string/app_name\"\r\n    android:permission=\"android.permission.BIND_CONTROLS\">\r\n    <intent-filter>\r\n        <action android:name=\"android.service.controls.ControlsProviderService\" />\r\n    </intent-filter>\r\n</service>\r\n```\r\n\r\n# DeviceControlsService っていうサービス作成\r\n`DeviceControlsService.kt`を作成します。  \r\n作成したら、`ControlsProviderService()`を継承します。\r\n```kotlin\r\nclass DeviceControlsService : ControlsProviderService() {\r\n    override fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\r\n\r\n    }\r\n\r\n    override fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\r\n\r\n    }\r\n\r\n    override fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\r\n\r\n    }\r\n}\r\n```\r\n\r\nでもこのままだと返り値なにもないのでIDEが赤いなみなみ出すので今から書いていきましょう。\r\n\r\n## 利用可能コントローラーの一覧を用意する\r\nこれから追加可能コントローラーを作っていきます。  \r\nここからユーザーが選ぶわけですね。  \r\n`createPublisherForAllAvailable()`に書いていきます。\r\n```kotlin\r\n// 追加するデバイスのID\r\nval TOGGLE_BUTTON_ID = \"toggle_button_id\"\r\n/**\r\n * 追加可能コントローラーを用意する。\r\n * */\r\noverride fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\r\n    // コントローラーを長押しした時に表示するActivity\r\n    val intent = Intent(baseContext, MainActivity::class.java)\r\n    val pendingIntent =\r\n        PendingIntent.getActivity(baseContext, 10, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n    // まとめてコントローラーを追加するので配列に\r\n    val controlList = mutableListOf<Control>()\r\n    // ON/OFFサンプル。\r\n    val toggleControl = Control.StatelessBuilder(TOGGLE_BUTTON_ID, pendingIntent)\r\n        .setTitle(\"ON/OFFサンプル\") // たいとる\r\n        .setSubtitle(\"おすとON/OFFが切り替わります。\") // サブタイトル\r\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) // あいこんといろの設定。\r\n        .build()\r\n    // 配列に追加\r\n    controlList.add(toggleControl)\r\n    // Reactive Streamsの知識が必要な模様。私にはないのでサンプルコピペする。\r\n    return FlowAdapters.toFlowPublisher(Flowable.fromIterable(controlList))\r\n}\r\n```\r\n\r\nコメント文は各自消してね。  \r\n### 注意\r\nここで使う`Control`は`Control.StatelessBuilder`の方です。  \r\nこれはまだ状態が（スイッチがONとかOFFとかって話）が分からない時に使うとか書いてあるけど多分この時に使います。\r\n\r\n## ユーザーが選んだコントローラーを用意する\r\n`利用可能コントローラーの一覧を用意する`で選んだコントローラーをユーザーが操作できるようにします。\r\n\r\n```kotlin\r\nlateinit var updatePublisher: ReplayProcessor<Control>\r\n/**\r\n * ユーザーが選んだコントローラーを用意する\r\n * 電源ボタン長押しでよばれる\r\n * */\r\noverride fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\r\n    // コントローラーを長押ししたときに表示するActivity\r\n    val intent = Intent(baseContext, MainActivity::class.java)\r\n    val pendingIntent =\r\n        PendingIntent.getActivity(baseContext, 12, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n    // 知識不足でわからん\r\n    updatePublisher = ReplayProcessor.create()\r\n    // コントローラー\r\n    if(p0.contains(TOGGLE_BUTTON_ID)) {\r\n        // ON/OFF\r\n        val toggle = ToggleTemplate(\"toggle_template\", ControlButton(false, \"OFFですねえ！\"))\r\n        // ここで作るControlは StatefulBuilder を使う。\r\n        val control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\r\n            .setTitle(\"ON/OFFサンプル\") // たいとる\r\n            .setSubtitle(\"おすとON/OFFが切り替わります。\") // サブタイトル\r\n            .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\r\n            .setStatus(Control.STATUS_OK) // 現在の状態\r\n            .setControlTemplate(toggle) // 今回はON/OFFボタン\r\n            .build()\r\n        updatePublisher.onNext(control)\r\n    }\r\n    return FlowAdapters.toFlowPublisher(updatePublisher)\r\n}\r\n```\r\n\r\nこれでエラーは一応消えるので、早速実行してみましょう。\r\n\r\n# コントローラー追加\r\n電源ボタン長押しすると、**デバイス コントロール**が追加されているので、押してみましょう。  \r\n押すと、コントローラーが提供されているアプリ一覧画面が表示されるので、今作っているアプリを選びましょう。  \r\nすると、さっき作ったコントローラーが現れるのでチェックを入れて、右下の保存ボタンを押しましょう。  \r\n\r\n![Imgur](https://imgur.com/r2Wyog1.png)\r\n\r\nするとコントローラーが追加されているはずです。  \r\nですがこの段階では押してもなにも変わらないのでこれから押した時に`ON/OFF`を切り替える処理を書いていきたいと思います。\r\n\r\nちなみにエミュレータでAndroid 11動かすのにダウンロードが長かった。\r\n\r\n# コントローラーを押したときの処理\r\n押した時にON/OFFを切り替えられるようにします。\r\n```kotlin\r\n/**\r\n * コントローラーを押したとき\r\n * */\r\noverride fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\r\n    // コントローラーを長押ししたときに表示するActivity\r\n    val intent = Intent(baseContext, MainActivity::class.java)\r\n    val pendingIntent =\r\n        PendingIntent.getActivity(baseContext, 11, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n    // システムに処理中とおしえる\r\n    p2.accept(ControlAction.RESPONSE_OK)\r\n    // コントローラー分岐\r\n    when (p0) {\r\n        TOGGLE_BUTTON_ID -> {\r\n            // ON/OFF切り替え\r\n            // ToggleTemplate は BooleanAction\r\n            if (p1 is BooleanAction) {\r\n                // ONかどうか\r\n                val isOn = p1.newState\r\n                val message = if (isOn) \"ONです\" else \"OFFです\"\r\n                val toggle = ToggleTemplate(\"toggle_template\", ControlButton(isOn, message))\r\n                // Control更新\r\n                val control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\r\n                    .setTitle(\"ON/OFFサンプル\") // たいとる\r\n                    .setSubtitle(\"おすとON/OFFが切り替わります。\") // サブタイトル\r\n                    .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\r\n                    .setStatus(Control.STATUS_OK) // 現在の状態\r\n                    .setControlTemplate(toggle) // 今回はON/OFFボタン\r\n                    .setStatusText(message)\r\n                    .build()\r\n                updatePublisher.onNext(control)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nこれで押した時にON/OFFが切り替わるようになりました。  \r\n`DeviceType#TYPE_LIGHT`見た目いい感じ。  \r\nスマートホームやってみたい（金ないけど）\r\n\r\n![Imgur](https://imgur.com/2TNFYZz.png)\r\n\r\n# おわりに\r\nソースコードです。https://github.com/takusan23/DeviceControlsTest\r\n\r\n~~それと**本当**はスライダー（値を調整できる`RangeTemplate`てやつ）コントローラーがあったんですけど、私の環境ではうまく動きませんでした。Beta版だからなのかそもそも私が間違ってるのか？~~\r\n\r\n**RangeTemplate**動きました。[参考にしました](https://gist.github.com/KieronQuinn/c9950f3ee09e11f305ce16e7f48f03b8)\r\n\r\n```kotlin\r\nval sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\r\n    .setTitle(\"スライダーサンプル\") // たいとる\r\n    .setSubtitle(\"スライダーです。\") // サブタイトル\r\n    .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\r\n    .setControlId(SLIDER_BUTTON_ID)\r\n    .setStatus(Control.STATUS_OK) // 現在の状態\r\nsliderControl.setControlTemplate(\r\n    ToggleRangeTemplate(\r\n        \"slider_template\",\r\n        ControlButton(true, \"slider_button\"),\r\n        RangeTemplate(\"range\", 0f, 10f, 1f, 1f, null)\r\n    )\r\n)\r\nupdatePublisher.onNext(sliderControl.build())\r\n```\r\n\r\nperformControlAction()はこうです。\r\n\r\n```kotlin\r\n// スライダー\r\n// RangeTemplate は FloatAction\r\nif (p1 is FloatAction) {\r\n    // 現在の値\r\n    val currentValue = p1.newValue\r\n    val sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\r\n        .setTitle(\"スライダーサンプル\") // たいとる\r\n        .setSubtitle(\"スライダーです。\") // サブタイトル\r\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\r\n        .setControlId(SLIDER_BUTTON_ID)\r\n        .setStatus(Control.STATUS_OK) // 現在の状態\r\n    val controlButton = ControlButton(true, \"slider_button\")\r\n    sliderControl.setControlTemplate(\r\n        ToggleRangeTemplate(\r\n            \"slider_template\",\r\n            controlButton,\r\n            RangeTemplate(\"range\", 0f, 10f, currentValue, 1f, null)\r\n        )\r\n    )\r\n    updatePublisher.onNext(sliderControl.build())\r\n}\r\n```\r\n\r\n\r\nあと`DeviceType`がいっぱいあるので全種類アイコンと色を見てみたい。やってみるか。\r\n\r\nやりました→ https://github.com/takusan23/DeviceControlAllDeviceTypeSample\r\n\r\n\r\nDynamic Intent Filterもやりたい"},{"title":"Hello Android11。Device Control編","link":"/posts/android11_release_devicecontrol/","markdown":"\r\nAndroid 11の正式版が出ましたね。おめでとうございます  \r\n自己PR と 長所短所 って違うのか\r\n\r\n# Device Control #とは\r\n家電操作用クイック設定パネル。電源長押しで開ける。  \r\n\r\n![Imgur](https://imgur.com/w0IUBYW.png)\r\n\r\n↑こんなやつ。\r\n\r\nなお、**Reactive Stream**が何なのかわからんのでそこはコピペで頼む\r\n\r\n# 環境\r\n|なまえ|あたい|\r\n|---|---|\r\n|Android|11|\r\n|言語|Kotlin|\r\n\r\n\r\n# つくる\r\n公式の解説です：https://developer.android.com/guide/topics/ui/device-control\r\n\r\n## Android Manifest\r\nサービスを宣言します。  \r\n`android:label`がデバイスコントロールアプリ一覧に表示される名前だって~~（誰も教えてくれないAndroid）~~\r\n\r\n```xml\r\n<!-- Device Control のサービス -->\r\n<service android:name=\"DeviceControlService\" android:label=\"デバイスコントロールのサンプル\"\r\n    android:permission=\"android.permission.BIND_CONTROLS\">\r\n    <intent-filter>\r\n        <action android:name=\"android.service.controls.ControlsProviderService\" />\r\n    </intent-filter>\r\n</service>\r\n```\r\n\r\n## DeviceControlService.kt\r\nを作成します。\r\n\r\nできたら、以下のように`ControlsProviderService`を継承させます。\r\n\r\n```kotlin\r\n/** デバイスコントロールのサービス */\r\nclass DeviceControlService :ControlsProviderService(){\r\n\r\n    /** 利用可能なデバイスコントロールはここで */\r\n    override fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\r\n\r\n    }\r\n\r\n    /** 実際にデバイスコントロールを有効にした場合はここ */\r\n    override fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\r\n\r\n    }\r\n\r\n    /** デバイスコントロールを操作したときはここ */\r\n    override fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## デバイスコントロールを作成する関数を作る\r\n今回は値の変更ができるコントロール（`RangeTemplate`）を作成します。  \r\nなお今回は値をハードコートしますが本来は\r\n- createPublisherForAllAvailable()\r\n    - ここではユーザーに利用可能なコントロールを表示\r\n    - ので値は適当でもいい\r\n- createPublisherFor()\r\n    - ここではユーザーが実際に操作するコントロールを表示\r\n    - よって値はちゃんと入れておかないといけない\r\n\r\n```kotlin\r\n/**\r\n * コントロールを返す関数\r\n * @param floatValue シークを進める場合は入れてください\r\n * */\r\nprivate fun createControl(floatValue: Float = 0f): Control {\r\n    // コントロールを長押ししたときのインテント\r\n    val intent = Intent(this, MainActivity::class.java)\r\n    val pendingIntent =\r\n        PendingIntent.getBroadcast(this, 4545, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n    return Control.StatefulBuilder(\"sample_control\", pendingIntent).apply {\r\n        setTitle(\"シーリングライト\")\r\n        setSubtitle(\"リビング\")\r\n        setDeviceType(DeviceTypes.TYPE_LIGHT)\r\n        setStatus(Control.STATUS_OK)\r\n        // 値を調整できるように\r\n        setControlTemplate(RangeTemplate(\"sample_range\", 0f, 10f, floatValue, 1f, \"%.0f\"))\r\n    }.build()\r\n}\r\n```\r\n\r\n## createPublisherForAllAvailable()\r\nここではユーザーに利用可能なコントロールを表示させるときに呼ばれる。  \r\n詳しくないのでコピペ\r\n\r\n```kotlin\r\n/** 利用可能なデバイスコントロールはここで */\r\noverride fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\r\n    val control = createControl(0f)\r\n    return Flow.Publisher { subscriber ->\r\n        subscriber.onNext(control)\r\n        subscriber.onComplete()\r\n    }\r\n}\r\n```\r\n\r\n## createPublisherFor()\r\nここではユーザーが選択したコントロールが表示される時に呼ばれます？  \r\n電源ボタン長押しで表示させたときですね。\r\n\r\n```kotlin\r\n/** Controlの操作に使う */\r\nprivate lateinit var subscriber: Flow.Subscriber<in Control>\r\n/** 実際にデバイスコントロールを有効にした場合はここ */\r\noverride fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\r\n    // ここで値を取得するなりする。今回はハードコート\r\n    val control = createControl(0f)\r\n    return Flow.Publisher<Control> {\r\n        subscriber = it\r\n        it.onSubscribe(object : Flow.Subscription {\r\n            override fun request(p0: Long) {\r\n            }\r\n            override fun cancel() {\r\n            }\r\n        })\r\n        it.onNext(control)\r\n    }\r\n}\r\n```\r\n\r\n## performControlAction()\r\nここではユーザーがコントロールを操作した時に呼ばれます。  \r\n`RangeTemplate`の値は第二引数を`FloatAction`でキャストすれば取得できます。  \r\n\r\n```kotlin\r\n/** デバイスコントロールを操作したときはここ */\r\noverride fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\r\n    // システムに処理中とおしえる\r\n    p2.accept(ControlAction.RESPONSE_OK)\r\n    if (p1 is FloatAction) {\r\n        val control = createControl(p1.newValue)\r\n        subscriber.onNext(control)\r\n    }\r\n}\r\n```\r\n\r\nできたら実行して、電源ボタン長押し→︙→コントロールを追加へ進み、  \r\n追加してみてください。\r\n\r\n追加するとこのように表示されるはずです。  \r\n\r\n![Imgur](https://imgur.com/1aE1SX4.png)\r\n\r\nお疲れ様です。8888888888\r\n\r\n# 全部くっつけたコード\r\n\r\n```kotlin\r\n/** デバイスコントロールのサービス */\r\nclass DeviceControlService : ControlsProviderService() {\r\n\r\n    /** 利用可能なデバイスコントロールはここで */\r\n    override fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\r\n        val control = createControl(0f)\r\n        return Flow.Publisher { subscriber ->\r\n            subscriber.onNext(control)\r\n            subscriber.onComplete()\r\n        }\r\n    }\r\n\r\n    /** Controlの操作に使う */\r\n    private lateinit var subscriber: Flow.Subscriber<in Control>\r\n\r\n    /** 実際にデバイスコントロールを有効にした場合はここ */\r\n    override fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\r\n        // ここで値を取得するなりする。今回はハードコート\r\n        val control = createControl(0f)\r\n        return Flow.Publisher<Control> {\r\n            subscriber = it\r\n            it.onSubscribe(object : Flow.Subscription {\r\n                override fun request(p0: Long) {\r\n\r\n                }\r\n\r\n                override fun cancel() {\r\n\r\n                }\r\n            })\r\n            it.onNext(control)\r\n        }\r\n    }\r\n\r\n    /** デバイスコントロールを操作したときはここ */\r\n    override fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\r\n        // システムに処理中とおしえる\r\n        p2.accept(ControlAction.RESPONSE_OK)\r\n        if (p1 is FloatAction) {\r\n            val control = createControl(p1.newValue)\r\n            subscriber.onNext(control)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * コントロールを返す関数\r\n     * @param floatValue シークを進める場合は入れてください\r\n     * */\r\n    private fun createControl(floatValue: Float = 0f): Control {\r\n        // コントロールを長押ししたときのインテント\r\n        val intent = Intent(this, MainActivity::class.java)\r\n        val pendingIntent =\r\n            PendingIntent.getBroadcast(this, 4545, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n        return Control.StatefulBuilder(\"sample_control\", pendingIntent).apply {\r\n            setTitle(\"シーリングライト\")\r\n            setSubtitle(\"リビング\")\r\n            setDeviceType(DeviceTypes.TYPE_LIGHT)\r\n            setStatus(Control.STATUS_OK)\r\n            // 値を調整できるように\r\n            setControlTemplate(RangeTemplate(\"sample_range\", 0f, 10f, floatValue, 1f, \"%.0f\"))\r\n        }.build()\r\n    }\r\n\r\n}\r\n```\r\n\r\nGitHubです：https://github.com/takusan23/DeviceControlSample\r\n\r\n# おわりに\r\n今回のイースターエッグのソースはここ？：https://github.com/aosp-mirror/platform_frameworks_base/blob/android11-release/packages/EasterEgg/src/com/android/egg/neko/NekoControlsService.kt\r\n\r\n背面タップ、結局実装されなかった  "},{"title":"Hello Android 11。systemUiVisibility編","link":"/posts/android11_statusbar_hide/","markdown":"\r\nよーこそ`targetSdkVersion 30`の世界へ\r\n\r\n# 本題\r\nActivityを全画面にしたり、ステータスバー、ナビゲーションを一時的に消すときに`window?.decorView?.systemUiVisibility`がAndroid 11から非推奨になった  \r\n代わりに`WindowInsetsController`を使って消すらしい。\r\n\r\n# 環境\r\n\r\n| なまえ  | あたい     |\r\n|---------|------------|\r\n| 端末    | Pixel 3 XL |\r\n| Android | 11 Beta 1  |\r\n\r\n# 非表示の種類\r\n- **スワイプすることで一時的にはステータスバー、ナビゲーションバーが表示され、数秒操作しないとまた自動で全画面に戻る**\r\n    - 動画アプリとか\r\n    - `WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE`を使う（後述）\r\n- **スワイプして、ステータスバーを表示させるけどそのまま表示したままになる**\r\n    - どこで使ってるかはわからんな\r\n    - `WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE`を使う（後述）\r\n\r\n# 追記\r\nAndroid 6 以降ならAndroidX(`androix.`から始まるパッケージ、クラスの最後に`Compat`がつく)によるバックポートがあるのでそれを使えばいいと思います。  \r\n`WindowInsetsController`もAndroid 11から追加されたAPIですが、`AndroidX`(旧称：サポートライブラリ)を利用することでAndroid 6から対応することができます。\r\n\r\n```kotlin\r\n/**\r\n * キーボードを非表示にする。\r\n *\r\n * IMEで思い出した。XperiaのPOBox Plus返して。あれ使いやすかったのに\r\n *\r\n * @param activity Activity\r\n * */\r\nfun hideKeyboard(activity: Activity) {\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n        val insetsControllerCompat = WindowInsetsControllerCompat(activity.window, activity.window.decorView)\r\n        insetsControllerCompat.hide(WindowInsetsCompat.Type.ime())\r\n    }\r\n}\r\n```\r\n\r\n# つくる\r\n\r\nスワイプすると一時的に表示される方  \r\n一時的に表示しているバーは半透明になっている。\r\n\r\n```kotlin\r\nsupportActionBar?.hide()\r\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\r\n    // ステータスバーの後ろにViewを潜らせるならこれも\r\n    window?.setDecorFitsSystemWindows(false)\r\n    // Android 11 以上と分岐\r\n    window?.insetsController?.apply {\r\n        // StatusBar + NavigationBar 非表示\r\n        hide(WindowInsets.Type.systemBars())\r\n        // スワイプで一時的に表示可能\r\n        systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\r\n        // ノッチにも侵略\r\n        window?.attributes?.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\r\n    }\r\n} else {\r\n    // Android 10 以前。\r\n    window?.decorView?.systemUiVisibility = View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\r\n}\r\n```\r\n\r\nノッチまでは広げなくていい場合は、ノッチにも侵略の一行をコメントアウトしてね。  \r\n\r\nもし一時的に表示ではなく、一回表示したらずっと出っぱなしにする際は`systemBarsBehavior`を  \r\n\r\n```kotlin\r\nsystemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE\r\n```\r\n\r\nにすればいいと思います。\r\n\r\n`Type#systemBars()`を使うと、ステータスバーとナビゲーションバーを消しますが、別に以下のコードでも動きます。  \r\n\r\n```kotlin\r\n// ステータスバー\r\nhide(WindowInsets.Type.statusBars())\r\n// ナビゲーションバー\r\nhide(WindowInsets.Type.navigationBars())\r\n```\r\n\r\n# おまけ\r\nIME（キーボードのこと）もこの`WindowInsetsController`を利用することで、一行で消せるようになりました。\r\n\r\n```kotlin\r\nwindow?.insetsController?.hide(WindowInsets.Type.ime())\r\n```\r\n\r\nキーボード隠すのなんか面倒だし成功したことないからこの方法が使えるのは嬉しい。🥳\r\n"},{"title":"Android 11のワイヤレスデバッグ(Wi-Fi経由のADB)が動かないのを直す","link":"/posts/android_11_wifi_over_adb_not_working/","markdown":"\r\nどうもこんばんわ。銀行系アプリがUSBデバッグ有効時に起動しないのめんどくせえ\r\n\r\n# 本題\r\nWi-Fi経由のADBがなんかうまく動かない。  \r\nうまくいくときは上手くいくんだけどね。うまく動かないときはずっとAndroid側が読み込んでる。\r\n\r\n# 環境\r\n\r\n|なまえ|あたい|\r\n|---|---|\r\n|Android Stuido|Android Studio Arctic Fox | 2020.3.1 Canary 14|\r\n|Windows|10 Pro|\r\n|スマホ|Pixel 3 XL(Android 11) / Android 11のカスタムROM搭載機|\r\n\r\n# 対処する\r\nまず`SDK Manager`を開き、`SDK Tools`へ移動して`Android SDK Platform-Tools`を更新します。  \r\n\r\n本来はこれで利用できるはずなんですが、私の場合はなぜか利用できませんでした。\r\n\r\n# ADBのパスを修正\r\nドキュメントを見ると、`adb pair`コマンドが使えるようになったっぽいんですが、私の環境でやるとなぜか存在しないんですね。  \r\n更新したのに\r\n\r\n```\r\nadb pair\r\nadb: usage: unknown command pair\r\n```\r\n\r\nその次に、`ADB`のバージョンを確認しようと`adb --version`を叩くと衝撃の事実が。\r\n\r\n```\r\nadb --version\r\nAndroid Debug Bridge version 1.0.40\r\nVersion 4797878\r\nInstalled as C:\\Program Files (x86)\\Android\\platform-tools\\adb.exe\r\n```\r\n\r\n`adb.exe`は`C:\\Program Files (x86)\\Android\\platform-tools`にある？あれ？  \r\n`SDK Location`は`AppData\\Local\\Android\\Sdk`に設定してあるのに？\r\n\r\n# 環境変数を直す\r\nWindowsの検索から環境変数で調べてもらってもいいですし、スタートボタン（\"スタート\"の文字がVistaから消えて何年たった？）を右クリックして`システム`を押して、`システムの詳細設定`を選び、`環境変数`を押してもいいです。\r\n\r\n開けたら、`システム環境変数`の方の`Path`をダブルクリックして、\r\n\r\n`C:\\Program Files (x86)\\Android\\platform-tools`を消して\r\n\r\n`C:\\Users\\ユーザー名\\AppData\\Local\\Android\\Sdk\\platform-tools`を追加して閉じます。\r\n\r\nそして再起動\r\n\r\n再起動後、コマンドプロンプトで`adb --version`と入力して、パスが修正されていれば完了です。\r\n\r\n# これで利用できるようになったはず\r\n多分おま環でしょうが一応置いておきます。  \r\nあとワイヤレスデバッグを一旦OFFにしてまたONにすると直ったりするかも。\r\n\r\n以上です。"},{"title":"Android 12 の電池ウイジェット作った","link":"/posts/android_12_battery_widget_make/","markdown":"どうもこんばんわ。  \r\n**（ちょっと前だけど）ついにfengのアルバムを手に入れました。**  \r\n神。  \r\n冬華さま～\r\n\r\n![Imgur](https://imgur.com/fiuZ0TW.png)\r\n\r\n# 本題\r\n\r\nAndroid 12 のコンセプト画像？にあるこの電池残量ウイジェットってどこにあるの？  \r\nこれほしいんだが\r\n\r\n![Imgur](https://imgur.com/BiVH4Zz.png)\r\n\r\n# 作った\r\nスマホの電池残量とBluetoothデバイス（一台だけ）の電池残量が見れます。  \r\nBluetoothデバイスの方は10%刻みですが仕様です（後述）\r\n\r\n![Imgur](https://imgur.com/SAtNPAa.png)\r\n\r\n![Imgur](https://imgur.com/rlr7nd6.png)\r\n\r\n↑ 友愛進化論のフルありがとうfeng\r\n\r\n# ダウンロードとソースコード\r\n- PlayStore\r\n    - https://play.google.com/store/apps/details?id=io.github.takusan23.materialbatterywidget\r\n- GitHub\r\n    - https://github.com/takusan23/MaterialBatteryWidget\r\n\r\n## AndroidでBluetoothデバイスの電池残量取得\r\n(全部のデバイスで使えるわけじゃないと思う)\r\n\r\n`BluetoothDevice#getBatteryLevel()`っていうメソッドがあります。  \r\nが、`@hide`と`@UnsupportedAppUsage`が付いているため普通には見れません。が、逆に言えば成約はこれだけなのでリフレクションで呼び出せます。  \r\n変にシステムアプリ限定権限とかなくてよかった。\r\n\r\n```kotlin\r\nval getBatteryLevelMethod = BluetoothDevice::class.java\r\n            .methods\r\n            .find { it.name == \"getBatteryLevel\" }!!\r\ngetBatteryLevelMethod.invoke(/* BluetoothDevice */)\r\n```\r\n\r\n実際にペアリングデバイスを取得して電池残量を取得するコードです\r\n\r\n```kotlin\r\nval bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\r\nif (!bluetoothManager.adapter.isEnabled) return null\r\n\r\n// 電池残量を取得するメソッドが @hide で隠されているので、リフレクションで呼び出す\r\nval getBatteryLevelMethod = BluetoothDevice::class.java\r\n    .methods\r\n    .find { it.name == \"getBatteryLevel\" }!!\r\nval deviceList = bluetoothManager.adapter.bondedDevices\r\n    .map { Pair(it.name, getBatteryLevelMethod.invoke(it) as Int) }\r\n    .filter { it.second != -1 }\r\n\r\nreturn deviceList.firstOrNull()\r\n```\r\n\r\nちなみにAndroid 11以前はBluetooth権限、Android 12以降は`BLUETOOTH_CONNECT`とかいうダイアログで権限求める系の権限が必要です。\r\n\r\n## 10%刻みで返ってくる\r\n多分どうしようもない。サードパーティアプリの限界？  \r\nイヤホンによっては端末のBluetooth設定画面からは1%刻みの残量とか充電ケースの残量も取得できますが、これはシステムアプリ限定権限を使っている上に  \r\nそもそも権限がなくてもシステムアプリ以外メソッドが呼び出せないという二段構えで詰んでます。~~つまんね～~~\r\n\r\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/bluetooth/BluetoothDevice.java;drc=master;l=2808\r\n\r\n```java\r\n@SystemApi\r\n@Nullable\r\n@RequiresPermission(allOf = {\r\n        android.Manifest.permission.BLUETOOTH_CONNECT,\r\n        android.Manifest.permission.BLUETOOTH_PRIVILEGED,\r\n})\r\npublic byte[] getMetadata(@MetadataKey int key) {\r\n```\r\n\r\n## Android 12 以降はダイナミックカラーに対応しています\r\nダイナミックカラーの値を取得する場合は`@android:color/system_accent*`系を使うと取得できます。  \r\n詳しくはAndroid 12のイースターエッグ見て下さい。  \r\n\r\nあとはウイジェット内で使う色を`color.xml`で切り出して使えばいいと思います\r\n\r\n```xml\r\n<!-- values-v31/colors.xml -->\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<resources>\r\n    <!-- バッテリーのプログレスバーの表面の色 -->\r\n    <color name=\"battery_color\">@android:color/system_accent1_300</color>\r\n    <!-- バッテリーのプログレスバーの背面の色 -->\r\n    <color name=\"battery_background_color\">@android:color/system_accent1_200</color>\r\n    <!-- テキストの色 -->\r\n    <color name=\"battery_text_color\">@android:color/system_accent1_900</color>\r\n    <!-- ウイジェットの背景色 -->\r\n    <color name=\"widget_background_color\">@android:color/system_accent2_100</color>\r\n</resources>\r\n```\r\n\r\n```xml\r\n<!-- values/colors.xml -->\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<resources>\r\n\r\n    <!-- Android 12 用の色リソースはv31の方参照 -->\r\n\r\n    <!-- バッテリーのプログレスバーの表面の色 -->\r\n    <color name=\"battery_color\">#FFAFCBFB</color>\r\n    <!-- バッテリーのプログレスバーの背面の色 -->\r\n    <color name=\"battery_background_color\">#FFE8F0FE</color>\r\n    <!-- テキストの色 -->\r\n    <color name=\"battery_text_color\">#FF1B72E8</color>\r\n    <!-- ウイジェットの背景色 -->\r\n    <color name=\"widget_background_color\">@color/white</color>\r\n\r\n    <!-- 省略 -->\r\n```\r\n\r\n# 終わりに\r\nこのアルバムが本当にfengの最後だと思うととても悲しい。  \r\nそしてエロゲ板のfengスレも解散スレに..."},{"title":"Hello Android 12。スプラッシュスクリーン無効化？編","link":"/posts/android_12_disable_splashscreen/","markdown":"どうもこんにちは。  \r\n\r\n- スプラッシュスクリーンガチアンチ\r\n- 既存のスプラッシュスクリーンから移行できない（クロスプラットフォームなどで）\r\n- **電話アプリ（特に着信）、QRコードに限らず決済アプリ、カメラアプリ などの応答性が必要なアプリ** で、ユーザーに「スプラッシュスクリーンなんて見せなくていいから早く起動しろよ！」と思われてしまう可能性がある方\r\n\r\nそんな方へ捧げる。\r\n\r\n# 答え\r\n\r\n**！公式で文書化されているわけじゃないので気をつけてください！**\r\n\r\n`AndroidManifest.xml`の`<application>`タグの`theme`に指定しているテーマに、  \r\n`<item name=\"android:windowIsTranslucent\">true</item>`を追加して、半透明なActivityとして認識させます。  \r\n（実際に半透明にするためにはまだ手を加える必要があるので、これを追記したところで半透明にはならない）  \r\n\r\n以下例です。\r\n\r\n`src/main/res/values/themes.xml`\r\n\r\n```xml\r\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\r\n    <!-- Base application theme. -->\r\n    <style name=\"Theme.Android12DisableSplashScreen\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\r\n        <!-- Primary brand color. -->\r\n        <item name=\"colorPrimary\">@color/purple_500</item>\r\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\r\n        <item name=\"colorOnPrimary\">@color/white</item>\r\n        <!-- Secondary brand color. -->\r\n        <item name=\"colorSecondary\">@color/teal_200</item>\r\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\r\n        <item name=\"colorOnSecondary\">@color/black</item>\r\n        <!-- Status bar color. -->\r\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\r\n        <!-- これ -->\r\n        <item name=\"android:windowIsTranslucent\">true</item>\r\n        <!-- Customize your theme here. -->\r\n    </style>\r\n</resources>\r\n```\r\n\r\n## 既存のテーマ/ Activity に変更入れたくない or 既存のスプラッシュスクリーン用Activityがある場合は\r\n\r\n新しくスプラッシュスクリーンを無効にしたテーマを書きます。\r\n\r\n```xml\r\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\r\n    <!-- Base application theme. -->\r\n    <style name=\"Theme.Android12DisableSplashScreen\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\r\n        <!-- Primary brand color. -->\r\n        <item name=\"colorPrimary\">@color/purple_500</item>\r\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\r\n        <item name=\"colorOnPrimary\">@color/white</item>\r\n        <!-- Secondary brand color. -->\r\n        <item name=\"colorSecondary\">@color/teal_200</item>\r\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\r\n        <item name=\"colorOnSecondary\">@color/black</item>\r\n        <!-- Status bar color. -->\r\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\r\n        <!-- Customize your theme here. -->\r\n    </style>\r\n\r\n    <!-- これ -->\r\n    <style name=\"Theme.DisableSplashScreen\" parent=\"Theme.Android12DisableSplashScreen\">\r\n        <item name=\"android:windowIsTranslucent\">true</item>\r\n    </style>\r\n\r\n</resources>\r\n```\r\n\r\n次にアプリを起動したときに`MainActivity`の代わりに表示する`Activity`を作成します。  \r\nもう既にスプラッシュスクリーン用Activityがある場合はそれを使ってもいいです。    \r\nこのActivityを経由して`MainActivity`を表示させます。\r\n\r\n```kotlin\r\nclass TransparentActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        startActivity(Intent(this, MainActivity::class.java))\r\n        // Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK は使えない\r\n        finish()\r\n\r\n    }\r\n}\r\n```\r\n\r\nそしたら、`AndroidManifest`をこうです\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.android12disablesplashscreen\">\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.Android12DisableSplashScreen\">\r\n        \r\n        <activity\r\n            android:name=\".TransparentActivity\"\r\n            android:exported=\"true\"\r\n            android:theme=\"@style/Theme.DisableSplashScreen\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n        \r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\" />\r\n        \r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n## その他、なにもないスプラッシュスクリーンでごまかす編\r\n\r\n前書いたのでそっち見てください： [Hello Android 12。スプラッシュスクリーン編](/posts/android_12_splashscreen/)\r\n\r\n# なんで消せるの？\r\n`AOSP`追いかけます。Code Searchでもブランチ`android-12.0.0-r1`が選べるようになっているので読めます。\r\n\r\n多分間違えてると思うんでこっから先読まなくていいと思います。\r\n\r\n`Window_windowSplashScreenAnimatedIcon`で検索をかけます。`SplashscreenContentDrawer.java`が引っかかります。  \r\nこのクラスの`createContentView()`がスプラッシュスクリーンを返してそうですね。このメソッドを読んでる部分を探します。  \r\n↓  \r\n`StartingSurfaceDrawer.java`の`addSplashScreenStartingWindow()`メソッドの中で呼んでますね。でも条件分岐とか見てもそれっぽい事書いてないですね。  \r\nというわけでこのメソッドを読んでる部分を探します。  \r\n↓  \r\n`StartingWindowController.java`の`addStartingWindow()`の中で呼んでますね。  \r\nここの`isSplashScreenType()`ってのがもしかしたら...!って思いましたが、違うみたいです。それじゃどっから呼ばれてるか探します。  \r\n↓  \r\n多分`ShellTaskOrganizer.java`の`addStartingWindow()`ですかね。  \r\nそしてこれは  \r\n↓  \r\n`TaskOrganizer.java`の`ITaskOrganizer`の`addStartingWindow()`で呼んでます。間違ってるかもしれん。  \r\nそして\r\n↓  \r\n`TaskOrganizerController.java`の`TaskOrganizerCallbacks`の`addStartingWindow()`で呼んでますね。ここに`theme`がなんとかって書いてありますが多分違います。  \r\nそてしてこれは  \r\n↓  \r\n`TaskOrganizerController.java`の`TaskOrganizerState`の`addStartingWindow()`で呼んでますね。  \r\nそして  \r\n↓  \r\n`TaskOrganizerController.java`の`TaskOrganizerController`の`addStartingWindow()`で呼んでますね。  \r\nそれっぽいことは書いてないなあというわけで読んでる部分を探し  \r\n↓  \r\n`StartingSurfaceController.java`の`createSplashScreenStatingSurface()`で呼んでますね。  \r\nそーしーてー  \r\n↓  \r\n`SplashScreenStartingData.java`の`createStartingSurface()`で呼んでますね。  \r\nそろそろ終わりかな？  \r\n↓  \r\n`ActivityRecord.java`の`AddStartingWindow`の`run()`の中で呼んでますね。  \r\nそれっぽい処理はないので読んでる部分を探します  \r\n↓  \r\n`ActivityRecord.java`で`AddStartingWindow`のインスタンスを作成してるみたいです。  \r\n↓  \r\n`ActivityRecord.java`の`scheduleAddStartingWindow()`で`AddStartingWindow`にある`run()`メソッドを呼んでるみたいです。  \r\n↓  \r\n`ActivityRecord.java`の`addStartingWindow()`に、それっぽい記述がありますよ？  \r\n\r\n```java\r\n// Original theme can be 0 if developer doesn't request any theme. So if resolved theme is 0\r\n// but original theme is not 0, means this package doesn't want a starting window.\r\nif (resolvedTheme == 0 && theme != 0) {\r\n    return false;\r\n}\r\n```\r\n\r\n`resolvedTheme`と`theme`が気になりますのでもう少し読み進めてみる。  \r\n↓  \r\n`ActivityRecord.java`の`showStartingWindow()`で呼んでますね。  \r\n\r\n```java\r\nfinal int resolvedTheme = evaluateStartingWindowTheme(prev, packageName, theme, splashScreenTheme);\r\n```\r\n\r\n`evaluateStartingWindowTheme()`を見る。\r\n\r\n```java\r\n    /**\r\n     * Evaluate the theme for a starting window.\r\n     * @param prev Previous activity which may have a starting window.\r\n     * @param originalTheme The original theme which read from activity or application.\r\n     * @param replaceTheme The replace theme which requested from starter.\r\n     * @return Resolved theme.\r\n     */\r\n    private int evaluateStartingWindowTheme(ActivityRecord prev, String pkg, int originalTheme, int replaceTheme) {\r\n    // Skip if the package doesn't want a starting window.\r\n    if (!validateStartingWindowTheme(prev, pkg, originalTheme)) {\r\n        return 0;\r\n    }\r\n\r\n    // 省略\r\n```\r\n\r\n`validateStartingWindowTheme()`が気になる  \r\n\r\n↓  \r\n\r\n```java\r\nprivate boolean validateStartingWindowTheme(ActivityRecord prev, String pkg, int theme) {\r\n    // If this is a translucent window, then don't show a starting window -- the current\r\n    // effect (a full-screen opaque starting window that fades away to the real contents\r\n    // when it is ready) does not work for this.\r\n    if (com.android.server.wm.ProtoLogCache.WM_DEBUG_STARTING_WINDOW_enabled) { long protoLogParam0 = theme; com.android.internal.protolog.ProtoLogImpl.v(WM_DEBUG_STARTING_WINDOW, -1782453012, 1, null, protoLogParam0); }\r\n    if (theme == 0) {\r\n        return false;\r\n    }\r\n    final AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,\r\n            com.android.internal.R.styleable.Window, mWmService.mCurrentUserId);\r\n    if (ent == null) {\r\n        // Whoops!  App doesn't exist. Um. Okay. We'll just pretend like we didn't\r\n        // see that.\r\n        return false;\r\n    }\r\n    final boolean windowIsTranslucent = ent.array.getBoolean(\r\n            com.android.internal.R.styleable.Window_windowIsTranslucent, false);\r\n    final boolean windowIsFloating = ent.array.getBoolean(\r\n            com.android.internal.R.styleable.Window_windowIsFloating, false);\r\n    final boolean windowShowWallpaper = ent.array.getBoolean(\r\n            com.android.internal.R.styleable.Window_windowShowWallpaper, false);\r\n    final boolean windowDisableStarting = ent.array.getBoolean(\r\n            com.android.internal.R.styleable.Window_windowDisablePreview, false);\r\n    if (com.android.server.wm.ProtoLogCache.WM_DEBUG_STARTING_WINDOW_enabled) { String protoLogParam0 = String.valueOf(windowIsTranslucent); String protoLogParam1 = String.valueOf(windowIsFloating); String protoLogParam2 = String.valueOf(windowShowWallpaper); String protoLogParam3 = String.valueOf(windowDisableStarting); com.android.internal.protolog.ProtoLogImpl.v(WM_DEBUG_STARTING_WINDOW, -124316973, 0, null, protoLogParam0, protoLogParam1, protoLogParam2, protoLogParam3); }\r\n\r\n    // If this activity is launched from system surface, ignore windowDisableStarting\r\n    if (windowIsTranslucent || windowIsFloating) {\r\n        return false;\r\n    }\r\n```\r\n\r\n見つけたぞ！！！\r\n\r\n`if (windowIsTranslucent || windowIsFloating)` ← 多分ここが true がになってこの関数の返り値がfalseになる。\r\n"},{"title":"国内版Pixel 3 XLにAndroid 12 DPを入れる","link":"/posts/android_12_dp_hitobashira/","markdown":"\nPixel 3シリーズで適用できる最後のバージョンかな[^1]\n\n# 本題\nAndroid 12 DP1 が公開されたので、国内版Pixel 3 XLに入れて見るお話です。  \n\n# 注意\n今でてるベータ版は`Developer Preview (DP)`で開発者向けです。エンドユーザー向けの`Beta`ではないです。  \n`Developer Preview`では、`Beta`版と違い、ソフトウェアアップデートアプリ経由の提供がありませんのでパソコンが必要です。\n\n\nなお`Beta`版が始まるとここから端末の登録ができるようになります。  \nhttps://www.google.com/android/beta?hl=ja\n\n# 環境\n|なまえ|あたい|\n|---|---|\n|端末|Pixel 3 XL (docomoで購入)|\n|Android|Android 11|\n|PC|Windows 10 Pro / ADBセットアップ済み（コマンドプロンプト、PowerShell等で`adb`って入力して英語の説明が返ってくればおｋ）|\n\nadbは各自セットアップしといてください（私はAndroid Studio入れてあるのでここでは省略）\n\n# やる前に\nデータがなくなるのでなくなったら困るデータは逃しておきましょう。  \n(LINEとかねこあつめとか)  \nバックアップ機能が無いアプリは、`adb`があればバックアップができるかもしれません。  \nパッケージ名(アプリケーションIDとも言う？)はドメインみたいなやつで、一部のファイルマネージャーでは見ることができると思います\n```\nadb backup パッケージ名\n```\n\n# やりかた\n多分二通りあります。`adb sideload`で`OTA`を適用する方法と、データを全部消して（工場出荷状態）`Android Flash Tool`を使う方法（`fastboot`）ですね。\n\n||OTA|Android Flash Tool|\n|---|---|---|\n|ブートローダーアンロックが必要|☓|○|\n|データを残してアップデートが可能|○|☓|\n\n今回は`OTA`ファイルを利用してアップデートしてみます。\n\n# OTAファイルを適用\n\n## OTAファイルをダウンロード\nhttps://developer.android.com/about/versions/12/download-ota  \nこっから自分の持ってる機種のファイルをダウンロードします。  \nSHA-256を確認したい場合は以下のコマンドをPowerShellに入れると確認できます。(Windows以外はしらん)\n\n```\nCertUtil -hashfile <ダウンロードしたzipファイル> SHA256\n```\n\n## USBデバッグを有効に\n普段アプリ開発をしていれば有効になってると思いますが、`USBデバッグ`を有効にする必要があります。  \nもし銀行系アプリを使うためにOFFにしている場合はもう一度ONにしてください。  \n\n## PCとつなぐ\nUSBデバッグを許可するか聞かれたら許可してください。  \nできたら、以下のコマンドをPowerShell等で入力してください。\n\n```\nadb reboot recovery\n```\n\nするとスマホが暗くなってドロイド君が倒れてる画面に切り替わると思います。OLEDきれい\n\nこの画面になったら電源ボタンを押しながら音量アップキーを押します。すると上に`Android Recovery`と書かれた画面に切り替わると思います。  \n\nこんなの\n\n```\nAndroid Recovery\ngoogle/crosshatch/crosshatch\n11\nuser/release-keys\nUse volume up/down and power.\n-----------------------------------------\nReboot system now\nReboot to bootloader\nEnter fastboot\nApply update from ADB\nApply update from SD card\nWipe data/factory reset\nMound /system\nView recocvery logs\nRun graphics test\nRun locale test\nPower off\n```\n\n## Apply update from ADB\nを音量キーを使い選び、電源ボタンを押します。できたらPowerShellで以下のコマンドを入力します\n\n```\nadb sideload <ダウンロードしたzipファイル>\n```\nあとは待ちます。\n\n![Imgur](https://imgur.com/kevfdt6.png)\n\n終わったら、さっきの画面に戻るので、一番上の`Reboot system now`を選べばおｋです。\n\n![Imgur](https://imgur.com/ZtGTSLG.png)\n\nデータを消さずにアップデートできた。\n\n# アプリの生存確認\n- Google Pay\n    - 起動できた\n- おサイフケータイ\n    - 起動できた\n- モバイルSuica\n    - 起動できた\n- COCOA\n    - 起動できた\n- Kyash\n    - 起動できた\n- SMBC\n    - 起動できた\n\n何が起動できないんだろ\n\n# おわりに\n通知からアプリを起動する速度が上がってむしろAndroid 11のときより動きがいい気がする\n\n[^1]: Pixel 2シリーズが11で終わってるので多分そう"},{"title":"Hello Android12。RenderEffect編","link":"/posts/android_12_dp_render_effect_api/","markdown":"マテリアルデザインって半透明とかぼかしとかやらないイメージある\r\n\r\n# 本題\r\n\r\n`Android 12 DP2`に、Viewをぼかしたりできる`RenderEffect API`が追加されたので試してみる\r\n\r\n![Imgur](https://imgur.com/aW11fUG.png)\r\n\r\n## 環境\r\n\r\n| なまえ  | あたい     |\r\n|---------|------------|\r\n| Android | 12 DP2     |\r\n| 端末    | Pixel 3 XL |\r\n\r\n## バージョン\r\nAndroid 12な環境が必要です。  \r\n`SDK Manager`から`Android S Preview`を入れておいてください。  \r\n\r\nまた、build.gradleは以下のように\r\n\r\n```gradle\r\nandroid {\r\n    compileSdkVersion \"android-S\"\r\n    buildToolsVersion \"30.0.3\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.android12blur\"\r\n        minSdkVersion \"S\"\r\n        targetSdkVersion \"S\"\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n    \r\n    // 省略\r\n}\r\n```\r\n\r\n## activity_main.xml\r\n好きなViewを置けばいいです\r\n\r\n## MainActivity.kt\r\n`View#setRenderEffect()`を呼べばおk\r\n\r\n```kotlin\r\nimageView.post {\r\n    imageView.setRenderEffect(RenderEffect.createBlurEffect(10f, 10f, Shader.TileMode.CLAMP))\r\n}\r\n```\r\n\r\n# おわりに\r\n\r\nGitHubにコード上げときました\r\n\r\nhttps://github.com/takusan23/Android12Blur"},{"title":"Hello Android12。フォアグラウンドサービス編","link":"/posts/android_12_foreground_service/","markdown":"\nお一人様インスタンス作ってみたい（タイトル全然関係なくてあれ）\n\n# 本題\n`Context#startForegroundService()`に制限が追加された模様。  \nので検証してみる\n\n# 環境\n|なまえ|あたい|\n|---|---|\n|Android|12 DP 1|\n|スマホ|Pixel 3 XL|\n\n# フォアグラウンドサービスの開始制限 #とは\nアプリがバックグラウンドな状態の時に`Context#startForegroundService()`が呼べなくなった模様。  \n\n## アプリがバックグラウンド の定義\nどの状態のことを言っているのかというとここに書いてある→ https://developer.android.com/guide/background#definition\n\n\n# 確かめる\n\nAndroid 12 を対象にします\n\n`app/build.gradle`\n\n```gradle\nandroid {\n    compileSdkVersion \"android-S\"\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"io.github.takusan23.backgroundstartforegroundservice\"\n        minSdkVersion \"S\"\n        targetSdkVersion \"S\"\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n```\n\n## AndroidManifest.xml\n\nフォアグラウンドサービス利用権限が必要です（インターネット権限並に書き忘れるやつ）\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"io.github.takusan23.backgroundstartforegroundservice\">\n\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.BackgroundStartForegroundService\">\n\n        <service android:name=\".ExampleService\" />\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n## MainActivity.kt\n\nサービスを起動するコードだけ。バックグラウンドに行ったことを検知するため`onStop()`に書く\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n\n    /** バッググラウンド判定 */\n    override fun onStop() {\n        super.onStop()\n        Toast.makeText(this, \"onStop\", Toast.LENGTH_SHORT).show()\n        Timer().schedule(5000) {\n            runOnUiThread {\n                Toast.makeText(this@MainActivity, \"Start service\", Toast.LENGTH_SHORT).show()\n                startForegroundService(Intent(this@MainActivity, ExampleService::class.java))\n            }\n        }\n    }\n}\n```\n\n## ExampleService.kt\n\n特に何もしませんが\n\n```kotlin\nclass ExampleService : Service() {\n\n    /** 通知チャンネル追加で使う */\n    private val notificationManager by lazy { getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        postNotification()\n        return START_NOT_STICKY\n    }\n\n    override fun onBind(p0: Intent?): IBinder? {\n        return null\n    }\n\n    /** フォアグラウンド開始 */\n    private fun postNotification() {\n        val notificationChannelId = \"test_notification\"\n        if (notificationManager.getNotificationChannel(notificationChannelId) == null) {\n            // 通知チャンネル登録\n            val channel = NotificationChannel(notificationChannelId, \"通知テスト\", NotificationManager.IMPORTANCE_LOW)\n            notificationManager.createNotificationChannel(channel)\n        }\n        val notification = Notification.Builder(this, notificationChannelId).apply {\n            setContentTitle(\"サービス起動中\")\n            setContentText(\"サービス起動テスト\")\n            setSmallIcon(R.drawable.ic_outline_textsms_24)\n        }.build()\n        startForeground(1, notification)\n    }\n\n}\n```\n\n# 実行してみる\n\n起動する→アプリから離れる→5秒待つと？\n\n```\njava.lang.IllegalStateException: startForegroundService() not allowed due to mAllowStartForeground false: service io.github.takusan23.backgroundstartforegroundservice/.ExampleService\n```\n\n起動しない。あと通知も飛んでくる\n\n![Imgur](https://imgur.com/lM5rVxJ.png)\n\n# その他、フォアグラウンドサービスの仕様変更\n`Context#startForeground()`を呼んでも10秒間は通知を出さずにサービスを起動しておけるらしい。  \nただし、以下の条件に一個でも当てはまるとすぐに通知が出るようになる。\n\n- 通知にボタンがある\n\n```kotlin\nval notification = Notification.Builder(this, notificationChannelId).apply {\n    setContentTitle(\"サービス起動中\")\n    setContentText(\"サービス起動テスト\")\n    setSmallIcon(R.drawable.ic_outline_textsms_24)\n    addAction(Notification.Action.Builder(Icon.createWithResource(this@ExampleService, R.drawable.ic_outline_textsms_24), \"ボタン\", null).build())\n}.build()\n```\n\n- `foregroundServiceType`が`connectedDevice`、`mediaPlayback`、`mediaProjection`、`phoneCall` のとき\n\n```xml\n<service android:name=\".ExampleService\" android:foregroundServiceType=\"mediaProjection\" />\n```\n\n- 通知作成時に ~~setShowForegroundImmediately(true)~~ `setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)`を指定した\n\n```kotlin\nval notification = Notification.Builder(this, notificationChannelId).apply {\n    setContentTitle(\"サービス起動中\")\n    setContentText(\"サービス起動テスト\")\n    setSmallIcon(R.drawable.ic_outline_textsms_24)\n    setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE) // これ\n}.build()\n```\n\nこれに当てはまらなければ`Service#startForeground()`を呼んだ後10秒間は通知が表示されずにサービスを実行できます\n\n# おわりに\n間違ってたらすいません\n\n`startActivity()`の制限の次は`startForegroundService()`がやられるのか"},{"title":"Hello Android12。Material You 編","link":"/posts/android_12_material_you/","markdown":"\r\nどうもこんばんわ。  \r\nこの青空に約束を― 攻略しました。  \r\n\r\n![Imgur](https://imgur.com/pbgKYnB.png)\r\n\r\nオープニング曲聞いて気になってたのでやりました。  \r\n海己ちゃんルートを最後にとっておいてよかった。結ばれるまでのお話が好き。  \r\n静ちゃん初見時はこの子も攻略するの？とか思ってましたがエピローグの成長した姿みて反省しましたすいません。\r\n\r\nこれからやる方はWin8対応の新装版を買えばいいです。Win10で動作確認済です。DL版(Fanza)なら少し安く買える？\r\n\r\nあと戯画はイベントモードがあるのがいいね。セーブ枠をセーブしておける←？？？\r\n\r\n# 本題\r\n`material-components-android`が`1.5.0-alpha03`から`M3 (Material 3)`に対応した模様。  \r\nついにMaterial You（動的テーマ）対応！！！\r\n\r\n# Material You #とは\r\niモードケータイの着せ替えツールみたいなやつ。今の所、色だけ？が自由に決められる。  \r\n\r\n# Monet #とは\r\n壁紙からMaterial Youで使う取り出すシステム？のはず。`Android 12 Beta 4`からライブ壁紙でも動くそうな。  \r\n\r\n## 悲報？\r\n残念ながらAndroid 11？10？にあったステータスバーのアイコン変更機能、アプリアイコンの背景の変形機能は今の所削除されたままです。  \r\n復活してほしい。\r\n\r\n# つくる\r\n\r\n# 公式ドキュメント\r\n\r\nhttps://github.com/material-components/material-components-android/blob/master/docs/theming/Color.md#using-dynamic-colors\r\n\r\n# 環境\r\n\r\n| なまえ  | あたい    |\r\n|---------|-----------|\r\n| Android | 12 Beta 4 |\r\n| Pixel   | 3 XL      |\r\n\r\n## compileSdkVersion を 31 にする\r\n\r\n`app/build.gradle`を開いて、`compileSdk`を31に変更します。\r\n\r\n```gradle\r\nandroid {\r\n    compileSdk 31 // ここ\r\n\r\n    defaultConfig {\r\n        // 省略\r\n```\r\n\r\n次に、ライブラリを追加します。\r\n\r\n```gradle\r\ndependencies {\r\n    implementation 'com.google.android.material:material:1.5.0-alpha03'\r\n    implementation 'androidx.core:core-ktx:1.6.0' // 追加済みの場合はいらない\r\n\r\n    // 以下省略\r\n}\r\n```\r\n\r\nここから先は以下の選択ができます。\r\n\r\n- すべての画面で動的テーマを利用する\r\n- 指定したActivityのみに動的テーマを当てる\r\n- 指定したFragmentのみに動的テーマを当てる\r\n- 動的に作ったViewに動的テーマを当てる\r\n\r\n## すべての画面で動的テーマを利用する場合\r\nまず、`Application`を継承したクラスを作ります。\r\n\r\n```kotlin\r\n/** アプリが起動したら呼ばれる */\r\nclass MainApplication : Application() {\r\n    \r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        // 動的テーマ有効化\r\n        DynamicColors.applyToActivitiesIfAvailable(this)\r\n    }\r\n    \r\n}\r\n```\r\n\r\n`AndroidManifest.xml`を開き、`android:theme`を`@style/Theme.Material3.DayNight`(もしくは`@style/Theme.Material3.DayNight`を継承したテーマ)に変更して、  \r\n`android:name=\".MainApplication\"`を追加します\r\n\r\n```xml\r\n<application\r\n    android:allowBackup=\"true\"\r\n    android:icon=\"@mipmap/ic_launcher\"\r\n    android:label=\"@string/app_name\"\r\n    android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n    android:supportsRtl=\"true\"\r\n    android:name=\".MainApplication\"\r\n    android:theme=\"@style/Theme.Material3.DayNight\"> \r\n```\r\n\r\nそしたら、`activity_main.xml`にいくつかViewを置いて次世代のマテリアルデザインを体験しましょう。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Button\" />\r\n\r\n    <Button\r\n        style=\"@style/Widget.Material3.Button.OutlinedButton\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Outlined Button\" />\r\n\r\n</LinearLayout>\r\n```\r\n\r\n## 指定したActivityのみで動的テーマを利用する\r\nMaterial YouをActivityで使う。\r\n\r\nこの場合は、`Application`クラスを継承したクラスを作成する手順は不要で、  \r\n`AndroidManifest.xml`で、動的テーマを利用したいActivityの`android:theme`を`@style/Theme.Material3.DayNight`(もしくは`@style/Theme.Material3.DayNight`を継承したテーマ)に変更します。\r\n\r\n```xml\r\n<activity\r\n    android:name=\".MainActivity\"\r\n    android:exported=\"true\"\r\n    android:theme=\"@style/Theme.Material3.DayNight\">\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n</activity>\r\n```\r\n\r\nつぎに、動的テーマを利用したいActivityの`setContentView()`の前に、一行書き足します。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        \r\n        // setContentView() の前に呼ぶ\r\n        DynamicColors.applyIfAvailable(this)\r\n        \r\n        setContentView(R.layout.activity_main)\r\n        \r\n    }\r\n}\r\n```\r\n\r\nあとは、`activity_main.xml`にViewを置きます。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Button\" />\r\n\r\n    <Button\r\n        style=\"@style/Widget.Material3.Button.OutlinedButton\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Outlined Button\" />\r\n\r\n</LinearLayout>\r\n```\r\n\r\n## Fragmentに動的テーマを適用する\r\nMaterial YouをFragmentで使う。\r\n\r\nFragmentとかで部分的に使う際に便利なんだろうけど、Google曰く簡単ではないらしい。  \r\n多分こんな感じだと思う。\r\n\r\n```kotlin\r\nclass MainFragment : Fragment() {\r\n\r\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\r\n        // 動的テーマを適用したContext\r\n        val context = DynamicColors.wrapContextIfAvailable(requireContext())\r\n        // 動的テーマを適用したContextを使ったLayoutInflaterを生成\r\n        val dynamicColorApplyLayoutInflater = LayoutInflater.from(context)\r\n        return dynamicColorApplyLayoutInflater.inflate(R.layout.fragment_main, container, false)\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n`framgnet_main.xml`はこんな感じね。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    android:layout_height=\"match_parent\">\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Fragment Button\" />\r\n\r\n    <Button\r\n        style=\"@style/Widget.Material3.Button.OutlinedButton\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_margin=\"10dp\"\r\n        android:text=\"Fragment Outlined Button\" />\r\n\r\n</LinearLayout>\r\n```\r\nあとは、Fragmentを置くActivityの`android:theme`を`@style/Theme.Material3.DayNight`にします。なんなら`setContentView()`の前に`setTheme()`してもいいです。\r\n\r\n`AndroidManifest.xml`\r\n\r\n```xml\r\n<activity\r\n    android:name=\".MainActivity\"\r\n    android:exported=\"true\"\r\n    android:theme=\"@style/Theme.Material3.DayNight\">\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n</activity>\r\n```\r\n\r\n`MainActivity.kt`\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        setContentView(R.layout.activity_main)\r\n\r\n    }\r\n}\r\n```\r\n\r\n`activity_main.xml`\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <androidx.fragment.app.FragmentContainerView\r\n        android:id=\"@+id/fragmentContainerView\"\r\n        android:name=\"io.github.takusan23.materialyousample.MainFragment\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\" />\r\n\r\n</LinearLayout>\r\n```\r\n\r\n## 動的に生成したViewに動的テーマを適用する\r\nMaterial YouをViewで使う。\r\n\r\nこの場合でも、`Activity`に`android:theme`で`@style/Theme.Material3.DayNight`を指定しておく必要があります。\r\n\r\n`AndroidManifest.xml`\r\n\r\n```xml\r\n<activity\r\n    android:name=\".MainActivity\"\r\n    android:exported=\"true\"\r\n    android:theme=\"@style/Theme.Material3.DayNight\">\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n</activity>\r\n```\r\n\r\n`View`の第一引数に渡す`Context`に`DynamicColors.wrapContextIfAvailable(context)`の戻り値を指定します。  \r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        val context = DynamicColors.wrapContextIfAvailable(this)\r\n        val dynamicColorButton = MaterialButton(context).apply {\r\n            layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)\r\n            text = \"動的テーマ + 動的生成View\"\r\n        }\r\n        setContentView(dynamicColorButton)\r\n\r\n    }\r\n}\r\n```\r\n\r\n# おわりに\r\n\r\n![Imgur](https://imgur.com/rF6V5LB.png)\r\n\r\nサンプルコード置いておきますね。\r\n\r\nhttps://github.com/takusan23/MaterialYouSample"},{"title":"Hello Android 12。アプリ履歴からURL共有機能","link":"/posts/android_12_recent_screen_share_url/","markdown":"どうもこんばんわ。  \r\n私のPixel 3 XLくん、最近充電が一時的に無効になってますで進まない時があるんだけど大丈夫なのかな。\r\n\r\n# 本題\r\nAndroid 12から最近のアプリ履歴画面からWebページのURLを共有できる機能が追加されて、ドキュメントに実装方法が追加されたので見てみる\r\n\r\n![Imgur](https://imgur.com/WxaAUa0.png)\r\n\r\n# ドキュメント\r\nhttps://developer.android.com/about/versions/12/features#recents-url-sharing\r\n\r\n# 環境\r\n| なまえ  | あたい    |\r\n|---------|-----------|\r\n| Android | 12 Beta 3 |\r\n| Pixel   | 3 XL      |\r\n| 言語    | Kotlin    |\r\n\r\n# 実装方法\r\n見て見る感じ、Android 12から追加されたAPIを使っているわけではない模様。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n    }\r\n\r\n    override fun onProvideAssistContent(outContent: AssistContent?) {\r\n        super.onProvideAssistContent(outContent)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            // ここでURLを指定する\r\n            outContent?.webUri = \"https://takusan.negitoro.dev/\".toUri()\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## URL共有ボタンを非表示にしたいときは\r\n多分`AssistContent#setWebUri()`に`null`を入れればいいと思う。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val button by lazy { findViewById<Button>(R.id.button) }\r\n\r\n    private var isURLShare = true\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        button.setOnClickListener {\r\n            // フラグ切り替え\r\n            isURLShare = !isURLShare\r\n        }\r\n\r\n    }\r\n\r\n    override fun onProvideAssistContent(outContent: AssistContent?) {\r\n        super.onProvideAssistContent(outContent)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            // ここでURLを指定する\r\n            outContent?.webUri = if (isURLShare) {\r\n                \"https://takusan.negitoro.dev/\".toUri()\r\n            } else {\r\n                null\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n# ソースコード\r\nhttps://github.com/takusan23/Android12RecentScreenURLShare\r\n\r\n# 終わりに\r\nAndroid 12 Beta3ってことはこれ以降APIの追加って無いってこと？"},{"title":"Hello Android12。スプラッシュスクリーン編","link":"/posts/android_12_splashscreen/","markdown":"どうもこんばんわ。Androidにスプラッシュスクリーンっていらねえよなぁ  \niOS版もリリースしていてiOSと同じにしてください！みたいなことがない限りいらないと思う。\n\n# 本題\nAndroid 12からアプリ起動時にスプラッシュスクリーンが無条件で追加される模様。  \nカメラを起動するときはスプラッシュスクリーン出ないけど、多分あれ真っ暗の背景色を指定してるんだと思う。  \n**なお、独自でスプラッシュスクリーンを実装している場合は二連続でスプラッシュスクリーンが出ます。**  \n\n# 環境\n| なまえ  | あたい    |\n|---------|-----------|\n| Android | 12 Beta 3 |\n| Pixel   | 3 XL      |\n\n# ドキュメントです\nhttps://developer.android.com/about/versions/12/features/splash-screen\n\n# とりあえず\nAndroid 12をターゲットにします。SDK Managerを起動してAndroid 12のSDKを入れて、`app/build.gradle`を開いて、以下を変えます。\n\n```gradle\nandroid {\n    compileSdk 31 // ここを31\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"io.github.takusan23.splashscreen\"\n        minSdk 21\n        targetSdk 31 // ここを31\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n```\n\n# 無効化する方法はない？\nちらっと見た感じなさそう。\n\n代わりに、\n- スプラッシュスクリーンの背景色\n    - 透明を指定\n- Adaptive Iconの背景色\n    - 透明を指定\n- Adaptive Iconの前面画像\n    - なにもないDrawableを作成して指定\n\nよく調べてないのであとは頼んだ。\n\n## なにもないDrawableを作る\n適当に中身のないDrawableを作ればいいと思います。  \nこっから作成できます\n\n![Imgur](https://imgur.com/8oSywlA.png)\n\n中身は空っぽで\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n</selector>\n```\n\n## themes.xml\n\n次に`src/main/res/values/themes.xml`を開いて書き足します\n\n```xml\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n\n    <style name=\"Theme.SplashScreen\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n\n        <!-- こっから三行 -->\n        <item name=\"android:windowSplashScreenBackground\">@android:color/transparent</item>\n        <item name=\"android:windowSplashScreenIconBackgroundColor\">@android:color/transparent</item>\n        <item name=\"android:windowSplashScreenAnimatedIcon\">@drawable/empty_drawable</item>\n\n        <!-- Customize your theme here. -->\n    </style>\n</resources>\n```\n\n`src/main/res/values-night/themes.xml`も書き換えましょう。ダークモード時の挙動です\n\n```xml\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n    <!-- Base application theme. -->\n    <style name=\"Theme.SplashScreen\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n        <!-- Primary brand color. -->\n        <item name=\"colorPrimary\">@color/purple_200</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorOnPrimary\">@color/black</item>\n        <!-- Secondary brand color. -->\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_200</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <!-- Status bar color. -->\n        <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n        <!-- Customize your theme here. -->\n\n        <!-- こっから三行 -->\n        <item name=\"android:windowSplashScreenBackground\">@android:color/transparent</item>\n        <item name=\"android:windowSplashScreenIconBackgroundColor\">@android:color/transparent</item>\n        <item name=\"android:windowSplashScreenAnimatedIcon\">@drawable/empty_drawable</item>\n\n    </style>\n</resources>\n```\n\nこれで見た感じ今まで通りの挙動になると思います。\n\n# Android 6までならバックポートのライブラリで対応できます\nこれを使うことでAndroid 6(API 23 / マシュマロ)までさかのぼってスプラッシュスクリーンを追加できます。\n\nまず`app/build.gradle`を開き、`compileSdk`を`31`にする必要があるみたいです。KDoc見れば作れるってGoogle言ってたのにこんな事書いてないぞ！嘘つき！  \n参考：https://dev.to/tkuenneth/a-peek-inside-jetpack-core-splashscreen-odo\n\nそしたらライブラリを書き足します。\n\n```gradle\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n}\n\nandroid {\n    compileSdk 31\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"io.github.takusan23.splashscreenbackport\"\n        minSdk 23\n        targetSdk 30\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n\ndependencies {\n    // これ\n    implementation \"androidx.core:core-splashscreen:1.0.0-alpha01\"\n\n    implementation 'androidx.core:core-ktx:1.6.0'\n    implementation 'androidx.appcompat:appcompat:1.3.0'\n    implementation 'com.google.android.material:material:1.4.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n}\n```\n\nそしたら次は`themes.xml`を開き、スプラッシュスクリーン時のテーマを定義します。\n\n```xml\n<!-- Base application theme. -->\n<style name=\"Theme.SplashScreenBackport\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n    <!-- Primary brand color. -->\n    <item name=\"colorPrimary\">@color/purple_500</item>\n    <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n    <item name=\"colorOnPrimary\">@color/white</item>\n    <!-- Secondary brand color. -->\n    <item name=\"colorSecondary\">@color/teal_200</item>\n    <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n    <item name=\"colorOnSecondary\">@color/black</item>\n    <!-- Status bar color. -->\n    <item name=\"android:statusBarColor\" tools:targetApi=\"l\">?attr/colorPrimaryVariant</item>\n    <!-- Customize your theme here. -->\n</style>\n\n<style name=\"Theme.OriginalSplashScreen\" parent=\"Theme.SplashScreen\">\n    <!-- アイコン -->\n    <item name=\"windowSplashScreenAnimatedIcon\">@mipmap/ic_launcher</item>\n    <!-- スプラッシュスクリーン後のテーマ。今までAndroidManifestで指定してたテーマね -->\n    <item name=\"postSplashScreenTheme\">@style/Theme.SplashScreenBackport</item>\n</style>\n```\n\n次に、`AndroidManifest.xml`を開き`application`要素の`theme`属性を`Theme.OriginalSplashScreen`に変更します。\n\n```xml\n<application\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:roundIcon=\"@mipmap/ic_launcher_round\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@style/Theme.OriginalSplashScreen\">\n    <activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n    </activity>\n</application>\n```\n\n最後に、`MainActivity.kt`を開き`installSplashScreen()`を呼んだあとに`setContentView()`するように書き換えます。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        installSplashScreen()\n\n        setContentView(R.layout.activity_main)\n\n    }\n\n}\n```\n\nこれでスプラッシュスクリーンがバックポートされました。\n\n# 終わりに\nGmailとかGoogle Driveにはアニメーション付きスプラッシュスクリーンが実装されたそうですが、あれアニメーション見せるのが目的になってない？  \nアニメーションなんていらんからはよ本題行ってくれってお気持ち。\n\n仕様なのかBetaだからなのかは知りませんが、ランチャー以外からアプリを起動するとスプラッシュスクリーン出ないんだけど？"},{"title":"Hello Android 12。ローカルIPアドレス編","link":"/posts/android_12_wifi_local_ip_address/","markdown":"どうもこんばんわ。  \nChromeくんがたまによく固まるんだけどどうした？\n\n# 本題\nAndroid 12からローカルIPアドレスを取得する際に`WifiManager`を利用するほうが非推奨になり、  \n`ConnectivityManager`を使うのが正規ルートになったみたいなのでメモ  \n\n![Imgur](https://imgur.com/Rpjusp8.png)\n\n# 公式リファレンス\n\nhttps://developer.android.com/reference/android/net/ConnectivityManager#getLinkProperties(android.net.Network)\n\nhttps://developer.android.com/reference/kotlin/android/net/wifi/WifiManager#getConnectionInfo()\n\n# 権限\n\n`AndroidManifest.xml`に`android.permission.ACCESS_NETWORK_STATE`を追加します。  \nDANGERレベルじゃないので自動で付与されます。\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n# レイアウト\n適当にTextViewを置いておけばいいと思います（idは`activity_main_text_view`）\n\n# 同期的に取得\n一回だけ取得する際はどんな難しくないです。ただしネットワークの変更があった際に対応できません。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val textView = findViewById<TextView>(R.id.activity_main_text_view)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            textView.text = getIpAddress(this)\n        }\n    }\n\n     /**\n     * IPアドレスを取得する関数\n     *\n     * @param context Context\n     * @return IPv4のIPアドレス\n     * */\n   @RequiresApi(Build.VERSION_CODES.M)\n    fun getIpAddress(context: Context): String? {\n        val connectivityManager = context.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n        val activeNetwork = connectivityManager.activeNetwork\n        val linkProperties = connectivityManager.getLinkProperties(activeNetwork)\n        println(linkProperties?.linkAddresses)\n        val localIpAddress = linkProperties?.linkAddresses\n            ?.find { it.address?.toString()?.contains(\"192\") == true }\n            ?.address\n            ?.hostAddress\n        return localIpAddress\n    }\n}\n```\n\n## LinkProperties#getLinkAddresses() メソッド\nどうやらこれ、IPv6アドレス（16進数の`:`区切りのやつ）とIPv4アドレス（10進数で`.`区切りのやつ）が一緒の配列に入ってるみたいなので、  \n配列の中からIPアドレスに`192`が含まれているものを探してます。\n\n該当のコード\n\n```kotlin\nval localIpAddress = linkProperties?.linkAddresses\n    ?.find { it.address?.toString()?.contains(\"192\") == true }\n    ?.address\n    ?.hostAddress\n```\n\n# 非同期的に取得する\nコードが複雑になる代償にネットワーク変更の検知に対応できます。\n\n## ライブラリ\n\n`app/build.gradle`にコルーチンとライフサイクルのライブラリを入れます。\n\n```gradle\ndependencies {\n\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.4.0\"\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.2\"\n\n    // 省略\n```\n\n## コールバックをいい感じに扱いたい！\n`Kotlin`のコルーチンにある、`Flow`の一種、`callbackFlow`がいい感じに扱ってくれます。  \nこれを使うと、コールバック形式のコードをFlowに変換してくれます。さらに、コルーチンが終了した際の後始末まで一つの関数で完結するのでマジ便利。\n\n```kotlin\ncallbackFlow {\n    // BroadcastReceiver など\n    awaitClose {\n        // Context#unregisterReceiver() で登録解除\n    }\n}\n```\n\n## FlowでIPアドレスを送る関数\n\n`lifecycleScope`を利用することで、Activityのライフサイクルに合わせてコルーチンを終了してくれます。  \nコルーチンが終了すると、`callbackFlow`内の`awaitClose`へ進み後始末をしてくれます。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val textView = findViewById<TextView>(R.id.activity_main_text_view)\n        lifecycleScope.launch {\n            collectIpAddress(this@MainActivity).collect {\n                textView.text = it\n            }\n        }\n    }\n\n    /**\n     * IPアドレスをFlowで受け取る\n     *\n     * @param context Context\n     * @return IPv4のIPアドレス\n     * */\n    @OptIn(ExperimentalCoroutinesApi::class)\n    fun collectIpAddress(context: Context) = callbackFlow {\n        val connectivityManager = context.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n        val request = NetworkRequest.Builder()\n            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)\n            .build()\n        // コールバック\n        val networkCallback = object : ConnectivityManager.NetworkCallback() {\n            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {\n                super.onCapabilitiesChanged(network, networkCapabilities)\n                val linkProperties = connectivityManager.getLinkProperties(network)\n                // IPv4アドレスを探す\n                val address = linkProperties?.linkAddresses\n                    ?.find { it.address?.toString()?.contains(\"192\") == true }\n                    ?.address?.hostAddress\n                if (address != null) {\n                    trySend(address)\n                }\n            }\n        }\n        connectivityManager.registerNetworkCallback(request, networkCallback)\n        awaitClose {\n            connectivityManager.unregisterNetworkCallback(networkCallback)\n        }\n    }\n\n}\n```\n\n以上です。\n\nお疲れさまでした\n\n# おわりに\n\nソースコード置いておきます\n\nhttps://github.com/takusan23/Android12GetIPAddress"},{"title":"Hello Android 13。懐中電灯編","link":"/posts/android_13_camera_flash_torch_level/","markdown":"\r\nどうもこんばんわ。  \r\n姫宮さんはかまいたい 攻略しました。こういうのでいいんだよ。\r\n\r\n![Imgur](https://imgur.com/cI9ldMy.jpg)\r\n\r\nそれな\r\n\r\n![Imgur](https://imgur.com/bglBKYa.jpg)\r\n\r\n![Imgur](https://imgur.com/wNwRC4D.jpg)\r\n\r\nかわいい！\r\n\r\n戯画、ゲームエンジンが使いやすい。\r\n\r\n# 本題\r\n`Android 13` に `Galaxy`とか`iPhone`なんかに搭載されているフラッシュライト（懐中電灯）の明るさ調整機能が追加されたらしい。  \r\nので試してみる。\r\n\r\nhttps://developer.android.com/sdk/api_diff/t-dp2/changes/android.hardware.camera2.CameraManager\r\n\r\nhttps://www.xda-developers.com/android-13-flashlight-brightness-adjustment/\r\n\r\nGalaxy S7 Edge にはフラッシュライトの明るさ調整が存在する。Samsung Experience 懐かしい。  \r\nあの時はSDカードが刺さるって宣伝してたのに今は...  \r\n\r\n![Imgur](https://imgur.com/dw93hKy.png)\r\n\r\n## 環境\r\n\r\n| なまえ  | あたい                    |\r\n|---------|---------------------------|\r\n| 端末    | Google Pixel 6 Pro        |\r\n| 言語    | Kotlin                    |\r\n| Android | Tiramisu (Android 13 DP2) |\r\n\r\n## 作る\r\nAndroid 13 (ティラミス) 以上が必要です。  \r\nSDK Manager から入れましょう。\r\n![Imgur](https://imgur.com/FDV0zju.png)\r\n\r\n## 公式\r\n\r\nhttps://developer.android.com/reference/android/hardware/camera2/CameraManager#turnOnTorchWithStrengthLevel(java.lang.String,%20int)\r\n\r\n### appフォルダ内 build.gradle\r\nライブラリとかはいらないです。  \r\nSDKのバージョンだけ13（Tiramisu）にしましょう。\r\n\r\n```java\r\nplugins {\r\n    id 'com.android.application'\r\n    id 'org.jetbrains.kotlin.android'\r\n}\r\n\r\nandroid {\r\n    compileSdkPreview \"Tiramisu\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.androidtiramisutorch\"\r\n        minSdkPreview \"Tiramisu\"\r\n        targetSdkPreview \"Tiramisu\"\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    // 省略...\r\n```\r\n\r\n### MainActivity.kt\r\n\r\n懐中電灯光らせるだけならカメラの権限すらいりません。  \r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val cameraManager by lazy { getSystemService(Context.CAMERA_SERVICE) as CameraManager }\r\n\r\n    // 警告が出るので黙らせる\r\n    @RequiresApi(33)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val list = cameraManager.cameraIdList\r\n        // 多分アウトカメラ\r\n        val outCameraId = list[0]\r\n        // アウトカメラ情報\r\n        val cameraCharacteristics = cameraManager.getCameraCharacteristics(outCameraId)\r\n        // 懐中電灯最大の明るさレベル\r\n        val torchMaxLevel = cameraCharacteristics[CameraCharacteristics.FLASH_INFO_STRENGTH_MAXIMUM_LEVEL] ?: -1\r\n        // 未対応\r\n        if (torchMaxLevel < 0) {\r\n            Toast.makeText(this, \"明るさ調整に未対応です\", Toast.LENGTH_SHORT).show()\r\n        } else {\r\n            // 点灯させる\r\n            cameraManager.turnOnTorchWithStrengthLevel(outCameraId, 1)\r\n        }\r\n    }\r\n\r\n    /** アプリ終了時に消す */\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        val list = cameraManager.cameraIdList\r\n        val outCameraId = list[0]\r\n        cameraManager.setTorchMode(outCameraId, false)\r\n    }\r\n}\r\n```\r\n\r\n`CameraCharacteristics.FLASH_INFO_STRENGTH_MAXIMUM_LEVEL`が1以上を返していない場合は懐中電灯の明るさ調整機能に対応していません。  \r\n`Pixel 6 Pro`で動いてることは確認済みなので**みんなも買おう。**\r\n\r\n`turnOnTorchWithStrengthLevel`の第2引数が明るさレベルになっていて、この値を `1`から`torchMaxLevel` まで変化させることが出来ます。   \r\n`Pixel 6 Pro`で`CameraCharacteristics.FLASH_INFO_STRENGTH_MAXIMUM_LEVEL`の返り値は`128`でした。\r\n\r\n## 明るさスライダーを付ける\r\n\r\n明るさの変化がわかりにくいのでシークバーで可変出来るようにする。\r\n\r\n![Imgur](https://imgur.com/MdeB5Bp.png)\r\n\r\n### activity_main.xml\r\n適当にレイアウトを作りましょう。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n\r\n    <SeekBar\r\n        android:id=\"@+id/activity_main_seekbar\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginStart=\"16dp\"\r\n        android:layout_marginEnd=\"16dp\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_textview\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginTop=\"16dp\"\r\n        app:layout_constraintEnd_toEndOf=\"@+id/activity_main_seekbar\"\r\n        app:layout_constraintStart_toStartOf=\"@+id/activity_main_seekbar\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/activity_main_seekbar\" />\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n### MainActivity.kt\r\n\r\n小規模なので`findViewById`使いますが、出来れば`ViewBinding`を使うことをおすすめします。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val cameraManager by lazy { getSystemService(Context.CAMERA_SERVICE) as CameraManager }\r\n\r\n    /** シークバー */\r\n    private val lightLevelSeekBar by lazy { findViewById<SeekBar>(R.id.activity_main_seekbar) }\r\n\r\n    /** 明るさレベル表示用TextView */\r\n    private val lightLevelTextView by lazy { findViewById<TextView>(R.id.activity_main_textview) }\r\n\r\n    // 警告が出るので黙らせる\r\n    @RequiresApi(33)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val list = cameraManager.cameraIdList\r\n        // 多分アウトカメラ\r\n        val outCameraId = list[0]\r\n        // アウトカメラ情報\r\n        val cameraCharacteristics = cameraManager.getCameraCharacteristics(outCameraId)\r\n        // 懐中電灯最大の明るさレベル\r\n        val torchMaxLevel = cameraCharacteristics[CameraCharacteristics.FLASH_INFO_STRENGTH_MAXIMUM_LEVEL] ?: -1\r\n        // 未対応\r\n        if (torchMaxLevel < 0) {\r\n            Toast.makeText(this, \"明るさ調整に未対応です\", Toast.LENGTH_SHORT).show()\r\n        } else {\r\n            // 最大値\r\n            lightLevelSeekBar.max = torchMaxLevel\r\n            lightLevelSeekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {\r\n                override fun onProgressChanged(p0: SeekBar?, p1: Int, p2: Boolean) {\r\n                    // シークバー操作時に呼ばれる\r\n                    cameraManager.turnOnTorchWithStrengthLevel(outCameraId, p1)\r\n                    lightLevelTextView.text = \"明るさレベル ${p1}\"\r\n                }\r\n\r\n                override fun onStartTrackingTouch(p0: SeekBar?) {\r\n\r\n                }\r\n\r\n                override fun onStopTrackingTouch(p0: SeekBar?) {\r\n\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    /** アプリ終了時に消す */\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        val list = cameraManager.cameraIdList\r\n        val outCameraId = list[0]\r\n        cameraManager.setTorchMode(outCameraId, false)\r\n    }\r\n}\r\n```\r\n\r\n## ご褒美\r\nAPK置いておきます。\r\n\r\nhttps://github.com/takusan23/AndroidTiramisuTorch/releases\r\n\r\n## ソースコード\r\nAndroid Studio 最新版でも多分開けると思います。(更新しようとしたら容量不足でコケた...)\r\n\r\nhttps://github.com/takusan23/AndroidTiramisuTorch\r\n\r\n# おわりに\r\nGoogle Pixel だと PayPay のSMS認証来ないんですけどおま環ですか..."},{"title":"Hello Android 13。ダイナミックカラーのアイコン編 (Android 12もあるよ)","link":"/posts/android_13_dynamic_color_icon/","markdown":"どうもこんばんわ。  \r\n友だちから恋びとへ 攻略しました。\r\n\r\n![Imgur](https://imgur.com/fIZi2Wu.png)\r\n\r\nこの手のゲームは`ヒロイン+サブヒロイン`とかで大体サブヒロインは攻略できない系が多いんだけど今回はふたりとも攻略できる！！！\r\n\r\n![Imgur](https://imgur.com/JsGTljv.png)\r\n\r\n# 本題\r\nAndroid 13 Developer Preview が出てた！  \r\nこの中から簡単に使えそうな新機能を一つ（というかまだ全然ない）\r\n\r\n## Material You なアイコンが作れるようになった\r\n一部のシステムアイコンはアイコンの色に壁紙の色をつけてくれるのですが、これがサードパーティーアプリにも開放されました。  \r\n(なんでこれAndroid 12に入れなかったんだ？monetがAOSP入りしなかったから？)\r\n\r\n![Imgur](https://imgur.com/4Q3em8N.png)\r\n\r\nEZWebが終わる今、きせかえツールのような機能が追加されるとは\r\n\r\n## こうしき\r\n\r\nhttps://developer.android.com/about/versions/13/features#themed-app-icons\r\n\r\n## 作り方\r\n\r\n### app/build.gradle\r\n\r\n`Tiramisu`を指定します。お菓子のコードネームだ！！  \r\nSDK入っていない場合は右上にある`SDK Manager`から入れましょう。\r\n\r\n![Imgur](https://imgur.com/JWDLgmJ.png)\r\n\r\nそしてこうです\r\n\r\n```java\r\nandroid {\r\n    compileSdkPreview \"Tiramisu\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.dynamiccoloricon\"\r\n        minSdkPreview \"Tiramisu\"\r\n        targetSdkPreview \"Tiramisu\"\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n    }\r\n}\r\n```\r\n\r\n## Adaptive Iconのファイルを開き\r\n\r\n- `mipmap-anydpi-v26/ic_launcher_round.xml`\r\n- `mipmap-anydpi-v26/ic_launcher.xml`\r\n\r\nを開いて、それぞれ`<monochrome android:drawable=\"アイコンのベクター画像\" />`の一行を書き足します\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <background android:drawable=\"@drawable/ic_launcher_background\" />\r\n    <foreground android:drawable=\"@drawable/ic_launcher_foreground\" />\r\n    <!-- ↓ これ -->\r\n    <monochrome android:drawable=\"@drawable/ic_launcher_foreground\" /> \r\n</adaptive-icon>\r\n```\r\n\r\n基本的には通知に使ってるアイコンが使えると思います（ってGoogleが言ってた）\r\n\r\n以上です。\r\n\r\n# 全員が全員 Android 13 使ってると思うなよ\r\n元ネタ：全員が全員iPhone使ってると思うなよ\r\n\r\nAndroidには`activity-alias`と`PackageManager#setComponentEnabledSetting`で予め用意しておいたアイコンを切り替えることができるみたい。  \r\n(動的にアイコンの画像を差し替えるとかは出来ないと思う。もしやりたければ`ShortcutManager#requestPinShortcut`でショートカットを作るといい)\r\n\r\n## 動的にアイコンを切り替えられるみたい\r\n\r\n参照：  \r\n\r\nhttps://qiita.com/temoki/items/3fa4acc0a897bbbbbc8f\r\n\r\n## テーマアイコン用のAdaptive Iconを用意する\r\n\r\n`src/main/res/`の中に`mipmap-anydpi-v31`を作成して\r\n\r\n- `ic_launcher_dynamic_color.xml`\r\n- `ic_launcher_round_dynamic_color.xml`\r\n\r\nの2つを作成して、ファイルの中身はこれです。（中身一緒だから一つでも良かったですね）\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <background android:drawable=\"@android:color/system_accent2_100\" />\r\n    <foreground android:drawable=\"@drawable/ic_launcher_foreground_dynamic_color\" />\r\n</adaptive-icon>\r\n```\r\n\r\n![Imgur](https://imgur.com/BYkzZUP.png)\r\n\r\nまた、`@drawable/ic_launcher_foreground_dynamic_color`が無いので作ります。  \r\n`drawable`の中に`ic_launcher_foreground_dynamic_color.xml`で作りましょう。  \r\n\r\nファイルの中身は皆さんのAdaptive Iconの`foreground`で指定してる`xml`をそのまま使えると思います。  \r\nというわけで`launcher_foreground.xml`をコピーして、`android:tint=\"@android:color/system_accent2_700\"`を足します。\r\n\r\n```xml\r\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:aapt=\"http://schemas.android.com/aapt\"\r\n    android:width=\"108dp\"\r\n    android:height=\"108dp\"\r\n    android:tint=\"@android:color/system_accent2_700\"\r\n    android:viewportWidth=\"108\"\r\n    android:viewportHeight=\"108\">\r\n    <!-- 省略... -->\r\n</vector>\r\n```\r\n\r\n## AndroidManifest.xml にテーマアイコン用の <activity-alias>　を書き足す\r\n\r\n以下のように書き足します\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.android12dynamicicon\">\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.Android12DynamicIcon\">\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n\r\n        <!-- これを書き足す -->\r\n        <activity-alias\r\n            android:name=\".MainActivity_dynamic_icon\"\r\n            android:enabled=\"true\"\r\n            android:exported=\"true\"\r\n            android:icon=\"@mipmap/ic_launcher_dynamic_color\"\r\n            android:label=\"@string/app_name\"\r\n            android:roundIcon=\"@mipmap/ic_launcher_round_dynamic_color\"\r\n            android:targetActivity=\".MainActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity-alias>\r\n\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n## コードを書く\r\n\r\n### activity_main.xml\r\n切り替えスイッチをおきます\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <com.google.android.material.switchmaterial.SwitchMaterial\r\n        android:id=\"@+id/enable_theme_icon\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"テーマアイコンに切り替える\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n### MainActivity.kt\r\n\r\nスイッチの初期値設定とスイッチを切り替えたときに`<activity-alias>`へ切り替える関数があります。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 切り替えスイッチ */\r\n    private val themeIconSwitch by lazy { findViewById<SwitchMaterial>(R.id.enable_theme_icon) }\r\n\r\n    /** デフォ ComponentName */\r\n    private val defaultComponentName by lazy { ComponentName(packageName, \"${packageName}.MainActivity\") }\r\n\r\n    /** テーマアイコンにした ComponentName */\r\n    private val themeIconComponentName by lazy { ComponentName(packageName, \"${packageName}.MainActivity_dynamic_icon\") }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // 今の状態をスイッチに入れる\r\n        themeIconSwitch.isChecked = !isDefaultIcon()\r\n        // 切り替えたらアイコンも切り替える\r\n        themeIconSwitch.setOnCheckedChangeListener { buttonView, isChecked ->\r\n            setThemeIcon(isChecked)\r\n        }\r\n\r\n    }\r\n\r\n    /** デフォアイコンの場合はtrue */\r\n    private fun isDefaultIcon(): Boolean {\r\n        return packageManager.getComponentEnabledSetting(defaultComponentName).let {\r\n            it == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || it == PackageManager.COMPONENT_ENABLED_STATE_ENABLED\r\n        }\r\n    }\r\n\r\n    /**\r\n     * テーマアイコンを適用するか\r\n     *\r\n     * @param isEnable テーマアイコンならtrue、デフォアイコンならfase\r\n     * */\r\n    private fun setThemeIcon(isEnable: Boolean) {\r\n        // Android 12 以降のみ\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n            packageManager.setComponentEnabledSetting(\r\n                if (isEnable) themeIconComponentName else defaultComponentName,\r\n                PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\r\n                PackageManager.DONT_KILL_APP)\r\n            packageManager.setComponentEnabledSetting(\r\n                if (!isEnable) themeIconComponentName else defaultComponentName,\r\n                PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\r\n                PackageManager.DONT_KILL_APP)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nこれで動くはず\r\n\r\n![Imgur](https://imgur.com/BGCaO9e.png)\r\n\r\n![Imgur](https://imgur.com/UtfBON1.png)\r\n\r\n### メモ\r\n有効状態だと`MainActivity`を指したIntentを解決出来なくなり、Android Studioから実行してもActivityが存在しないエラーが発生します。  \r\n気をつけてね。\r\n\r\n## そーすこーど\r\n\r\nhttps://github.com/takusan23/Android12DynamicIcon\r\n\r\n# おわりに\r\nEngaged日本版終わるの悲しい...？  \r\n過去の記事も読めなくなるのか辛いね..."},{"title":"Android Architecture ComponentsのLifeCycleでonDestory()に書き忘れを回避","link":"/posts/android_aac_lifecycle/","markdown":"ねむい\r\n\r\n# 本題\r\nライフサイクルのコールバックをActivity/Fragment以外のクラスで受け取りたいって話。\r\n\r\n## あると何がいいか\r\nこんなふうなセンサーの値をとるクラスがあったとして、\r\n\r\n```kotlin\r\n/**\r\n * 加速度センサーの値取得クラス\r\n * @param activity Contextとるため\r\n * @param sensorChanged センサーの値が変更された時に呼ばれる高階関数\r\n * */\r\nclass GetSensor(activity: Activity, sensorChanged: (SensorEvent?) -> Unit) {\r\n\r\n    private val sensorManager = activity.getSystemService(Context.SENSOR_SERVICE) as SensorManager\r\n    private var sensorEventListener: SensorEventListener\r\n\r\n    init {\r\n        sensorEventListener = object : SensorEventListener {\r\n            override fun onAccuracyChanged(p0: Sensor?, p1: Int) {\r\n\r\n            }\r\n\r\n            override fun onSensorChanged(p0: SensorEvent?) {\r\n                // 値が変更された\r\n                sensorChanged(p0)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** 終了時に呼んでね */\r\n    fun destroy() {\r\n        sensorManager.unregisterListener(sensorEventListener)\r\n    }\r\n\r\n    /** 開始時に呼んでね */\r\n    fun start(){\r\n        // 加速度センサー\r\n        val sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\r\n        // センサー登録\r\n        sensorManager.registerListener(\r\n            sensorEventListener,\r\n            sensor,\r\n            SensorManager.SENSOR_DELAY_NORMAL\r\n        )\r\n    }\r\n\r\n}\r\n```\r\n\r\n`MainActivity.kt`あたりで使うとして、こうですね\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private lateinit var sensor: GetSensor\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        sensor = GetSensor(this) {\r\n            // X軸を出力\r\n            println(it?.values?.get(0))\r\n        }\r\n\r\n    }\r\n\r\n    // センサーの登録解除\r\n    override fun onPause() {\r\n        super.onPause()\r\n        sensor.destroy()\r\n    }\r\n\r\n    // センサーの登録\r\n    override fun onResume() {\r\n        super.onResume()\r\n        sensor.start()\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n## これの何が問題なのか\r\n~~(activityじゃなくてcontextで良いだろ)~~\r\n- `onPause()`に書き忘れる可能性がある\r\n- `GetSensor`クラスで登録とか解除とかを自動でやってほしい\r\n    - なんでActivityの`onPause`とかに書かないといけないの？\r\n\r\n# ライフサイクル対応コンポーネント を利用して解決\r\nこれを使うと、\r\n- `DESTROY`状態になったら呼ばれる関数(べつにSTARTでも良いよ)\r\n    - **ActivityやFragmentのonPause()関数等がActivity/Fragment以外(自作クラス)でも利用できる！！！**\r\n\r\n~~ライフサイクルはクソなので助かる~~\r\n\r\nなので書き直すと\r\n\r\n## LifecycleObserverを継承\r\n`LifecycleObserver`は実は中身空っぽなので書き足すだけでいいです\r\n```kotlin\r\nclass GetSensor(activity: Activity, sensorChanged: (SensorEvent?) -> Unit) : LifecycleObserver {\r\n```\r\n\r\n## addObserver()\r\n`GetSensor`クラスのコンストラクタの引数に`lifecycle: Lifecycle`を付け足します。\r\n\r\n```kotlin\r\nclass GetSensor(activity: Activity, lifecycle: Lifecycle, sensorChanged: (SensorEvent?) -> Unit) : LifecycleObserver {\r\n```\r\n\r\nそして`init{ }`の中に以下の1行を足します\r\n```kotlin\r\nlifecycle.addObserver(this)\r\n```\r\n\r\n## ライフサイクルに関係している関数に`@OnLifecycleEvent`をつける\r\n\r\nまず忘れそうな`destroy()`関数につけましょう。  \r\nちゃんとコメントも書き換えて、privateにしてしまいましょう（勝手に呼ばれるのでもう書く必要がないため）。\r\n\r\n```kotlin\r\n/** 終了時に勝手に呼ばれる */\r\n@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\r\nprivate fun destroy() {\r\n    sensorManager.unregisterListener(sensorEventListener)\r\n}\r\n```\r\n\r\nそれとセンサーを登録する関数も、ライフサイクルが`Resume`の状態になったら自動で呼ぶようにします\r\n```kotlin\r\n/** 開始状態になったら勝手に呼ばれる */\r\n@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\r\nprivate fun start() {\r\n    // 加速度センサー\r\n    val sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\r\n    // センサー登録\r\n    sensorManager.registerListener(\r\n        sensorEventListener,\r\n        sensor,\r\n        SensorManager.SENSOR_DELAY_NORMAL\r\n    )\r\n}\r\n```\r\n\r\n最後に`MainActivity`を修正して終わりです！\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        GetSensor(this, lifecycle) {\r\n            // X軸を出力\r\n            println(it?.values?.get(0))\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nわあ！すごいスッキリ\r\n\r\n実行してLogcatを出してアプリを離れると勝手に出力が終了し、また戻ってくると出力が始まってることが分かるはずです。\r\n\r\n# 全部くっつけたコード\r\n\r\n`GetSensor.kt`\r\n\r\n```kotlin\r\n/**\r\n * 加速度センサーの値取得クラス\r\n * @param activity Contextとるため\r\n * @param sensorChanged センサーの値が変更された時に呼ばれる高階関数\r\n * */\r\nclass GetSensor(activity: Activity, lifecycle: Lifecycle, sensorChanged: (SensorEvent?) -> Unit) :\r\n    LifecycleObserver {\r\n\r\n    private val sensorManager = activity.getSystemService(Context.SENSOR_SERVICE) as SensorManager\r\n    private var sensorEventListener: SensorEventListener\r\n\r\n    init {\r\n        lifecycle.addObserver(this)\r\n        sensorEventListener = object : SensorEventListener {\r\n            override fun onAccuracyChanged(p0: Sensor?, p1: Int) {\r\n\r\n            }\r\n\r\n            override fun onSensorChanged(p0: SensorEvent?) {\r\n                // 値が変更された\r\n                sensorChanged(p0)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** 終了時に勝手に呼ばれる */\r\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\r\n    private fun destroy() {\r\n        sensorManager.unregisterListener(sensorEventListener)\r\n    }\r\n\r\n    /** 開始状態になったら勝手に呼ばれる */\r\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\r\n    private fun start() {\r\n        // 加速度センサー\r\n        val sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)\r\n        // センサー登録\r\n        sensorManager.registerListener(\r\n            sensorEventListener,\r\n            sensor,\r\n            SensorManager.SENSOR_DELAY_NORMAL\r\n        )\r\n    }\r\n\r\n}\r\n```\r\n\r\n`MainActivity.kt`\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        GetSensor(this, lifecycle) {\r\n            // X軸を出力\r\n            println(it?.values?.get(0))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 参考にしました\r\nhttps://developer.android.com/topic/libraries/architecture/lifecycle?hl=ja"},{"title":"startActivityForResultに打消し線が出た","link":"/posts/android_activity_result_api/","markdown":"\r\nやっと週末が\r\n\r\n# 本題\r\nつまり非推奨になったってことです。\r\n\r\n# startActivityForResult って何\r\n画像を選択する時、選択した画像を受け取る時に使う。  \r\n\r\n# Activity Result API とは\r\nstartActivityForResult よりも簡素化された？。  \r\n第二引数の`REQUEST_CODE`が省略できるように。  \r\n（代わりにその都度`startActivityForResult`を用意する模様？）\r\n\r\n# Storage Access Framework での例\r\n\r\nFragmentとActivityのバージョンをあげます。\r\n多分Fragment/Activity両方書かないとエラー出ると思います。\r\n\r\n```gradle\r\ndependencies {\r\n    implementation 'androidx.activity:activity-ktx:1.2.0-alpha08'\r\n    implementation 'androidx.fragment:fragment:1.3.0-alpha08'\r\n}\r\n```\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 選択した画像をここで受け取る。Activity Result APIってやつらしい。 */\r\n    val getContent =\r\n        registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\r\n            println(uri?.path)\r\n        }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        content_select.setOnClickListener {\r\n            // 画像選択。SAF。\r\n            getContent.launch(\"image/*\")\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\nボタンを作成して(IDは`content_select`)レイアウトに置いておいてください。"},{"title":"AndroidでMediaCodecを利用して動画の上に文字をかさねる","link":"/posts/android_add_canvas_text_to_video/","markdown":"どうもこんばんわ  \r\nD.S. -Dal Segno- 攻略しました。  \r\nD.C.4 ってもしかして D.S.2 、、、？\r\n\r\nOP曲が良すぎ。ぜひ聞いてみてね  \r\n\r\n<script type=\"application/javascript\" src=\"https://embed.nicovideo.jp/watch/so28350805/script?w=320&h=180\"></script><noscript><a href=\"https://www.nicovideo.jp/watch/so28350805\">D.S. -Dal Segno- オープニングムービー</a></noscript>\r\n\r\nヒロインみんなかわいいので置いておきますね。  \r\nイベントCGがめっちゃいいのでやってみてね。\r\n\r\n![Imgur](https://imgur.com/qUF7Dcr.png)  \r\n声がふわふわしててかわいい\r\n\r\n![Imgur](https://imgur.com/IY6kJjj.png)  \r\nここ何回でも聞ける\r\n\r\n![Imgur](https://imgur.com/TPRc8vg.png)  \r\nオンオフ合ったほうがいいよね\r\n\r\n![Imgur](https://imgur.com/jpRWjaJ.png)  \r\n姉さん女房！！！\r\n\r\n![Imgur](https://imgur.com/nOW8MqM.png)  \r\nファンディスクに期待、、！\r\n\r\nどうやらファンディスクの方ではデフォルトネームを呼んでくれるらしい？ので気になっております  \r\nそれはそれとしてじゃあ D.C.5 やるからまたね\r\n\r\n# 動画に文字をかさねてみた\r\n↓ こんな感じに テキストとドロイド君（画像） 重ねてエンコードしてみる話です。  \r\n元動画はこれ：https://nico.ms/sm36044089\r\n\r\n<video src=\"https://user-images.githubusercontent.com/32033405/219969962-999f71a9-2b55-484e-adfd-ad6f597431b9.mp4\" width=\"80%\" controls></video>\r\n\r\n![Imgur](https://imgur.com/vw7176n.png)\r\n\r\nhttps://github.com/takusan23/AkariDroid\r\n\r\nお正月に試してたことの話をします、、、\r\n\r\n# 二番煎じ\r\nhttps://www.sisik.eu/blog/android/media/add-text-to-video\r\n\r\nはい。\r\n\r\n# めんどいんだけど？\r\n本当に（ほんとうに）最低限の状態で`MavenCentral`に公開したのでお試しには使えるかも、、、\r\n![Maven Central](https://img.shields.io/maven-central/v/io.github.takusan23/akaricore)\r\n\r\n```kotlin\r\nimplementation(\"io.github.takusan23:akaricore:1.0.0-alpha03\")\r\n```\r\n\r\n最低限過ぎてこの記事で紹介する`音声の追加`部分、`MediaStore`の部分はまだ存在しないので自分で作る必要があります。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    private val folder by lazy { File(getExternalFilesDir(null), \"video_edit\").apply { mkdir() } }\r\n    private val originVideoFile by lazy { File(folder, ORIGIN_VIDEO_FILE).apply { createNewFile() } }\r\n\r\n    private val videoPicker = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->\r\n        uri ?: return@registerForActivityResult\r\n        // 動画をコピーしてエンコードする\r\n        originVideoFile.delete()\r\n        contentResolver.openInputStream(uri)?.use { inputStream ->\r\n            originVideoFile.outputStream().use { outputStream ->\r\n                inputStream.copyTo(outputStream)\r\n            }\r\n        }\r\n        videoProcessorStart()\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        // 動画を選択する\r\n        videoPicker.launch(\"video/mp4\")\r\n    }\r\n\r\n    private fun videoProcessorStart() {\r\n        // エンコード後のファイル\r\n        val resultFile = File(folder, RESULT_VIDEO_FILE)\r\n        lifecycleScope.launch {\r\n            // エンコーダー\r\n            val videoWidth = 1280\r\n            val videoHeight = 720\r\n\r\n            val textPaint = Paint().apply {\r\n                textSize = 100f\r\n            }\r\n            val logoBitmap = ContextCompat.getDrawable(this@MainActivity, R.drawable.ic_launcher_foreground)?.apply {\r\n                setTint(Color.WHITE)\r\n            }?.toBitmap(300, 300)!!\r\n\r\n            // Canvas にかく\r\n            // 処理が終わるまで一時停止する\r\n            VideoCanvasProcessor.start(\r\n                videoFile = originVideoFile, // もと動画ファイル\r\n                resultFile = resultFile, // エンコード後の動画ファイル\r\n                outputVideoWidth = videoWidth,\r\n                outputVideoHeight = videoHeight\r\n            ) { positionMs ->\r\n                // 適当に文字を書く\r\n                val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n\r\n                textPaint.color = Color.BLACK\r\n                textPaint.style = Paint.Style.STROKE\r\n                // 枠取り文字\r\n                drawText(text, 200f, 300f, textPaint)\r\n\r\n                textPaint.style = Paint.Style.FILL\r\n                textPaint.color = Color.WHITE\r\n                // 枠無し文字\r\n                drawText(text, 200f, 300f, textPaint)\r\n\r\n                // 画像も表示する\r\n                drawBitmap(logoBitmap, (videoWidth - logoBitmap.width).toFloat(), (videoHeight - logoBitmap.height).toFloat(), textPaint)\r\n            }\r\n\r\n            // 音声の追加など\r\n            // MediaStore を使って ギャラリーに追加するとか\r\n            Toast.makeText(this@MainActivity, \"終了しました\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val ORIGIN_VIDEO_FILE = \"origin_video_file.mp4\"\r\n        private const val RESULT_VIDEO_FILE = \"result.mp4\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n# MediaCodecシリーズ\r\n\r\n- [動画をつなげる](/posts/android_mediacodec_merge_video/)\r\n    - `MediaCodec` / `MediaExtractor` / `MediaMuxer` の雑な説明があります\r\n        - 説明はこっちに任せて本記事では省略します...\r\n    - https://github.com/takusan23/Coneco\r\n    - https://github.com/takusan23/AndroidMediaCodecVideoMerge\r\n- [なんちゃってライブ配信をする](/posts/android_standalone_webm_livestreaming/)\r\n    - カメラの入力を`MediaCodec`に渡して細切れな`WebM`を作ってブラウザで見る\r\n    - https://github.com/takusan23/AndroidWebMDashLive\r\n\r\n# Android で文字を動画にかさねるには\r\n`FFmpeg`とかを利用しない場合、`MediaCodec`をそのまま使うしかないです。（使いにくいやつ）  \r\n\r\nこれのそのままですが  \r\nhttps://speakerdeck.com/masayukisuda/mediacodecdedong-hua-bian-ji-wositemiyou\r\n\r\n- MediaExtractorで動画を取り出して\r\n- MediaCodecで動画をデコードして\r\n- Canvasで文字を書く\r\n    - AndroidのCanvasに書ければ図形でも画像でも行けるはず\r\n- OpenGLで動画とCanvasを描画する\r\n- OpenGLの出力をもとにMediaCodecでエンコードする\r\n- エンコーダーから\r\n- 繰り返す\r\n\r\n`OpenGL`を使う理由ですが、`MediaCodec`の入力用`Surface`では`lockCanvas`を使っての描画ができないことが書かれています。  \r\n\r\nhttps://developer.android.com/reference/android/media/MediaCodec#createInputSurface()\r\n\r\n# 動画関係のメモ\r\n\r\n## コーデックとコンテナ\r\n一応置いておきます\r\n\r\n- コンテナ\r\n    - エンコードした映像と音声を一つのファイルに保存するための技術\r\n    - AAC / H.264 (AVC) はコーデックの種類なので間違い\r\n        - mp4\r\n        - mpeg2-ts\r\n        - WebM\r\n- コーデック\r\n    - 映像、音声を圧縮するプログラム\r\n        - 圧縮する作業をエンコードとかいいます\r\n        - 逆に再生するために戻す作業をデコードといいます\r\n    - パラパラ漫画にするよりも動画にするほうが容量が小さいのはコーデックが圧縮しているから\r\n        - AAC\r\n            - 音声\r\n        - Opus\r\n            - 音声\r\n            - JavaScript の MediaRecorder はこれが採用されていたかな\r\n        - H.264 / AVC\r\n            - 映像\r\n        - H.265 / HEVC\r\n            - 映像\r\n            - H.264 の半分で同じ画質と言われている(つまり容量半分)\r\n            - カメラアプリによっては H.265 を利用して容量を節約する機能があったり\r\n        - VP9\r\n            - 映像\r\n            - JavaScript の MediaRecorder で使えたような？\r\n            - H.265 の Google バージョン\r\n\r\n# つくる\r\nOpenGLの部分とかはほぼコピーです\r\n\r\n| なまえ         | あたい                      |\r\n|----------------|-----------------------------|\r\n| 言語           | Kotlin / OpenGL (一部)      |\r\n| targetSdk      | 33                          |\r\n| Android Studio | Android Studio Electric Eel |\r\n| たんまつ       | Xperia Pro-I Android 13     |\r\n\r\n# app/build.gradle\r\n`app/build.gradle`に書き足します。  \r\n`ViewBinding`と最低限のライブラリを\r\n\r\n```gradle\r\n\r\nandroid {\r\n    namespace 'io.github.takusan23.androidmediacodecaddcanvastexttovideo'\r\n    compileSdk 33\r\n\r\n    // 省略...\r\n\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n\r\n    // 省略...\r\n\r\n}\r\n\r\ndependencies {\r\n\r\n    // lifecycleScope\r\n    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.5.1'\r\n\r\n    // 省略...\r\n}\r\n```\r\n\r\n# activity_main.xml\r\n動画を選択するボタンと、エンコードするボタンと、現在の状態を表すTextView を置きました。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <Button\r\n        android:id=\"@+id/video_select_button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"動画ファイルを選択する\"\r\n        app:layout_constraintBottom_toTopOf=\"@+id/encode_button\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintHorizontal_bias=\"0.5\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/encode_status_text_view\" />\r\n\r\n    <TextView\r\n        android:id=\"@+id/encode_status_text_view\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"エンコード前\"\r\n        app:layout_constraintBottom_toTopOf=\"@+id/video_select_button\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintHorizontal_bias=\"0.5\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/encode_button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"エンコードする\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintHorizontal_bias=\"0.5\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/video_select_button\" />\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## 動画ファイルをコピーする\r\nまずは動画ファイルをアプリの固有ストレージにコピーする部分を作ります。  \r\n`Uri`だと使いにくいので、一旦`Context#getExternalFilesDir`の領域に保存します。その領域では`Java File API`が使えるので。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val workFolder by lazy { File(getExternalFilesDir(null), \"video\").apply { mkdir() } }\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    /** 動画ピッカー */\r\n    private val videoPicker = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->\r\n        uri ?: return@registerForActivityResult\r\n        // コピーする\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            val videoFile = File(workFolder, VIDEO_FILE_NAME).apply {\r\n                createNewFile()\r\n            }\r\n            videoFile.outputStream().use { outputStream ->\r\n                contentResolver.openInputStream(uri)?.use { inputStream ->\r\n                    inputStream.copyTo(outputStream)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        // 動画を選択する\r\n        viewBinding.videoSelectButton.setOnClickListener {\r\n            videoPicker.launch(\"video/mp4\")\r\n        }\r\n\r\n    }\r\n\r\n    companion object {\r\n        /** かさねる動画のファイル名 */\r\n        private const val VIDEO_FILE_NAME = \"origin_video_file.mp4\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n## OpenGL の用意をする\r\nAOSPのCTSテストとかでも使われているやつですね。  \r\nhttps://cs.android.com/android/platform/superproject/+/master:cts/tests/tests/media/src/android/media/cts/InputSurface.java\r\n\r\n### CodecInputSurface.kt\r\n`GLSurfaceView`とかはこの辺意識しなくてもいきなり`OpenGL`のシェーダー書くところから始められるので良いですね、、、  \r\nよく知らないのでコピペしてください、、、\r\n\r\n```kotlin\r\n/*\r\n * https://android.googlesource.com/platform/cts/+/jb-mr2-release/tests/tests/media/src/android/media/cts/InputSurface.java\r\n *\r\n * Copyright (C) 2013 The Android Open Source Project\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * MediaCodecで使うOpenGLを管理するクラス\r\n *\r\n * Holds state associated with a Surface used for MediaCodec encoder input.\r\n * The constructor takes a Surface obtained from MediaCodec.createInputSurface(), and uses that\r\n * to create an EGL window surface.  Calls to eglSwapBuffers() cause a frame of data to be sent\r\n * to the video encoder.\r\n *\r\n * @param surface MediaCodecでもらえるcreateInputSurface\r\n */\r\nclass CodecInputSurface(\r\n    private val surface: Surface,\r\n    private val textureRenderer: TextureRenderer,\r\n) : SurfaceTexture.OnFrameAvailableListener {\r\n\r\n    private var mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n    private var mEGLContext = EGL14.EGL_NO_CONTEXT\r\n    private var mEGLSurface = EGL14.EGL_NO_SURFACE\r\n    private val mFrameSyncObject = Object()\r\n    private var mFrameAvailable = false\r\n    private var surfaceTexture: SurfaceTexture? = null\r\n\r\n    /** MediaCodecのデコーダーSurfaceとしてこれを使う */\r\n    var drawSurface: Surface? = null\r\n        private set\r\n\r\n    init {\r\n        eglSetup()\r\n    }\r\n\r\n    fun createRender() {\r\n        textureRenderer.surfaceCreated()\r\n        surfaceTexture = SurfaceTexture(textureRenderer.videoTextureID).also { surfaceTexture ->\r\n            surfaceTexture.setOnFrameAvailableListener(this)\r\n        }\r\n        drawSurface = Surface(surfaceTexture)\r\n    }\r\n\r\n    /**\r\n     * Prepares EGL.  We want a GLES 2.0 context and a surface that supports recording.\r\n     */\r\n    private fun eglSetup() {\r\n        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)\r\n        if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n            throw RuntimeException(\"unable to get EGL14 display\")\r\n        }\r\n        val version = IntArray(2)\r\n        if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n            throw RuntimeException(\"unable to initialize EGL14\")\r\n        }\r\n        // Configure EGL for recording and OpenGL ES 2.0.\r\n        val attribList = intArrayOf(\r\n            EGL14.EGL_RED_SIZE, 8,\r\n            EGL14.EGL_GREEN_SIZE, 8,\r\n            EGL14.EGL_BLUE_SIZE, 8,\r\n            EGL14.EGL_ALPHA_SIZE, 8,\r\n            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\r\n            EGL_RECORDABLE_ANDROID, 1,\r\n            EGL14.EGL_NONE\r\n        )\r\n        val configs = arrayOfNulls<EGLConfig>(1)\r\n        val numConfigs = IntArray(1)\r\n        EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.size, numConfigs, 0)\r\n        checkEglError(\"eglCreateContext RGB888+recordable ES2\")\r\n\r\n        // Configure context for OpenGL ES 2.0.\r\n        val attrib_list = intArrayOf(\r\n            EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLContext = EGL14.eglCreateContext(\r\n            mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT,\r\n            attrib_list, 0\r\n        )\r\n        checkEglError(\"eglCreateContext\")\r\n\r\n        // Create a window surface, and attach it to the Surface we received.\r\n        val surfaceAttribs = intArrayOf(\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], surface, surfaceAttribs, 0)\r\n        checkEglError(\"eglCreateWindowSurface\")\r\n    }\r\n\r\n    fun changeFragmentShader(fragmentShader: String) {\r\n        textureRenderer.changeFragmentShader(fragmentShader)\r\n    }\r\n\r\n    fun awaitNewImage() {\r\n        val TIMEOUT_MS = 5000\r\n        synchronized(mFrameSyncObject) {\r\n            while (!mFrameAvailable) {\r\n                try {\r\n                    mFrameSyncObject.wait(TIMEOUT_MS.toLong())\r\n                    if (!mFrameAvailable) {\r\n                        throw RuntimeException(\"Surface frame wait timed out\")\r\n                    }\r\n                } catch (ie: InterruptedException) {\r\n                    throw RuntimeException(ie)\r\n                }\r\n            }\r\n            mFrameAvailable = false\r\n        }\r\n        textureRenderer.checkGlError(\"before updateTexImage\")\r\n        surfaceTexture?.updateTexImage()\r\n    }\r\n\r\n    /**\r\n     * フレームが来たら描画する\r\n     *\r\n     * @param onCanvasDrawRequest Canvasを渡すので描画して返してください\r\n     */\r\n    fun drawImage(onCanvasDrawRequest: (Canvas) -> Unit) {\r\n        val surfaceTexture = surfaceTexture ?: return\r\n        textureRenderer.prepareDraw()\r\n        textureRenderer.drawFrame(surfaceTexture)\r\n        textureRenderer.drawCanvas(onCanvasDrawRequest)\r\n        textureRenderer.invokeGlFinish()\r\n    }\r\n\r\n    override fun onFrameAvailable(st: SurfaceTexture) {\r\n        synchronized(mFrameSyncObject) {\r\n            if (mFrameAvailable) {\r\n                throw RuntimeException(\"mFrameAvailable already set, frame could be dropped\")\r\n            }\r\n            mFrameAvailable = true\r\n            mFrameSyncObject.notifyAll()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Discards all resources held by this class, notably the EGL context.  Also releases the\r\n     * Surface that was passed to our constructor.\r\n     */\r\n    fun release() {\r\n        if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n            EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT)\r\n            EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface)\r\n            EGL14.eglDestroyContext(mEGLDisplay, mEGLContext)\r\n            EGL14.eglReleaseThread()\r\n            EGL14.eglTerminate(mEGLDisplay)\r\n        }\r\n        surface.release()\r\n        mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n        mEGLContext = EGL14.EGL_NO_CONTEXT\r\n        mEGLSurface = EGL14.EGL_NO_SURFACE\r\n    }\r\n\r\n    /**\r\n     * Makes our EGL context and surface current.\r\n     */\r\n    fun makeCurrent() {\r\n        EGL14.eglMakeCurrent(mEGLDisplay, mEGLSurface, mEGLSurface, mEGLContext)\r\n        checkEglError(\"eglMakeCurrent\")\r\n    }\r\n\r\n    /**\r\n     * Calls eglSwapBuffers.  Use this to \"publish\" the current frame.\r\n     */\r\n    fun swapBuffers(): Boolean {\r\n        val result = EGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface)\r\n        checkEglError(\"eglSwapBuffers\")\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Sends the presentation time stamp to EGL.  Time is expressed in nanoseconds.\r\n     */\r\n    fun setPresentationTime(nsecs: Long) {\r\n        EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs)\r\n        checkEglError(\"eglPresentationTimeANDROID\")\r\n    }\r\n\r\n    /**\r\n     * Checks for EGL errors.  Throws an exception if one is found.\r\n     */\r\n    private fun checkEglError(msg: String) {\r\n        val error = EGL14.eglGetError()\r\n        if (error != EGL14.EGL_SUCCESS) {\r\n            throw RuntimeException(\"$msg: EGL error: 0x${Integer.toHexString(error)}\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val EGL_RECORDABLE_ANDROID = 0x3142\r\n    }\r\n\r\n}\r\n```\r\n\r\n### TextureRenderer.kt\r\nこちらは映像とCanvasをOpenGLを利用してかさねるためのクラスです。  \r\nまずコード全文を\r\n\r\n```kotlin\r\n/**\r\n * OpenGL関連\r\n * 映像にCanvasを重ねてエンコーダーに渡す。\r\n * 映像を描画したあとにCanvasを描画する。二回四角形を描画している。\r\n *\r\n * @param outputVideoWidth エンコード時の動画の幅\r\n * @param outputVideoHeight エンコード時の動画の高さ\r\n * @param originVideoWidth 元動画の幅\r\n * @param originVideoHeight 元動画の高さ\r\n * @param videoRotation 映像を回転させる場合に利用\r\n */\r\nclass TextureRenderer(\r\n    private val outputVideoWidth: Int,\r\n    private val outputVideoHeight: Int,\r\n    private val originVideoHeight: Int,\r\n    private val originVideoWidth: Int,\r\n    private val videoRotation: Float\r\n) {\r\n\r\n    private var mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.size * FLOAT_SIZE_BYTES).run {\r\n        order(ByteOrder.nativeOrder())\r\n        asFloatBuffer().apply {\r\n            put(mTriangleVerticesData)\r\n            position(0)\r\n        }\r\n    }\r\n\r\n    private val mMVPMatrix = FloatArray(16)\r\n    private val mSTMatrix = FloatArray(16)\r\n\r\n    /** Canvasで書いたBitmap。Canvasの内容をOpenGLのテクスチャとして利用 */\r\n    private val canvasBitmap by lazy { Bitmap.createBitmap(outputVideoWidth, outputVideoHeight, Bitmap.Config.ARGB_8888) }\r\n\r\n    /** Canvas。これがエンコーダーに行く */\r\n    private val canvas by lazy { Canvas(canvasBitmap) }\r\n\r\n    // ハンドルたち\r\n    private var mProgram = 0\r\n    private var muMVPMatrixHandle = 0\r\n    private var muSTMatrixHandle = 0\r\n    private var maPositionHandle = 0\r\n    private var maTextureHandle = 0\r\n    private var uCanvasTextureHandle = 0\r\n    private var uVideoTextureHandle = 0\r\n    private var uDrawVideo = 0\r\n\r\n    /** キャンバスの画像を渡すOpenGLのテクスチャID */\r\n    private var canvasTextureID = -1\r\n\r\n    /** デコード結果が流れてくるOpenGLのテクスチャID */\r\n    var videoTextureID = -1\r\n        private set\r\n\r\n    init {\r\n        Matrix.setIdentityM(mSTMatrix, 0)\r\n    }\r\n\r\n    /** 描画前に呼び出す */\r\n    fun prepareDraw() {\r\n        // glError 1282 の原因とかになる\r\n        GLES20.glUseProgram(mProgram)\r\n        checkGlError(\"glUseProgram\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n\r\n        // Snapdragon だと glClear が無いと映像が乱れる\r\n        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT or GLES20.GL_COLOR_BUFFER_BIT)\r\n    }\r\n\r\n    /**\r\n     * フレームを描画する\r\n     *\r\n     * @param surfaceTexture [SurfaceTexture]\r\n     */\r\n    fun drawFrame(surfaceTexture: SurfaceTexture) {\r\n        checkGlError(\"onDrawFrame start\")\r\n        surfaceTexture.getTransformMatrix(mSTMatrix)\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, videoTextureID)\r\n        // 映像のテクスチャユニットは GLES20.GL_TEXTURE0 なので 0\r\n        GLES20.glUniform1i(uVideoTextureHandle, 0)\r\n        // Canvasのテクスチャユニットは GLES20.GL_TEXTURE1 なので 1\r\n        GLES20.glUniform1i(uCanvasTextureHandle, 1)\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n        // ----\r\n        // 映像を描画するフラグを立てる\r\n        // ----\r\n        GLES20.glUniform1i(uDrawVideo, 1)\r\n        // アスペクト比を調整する\r\n        Matrix.setIdentityM(mMVPMatrix, 0)\r\n\r\n        // 横幅を計算して合わせる\r\n        // 縦は outputHeight 最大まで\r\n        val scaleY = (outputVideoHeight / originVideoHeight.toFloat())\r\n        val textureWidth = originVideoWidth * scaleY\r\n        val percent = textureWidth / outputVideoWidth.toFloat()\r\n        Matrix.scaleM(mMVPMatrix, 0, percent, 1f, 1f)\r\n\r\n        // 動画が回転している場合に戻す\r\n        Matrix.rotateM(mMVPMatrix, 0, videoRotation, 0f, 0f, 1f)\r\n\r\n        // 描画する\r\n        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0)\r\n        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0)\r\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)\r\n        checkGlError(\"glDrawArrays VideoFrame\")\r\n    }\r\n\r\n    /**\r\n     * Canvas に書いて OpenGL で描画する。\r\n     * [drawFrame]のあとに呼び出す必要あり。\r\n     *\r\n     * @param onCanvasDrawRequest Canvasを渡すので描画して返してください\r\n     */\r\n    fun drawCanvas(onCanvasDrawRequest: (Canvas) -> Unit) {\r\n        checkGlError(\"drawCanvas start\")\r\n        // コンテキストをCanvasのテクスチャIDに切り替える\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)\r\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, canvasTextureID)\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)\r\n        // 前回のを消す\r\n        canvas.drawColor(0, PorterDuff.Mode.CLEAR)\r\n        // Canvasで書く\r\n        onCanvasDrawRequest(canvas)\r\n        // glActiveTexture したテクスチャへCanvasで書いた画像を転送する\r\n        // 更新なので texSubImage2D\r\n        GLUtils.texSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, canvasBitmap)\r\n        checkGlError(\"GLUtils.texSubImage2D canvasTextureID\")\r\n        // Uniform 変数へテクスチャを設定\r\n        // 第二引数の 1 って何、、、（GLES20.GL_TEXTURE1 だから？）\r\n        GLES20.glUniform1i(uCanvasTextureHandle, 1)\r\n        checkGlError(\"glUniform1i uCanvasTextureHandle\")\r\n        // ----\r\n        // Canvasを描画するフラグを立てる\r\n        // ----\r\n        GLES20.glUniform1i(uDrawVideo, 0)\r\n        // アスペクト比の調整はいらないのでリセット（エンコーダーの出力サイズにCanvasを合わせて作っているため）\r\n        Matrix.setIdentityM(mMVPMatrix, 0)\r\n        // 描画する\r\n        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0)\r\n        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0)\r\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)\r\n        checkGlError(\"glDrawArrays Canvas\")\r\n    }\r\n\r\n    /** glFinish をよびだす */\r\n    fun invokeGlFinish() {\r\n        GLES20.glFinish()\r\n    }\r\n\r\n    fun surfaceCreated() {\r\n        mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER)\r\n        if (mProgram == 0) {\r\n            throw RuntimeException(\"failed creating program\")\r\n        }\r\n        maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\")\r\n        checkGlError(\"glGetAttribLocation aPosition\")\r\n        if (maPositionHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aPosition\")\r\n        }\r\n        maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\")\r\n        checkGlError(\"glGetAttribLocation aTextureCoord\")\r\n        if (maTextureHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aTextureCoord\")\r\n        }\r\n        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\")\r\n        checkGlError(\"glGetUniformLocation uMVPMatrix\")\r\n        if (muMVPMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uMVPMatrix\")\r\n        }\r\n        muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\")\r\n        checkGlError(\"glGetUniformLocation uSTMatrix\")\r\n        if (muSTMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uSTMatrix\")\r\n        }\r\n        uCanvasTextureHandle = GLES20.glGetUniformLocation(mProgram, \"uCanvasTexture\")\r\n        uVideoTextureHandle = GLES20.glGetUniformLocation(mProgram, \"uVideoTexture\")\r\n        uDrawVideo = GLES20.glGetUniformLocation(mProgram, \"uDrawVideo\")\r\n\r\n        // 映像が入ってくるテクスチャ、Canvasのテクスチャを登録する\r\n        // テクスチャ2つ作る\r\n        val textures = IntArray(2)\r\n        GLES20.glGenTextures(2, textures, 0)\r\n\r\n        // 映像テクスチャ\r\n        videoTextureID = textures[0]\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, videoTextureID)\r\n        checkGlError(\"glBindTexture videoTextureID\")\r\n\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST.toFloat())\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR.toFloat())\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)\r\n        checkGlError(\"glTexParameter videoTextureID\")\r\n\r\n        // Canvasテクスチャ\r\n        canvasTextureID = textures[1]\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)\r\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, canvasTextureID)\r\n        checkGlError(\"glBindTexture canvasTextureID\")\r\n\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)\r\n\r\n        // テクスチャを初期化\r\n        // 更新の際はコンテキストを切り替えた上で texSubImage2D を使う\r\n        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, canvasBitmap, 0)\r\n        checkGlError(\"glTexParameter canvasTextureID\")\r\n\r\n        // アルファブレンドを有効\r\n        // これにより、透明なテクスチャがちゃんと透明に描画される\r\n        GLES20.glEnable(GLES20.GL_BLEND)\r\n        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA)\r\n        checkGlError(\"glEnable BLEND\")\r\n    }\r\n\r\n    fun changeFragmentShader(fragmentShader: String) {\r\n        GLES20.glDeleteProgram(mProgram)\r\n        mProgram = createProgram(VERTEX_SHADER, fragmentShader)\r\n        if (mProgram == 0) {\r\n            throw RuntimeException(\"failed creating program\")\r\n        }\r\n    }\r\n\r\n    private fun loadShader(shaderType: Int, source: String): Int {\r\n        var shader = GLES20.glCreateShader(shaderType)\r\n        checkGlError(\"glCreateShader type=$shaderType\")\r\n        GLES20.glShaderSource(shader, source)\r\n        GLES20.glCompileShader(shader)\r\n        val compiled = IntArray(1)\r\n        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0)\r\n        if (compiled[0] == 0) {\r\n            GLES20.glDeleteShader(shader)\r\n            shader = 0\r\n        }\r\n        return shader\r\n    }\r\n\r\n    private fun createProgram(vertexSource: String, fragmentSource: String): Int {\r\n        val vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource)\r\n        if (vertexShader == 0) {\r\n            return 0\r\n        }\r\n        val pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource)\r\n        if (pixelShader == 0) {\r\n            return 0\r\n        }\r\n        var program = GLES20.glCreateProgram()\r\n        checkGlError(\"glCreateProgram\")\r\n        if (program == 0) {\r\n            return 0\r\n        }\r\n        GLES20.glAttachShader(program, vertexShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glAttachShader(program, pixelShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glLinkProgram(program)\r\n        val linkStatus = IntArray(1)\r\n        GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0)\r\n        if (linkStatus[0] != GLES20.GL_TRUE) {\r\n            GLES20.glDeleteProgram(program)\r\n            program = 0\r\n        }\r\n        return program\r\n    }\r\n\r\n    fun checkGlError(op: String) {\r\n        val error = GLES20.glGetError()\r\n        if (error != GLES20.GL_NO_ERROR) {\r\n            throw RuntimeException(\"$op: glError $error\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        private val mTriangleVerticesData = floatArrayOf(\r\n            -1.0f, -1.0f, 0f, 0f, 0f,\r\n            1.0f, -1.0f, 0f, 1f, 0f,\r\n            -1.0f, 1.0f, 0f, 0f, 1f,\r\n            1.0f, 1.0f, 0f, 1f, 1f\r\n        )\r\n\r\n        private const val FLOAT_SIZE_BYTES = 4\r\n        private const val TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES\r\n        private const val TRIANGLE_VERTICES_DATA_POS_OFFSET = 0\r\n        private const val TRIANGLE_VERTICES_DATA_UV_OFFSET = 3\r\n\r\n        /** バーテックスシェーダー。座標などを決める */\r\n        private const val VERTEX_SHADER = \"\"\"\r\n            uniform mat4 uMVPMatrix;\r\n            uniform mat4 uSTMatrix;\r\n            attribute vec4 aPosition;\r\n            attribute vec4 aTextureCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            void main() {\r\n              gl_Position = uMVPMatrix * aPosition;\r\n              vTextureCoord = (uSTMatrix * aTextureCoord).xy;\r\n            }\r\n        \"\"\"\r\n\r\n        /** フラグメントシェーダー。実際の色を返す */\r\n        private const val FRAGMENT_SHADER = \"\"\"\r\n            #extension GL_OES_EGL_image_external : require\r\n\r\n            precision mediump float;\r\n            varying vec2 vTextureCoord;\r\n            uniform samplerExternalOES uVideoTexture;        \r\n            uniform sampler2D uCanvasTexture;\r\n            \r\n            // 映像を描画するのか、Canvasを描画するのかのフラグ\r\n            uniform int uDrawVideo;\r\n        \r\n            void main() {\r\n                vec4 videoTexture = texture2D(uVideoTexture, vTextureCoord);\r\n                vec4 canvasTexture = texture2D(uCanvasTexture, vTextureCoord);\r\n                \r\n                if (bool(uDrawVideo)) {\r\n                    gl_FragColor = videoTexture;                \r\n                } else {\r\n                    gl_FragColor = canvasTexture;\r\n                }\r\n            }\r\n        \"\"\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### よく分からんなりの解説\r\n`Surface`の映像は`Android`の`SurfaceTexture`を利用することで`OpenGL`のテクスチャ（画像）として取得できます。（`sampler2D`ではなく`samplerExternalOES`です）  \r\n`Canvas`は`Bitmap`にすることで、`OpenGL`のテクスチャとして取得できます。（`sampler2D`です）  \r\n\r\n- 映像のフレームがやってくる\r\n- Canvasに描画する\r\n- `glDrawArrays`を呼び出して映像を描画する\r\n- 今度は `Canvas` の内容を `glDrawArrays` を呼び出して重ねて描画する\r\n    - `uniform 変数 uDrawVideo`を切り替えて Canvas を描画する\r\n- エンコーダーに行く？\r\n\r\n今回は`フラグメントシェーダ`に用意したフラグを切り替えることで映像とCanvasの画像を切り替えて描画できるようにしてあります。（`uDrawVideo`フラグ）  \r\n（どうやって 映像とCanvasの画像 を重ねるんだろうって一週間ぐらい悩んでましたが、二回描画すればいいんですね。基礎がなってないね）\r\n\r\nまた、`gl_Position`の値を制御することで回転やスケールの調整ができます。  \r\n今回は`gl_Position`をいい感じにして縦動画でも真ん中にフィットさせて描画されるようにしてあります。`Matrix.scaleM`の部分です。（引数に動画のサイズを取ってるのはそのせい）  \r\nまた、（後でまた書きますが）縦動画の場合は`gl_Position`をいい感じにして回転させる処理を追加しています。行列の回転とかいうやつらしいです。`Matrix.rotateM`の部分です。\r\n（もしうまく動いてない（ひっくり返ってる）場合は `Matrix.rotateM` の部分を見直してみてください、、よくわかりません。）\r\n\r\nあと、`Canvas`の何も書いていない部分は透明になるのですが、`アルファブレンド`の設定をしていないと`重ねたCanvas`のせいで透明の部分が真っ黒になります。\r\n\r\n#### Snapdragon端末で映像が乱れた\r\n`glClear`関数を呼ぶことで直りました。\r\n\r\n### VideoProcessor.kt\r\n最後に MediaCodec とかと上で書いたコードを組み合わせます。  \r\nまず全文貼りますね  \r\nここにもいくつか罠があって、、、\r\n\r\n```kotlin\r\n/**\r\n * 動画にCanvasをかさねる処理\r\n *\r\n * @param videoFile 元動画\r\n * @param resultFile エンコード後の動画\r\n * @param bitRate ビットレート\r\n * @param frameRate フレームレート\r\n * @param outputVideoWidth エンコード後の動画の幅\r\n * @param outputVideoHeight エンコード後の動画の高さ\r\n */\r\nclass VideoProcessor(\r\n    private val videoFile: File,\r\n    private val resultFile: File,\r\n    private val bitRate: Int = 1_000_000,\r\n    private val frameRate: Int = 30,\r\n    private val outputVideoWidth: Int = 1280,\r\n    private val outputVideoHeight: Int = 720,\r\n) {\r\n\r\n    /** データを取り出すやつ */\r\n    private var mediaExtractor: MediaExtractor? = null\r\n\r\n    /** エンコード用 [MediaCodec] */\r\n    private var encodeMediaCodec: MediaCodec? = null\r\n\r\n    /** デコード用 [MediaCodec] */\r\n    private var decodeMediaCodec: MediaCodec? = null\r\n\r\n    /** コンテナフォーマットへ格納するやつ */\r\n    private val mediaMuxer by lazy { MediaMuxer(resultFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) }\r\n\r\n    /** OpenGL で加工する */\r\n    private var codecInputSurface: CodecInputSurface? = null\r\n\r\n    /**\r\n     * エンコードを開始する\r\n     *\r\n     * @param onCanvasDrawRequest Canvasで描画する。timeMsは動画の時間\r\n     */\r\n    suspend fun encode(\r\n        onCanvasDrawRequest: Canvas.(timeMs: Long) -> Unit,\r\n    ) = withContext(Dispatchers.Default) {\r\n        // 動画を取り出す\r\n        val (mediaExtractor, index, format) = extractMedia(videoFile.path, \"video/\")\r\n        this@VideoProcessor.mediaExtractor = mediaExtractor\r\n        // 動画トラック\r\n        mediaExtractor.selectTrack(index)\r\n        mediaExtractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC)\r\n\r\n        // 解析結果から各パラメータを取り出す\r\n        val videoMimeType = format.getString(MediaFormat.KEY_MIME)!!\r\n        val videoWidth = format.getInteger(MediaFormat.KEY_WIDTH)\r\n        val videoHeight = format.getInteger(MediaFormat.KEY_HEIGHT)\r\n        // 画面回転情報\r\n        // Androidの縦動画はどうやら回転させているらしいので、回転を戻す\r\n        // TODO KEY_ROTATION が Android 6 以降\r\n        val hasRotation = format.getIntegerOrNull(MediaFormat.KEY_ROTATION) == 90\r\n        // 画面回転度がある場合は width / height がそれぞれ入れ替わるので注意（一敗）\r\n        val originVideoWidth = if (hasRotation) videoHeight else videoWidth\r\n        val originVideoHeight = if (hasRotation) videoWidth else videoHeight\r\n\r\n        // エンコード用（生データ -> H.264）MediaCodec\r\n        encodeMediaCodec = MediaCodec.createEncoderByType(videoMimeType).apply {\r\n            // エンコーダーにセットするMediaFormat\r\n            // コーデックが指定されていればそっちを使う\r\n            val videoMediaFormat = MediaFormat.createVideoFormat(videoMimeType, outputVideoWidth, outputVideoHeight).apply {\r\n                setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n                setInteger(MediaFormat.KEY_FRAME_RATE, frameRate)\r\n                setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)\r\n                setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n            }\r\n            configure(videoMediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n\r\n        // エンコーダーのSurfaceを取得して、OpenGLを利用してCanvasを重ねます\r\n        codecInputSurface = CodecInputSurface(\r\n            encodeMediaCodec!!.createInputSurface(),\r\n            TextureRenderer(\r\n                outputVideoWidth = outputVideoWidth,\r\n                outputVideoHeight = outputVideoHeight,\r\n                originVideoWidth = originVideoWidth,\r\n                originVideoHeight = originVideoHeight,\r\n                videoRotation = if (hasRotation) 270f else 0f\r\n            )\r\n        )\r\n\r\n        codecInputSurface?.makeCurrent()\r\n        encodeMediaCodec!!.start()\r\n\r\n        // デコード用（H.264 -> 生データ）MediaCodec\r\n        codecInputSurface?.createRender()\r\n        decodeMediaCodec = MediaCodec.createDecoderByType(videoMimeType).apply {\r\n            // 画面回転データが有った場合にリセットする\r\n            // このままだと回転されたままなので、OpenGL 側で回転させる\r\n            // setInteger をここでやるのは良くない気がするけど面倒なので\r\n            format.setInteger(MediaFormat.KEY_ROTATION, 0)\r\n            configure(format, codecInputSurface!!.drawSurface, null, 0)\r\n        }\r\n        decodeMediaCodec?.start()\r\n\r\n        // nonNull\r\n        val decodeMediaCodec = decodeMediaCodec!!\r\n        val encodeMediaCodec = encodeMediaCodec!!\r\n\r\n        // メタデータ格納用\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n\r\n        var videoTrackIndex = -1\r\n\r\n        var outputDone = false\r\n        var inputDone = false\r\n\r\n        while (!outputDone) {\r\n            if (!inputDone) {\r\n\r\n                val inputBufferId = decodeMediaCodec.dequeueInputBuffer(TIMEOUT_US)\r\n                if (inputBufferId >= 0) {\r\n                    val inputBuffer = decodeMediaCodec.getInputBuffer(inputBufferId)!!\r\n                    val size = mediaExtractor.readSampleData(inputBuffer, 0)\r\n                    if (size > 0) {\r\n                        // デコーダーへ流す\r\n                        // 今までの動画の分の再生位置を足しておく\r\n                        decodeMediaCodec.queueInputBuffer(inputBufferId, 0, size, mediaExtractor.sampleTime, 0)\r\n                        mediaExtractor.advance()\r\n                    } else {\r\n                        // 終了\r\n                        decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n                        // 開放\r\n                        mediaExtractor.release()\r\n                        // 終了\r\n                        inputDone = true\r\n                    }\r\n                }\r\n            }\r\n            var decoderOutputAvailable = true\r\n            while (decoderOutputAvailable) {\r\n                // Surface経由でデータを貰って保存する\r\n                val encoderStatus = encodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (encoderStatus >= 0) {\r\n                    val encodedData = encodeMediaCodec.getOutputBuffer(encoderStatus)!!\r\n                    if (bufferInfo.size > 1) {\r\n                        if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                            // MediaMuxer へ addTrack した後\r\n                            mediaMuxer.writeSampleData(videoTrackIndex, encodedData, bufferInfo)\r\n                        }\r\n                    }\r\n                    outputDone = bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0\r\n                    encodeMediaCodec.releaseOutputBuffer(encoderStatus, false)\r\n                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                    // MediaMuxerへ映像トラックを追加するのはこのタイミングで行う\r\n                    // このタイミングでやると固有のパラメーターがセットされたMediaFormatが手に入る(csd-0 とか)\r\n                    // 映像がぶっ壊れている場合（緑で塗りつぶされてるとか）は多分このあたりが怪しい\r\n                    val newFormat = encodeMediaCodec.outputFormat\r\n                    videoTrackIndex = mediaMuxer.addTrack(newFormat)\r\n                    mediaMuxer.start()\r\n                }\r\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                    continue\r\n                }\r\n                // Surfaceへレンダリングする。そしてOpenGLでゴニョゴニョする\r\n                val outputBufferId = decodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId == MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                    decoderOutputAvailable = false\r\n                } else if (outputBufferId >= 0) {\r\n                    // 進捗\r\n                    val doRender = bufferInfo.size != 0\r\n                    decodeMediaCodec.releaseOutputBuffer(outputBufferId, doRender)\r\n                    if (doRender) {\r\n                        var errorWait = false\r\n                        try {\r\n                            codecInputSurface?.awaitNewImage()\r\n                        } catch (e: Exception) {\r\n                            errorWait = true\r\n                        }\r\n                        if (!errorWait) {\r\n                            // 映像とCanvasを合成する\r\n                            codecInputSurface?.drawImage { canvas ->\r\n                                onCanvasDrawRequest(canvas, bufferInfo.presentationTimeUs / 1000L)\r\n                            }\r\n                            codecInputSurface?.setPresentationTime(bufferInfo.presentationTimeUs * 1000)\r\n                            codecInputSurface?.swapBuffers()\r\n                        }\r\n                    }\r\n                    if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {\r\n                        decoderOutputAvailable = false\r\n                        encodeMediaCodec.signalEndOfInputStream()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // デコーダー終了\r\n        decodeMediaCodec.stop()\r\n        decodeMediaCodec.release()\r\n        // OpenGL開放\r\n        codecInputSurface?.release()\r\n        // エンコーダー終了\r\n        encodeMediaCodec.stop()\r\n        encodeMediaCodec.release()\r\n        // MediaMuxerも終了\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n    }\r\n\r\n    private fun MediaFormat.getIntegerOrNull(name: String): Int? {\r\n        return if (containsKey(name)) {\r\n            getInteger(name)\r\n        } else null\r\n    }\r\n\r\n    private fun extractMedia(videoPath: String, startMimeType: String): Triple<MediaExtractor, Int, MediaFormat> {\r\n        val mediaExtractor = MediaExtractor().apply { setDataSource(videoPath) }\r\n        // トラックとインデックス番号のPairを作って返す\r\n        val (index, track) = (0 until mediaExtractor.trackCount)\r\n            .map { index -> index to mediaExtractor.getTrackFormat(index) }\r\n            .first { (_, track) -> track.getString(MediaFormat.KEY_MIME)?.startsWith(startMimeType) == true }\r\n        return Triple(mediaExtractor, index, track)\r\n    }\r\n\r\n    companion object {\r\n        /** タイムアウト */\r\n        private const val TIMEOUT_US = 10_000L\r\n    }\r\n}\r\n```\r\n\r\n#### 雑な解説\r\nといってもデコーダーの出力をOpenGLに向けている以外になさそう？  \r\n映像が取得できたら、`Canvas`の更新をするようにしています。\r\n\r\n#### わな 縦動画の場合は動画の回転情報が入っている。\r\n- しれっと書いてあった\r\n    - https://developer.android.com/reference/android/media/MediaCodec#transformations-when-rendering-onto-surface\r\n    - Surface の場合回転情報があれば回転しますよって\r\n    - 回転した 横の動画 みたいな\r\n    - デコード時 に回転されたまま表示される\r\n- それだけじゃなく、動画のの幅、動画の高さも回転されている状態で保存される\r\n    - height / width が逆になる！？\r\n- 今回はこれを修正するため、縦動画の場合は`OpenGL`側で`Matrix.rotateM`をして回転情報がなくても縦動画にするようにしています。\r\n\r\n↓ ちょうどここ\r\n\r\n```kotlin\r\n// 画面回転情報\r\n// Androidの縦動画はどうやら回転させているらしいので、回転を戻す\r\n// TODO KEY_ROTATION が Android 6 以降\r\nval hasRotation = format.getIntegerOrNull(MediaFormat.KEY_ROTATION) == 90\r\n// 画面回転度がある場合は width / height がそれぞれ入れ替わるので注意（一敗）\r\nval originVideoWidth = if (hasRotation) videoHeight else videoWidth\r\nval originVideoHeight = if (hasRotation) videoWidth else videoHeight\r\n```\r\n\r\nあとは`MediaCodec`特有の使いにくさが相変わらずあるのですがそれは前に書いた他の記事で...\r\n\r\n## MainActivity.kt\r\n本当は長時間のタスクになるので、`フォアグラウンドサービス`でやるべきですが本題じゃないので、、  \r\n\r\n```kotlin\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    setContentView(viewBinding.root)\r\n    // 動画を選択する\r\n    viewBinding.videoSelectButton.setOnClickListener {\r\n        videoPicker.launch(\"video/mp4\")\r\n    }\r\n    // エンコーダーを起動する\r\n    viewBinding.encodeButton.setOnClickListener {\r\n        lifecycleScope.launch {\r\n            viewBinding.encodeStatusTextView.text = \"エンコード開始\"\r\n            val videoFile = File(workFolder, VIDEO_FILE_NAME)\r\n            val resultFile = File(workFolder, RESULT_VIDEO_FILE_NAME)\r\n            val videoProcessor = VideoProcessor(videoFile, resultFile)\r\n            videoProcessor.encode { currentTimeMs ->\r\n                // TODO この後すぐ\r\n            }\r\n            // TODO 音声の追加\r\n            // TODO MediaStoreへ追加\r\n            viewBinding.encodeStatusTextView.text = \"エンコード終了\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Canvasでお絵かきタイム\r\nおまたせしました。お絵かきタイムです  \r\n`this`に`Canvas`、`currentTimeMs`は動画の再生位置（ミリ秒）になります。\r\n\r\n```\r\nvideoProcessor.encode { currentTimeMs ->\r\n    // this は Canvas\r\n    // currentTimeMs は動画の再生位置（ミリ秒）\r\n}\r\n```\r\n\r\n例えば動画の再生時間を重ねた（ついでに画像も）場合はこんな感じ\r\n\r\n```kotlin\r\nval videoFile = File(workFolder, VIDEO_FILE_NAME)\r\nval resultFile = File(workFolder, RESULT_VIDEO_FILE_NAME)\r\nval videoWidth = 1280\r\nval videoHeight = 720\r\nval videoProcessor = VideoProcessor(\r\n    videoFile = videoFile,\r\n    resultFile = resultFile,\r\n    outputVideoWidth = videoWidth,\r\n    outputVideoHeight = videoHeight\r\n)\r\nval textPaint = Paint().apply {\r\n    textSize = 80f\r\n}\r\nval logoBitmap = ContextCompat.getDrawable(this@MainActivity, R.drawable.ic_launcher_foreground)?.apply {\r\n    setTint(Color.WHITE)\r\n}?.toBitmap(300, 300)!!\r\nvideoProcessor.encode { currentTimeMs ->\r\n    // this が Canvas\r\n    // 適当に文字を書く\r\n    val text = \"動画の時間 = ${\"%.2f\".format(currentTimeMs / 1000f)}\"\r\n    textPaint.color = Color.BLACK\r\n    textPaint.style = Paint.Style.STROKE\r\n    // 枠取り文字\r\n    drawText(text, 700f, 500f, textPaint)\r\n    textPaint.style = Paint.Style.FILL\r\n    textPaint.color = Color.WHITE\r\n    // 枠無し文字\r\n    drawText(text, 700f, 500f, textPaint)\r\n    // 画像も表示する\r\n    drawBitmap(logoBitmap, (videoWidth - logoBitmap.width).toFloat(), (videoWidth - logoBitmap.height).toFloat(), textPaint)\r\n}\r\n```\r\n\r\nついでにここまでの`MainActivity.kt`を置いておきます。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val workFolder by lazy { File(getExternalFilesDir(null), \"video\").apply { mkdir() } }\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    /** 動画ピッカー */\r\n    private val videoPicker = registerForActivityResult(ActivityResultContracts.GetContent()) { uri ->\r\n        uri ?: return@registerForActivityResult\r\n        // コピーする\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            val videoFile = File(workFolder, VIDEO_FILE_NAME).apply {\r\n                createNewFile()\r\n            }\r\n            videoFile.outputStream().use { outputStream ->\r\n                contentResolver.openInputStream(uri)?.use { inputStream ->\r\n                    inputStream.copyTo(outputStream)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        // 動画を選択する\r\n        viewBinding.videoSelectButton.setOnClickListener {\r\n            videoPicker.launch(\"video/mp4\")\r\n        }\r\n\r\n        // エンコーダーを起動する\r\n        viewBinding.encodeButton.setOnClickListener {\r\n            lifecycleScope.launch {\r\n\r\n                viewBinding.encodeStatusTextView.text = \"エンコード開始\"\r\n\r\n                val videoFile = File(workFolder, VIDEO_FILE_NAME)\r\n                val resultFile = File(workFolder, RESULT_VIDEO_FILE_NAME)\r\n                val videoWidth = 1280\r\n                val videoHeight = 720\r\n                val videoProcessor = VideoProcessor(\r\n                    videoFile = videoFile,\r\n                    resultFile = resultFile,\r\n                    outputVideoWidth = videoWidth,\r\n                    outputVideoHeight = videoHeight\r\n                )\r\n\r\n                val textPaint = Paint().apply {\r\n                    textSize = 100f\r\n                }\r\n                val logoBitmap = ContextCompat.getDrawable(this@MainActivity, R.drawable.ic_launcher_foreground)?.apply {\r\n                    setTint(Color.WHITE)\r\n                }?.toBitmap(300, 300)!!\r\n\r\n                videoProcessor.encode { currentTimeMs ->\r\n                    // 適当に文字を書く\r\n                    val text = \"動画の時間 = ${\"%.2f\".format(currentTimeMs / 1000f)}\"\r\n\r\n                    textPaint.color = Color.BLACK\r\n                    textPaint.style = Paint.Style.STROKE\r\n                    // 枠取り文字\r\n                    drawText(text, 200f, 300f, textPaint)\r\n\r\n                    textPaint.style = Paint.Style.FILL\r\n                    textPaint.color = Color.WHITE\r\n                    // 枠無し文字\r\n                    drawText(text, 200f, 300f, textPaint)\r\n\r\n                    // 画像も表示する\r\n                    drawBitmap(logoBitmap, (videoWidth - logoBitmap.width).toFloat(), (videoHeight - logoBitmap.height).toFloat(), textPaint)\r\n                }\r\n\r\n                viewBinding.encodeStatusTextView.text = \"エンコード終了\"\r\n\r\n                // TODO 音声の追加\r\n                // TODO MediaStoreへ追加\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    companion object {\r\n        /** かさねる動画のファイル名 */\r\n        private const val VIDEO_FILE_NAME = \"origin_video_file.mp4\"\r\n\r\n        /** エンコードした動画ファイル名 */\r\n        private const val RESULT_VIDEO_FILE_NAME = \"result.mp4\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n# 動かしてみる\r\n\r\n動画を選んだあとに、エンコードボタンを押します。  \r\nしばらく待ちます、終了しましたと表示されたら終わりです。  \r\n\r\nで、、、動画のパスなんですが、  \r\n`/storage/emulated/0/Android/data/アプリケーションID/files/video/result.mp4`  \r\nです。端末の動画フォルダに保存する処理はまだ書いてないのでこうなります  \r\n`アプリケーションID`は`build.gradle`の`applicationId`の部分の値です。  \r\n\r\n```gradle\r\n    defaultConfig {\r\n        applicationId \"こ↑こ↓\"\r\n        minSdk 21\r\n        targetSdk 33\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n        // 省略\r\n```\r\n\r\nどうでしょう、動画の上にCanvasで落書きした画像が重なってエンコードされていますでしょうか？  \r\n\r\n![Imgur](https://imgur.com/efE7zna.png)\r\n\r\nしかし音声がなくなってしまいました。  \r\nこの修正を次やります。\r\n\r\n# 音声を追加する\r\nさっきよりは難しくない。`Kotlin`で完結する上、`mp4`->`mp4`の場合はそのまま取り出して入れ直すだけなので`MediaCodec`すら出てきません。  \r\n（`mp4`->`WebM`の場合は`AAC`を`Opus`にするためエンコードする必要がありますが、、、（`MediaCodec`利用））\r\n\r\n## MixingTool.kt\r\n名前はお任せします。  \r\n`Util`クラス、スペルが`Tool`のほうが簡単だから`Tool`にしてるんだけどどうなんだろう（超どうでもいい）\r\n\r\n```kotlin\r\n/** エンコードされた動画には音声がないので、音声を追加するためのクラス */\r\nobject MixingTool {\r\n\r\n    /**\r\n     * [videoFile]に[audioFile]の音声を追加して、[resultFile]として生成する\r\n     */\r\n    @SuppressLint(\"WrongConstant\")\r\n    suspend fun addAudioTrack(\r\n        videoFile: File,\r\n        audioFile: File,\r\n        resultFile: File\r\n    ) = withContext(Dispatchers.Default) {\r\n        // audioFile から音声トラックを取得\r\n        val (audioMediaExtractor, audioFormat) = MediaExtractor().let { mediaExtractor ->\r\n            mediaExtractor.setDataSource(audioFile.path)\r\n            val (index, format) = (0 until mediaExtractor.trackCount)\r\n                .map { index -> index to mediaExtractor.getTrackFormat(index) }\r\n                .first { (_, format) -> format.getString(MediaFormat.KEY_MIME)?.startsWith(\"audio/\") == true }\r\n            mediaExtractor.selectTrack(index)\r\n            mediaExtractor to format\r\n        }\r\n        // videoFile から映像トラックを取得\r\n        val (videoMediaExtractor, videoFormat) = MediaExtractor().let { mediaExtractor ->\r\n            mediaExtractor.setDataSource(videoFile.path)\r\n            val (index, format) = (0 until mediaExtractor.trackCount)\r\n                .map { index -> index to mediaExtractor.getTrackFormat(index) }\r\n                .first { (_, format) -> format.getString(MediaFormat.KEY_MIME)?.startsWith(\"video/\") == true }\r\n            mediaExtractor.selectTrack(index)\r\n            mediaExtractor to format\r\n        }\r\n\r\n        // 新しくコンテナファイルを作って保存する\r\n        // 音声と映像を追加\r\n        val mediaMuxer = MediaMuxer(resultFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)\r\n        val audioTrackIndex = mediaMuxer.addTrack(audioFormat)\r\n        val videoTrackIndex = mediaMuxer.addTrack(videoFormat)\r\n        // MediaMuxerスタート。スタート後は addTrack が呼べない\r\n        mediaMuxer.start()\r\n\r\n        // 音声をコンテナに追加する\r\n        audioMediaExtractor.apply {\r\n            val byteBuffer = ByteBuffer.allocate(1024 * 4096)\r\n            val bufferInfo = MediaCodec.BufferInfo()\r\n            // データが無くなるまで回す\r\n            while (isActive) {\r\n                // データを読み出す\r\n                val offset = byteBuffer.arrayOffset()\r\n                bufferInfo.size = readSampleData(byteBuffer, offset)\r\n                // もう無い場合\r\n                if (bufferInfo.size < 0) break\r\n                // 書き込む\r\n                bufferInfo.presentationTimeUs = sampleTime\r\n                bufferInfo.flags = sampleFlags // Lintがキレるけど黙らせる\r\n                mediaMuxer.writeSampleData(audioTrackIndex, byteBuffer, bufferInfo)\r\n                // 次のデータに進める\r\n                advance()\r\n            }\r\n            // あとしまつ\r\n            release()\r\n        }\r\n\r\n        // 映像をコンテナに追加する\r\n        videoMediaExtractor.apply {\r\n            val byteBuffer = ByteBuffer.allocate(1024 * 4096)\r\n            val bufferInfo = MediaCodec.BufferInfo()\r\n            // データが無くなるまで回す\r\n            while (isActive) {\r\n                // データを読み出す\r\n                val offset = byteBuffer.arrayOffset()\r\n                bufferInfo.size = readSampleData(byteBuffer, offset)\r\n                // もう無い場合\r\n                if (bufferInfo.size < 0) break\r\n                // 書き込む\r\n                bufferInfo.presentationTimeUs = sampleTime\r\n                bufferInfo.flags = sampleFlags // Lintがキレるけど黙らせる\r\n                mediaMuxer.writeSampleData(videoTrackIndex, byteBuffer, bufferInfo)\r\n                // 次のデータに進める\r\n                advance()\r\n            }\r\n            // あとしまつ\r\n            release()\r\n        }\r\n\r\n        // 終わり\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n    }\r\n\r\n}\r\n```\r\n\r\n## MainActivity.kt\r\n音声を追加した動画ファイルを最終的なファイルとするため、ちょっと直します。  \r\n定数が増えているのが分かる通り、ファイルが三種類になりました（`元動画`、`Canvasと重ねた動画`、`Canvasと重ねた動画に音声を追加した動画`）\r\n\r\n```kotlin\r\nlifecycleScope.launch {\r\n    viewBinding.encodeStatusTextView.text = \"エンコード開始\"\r\n\r\n    // まずは Canvas と映像を重ねる\r\n    val videoFile = File(workFolder, VIDEO_FILE_NAME)\r\n    val canvasOverlayVideoFile = File(workFolder, VIDEO_CANVAS_OVERLAY_FILE_NAME)\r\n    val videoWidth = 1280\r\n    val videoHeight = 720\r\n    val videoProcessor = VideoProcessor(\r\n        videoFile = videoFile,\r\n        resultFile = canvasOverlayVideoFile,\r\n        outputVideoWidth = videoWidth,\r\n        outputVideoHeight = videoHeight\r\n    )\r\n    val textPaint = Paint().apply {\r\n        textSize = 100f\r\n    }\r\n    val logoBitmap = ContextCompat.getDrawable(this@MainActivity, R.drawable.ic_launcher_foreground)?.apply {\r\n        setTint(Color.WHITE)\r\n    }?.toBitmap(300, 300)!!\r\n    videoProcessor.encode { currentTimeMs ->\r\n        // 適当に文字を書く\r\n        val text = \"動画の時間 = ${\"%.2f\".format(currentTimeMs / 1000f)}\"\r\n        textPaint.color = Color.BLACK\r\n        textPaint.style = Paint.Style.STROKE\r\n        // 枠取り文字\r\n        drawText(text, 200f, 300f, textPaint)\r\n        textPaint.style = Paint.Style.FILL\r\n        textPaint.color = Color.WHITE\r\n        // 枠無し文字\r\n        drawText(text, 200f, 300f, textPaint)\r\n        // 画像も表示する\r\n        drawBitmap(logoBitmap, (videoWidth - logoBitmap.width).toFloat(), (videoHeight - logoBitmap.height).toFloat(), textPaint)\r\n    }\r\n\r\n    // 音声がないので元のファイルから音声だけもらってくる\r\n    // 音声を追加したファイルが最終的なファイルになる\r\n    val resultFile = File(workFolder, RESULT_VIDEO_FILE_NAME)\r\n    MixingTool.addAudioTrack(\r\n        videoFile = canvasOverlayVideoFile,\r\n        audioFile = videoFile,\r\n        resultFile = resultFile\r\n    )\r\n\r\n    viewBinding.encodeStatusTextView.text = \"エンコード終了\"\r\n}\r\n\r\n// 省略...\r\n\r\ncompanion object {\r\n    /** かさねる動画のファイル名 */\r\n    private const val VIDEO_FILE_NAME = \"origin_video_file.mp4\"\r\n\r\n    /** Canvasと重ねた動画のファイル名 */\r\n    private const val VIDEO_CANVAS_OVERLAY_FILE_NAME = \"temp_canvas_overlay.mp4\"\r\n\r\n    /** エンコードした動画ファイル名 */\r\n    private const val RESULT_VIDEO_FILE_NAME = \"result.mp4\"\r\n}\r\n```\r\n\r\nこれで音声が追加されているはずです！いかがでしょう！\r\n`VLC`で見るとオーディオについての項目が増えています！\r\n\r\n![Imgur](https://imgur.com/SqzaqGd.png)\r\n\r\n# MediaStoreを利用して、端末の動画フォルダに保存する\r\nこれで`Google フォト`アプリや他のギャラリーに見つけてもらうことができます。  \r\nが、結構面倒くさいのでコピペしましょう。\r\n\r\n## MediaStoreTool\r\n`Android`の`MediaStore`とかいう仕組み、使いにくいというか、、なんかなあ、、、  \r\n`MediaMuxer`や`MediaExtractor`とかが`MediaStore や Storage Access Framework`で取得できる`Uri (File#path のようなものだけど違う)`に対応してないから、  \r\n結局`File`が使える`getExternalFilesDir`とかに転送しないといけないのがなあ、、  \r\n`Android 10 の Scoped Storage`、やっぱ影響範囲めっちゃでかいよなあ\r\n\r\n```kotlin\r\n/** 端末の動画フォルダに保存する */\r\nobject MediaStoreTool {\r\n\r\n    /** [videoFile]を MediaStore に登録して、ギャラリーから参照できるようにする */\r\n    suspend fun addVideo(\r\n        context: Context,\r\n        videoFile: File\r\n    ) = withContext(Dispatchers.IO) {\r\n        val contentResolver = context.contentResolver\r\n        val contentValues = contentValuesOf(\r\n            MediaStore.MediaColumns.DISPLAY_NAME to videoFile.name,\r\n            // RELATIVE_PATH（ディレクトリを掘る） は Android 10 以降のみです\r\n            MediaStore.MediaColumns.RELATIVE_PATH to \"${Environment.DIRECTORY_MOVIES}/AndroidMediaCodecAddCanvasTextToVideo\"\r\n        )\r\n        val uri = contentResolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, contentValues) ?: return@withContext\r\n        // コピーする\r\n        contentResolver.openOutputStream(uri)?.use { outputStream ->\r\n            videoFile.inputStream().use { inputStream ->\r\n                inputStream.copyTo(outputStream)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## MainActivity.kt\r\nあとは`MixingTool`のあとに書き足すだけ。終わり\r\n\r\n```kotlin\r\n// 音声がないので元のファイルから音声だけもらってくる\r\n// 音声を追加したファイルが最終的なファイルになる\r\nval resultFile = File(workFolder, RESULT_VIDEO_FILE_NAME)\r\nMixingTool.addAudioTrack(\r\n    videoFile = canvasOverlayVideoFile,\r\n    audioFile = videoFile,\r\n    resultFile = resultFile\r\n)\r\n\r\n// 端末の動画フォルダへ転送する\r\nMediaStoreTool.addVideo(this@MainActivity, resultFile)\r\n// 転送したら要らなくなるので削除\r\nresultFile.delete()\r\ncanvasOverlayVideoFile.delete()\r\n// videoFile.delete() // 毎回消すなら\r\n\r\nviewBinding.encodeStatusTextView.text = \"エンコード終了\"\r\n```\r\n\r\nこれで `Google フォト` アプリの`デバイス内の写真`に表示されているはずです、どうでしょう？\r\n\r\n![Imgur](https://imgur.com/nCzp0hz.png)\r\n\r\n# 以上です。\r\nソースコードです。  \r\n\r\nhttps://github.com/takusan23/AndroidMediaCodecAddCanvasTextToVideo\r\n\r\n最終的な MainActivity.kt です\r\n\r\nhttps://github.com/takusan23/AndroidMediaCodecAddCanvasTextToVideo/blob/master/app/src/main/java/io/github/takusan23/androidmediacodecaddcanvastexttovideo/MainActivity.kt\r\n\r\n\r\n# おわりに\r\nこの更新から`Next.js`の`scrollRestoration`を`true`にしてます。  \r\n`experimental`なので使うか迷ってたんですけど特に影響なさそうなので有効にしました。\r\n\r\n# おわりに 2\r\n`WebKit`だと`JavaScript`の`Date.parse()`が`YYYY-MM-DD`をパースできなくて、何日前に投稿したかどうかの部分が `NaN` になっていました。  \r\n`Apple`デバイス持っていないので知りませんでした、、、そのうち直します"},{"title":"Androidアプリ内の言語を変更する","link":"/posts/android_app_language_change/","markdown":"\r\n期末おわった！\r\n\r\n# 本題\r\n`Context#getString()`で日本語だったら日本語（日本語のstrings.xmlがあれば）表示できますが、これ英語verがほしいってのが今回のお話です\r\n\r\n# こうです！\r\n\r\n日本語だけど`Context#getString()`やレイアウトの`R.string.app_name`は英語の文字列が欲しいってときは、**Activity**や**Service**にこんな感じに\r\n\r\n`MainActivity.kt`\r\n\r\n```kotlin\r\n/**\r\n * 言語変更機能をつける\r\n * 端末の設定で日本語でもこのアプリだけ英語で使うみたいな使い方ができます。\r\n * */\r\noverride fun attachBaseContext(newBase: Context?) {\r\n    val configuration = Configuration()\r\n    configuration.setLocale(Locale.ENGLISH)\r\n    super.attachBaseContext(baseContext?.createConfigurationContext(configuration))\r\n}\r\n```\r\n\r\n**Fragment**はActivityのが使われるそう？\r\n\r\n以上です。おつかれ８８８"},{"title":"AndroidのARCoreでGitHubの草(skyline)を表示させるまで。without Sceneform時代のARCoreを試す。","link":"/posts/android_ar_core_github_skyline/","markdown":"\r\nどうもこんばんわ  \r\nアマエミ -longing for you- 攻略しました。  \r\n絵がめっちゃかわいい！！！シナリオも重くなくあまあまなお話です。\r\n\r\n3人並ぶといいな...まぶしい\r\n\r\n![Imgur](https://imgur.com/mzyBGfn.png)\r\n\r\nかわいい！\r\n\r\n![Imgur](https://imgur.com/7RoYMk7.png)\r\n\r\nこの子が特に可愛かったです\r\n\r\n![Imgur](https://imgur.com/acwibMI.png)\r\n\r\n↑この目すき\r\n\r\n![Imgur](https://imgur.com/cKU7FPr.png)\r\n\r\n\r\nどうやらルート分岐で選んだ回数によって 告白される or する のどちらかになるっぽいです。すごい\r\n\r\nあと曲がいい。これだけで予約確定。\r\n\r\nおすすめです（アルテミスエンジンくんお願いだからクリックしたらオート解除するのやめて）\r\n\r\n# 本題\r\n`GitHub Skyline`っていうGitHubの草を3Dモデルで表示できるサービスがあるのですが、これARで見れたら面白いのではと思ったのでやります。  \r\n3Dプリンターで印刷するためのものなんでしょうが持ってないので...\r\n\r\n![Imgur](https://imgur.com/x2Kih8U.png)\r\n\r\n# ARCore の Sceneform ...\r\n`AR Core`といえば、簡単に使える`Sceneform`ってライブラリがあったと思います！  \r\n大昔に試してそんなに難しくなかった記憶  \r\n\r\nhttps://takusan23.github.io/Bibouroku/2020/04/06/ARCore/\r\n\r\nそれを使いたい、、、のですが、  \r\nなんと！使えなくなっていました！数年前は使えてたのですが...！おいGoogle！\r\n\r\n![Imgur](https://imgur.com/2nBm31S.png)\r\n\r\nうーんしゃあない最新の`AR Core`調べるか...  → https://github.com/google-ar/arcore-android-sdk/tree/master/samples/hello_ar_kotlin\r\n\r\nKotlinのサンプルコード、とりあえず実行できたけどどこで何やってるのかマジで分からん！！！！  \r\nなんか内容が難しい！！！\r\n\r\nというわけで、今回は`3Dモデル (GitHub Skyline)`を表示させるまで上記のサンプルをパクってやってみようと思います。\r\n\r\n# 環境\r\n\r\n| なまえ    | あたい                                                                  |\r\n|-----------|-------------------------------------------------------------------------|\r\n| 端末      | Pixel 6 Pro (Google Tensor / RAM 12GB) / Pixel 3 XL (SDM 845 / RAM 4GB) |\r\n| Android   | 13                                                                      |\r\n| minSdk    | 24 ?                                                                    |\r\n| OpenGL ES | 3.0 たと思う                                                            |\r\n\r\n今回は`Depth API`（現実と同じように手前にものがあれば隠れんぼする機能）を使います。  \r\n（てか Pixel 3 XL 物理的に軽くね？いや 6 Pro が重いだけか...）\r\n\r\n# ARCore\r\n`ARCore`には描画するための機能は持ち合わせてません。（`Sceneform`にはありましたが、`ARCore`の機能ではありません。）  \r\nそのため描画するための技術（`OpenGL`）と組み合わせて利用する必要があります。\r\n\r\n## ながれ\r\n\r\n- GitHub Skyline の3Dモデル`.stl`を`AR Core`で利用できる`.obj`に変換する\r\n    - ついでにサイズを小さくします。\r\n    - Blender 使います\r\n- `AR Core`を利用するための用意\r\n- カメラ映像の描画\r\n- 平面の描画\r\n- 3Dオブジェクトの描画\r\n\r\n# Blender をいれる\r\n`.stl`を`.obj`にするために使います。  \r\nあとサイズを小さくするためにも使ってます。\r\n\r\n使う機会なければ`Portable`の方でも良いんじゃないでしょうか（よく分からん）\r\n\r\n![Imgur](https://imgur.com/xFNIsKw.png)\r\n\r\n## GitHub Skyline のオブジェクトを読み込む\r\n\r\n`GitHub Skyline`のデータはここからダウンロードできます。\r\n\r\n![Imgur](https://imgur.com/Vu7t4lf.png)\r\n\r\n`Blender`を開き、最初からある立方体はいらないので選んで`Deleteキー`押して消しちゃいましょう。\r\n\r\n![Imgur](https://imgur.com/JE0RUTz.png)\r\n\r\nファイル > インポート > STL を選び、ダウンロードしたオブジェクトを選んで取り込みます。\r\n\r\n![Imgur](https://imgur.com/XbuK8O7.png)\r\n\r\nで、これそのまま使うとクソデカいので直します。\r\n\r\n![Imgur](https://imgur.com/sRLPLdN.png)\r\n\r\nちなみにどれぐらいクソデカいかというと、サンプルコードで使われているオブジェクトがこのくらい小さいです。\r\n\r\n![Imgur](https://imgur.com/xnBViJF.png)\r\n\r\n### サイズを小さくする\r\n\r\nキーボードの`N`を押すことで、`トランスフォーム`を表示させる事ができます。  \r\nで、`スケール`の部分を全部`0.005`ぐらいにします。\r\n\r\n![Imgur](https://imgur.com/IhuLOgX.png)\r\n\r\nこれでサンプルと同じぐらいの大きさぐらいに出来ました。保存しましょう。\r\n\r\n### 保存\r\nオブジェクトを選択した状態で、  \r\nファイル > エクスポート > Wavefront OBJ を選びます。\r\n\r\n![Imgur](https://imgur.com/nYfKgpU.png)\r\n\r\n選択物のみにして、適当な場所に保存します。\r\n\r\n![Imgur](https://imgur.com/EVLA3l6.png)\r\n\r\nこれでファイルの用意は終わりです。\r\n\r\n# 公式のサンプルコードをダウンロードします\r\n今回はGoogleのサンプルコードを8割ぐらい使います（`Apache License Version 2.0`）。ので以下のリポジトリを`zip`で落とすなり`git clone`するなりしてローカルに保存して下さい。  \r\nこれ`AR Core`のライブラリとして提供してほしいぐらいですよ。\r\n\r\nhttps://github.com/google-ar/arcore-android-sdk\r\n\r\n# アプリを作る\r\nAndroid Studio を開きます。\r\n\r\n# 適当なプロジェクトを作成\r\n`minSdk`は`24`です。\r\n\r\n![Imgur](https://imgur.com/MHytvCH.png)\r\n\r\n# AndroidManifest.xml\r\n`カメラ権限`が必要です。また、`uses-feature`をサンプル通り書いておきましたが無くても動くかもしれないです。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <!-- カメラ権限 -->\r\n    <uses-permission android:name=\"android.permission.CAMERA\" />\r\n    <!-- AR Core をサポートしている端末のみ Google Play で表示させる -->\r\n    <uses-feature\r\n        android:name=\"android.hardware.camera.ar\"\r\n        android:required=\"true\" />\r\n    <uses-feature\r\n        android:glEsVersion=\"0x00020000\"\r\n        android:required=\"true\" />\r\n```\r\n\r\nあともう一箇所、`application`の中に`meta-data`を一つ書きます\r\n\r\n```xml\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\r\n        android:fullBackupContent=\"@xml/backup_rules\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.ARCoreGitHubSkyline\"\r\n        tools:targetApi=\"31\">\r\n\r\n        <!-- AR Google Play Service のインストールを必須にする  -->\r\n        <meta-data\r\n            android:name=\"com.google.ar.core\"\r\n            android:value=\"required\" />\r\n```\r\n\r\n# build.gradle\r\n`AR Core`のライブラリと`obj`ファイルを扱うライブラリと公式のライフサイクルのライブラリ、あと権限取るので`Activity Result API`を入れます。\r\n\r\n```gradle\r\ndependencies {\r\n\r\n    // ARCore (Google Play Services for AR) library.\r\n    implementation(\"com.google.ar:core:1.34.0\")\r\n\r\n    // Obj - a simple Wavefront OBJ file loader\r\n    // https://github.com/javagl/Obj\r\n    implementation(\"de.javagl:obj:0.2.1\")\r\n\r\n    // ライフサイクル\r\n    implementation(\"androidx.lifecycle:lifecycle-common-java8:2.5.1\")\r\n\r\n    // Activity Result API\r\n    implementation(\"androidx.activity:activity-ktx:1.6.1\")\r\n    implementation(\"androidx.fragment:fragment-ktx:1.5.4\")\r\n```\r\n\r\nあ、ついでに`targetSdk`を`33`にしておきます。なんか`32`のままだったので  \r\nあと`ViewBinding`も有効にします。\r\n\r\n```gradle\r\nandroid {\r\n    namespace 'io.github.takusan23.arcoregithubskyline'\r\n    compileSdk 33 // ここも\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.arcoregithubskyline\"\r\n        minSdk 24\r\n        targetSdk 33 // ここ\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildFeatures {\r\n        viewBinding true // これも\r\n    }\r\n\r\n// 以下略\r\n```\r\n\r\n# 公式のサンプルコードをコピペする\r\n`hello_ar_kotlin`の`app/src/main/java/com/google/ar/core/examples/java`の中にある`common`をAndroid Studioの`MainActivity.kt`と同じフォルダにコピーします。  \r\nはい。`import`の部分でエラーが出ると思いますので、エラーの部分を消して`Alt+Enter`してインポートし直せば治ると思います。\r\n\r\n![Imgur](https://imgur.com/FtlBwSU.png)\r\n\r\n# 公式のアセットをコピペする\r\n今回は`OpenGL`の`GLSL言語`で書かれた`シェーダー`もパクることにします。まあ後で少し手直しをしますが。  \r\n1から書くとかはちょっと分からん...\r\n\r\n`assets`フォルダを作成して\r\n\r\n![Imgur](https://imgur.com/njIeQPa.png)\r\n\r\n`hello_ar_kotlin`の`app/src/main/assets`の`models`、`shaders`から以下のファイルをコピーしてきます。\r\n\r\n- models\r\n    - dfg.raw\r\n    - trigrid.png\r\n- shaders\r\n    - background_show_camera.vert\r\n    - cubemap_filter.frag\r\n    - cubemap_filter.vert\r\n    - environmental_hdr.frag\r\n    - environmental_hdr.vert\r\n    - occlusion.frag\r\n    - occlusion.vert\r\n    - plane.frag\r\n    - plane.vert\r\n    - point_cloud.frag\r\n    - point_cloud.vert\r\n\r\nこうなってれば良いはず\r\n\r\n![Imgur](https://imgur.com/afuGMoj.png)\r\n\r\n# オブジェクトファイルを入れる\r\nさっき作った`models`に`Blender`で保存した`objファイル`をコピーします。\r\n\r\n![Imgur](https://imgur.com/SRaUnkt.png)\r\n\r\nこれでアセット編は終わりなはず..\r\n\r\n# activity_main.xml\r\n`GlSurfaceView`を置きます。ずっと`Jetpack Compose`だったので懐かしいですね（？）\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <android.opengl.GLSurfaceView\r\n        android:id=\"@+id/activity_main_gl_surfaceview\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n# ARCore を使う\r\nARCoreのセッションを管理するクラスを作ります。  \r\nほぼサンプルコードそのままですが\r\n\r\n```kotlin\r\n/**\r\n * ARCoreのセッションとライフサイクル\r\n */\r\nclass ARCoreSessionLifecycleHelper(\r\n    private val activity: Activity,\r\n    private val features: Set<Session.Feature> = emptySet(),\r\n) : DefaultLifecycleObserver {\r\n\r\n    var installRequested = false\r\n    var session: Session? = null\r\n        private set\r\n\r\n    /**\r\n     * 失敗時に呼び出されるコールバック関数\r\n     *\r\n     * @see [Session constructor](https://developers.google.com/ar/reference/java/com/google/ar/core/Session#Session(android.content.Context))\r\n     */\r\n    var exceptionCallback: ((Exception) -> Unit)? = null\r\n\r\n    /**\r\n     * セッションの構成が必要になったら呼び出される。ARCoreの機能など\r\n     *\r\n     * [Session.configure](https://developers.google.com/ar/reference/java/com/google/ar/core/Session#configure-config)\r\n     * [setCameraConfig](https://developers.google.com/ar/reference/java/com/google/ar/core/Session#setCameraConfig-cameraConfig)\r\n     */\r\n    var beforeSessionResume: ((Session) -> Unit)? = null\r\n\r\n    /**\r\n     * セッションの作成を試みる。\r\n     * AR の Google Play Service がインストールされていない場合はインストールをリクエスト。\r\n     */\r\n    private fun tryCreateSession(): Session? {\r\n        // 権限がなければreturn\r\n        if (!CameraPermissionHelper.hasCameraPermission(activity)) {\r\n            return null\r\n        }\r\n\r\n        return try {\r\n            // Request installation if necessary.\r\n            when (ArCoreApk.getInstance().requestInstall(activity, !installRequested)) {\r\n                ArCoreApk.InstallStatus.INSTALL_REQUESTED -> {\r\n                    installRequested = true\r\n                    // tryCreateSession will be called again, so we return null for now.\r\n                    return null\r\n                }\r\n                ArCoreApk.InstallStatus.INSTALLED -> {\r\n                    // Left empty; nothing needs to be done.\r\n                }\r\n            }\r\n\r\n            // Create a session if Google Play Services for AR is installed and up to date.\r\n            Session(activity, features)\r\n        } catch (e: Exception) {\r\n            exceptionCallback?.invoke(e)\r\n            null\r\n        }\r\n    }\r\n\r\n    override fun onResume(owner: LifecycleOwner) {\r\n        val session = this.session ?: tryCreateSession() ?: return\r\n        try {\r\n            beforeSessionResume?.invoke(session)\r\n            session.resume()\r\n            this.session = session\r\n        } catch (e: CameraNotAvailableException) {\r\n            exceptionCallback?.invoke(e)\r\n        }\r\n    }\r\n\r\n    override fun onPause(owner: LifecycleOwner) {\r\n        session?.pause()\r\n    }\r\n\r\n    override fun onDestroy(owner: LifecycleOwner) {\r\n        // ARCoreのセッションを破棄する\r\n        // https://developers.google.com/ar/reference/java/arcore/reference/com/google/ar/core/Session#close()\r\n        session?.close()\r\n        session = null\r\n    }\r\n}\r\n```\r\n\r\n`MainActivity.kt`ではこんな感じに使います。  \r\nついでにカメラ権限ない場合はリクエストするようにしました。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** ARCoreのセッション管理 */\r\n    private val arCoreSessionLifecycleHelper by lazy { ARCoreSessionLifecycleHelper(this) }\r\n\r\n    /** 権限コールバック */\r\n    private val permissionRequester = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGrant ->\r\n        if (isGrant) {\r\n            setup()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        lifecycle.addObserver(arCoreSessionLifecycleHelper)\r\n\r\n        // 権限がない場合は取得する\r\n        if (CameraPermissionHelper.hasCameraPermission(this)) {\r\n            setup()\r\n        } else {\r\n            permissionRequester.launch(android.Manifest.permission.CAMERA)\r\n        }\r\n    }\r\n\r\n    private fun setup() {\r\n        arCoreSessionLifecycleHelper.apply {\r\n            // 失敗コールバック\r\n            exceptionCallback = { exception ->\r\n                exception.printStackTrace()\r\n            }\r\n            // 構成\r\n            beforeSessionResume = { session ->\r\n                session.configure(\r\n                    session.config.apply {\r\n                        lightEstimationMode = Config.LightEstimationMode.ENVIRONMENTAL_HDR\r\n                        // Depth API は使いたい\r\n                        depthMode = if (session.isDepthModeSupported(Config.DepthMode.AUTOMATIC)) {\r\n                            Config.DepthMode.AUTOMATIC\r\n                        } else {\r\n                            Config.DepthMode.DISABLED\r\n                        }\r\n                        // インスタント配置は使わない\r\n                        instantPlacementMode = Config.InstantPlacementMode.DISABLED\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# ViewBindingするクラス\r\nこのレベルだとそのまま使ったほうが良さそうまであるけど一応\r\n\r\n```kotlin\r\n/** GLSurfaceViewのライフサイクルするやつ */\r\nclass ARViewLifecycle(context: Context) : DefaultLifecycleObserver {\r\n\r\n    val viewBinding = ActivityMainBinding.inflate(LayoutInflater.from(context))\r\n\r\n    override fun onPause(owner: LifecycleOwner) {\r\n        super.onPause(owner)\r\n        viewBinding.activityMainGlSurfaceview.onPause()\r\n    }\r\n\r\n    override fun onResume(owner: LifecycleOwner) {\r\n        super.onResume(owner)\r\n        viewBinding.activityMainGlSurfaceview.onResume()\r\n    }\r\n}\r\n```\r\n\r\n`MainActivity.kt`で`setContentView`します。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** ARCoreのセッション管理 */\r\n    private val arCoreSessionLifecycleHelper by lazy { ARCoreSessionLifecycleHelper(this) }\r\n\r\n    /** GLSurfaceView */\r\n    private val arViewLifecycle by lazy { ARViewLifecycle(this) }\r\n\r\n    /** 権限コールバック */\r\n    private val permissionRequester = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGrant ->\r\n        if (isGrant) {\r\n            setup()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(arViewLifecycle.viewBinding.root)\r\n\r\n        lifecycle.addObserver(arCoreSessionLifecycleHelper)\r\n        lifecycle.addObserver(arViewLifecycle)\r\n\r\n        // 権限がない場合は取得する\r\n        if (CameraPermissionHelper.hasCameraPermission(this)) {\r\n            setup()\r\n        } else {\r\n            permissionRequester.launch(android.Manifest.permission.CAMERA)\r\n        }\r\n    }\r\n\r\n    // 省略\r\n}\r\n```\r\n\r\n# 描画するクラス\r\n\r\nいよいよ描画するクラスを作っていきます。  \r\n`ARCoreOpenGlRenderer.kt`です。\r\n\r\n```kotlin\r\n/** OpenGLを利用して描画するクラス */\r\nclass ARCoreOpenGlRenderer(\r\n    private val context: Context,\r\n    private val arCoreSessionLifecycleHelper: ARCoreSessionLifecycleHelper,\r\n    private val tapHelper: TapHelper,\r\n) : SampleRender.Renderer, DefaultLifecycleObserver {\r\n\r\n    override fun onResume(owner: LifecycleOwner) {\r\n        super.onResume(owner)\r\n    }\r\n\r\n    override fun onPause(owner: LifecycleOwner) {\r\n        super.onPause(owner)\r\n    }\r\n\r\n    override fun onSurfaceCreated(render: SampleRender?) {\r\n\r\n    }\r\n\r\n    override fun onSurfaceChanged(render: SampleRender?, width: Int, height: Int) {\r\n\r\n    }\r\n\r\n    override fun onDrawFrame(render: SampleRender?) {\r\n\r\n    }\r\n}\r\n```\r\n\r\nこれを`MainActivity`でこうやって使います\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** ARCoreのセッション管理 */\r\n    private val arCoreSessionLifecycleHelper by lazy { ARCoreSessionLifecycleHelper(this) }\r\n\r\n    /** GLSurfaceView */\r\n    private val arViewLifecycle by lazy { ARViewLifecycle(this) }\r\n\r\n    /** タッチイベント */\r\n    private val tapHelper by lazy { TapHelper(this).also { arViewLifecycle.viewBinding.activityMainGlSurfaceview.setOnTouchListener(it) } }\r\n\r\n    /** OpenGLでARCore描画するやつ */\r\n    private val renderer by lazy { ARCoreOpenGlRenderer(this, arCoreSessionLifecycleHelper, tapHelper) }\r\n\r\n    /** 権限コールバック */\r\n    private val permissionRequester = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGrant ->\r\n        if (isGrant) {\r\n            setup()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(arViewLifecycle.viewBinding.root)\r\n\r\n        lifecycle.addObserver(arCoreSessionLifecycleHelper)\r\n        lifecycle.addObserver(arViewLifecycle)\r\n        lifecycle.addObserver(renderer)\r\n\r\n        // 権限がない場合は取得する\r\n        if (CameraPermissionHelper.hasCameraPermission(this)) {\r\n            setup()\r\n        } else {\r\n            permissionRequester.launch(android.Manifest.permission.CAMERA)\r\n        }\r\n    }\r\n\r\n    private fun setup() {\r\n        arCoreSessionLifecycleHelper.apply {\r\n            // 失敗コールバック\r\n            exceptionCallback = { exception ->\r\n                exception.printStackTrace()\r\n            }\r\n            // 構成\r\n            beforeSessionResume = { session ->\r\n                session.configure(\r\n                    session.config.apply {\r\n                        lightEstimationMode = Config.LightEstimationMode.ENVIRONMENTAL_HDR\r\n                        // Depth API は使いたい\r\n                        depthMode = if (session.isDepthModeSupported(Config.DepthMode.AUTOMATIC)) {\r\n                            Config.DepthMode.AUTOMATIC\r\n                        } else {\r\n                            Config.DepthMode.DISABLED\r\n                        }\r\n                        // インスタント配置は使わない\r\n                        instantPlacementMode = Config.InstantPlacementMode.DISABLED\r\n                    }\r\n                )\r\n            }\r\n        }\r\n\r\n        // 描画する\r\n        SampleRender(arViewLifecycle.viewBinding.activityMainGlSurfaceview, renderer, assets)\r\n    }\r\n}\r\n```\r\n\r\n## そのまえに Toast を出すだけのクラスを作る\r\n\r\n```kotlin\r\n/** Toastを表示するだけのクラス */\r\nclass ToastManager(private val context: Context) {\r\n    private val handler = Handler(Looper.getMainLooper())\r\n\r\n    /** 前回のメッセージ */\r\n    private var prevMessage: String? = null\r\n\r\n    /**\r\n     * Toastを表示させる\r\n     * @param message 本文\r\n     */\r\n    fun show(message: String) {\r\n        // 同じ場合は出さない\r\n        if (prevMessage == message) {\r\n            return\r\n        }\r\n        handler.post {\r\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()\r\n            prevMessage = message\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## カメラ映像を描画する\r\nまずはカメラ映像を描画するようにしましょう。\r\n\r\n```kotlin\r\n/** OpenGLを利用して描画するクラス */\r\nclass ARCoreOpenGlRenderer(\r\n    private val context: Context,\r\n    private val arCoreSessionLifecycleHelper: ARCoreSessionLifecycleHelper,\r\n    private val tapHelper: TapHelper,\r\n) : SampleRender.Renderer, DefaultLifecycleObserver {\r\n\r\n    /** カメラ映像をレンダリングするやつ */\r\n    private lateinit var backgroundRenderer: BackgroundRenderer\r\n    private lateinit var virtualSceneFramebuffer: Framebuffer\r\n    private val displayRotationHelper = DisplayRotationHelper(context)\r\n\r\n    /** カメラ映像のテクスチャを渡したか。一度だけ行うため */\r\n    private var isAlreadySetTexture = false\r\n    \r\n    override fun onResume(owner: LifecycleOwner) {\r\n        super.onResume(owner)\r\n        displayRotationHelper.onResume()\r\n    }\r\n\r\n    override fun onPause(owner: LifecycleOwner) {\r\n        super.onPause(owner)\r\n        displayRotationHelper.onPause()\r\n    }\r\n\r\n    /** SurfaceViewが利用可能になったら呼ばれる */\r\n    override fun onSurfaceCreated(render: SampleRender) {\r\n        backgroundRenderer = BackgroundRenderer(render)\r\n        virtualSceneFramebuffer = Framebuffer(render, /*width=*/ 1, /*height=*/ 1)\r\n    }\r\n\r\n    /** SurfaceViewのサイズ変更時に */\r\n    override fun onSurfaceChanged(render: SampleRender, width: Int, height: Int) {\r\n        displayRotationHelper.onSurfaceChanged(width, height)\r\n        virtualSceneFramebuffer.resize(width, height)\r\n    }\r\n\r\n    /** 毎フレーム呼ばれる？ */\r\n    override fun onDrawFrame(render: SampleRender) {\r\n        val session = arCoreSessionLifecycleHelper.session ?: return\r\n\r\n        // カメラ映像テクスチャ\r\n        if (!isAlreadySetTexture) {\r\n            session.setCameraTextureNames(intArrayOf(backgroundRenderer.cameraColorTexture.textureId))\r\n            isAlreadySetTexture = true\r\n        }\r\n\r\n        // カメラ映像のサイズを合わせる\r\n        displayRotationHelper.updateSessionIfNeeded(session)\r\n\r\n        // ARSession から現在のフレームを取得\r\n        val frame = try {\r\n            session.update()\r\n        } catch (e: Exception) {\r\n            Log.e(TAG, \"Camera not available during onDrawFrame\", e)\r\n            return\r\n        }\r\n\r\n        val camera = frame.camera\r\n        // 深度設定\r\n        try {\r\n            backgroundRenderer.setUseDepthVisualization(render, false)\r\n            backgroundRenderer.setUseOcclusion(render, true)\r\n        } catch (e: IOException) {\r\n            Log.e(TAG, \"Failed to read a required asset file\", e)\r\n            return\r\n        }\r\n\r\n        // 座標を更新する\r\n        backgroundRenderer.updateDisplayGeometry(frame)\r\n        // 深度設定\r\n        val shouldGetDepthImage = true\r\n        if (camera.trackingState == TrackingState.TRACKING && shouldGetDepthImage) {\r\n            try {\r\n                val depthImage = frame.acquireDepthImage16Bits()\r\n                backgroundRenderer.updateCameraDepthTexture(depthImage)\r\n                depthImage.close()\r\n            } catch (e: NotYetAvailableException) {\r\n                // まだ深度データが利用できない\r\n                // 別にエラーではなく正常\r\n            }\r\n        }\r\n\r\n        // カメラ映像を描画する\r\n        if (frame.timestamp != 0L) {\r\n            // カメラがまだ最初のフレームを生成していない場合、レンダリングを抑制します。 これは避けるためです\r\n            // テクスチャが再利用される場合、以前のセッションから残っている可能性のあるデータを描画します。\r\n            backgroundRenderer.drawBackground(render)\r\n        }\r\n        // 追跡しない場合は、3D オブジェクトを描画しない\r\n        if (camera.trackingState == TrackingState.PAUSED) {\r\n            return\r\n        }\r\n\r\n        // 背景を使用して仮想シーンを構成します。\r\n        backgroundRenderer.drawVirtualScene(render, virtualSceneFramebuffer, Z_NEAR, Z_FAR)\r\n    }\r\n\r\n    companion object {\r\n        private val TAG = ARCoreOpenGlRenderer::class.java.simpleName\r\n\r\n        private const val Z_NEAR = 0.1f\r\n        private const val Z_FAR = 100f\r\n    }\r\n}\r\n```\r\n\r\n後は実行してカメラ映像が描画されていれば成功です！\r\n\r\n![Imgur](https://imgur.com/02T1zOV.png)\r\n\r\n## 平面とクラウドポイントを描画する\r\n\r\n平面はこの白色の三角形のタイルみたいなやつです。  \r\nクラウドポイントってのはこの青いてんてんのことです。\r\n\r\n![Imgur](https://imgur.com/sWGK2wA.png)\r\n\r\nオブジェクトの描画の際に使う`FloatArray`も今回まとめて書いちゃいます。\r\n\r\n```kotlin\r\n/** OpenGLを利用して描画するクラス */\r\nclass ARCoreOpenGlRenderer(\r\n    private val context: Context,\r\n    private val arCoreSessionLifecycleHelper: ARCoreSessionLifecycleHelper,\r\n    private val tapHelper: TapHelper,\r\n) : SampleRender.Renderer, DefaultLifecycleObserver {\r\n\r\n    /** カメラ映像をレンダリングするやつ */\r\n    private lateinit var backgroundRenderer: BackgroundRenderer\r\n    private lateinit var virtualSceneFramebuffer: Framebuffer\r\n    private val displayRotationHelper = DisplayRotationHelper(context)\r\n\r\n    /** カメラ映像のテクスチャを渡したか。一度だけ行うため */\r\n    private var isAlreadySetTexture = false\r\n\r\n    /** 平面をレンダリングするやつ */\r\n    private lateinit var planeRenderer: PlaneRenderer\r\n\r\n    /** Point Cloud (あの青い点) */\r\n    private lateinit var pointCloudVertexBuffer: VertexBuffer\r\n    private lateinit var pointCloudMesh: Mesh\r\n    private lateinit var pointCloudShader: Shader\r\n\r\n    /** 最後のポイントクラウド */\r\n    private var lastPointCloudTimestamp = 0L\r\n\r\n    /** AR上においたオブジェクト配列 */\r\n    private val wrappedAnchors = mutableListOf<WrappedAnchor>()\r\n\r\n    /** Toast出すだけ */\r\n    private val toastManager = ToastManager(context)\r\n\r\n    private val modelMatrix = FloatArray(16)\r\n    private val viewMatrix = FloatArray(16)\r\n    private val modelViewMatrix = FloatArray(16)\r\n    private val projectionMatrix = FloatArray(16)\r\n    private val modelViewProjectionMatrix = FloatArray(16)\r\n    private val viewInverseMatrix = FloatArray(16)\r\n    private val sphericalHarmonicsCoefficients = FloatArray(9 * 3)\r\n    private val worldLightDirection = floatArrayOf(0.0f, 0.0f, 0.0f, 0.0f)\r\n    private val viewLightDirection = FloatArray(4)\r\n\r\n    // 省略\r\n\r\n    /** SurfaceViewが利用可能になったら呼ばれる */\r\n    override fun onSurfaceCreated(render: SampleRender) {\r\n        // カメラ映像\r\n        backgroundRenderer = BackgroundRenderer(render)\r\n        virtualSceneFramebuffer = Framebuffer(render, /*width=*/ 1, /*height=*/ 1)\r\n\r\n        // 平面\r\n        planeRenderer = PlaneRenderer(render)\r\n\r\n        // ポイントクラウド (平面を見つける際に表示される青いやつ)\r\n        pointCloudShader = Shader.createFromAssets(\r\n            render,\r\n            \"shaders/point_cloud.vert\",\r\n            \"shaders/point_cloud.frag\",\r\n            /*defines=*/ null\r\n        ).apply {\r\n            setVec4(\"u_Color\", floatArrayOf(31.0f / 255.0f, 188.0f / 255.0f, 210.0f / 255.0f, 1.0f))\r\n            setFloat(\"u_PointSize\", 5.0f)\r\n        }\r\n        pointCloudVertexBuffer = VertexBuffer(render, /*numberOfEntriesPerVertex=*/ 4, /*entries=*/ null)\r\n        pointCloudMesh = Mesh(render, Mesh.PrimitiveMode.POINTS, /*indexBuffer=*/ null, arrayOf(pointCloudVertexBuffer))\r\n    }\r\n\r\n    // 省略\r\n\r\n    /** 毎フレーム呼ばれる？ */\r\n    override fun onDrawFrame(render: SampleRender) {\r\n        val session = arCoreSessionLifecycleHelper.session ?: return\r\n\r\n        // カメラ映像テクスチャ\r\n        if (!isAlreadySetTexture) {\r\n            session.setCameraTextureNames(intArrayOf(backgroundRenderer.cameraColorTexture.textureId))\r\n            isAlreadySetTexture = true\r\n        }\r\n\r\n        // カメラ映像のサイズを合わせる\r\n        displayRotationHelper.updateSessionIfNeeded(session)\r\n\r\n        // ARSession から現在のフレームを取得\r\n        val frame = try {\r\n            session.update()\r\n        } catch (e: Exception) {\r\n            Log.e(TAG, \"Camera not available during onDrawFrame\", e)\r\n            return\r\n        }\r\n\r\n        val camera = frame.camera\r\n        // 深度設定\r\n        try {\r\n            backgroundRenderer.setUseDepthVisualization(render, false)\r\n            backgroundRenderer.setUseOcclusion(render, true)\r\n        } catch (e: IOException) {\r\n            Log.e(TAG, \"Failed to read a required asset file\", e)\r\n            return\r\n        }\r\n\r\n        // 座標を更新する\r\n        backgroundRenderer.updateDisplayGeometry(frame)\r\n        val shouldGetDepthImage = true\r\n        if (camera.trackingState == TrackingState.TRACKING && shouldGetDepthImage) {\r\n            try {\r\n                val depthImage = frame.acquireDepthImage16Bits()\r\n                backgroundRenderer.updateCameraDepthTexture(depthImage)\r\n                depthImage.close()\r\n            } catch (e: NotYetAvailableException) {\r\n                // まだ深度データが利用できない\r\n                // 別にエラーではなく正常\r\n            }\r\n        }\r\n\r\n        // タップされたか、毎フレーム見る\r\n        handleTap(frame, camera)\r\n\r\n        // ARのステータス\r\n        // 平面が検出されてオブジェクトを配置できるようになったかどうかなど\r\n        when {\r\n            camera.trackingState == TrackingState.PAUSED && camera.trackingFailureReason == TrackingFailureReason.NONE -> \"平面を探しています\"\r\n            camera.trackingState == TrackingState.PAUSED -> null\r\n            hasTrackingPlane(session) && wrappedAnchors.isEmpty() -> \"平面を検出しました。タップして配置します。\"\r\n            hasTrackingPlane(session) && wrappedAnchors.isNotEmpty() -> null\r\n            else -> \"平面を探しています\"\r\n        }?.also {\r\n            toastManager.show(it)\r\n        }\r\n\r\n        // カメラ映像を描画する\r\n        if (frame.timestamp != 0L) {\r\n            // カメラがまだ最初のフレームを生成していない場合、レンダリングを抑制します。 これは避けるためです\r\n            // テクスチャが再利用される場合、以前のセッションから残っている可能性のあるデータを描画します。\r\n            backgroundRenderer.drawBackground(render)\r\n        }\r\n        // 追跡しない場合は、3D オブジェクトを描画しない\r\n        if (camera.trackingState == TrackingState.PAUSED) {\r\n            return\r\n        }\r\n\r\n        // 射影行列を取得する\r\n        camera.getProjectionMatrix(projectionMatrix, 0, Z_NEAR, Z_FAR)\r\n\r\n        // カメラ行列を取得して描画.\r\n        camera.getViewMatrix(viewMatrix, 0)\r\n\r\n        // ポイントクラウドの描画\r\n        frame.acquirePointCloud().use { pointCloud ->\r\n            if (pointCloud.timestamp > lastPointCloudTimestamp) {\r\n                pointCloudVertexBuffer.set(pointCloud.points)\r\n                lastPointCloudTimestamp = pointCloud.timestamp\r\n            }\r\n            Matrix.multiplyMM(modelViewProjectionMatrix, 0, projectionMatrix, 0, viewMatrix, 0)\r\n            pointCloudShader.setMat4(\"u_ModelViewProjection\", modelViewProjectionMatrix)\r\n            render.draw(pointCloudMesh, pointCloudShader)\r\n        }\r\n\r\n        // 平面を描画します\r\n        planeRenderer.drawPlanes(render, session.getAllTrackables(Plane::class.java), camera.displayOrientedPose, projectionMatrix)\r\n\r\n        // 背景を使用して仮想シーンを構成します。\r\n        backgroundRenderer.drawVirtualScene(render, virtualSceneFramebuffer, Z_NEAR, Z_FAR)\r\n    }\r\n\r\n    /** 1フレームごとにタップを処理する */\r\n    private fun handleTap(frame: Frame, camera: Camera) {\r\n        if (camera.trackingState != TrackingState.TRACKING) return\r\n        val tap = tapHelper.poll() ?: return\r\n\r\n        // ヒットは深さによってソートされます。平面上の最も近いヒットのみ\r\n        val hitResultList = frame.hitTest(tap)\r\n        val firstHitResult = hitResultList.firstOrNull { hit ->\r\n            when (val trackable = hit.trackable!!) {\r\n                is Plane -> trackable.isPoseInPolygon(hit.hitPose) && PlaneRenderer.calculateDistanceToPlane(hit.hitPose, camera.pose) > 0\r\n                is Point -> trackable.orientationMode == Point.OrientationMode.ESTIMATED_SURFACE_NORMAL\r\n                is InstantPlacementPoint -> true\r\n                // DepthPoints are only returned if Config.DepthMode is set to AUTOMATIC.\r\n                is DepthPoint -> true\r\n                else -> false\r\n            }\r\n        }\r\n\r\n        if (firstHitResult != null) {\r\n            // アンカー数に制限をかける\r\n            if (wrappedAnchors.size >= 20) {\r\n                wrappedAnchors[0].anchor.detach()\r\n                wrappedAnchors.removeAt(0)\r\n            }\r\n            // 追跡登録\r\n            wrappedAnchors.add(WrappedAnchor(firstHitResult.createAnchor(), firstHitResult.trackable))\r\n        }\r\n    }\r\n\r\n    /** 平面が1つ以上見つかっていれば true */\r\n    private fun hasTrackingPlane(session: Session) = session.getAllTrackables(Plane::class.java).any { it.trackingState == TrackingState.TRACKING }\r\n\r\n    /** アンカーとトラッカブルを紐つける */\r\n    private data class WrappedAnchor(\r\n        val anchor: Anchor,\r\n        val trackable: Trackable,\r\n    )\r\n\r\n    // 省略\r\n}\r\n```\r\n\r\n## オブジェクトを描画する (多分最後)\r\n\r\nついにGitHubの草をARに登場させます！！！  \r\n今回はテクスチャを用意しないので、単色で塗りつぶすよう`フラグメントシェーダ`にも手を加えます。\r\n\r\n面倒なのでここまで全部張ります。\r\n\r\n### ARCoreOpenGlRenderer\r\n\r\n```kotlin\r\n/** OpenGLを利用して描画するクラス */\r\nclass ARCoreOpenGlRenderer(\r\n    private val context: Context,\r\n    private val arCoreSessionLifecycleHelper: ARCoreSessionLifecycleHelper,\r\n    private val tapHelper: TapHelper,\r\n) : SampleRender.Renderer, DefaultLifecycleObserver {\r\n\r\n    /** カメラ映像をレンダリングするやつ */\r\n    private lateinit var backgroundRenderer: BackgroundRenderer\r\n    private lateinit var virtualSceneFramebuffer: Framebuffer\r\n    private val displayRotationHelper = DisplayRotationHelper(context)\r\n\r\n    /** カメラ映像のテクスチャを渡したか。一度だけ行うため */\r\n    private var isAlreadySetTexture = false\r\n\r\n    /** 平面をレンダリングするやつ */\r\n    private lateinit var planeRenderer: PlaneRenderer\r\n\r\n    /** Point Cloud (あの青い点) */\r\n    private lateinit var pointCloudVertexBuffer: VertexBuffer\r\n    private lateinit var pointCloudMesh: Mesh\r\n    private lateinit var pointCloudShader: Shader\r\n\r\n    /** 最後のポイントクラウド */\r\n    private var lastPointCloudTimestamp = 0L\r\n\r\n    /** GitHubのARモデル */\r\n    private lateinit var virtualObjectMesh: Mesh\r\n    private lateinit var virtualObjectShader: Shader\r\n\r\n    /** ARモデルの環境HDR */\r\n    private lateinit var dfgTexture: Texture\r\n    private lateinit var cubemapFilter: SpecularCubemapFilter\r\n\r\n    /** AR上においたオブジェクト配列 */\r\n    private val wrappedAnchors = mutableListOf<WrappedAnchor>()\r\n\r\n    /** Toast出すだけ */\r\n    private val toastManager = ToastManager(context)\r\n\r\n    private val modelMatrix = FloatArray(16)\r\n    private val viewMatrix = FloatArray(16)\r\n    private val modelViewMatrix = FloatArray(16)\r\n    private val projectionMatrix = FloatArray(16)\r\n    private val modelViewProjectionMatrix = FloatArray(16)\r\n    private val viewInverseMatrix = FloatArray(16)\r\n    private val sphericalHarmonicsCoefficients = FloatArray(9 * 3)\r\n    private val worldLightDirection = floatArrayOf(0.0f, 0.0f, 0.0f, 0.0f)\r\n    private val viewLightDirection = FloatArray(4)\r\n\r\n    override fun onResume(owner: LifecycleOwner) {\r\n        super.onResume(owner)\r\n        displayRotationHelper.onResume()\r\n    }\r\n\r\n    override fun onPause(owner: LifecycleOwner) {\r\n        super.onPause(owner)\r\n        displayRotationHelper.onPause()\r\n    }\r\n\r\n    /** SurfaceViewが利用可能になったら呼ばれる */\r\n    override fun onSurfaceCreated(render: SampleRender) {\r\n        // カメラ映像\r\n        backgroundRenderer = BackgroundRenderer(render)\r\n        virtualSceneFramebuffer = Framebuffer(render, /*width=*/ 1, /*height=*/ 1)\r\n\r\n        // 平面\r\n        planeRenderer = PlaneRenderer(render)\r\n\r\n        // ポイントクラウド (平面を見つける際に表示される青いやつ)\r\n        pointCloudShader = Shader.createFromAssets(\r\n            render,\r\n            \"shaders/point_cloud.vert\",\r\n            \"shaders/point_cloud.frag\",\r\n            /*defines=*/ null\r\n        ).apply {\r\n            setVec4(\"u_Color\", floatArrayOf(31.0f / 255.0f, 188.0f / 255.0f, 210.0f / 255.0f, 1.0f))\r\n            setFloat(\"u_PointSize\", 5.0f)\r\n        }\r\n        pointCloudVertexBuffer = VertexBuffer(render, /*numberOfEntriesPerVertex=*/ 4, /*entries=*/ null)\r\n        pointCloudMesh = Mesh(render, Mesh.PrimitiveMode.POINTS, /*indexBuffer=*/ null, arrayOf(pointCloudVertexBuffer))\r\n\r\n        // HDRの設定\r\n        cubemapFilter = SpecularCubemapFilter(render, CUBEMAP_RESOLUTION, CUBEMAP_NUMBER_OF_IMPORTANCE_SAMPLES)\r\n        dfgTexture = Texture(render, Texture.Target.TEXTURE_2D, Texture.WrapMode.CLAMP_TO_EDGE,/*useMipmaps=*/ false)\r\n\r\n        // DFT テクスチャの設定\r\n        val dfgResolution = 64\r\n        val dfgChannels = 2\r\n        val halfFloatSize = 2\r\n        val buffer = ByteBuffer.allocateDirect(dfgResolution * dfgResolution * dfgChannels * halfFloatSize).apply {\r\n            context.assets.open(\"models/dfg.raw\").use { it.read(this.array()) }\r\n        }\r\n\r\n        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, dfgTexture.textureId)\r\n        GLError.maybeThrowGLException(\"Failed to bind DFG texture\", \"glBindTexture\")\r\n        GLES30.glTexImage2D(\r\n            GLES30.GL_TEXTURE_2D,\r\n            /*level=*/ 0,\r\n            GLES30.GL_RG16F,\r\n            /*width=*/ dfgResolution,\r\n            /*height=*/ dfgResolution,\r\n            /*border=*/ 0,\r\n            GLES30.GL_RG,\r\n            GLES30.GL_HALF_FLOAT,\r\n            buffer\r\n        )\r\n        GLError.maybeThrowGLException(\"Failed to populate DFG texture\", \"glTexImage2D\")\r\n\r\n        // 3Dオブジェクトを読み込む\r\n        virtualObjectMesh = Mesh.createFromAsset(render, \"models/arcore_github_skyline.obj\")\r\n        virtualObjectShader = Shader.createFromAssets(\r\n            render,\r\n            \"shaders/environmental_hdr.vert\",\r\n            \"shaders/environmental_hdr.frag\",\r\n            mapOf(\"NUMBER_OF_MIPMAP_LEVELS\" to cubemapFilter.numberOfMipmapLevels.toString())\r\n        ).apply {\r\n            setTexture(\"u_Cubemap\", cubemapFilter.filteredCubemapTexture)\r\n            setTexture(\"u_DfgTexture\", dfgTexture)\r\n            // オブジェクトの色をUniform変数に入れる\r\n            setVec4(\"v_ObjColor\", floatArrayOf(0.25f, 0.76f, 0.38f, 1.0f))\r\n        }\r\n    }\r\n\r\n    /** SurfaceViewのサイズ変更時に */\r\n    override fun onSurfaceChanged(render: SampleRender, width: Int, height: Int) {\r\n        displayRotationHelper.onSurfaceChanged(width, height)\r\n        virtualSceneFramebuffer.resize(width, height)\r\n    }\r\n\r\n    /** 毎フレーム呼ばれる？ */\r\n    override fun onDrawFrame(render: SampleRender) {\r\n        val session = arCoreSessionLifecycleHelper.session ?: return\r\n\r\n        // カメラ映像テクスチャ\r\n        if (!isAlreadySetTexture) {\r\n            session.setCameraTextureNames(intArrayOf(backgroundRenderer.cameraColorTexture.textureId))\r\n            isAlreadySetTexture = true\r\n        }\r\n\r\n        // カメラ映像のサイズを合わせる\r\n        displayRotationHelper.updateSessionIfNeeded(session)\r\n\r\n        // ARSession から現在のフレームを取得\r\n        val frame = try {\r\n            session.update()\r\n        } catch (e: Exception) {\r\n            Log.e(TAG, \"Camera not available during onDrawFrame\", e)\r\n            return\r\n        }\r\n\r\n        val camera = frame.camera\r\n        // 深度設定\r\n        try {\r\n            backgroundRenderer.setUseDepthVisualization(render, false)\r\n            backgroundRenderer.setUseOcclusion(render, true)\r\n        } catch (e: IOException) {\r\n            Log.e(TAG, \"Failed to read a required asset file\", e)\r\n            return\r\n        }\r\n\r\n        // 座標を更新する\r\n        backgroundRenderer.updateDisplayGeometry(frame)\r\n        val shouldGetDepthImage = true\r\n        if (camera.trackingState == TrackingState.TRACKING && shouldGetDepthImage) {\r\n            try {\r\n                val depthImage = frame.acquireDepthImage16Bits()\r\n                backgroundRenderer.updateCameraDepthTexture(depthImage)\r\n                depthImage.close()\r\n            } catch (e: NotYetAvailableException) {\r\n                // まだ深度データが利用できない\r\n                // 別にエラーではなく正常\r\n            }\r\n        }\r\n\r\n        // タップされたか、毎フレーム見る\r\n        handleTap(frame, camera)\r\n\r\n        // ARのステータス\r\n        // 平面が検出されてオブジェクトを配置できるようになったかどうかなど\r\n        when {\r\n            camera.trackingState == TrackingState.PAUSED && camera.trackingFailureReason == TrackingFailureReason.NONE -> \"平面を探しています\"\r\n            camera.trackingState == TrackingState.PAUSED -> null\r\n            hasTrackingPlane(session) && wrappedAnchors.isEmpty() -> \"平面を検出しました。タップして配置します。\"\r\n            hasTrackingPlane(session) && wrappedAnchors.isNotEmpty() -> null\r\n            else -> \"平面を探しています\"\r\n        }?.also {\r\n            toastManager.show(it)\r\n        }\r\n\r\n        // カメラ映像を描画する\r\n        if (frame.timestamp != 0L) {\r\n            // カメラがまだ最初のフレームを生成していない場合、レンダリングを抑制します。 これは避けるためです\r\n            // テクスチャが再利用される場合、以前のセッションから残っている可能性のあるデータを描画します。\r\n            backgroundRenderer.drawBackground(render)\r\n        }\r\n        // 追跡しない場合は、3D オブジェクトを描画しない\r\n        if (camera.trackingState == TrackingState.PAUSED) {\r\n            return\r\n        }\r\n\r\n        // 射影行列を取得する\r\n        camera.getProjectionMatrix(projectionMatrix, 0, Z_NEAR, Z_FAR)\r\n\r\n        // カメラ行列を取得して描画.\r\n        camera.getViewMatrix(viewMatrix, 0)\r\n\r\n        // ポイントクラウドの描画\r\n        frame.acquirePointCloud().use { pointCloud ->\r\n            if (pointCloud.timestamp > lastPointCloudTimestamp) {\r\n                pointCloudVertexBuffer.set(pointCloud.points)\r\n                lastPointCloudTimestamp = pointCloud.timestamp\r\n            }\r\n            Matrix.multiplyMM(modelViewProjectionMatrix, 0, projectionMatrix, 0, viewMatrix, 0)\r\n            pointCloudShader.setMat4(\"u_ModelViewProjection\", modelViewProjectionMatrix)\r\n            render.draw(pointCloudMesh, pointCloudShader)\r\n        }\r\n\r\n        // 平面を描画します\r\n        planeRenderer.drawPlanes(render, session.getAllTrackables(Plane::class.java), camera.displayOrientedPose, projectionMatrix)\r\n\r\n        // シェーダのライティングパラメータを更新\r\n        updateLightEstimation(frame.lightEstimate, viewMatrix)\r\n\r\n        // ARオブジェクトを描画\r\n        render.clear(virtualSceneFramebuffer, 0f, 0f, 0f, 0f)\r\n        wrappedAnchors.filter { it.anchor.trackingState == TrackingState.TRACKING }.forEach { (anchor, trackable) ->\r\n            // アンカーポーズ\r\n            anchor.pose.toMatrix(modelMatrix, 0)\r\n            // モデル、ビュー、投影行列 を計算\r\n            Matrix.multiplyMM(modelViewMatrix, 0, viewMatrix, 0, modelMatrix, 0)\r\n            Matrix.multiplyMM(modelViewProjectionMatrix, 0, projectionMatrix, 0, modelViewMatrix, 0)\r\n            // シェーダーのUniform変数にセットする\r\n            virtualObjectShader.setMat4(\"u_ModelView\", modelViewMatrix)\r\n            virtualObjectShader.setMat4(\"u_ModelViewProjection\", modelViewProjectionMatrix)\r\n            // 描画\r\n            render.draw(virtualObjectMesh, virtualObjectShader, virtualSceneFramebuffer)\r\n        }\r\n\r\n        // 背景を使用して仮想シーンを構成します。\r\n        backgroundRenderer.drawVirtualScene(render, virtualSceneFramebuffer, Z_NEAR, Z_FAR)\r\n    }\r\n\r\n    /** 1フレームごとにタップを処理する */\r\n    private fun handleTap(frame: Frame, camera: Camera) {\r\n        if (camera.trackingState != TrackingState.TRACKING) return\r\n        val tap = tapHelper.poll() ?: return\r\n\r\n        // ヒットは深さによってソートされます。平面上の最も近いヒットのみ\r\n        val hitResultList = frame.hitTest(tap)\r\n        val firstHitResult = hitResultList.firstOrNull { hit ->\r\n            when (val trackable = hit.trackable!!) {\r\n                is Plane -> trackable.isPoseInPolygon(hit.hitPose) && PlaneRenderer.calculateDistanceToPlane(hit.hitPose, camera.pose) > 0\r\n                is Point -> trackable.orientationMode == Point.OrientationMode.ESTIMATED_SURFACE_NORMAL\r\n                is InstantPlacementPoint -> true\r\n                // DepthPoints are only returned if Config.DepthMode is set to AUTOMATIC.\r\n                is DepthPoint -> true\r\n                else -> false\r\n            }\r\n        }\r\n\r\n        if (firstHitResult != null) {\r\n            // アンカー数に制限をかける\r\n            if (wrappedAnchors.size >= 20) {\r\n                wrappedAnchors[0].anchor.detach()\r\n                wrappedAnchors.removeAt(0)\r\n            }\r\n            // 追跡登録\r\n            wrappedAnchors.add(WrappedAnchor(firstHitResult.createAnchor(), firstHitResult.trackable))\r\n        }\r\n    }\r\n\r\n    /** 光を処理する */\r\n    private fun updateLightEstimation(lightEstimate: LightEstimate, viewMatrix: FloatArray) {\r\n        if (lightEstimate.state != LightEstimate.State.VALID) {\r\n            virtualObjectShader.setBool(\"u_LightEstimateIsValid\", false)\r\n            return\r\n        }\r\n        virtualObjectShader.setBool(\"u_LightEstimateIsValid\", true)\r\n        Matrix.invertM(viewInverseMatrix, 0, viewMatrix, 0)\r\n        virtualObjectShader.setMat4(\"u_ViewInverse\", viewInverseMatrix)\r\n        updateMainLight(\r\n            lightEstimate.environmentalHdrMainLightDirection,\r\n            lightEstimate.environmentalHdrMainLightIntensity,\r\n            viewMatrix\r\n        )\r\n        cubemapFilter.update(lightEstimate.acquireEnvironmentalHdrCubeMap())\r\n    }\r\n\r\n    private fun updateMainLight(\r\n        direction: FloatArray,\r\n        intensity: FloatArray,\r\n        viewMatrix: FloatArray,\r\n    ) {\r\n        // ビュー空間に変換するための最終コンポーネントとして 0.0 を持つ vec4 の方向が必要です。\r\n        worldLightDirection[0] = direction[0]\r\n        worldLightDirection[1] = direction[1]\r\n        worldLightDirection[2] = direction[2]\r\n        Matrix.multiplyMV(viewLightDirection, 0, viewMatrix, 0, worldLightDirection, 0)\r\n        virtualObjectShader.setVec4(\"u_ViewLightDirection\", viewLightDirection)\r\n        virtualObjectShader.setVec3(\"u_LightIntensity\", intensity)\r\n    }\r\n\r\n    /** 平面が1つ以上見つかっていれば true */\r\n    private fun hasTrackingPlane(session: Session) = session.getAllTrackables(Plane::class.java).any { it.trackingState == TrackingState.TRACKING }\r\n\r\n    /** アンカーとトラッカブルを紐つける */\r\n    private data class WrappedAnchor(\r\n        val anchor: Anchor,\r\n        val trackable: Trackable,\r\n    )\r\n\r\n    companion object {\r\n        private val TAG = ARCoreOpenGlRenderer::class.java.simpleName\r\n\r\n        private const val Z_NEAR = 0.1f\r\n        private const val Z_FAR = 100f\r\n\r\n        private const val CUBEMAP_RESOLUTION = 16\r\n        private const val CUBEMAP_NUMBER_OF_IMPORTANCE_SAMPLES = 32\r\n    }\r\n}\r\n```\r\n\r\n### environmental_hdr.frag\r\n\r\nこの3Dオブジェクトに色を付けるのが、`environmental_hdr.frag`って名前のフラグメントシェーダです。  \r\n少し手を加えます。\r\n\r\n以下の3行を\r\n\r\n```glsl\r\n// The albedo and roughness/metallic textures.\r\nuniform sampler2D u_AlbedoTexture;\r\nuniform sampler2D u_RoughnessMetallicAmbientOcclusionTexture;\r\n```\r\n\r\nこうします\r\n\r\n```glsl\r\n// ここで3Dオブジェクトの色を定義しておく\r\nuniform vec4 v_ObjColor;\r\n```\r\n\r\n次にここを\r\n\r\n```glsl\r\n  // Skip all lighting calculations if the estimation is not valid.\r\n  if (!u_LightEstimateIsValid) {\r\n    o_FragColor = vec4(texture(u_AlbedoTexture, texCoord).rgb, 1.0);\r\n    return;\r\n  }\r\n```\r\n\r\nこうします\r\n\r\n```glsl\r\n  // Skip all lighting calculations if the estimation is not valid.\r\n  if (!u_LightEstimateIsValid) {\r\n    o_FragColor = v_ObjColor;\r\n    return;\r\n  }\r\n```\r\n\r\n関数呼び出しも直します。  \r\n以下の部分を\r\n\r\n```glsl\r\n  MaterialParameters material;\r\n  Pbr_CreateMaterialParameters(texCoord, u_AlbedoTexture,\r\n                               u_RoughnessMetallicAmbientOcclusionTexture,\r\n                               u_DfgTexture, shading, material);\r\n```\r\n\r\nこうします\r\n\r\n```glsl\r\n  MaterialParameters material;\r\n  Pbr_CreateMaterialParameters(texCoord, u_DfgTexture, shading, material);\r\n```\r\n\r\n`Pbr_CreateMaterialParameters`関数から引数を消して直します。\r\n\r\n```glsl\r\nvoid Pbr_CreateMaterialParameters(const in vec2 texCoord,\r\n                                  const in sampler2D albedoTexture,\r\n                                  const in sampler2D pbrTexture,\r\n                                  const in sampler2D dfgTexture,\r\n                                  const in ShadingParameters shading,\r\n                                  out MaterialParameters material) {\r\n  // Read the material parameters from the textures\r\n  vec3 albedo = texture(albedoTexture, texCoord).rgb;\r\n  vec3 roughnessMetallicAmbientOcclusion = texture(pbrTexture, texCoord).rgb;\r\n```\r\n\r\n```glsl\r\nvoid Pbr_CreateMaterialParameters(const in vec2 texCoord,\r\n                                  const in sampler2D dfgTexture,\r\n                                  const in ShadingParameters shading,\r\n                                  out MaterialParameters material) {\r\n  // Read the material parameters from the textures\r\n  vec3 albedo = v_ObjColor.rgb;\r\n  vec3 roughnessMetallicAmbientOcclusion = v_ObjColor.rgb;\r\n```\r\n\r\n### 何してたの？\r\n公式のサンプルコードでは、テクスチャ画像を読み込むような実装でした。  \r\n今回はテクスチャ画像無しで、単色で塗りつぶすようにするため上記の修正が必要になりました。\r\n\r\n### environmental_hdr.frag 全体\r\n\r\nほとんど変えてませんが\r\n\r\n```glsl\r\n#version 300 es\r\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nprecision mediump float;\r\n\r\n// This shader will light scenes based on ARCore's Environmental HDR mode with a\r\n// physically based rendering model.\r\n//\r\n// When using the HDR Cubemap from ARCore for specular reflections, please note\r\n// that the following equation is true of ARCore's Environmental HDR lighting\r\n// estimation, where E(x) is irradiance of x.\r\n//\r\n// E(spherical harmonics) + E(main light) == E(cubemap)\r\n//\r\n// In order to not duplicate the specular lighting contribution of the main\r\n// light, we must use the following equation, where Lo is total reflected\r\n// radiance (i.e. linear color output), Ld(x) is the reflected diffuse radiance\r\n// of x, and Ls(x) is reflected specular radiance of x.\r\n//\r\n// Lo = Ld(spherical harmonics) + Ld(main light) + Ls(cubemap)\r\n//\r\n// The Filament documentation has excellent documentation on the subject of\r\n// image based lighting:\r\n// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights\r\n//\r\n// If you would rather not use the HDR cubemap in your application, you would\r\n// need to adjust the lighting calculations to reflect the following equation\r\n// instead.\r\n//\r\n// Lo = Ld(spherical harmonics) + Ld(main light) + Ls(main light)\r\n//\r\n// See the definitions of Pbr_CalculateMainLightRadiance and\r\n// Pbr_CalculateEnvironmentalRadiance.\r\n\r\n// Number of mipmap levels in the filtered cubemap.\r\nconst int kNumberOfRoughnessLevels = NUMBER_OF_MIPMAP_LEVELS;\r\n\r\n// ここで3Dオブジェクトの色を定義しておく\r\nuniform vec4 v_ObjColor;\r\n\r\n// The intensity of the main directional light.\r\nuniform vec3 u_LightIntensity;\r\n\r\n// The direction of the main directional light in view space.\r\nuniform vec4 u_ViewLightDirection;\r\n\r\n// The coefficients for the spherical harmonic function which models the diffuse\r\n// irradiance of a distant environmental light for a given surface normal in\r\n// world space. These coefficients must be premultiplied with their\r\n// corresponding spherical harmonics constants. See\r\n// HelloArActivity.updateSphericalHarmonicsCoefficients for more information.\r\nuniform vec3 u_SphericalHarmonicsCoefficients[9];\r\n\r\n// The filtered cubemap texture which models the LD term (i.e. radiance (L)\r\n// times distribution function (D)) of the environmental specular calculation as\r\n// a function of direction and roughness.\r\nuniform samplerCube u_Cubemap;\r\n\r\n// The DFG lookup texture which models the DFG1 and DFG2 terms of the\r\n// environmental specular calculation as a function of normal dot view and\r\n// perceptual roughness.\r\nuniform sampler2D u_DfgTexture;\r\n\r\n// Inverse view matrix. Used for converting normals back into world space for\r\n// environmental radiance calculations.\r\nuniform mat4 u_ViewInverse;\r\n\r\n// If the current light estimate is valid. Used to short circuit the entire\r\n// shader when the light estimate is not valid.\r\nuniform bool u_LightEstimateIsValid;\r\n\r\nstruct MaterialParameters {\r\n  vec3 diffuse;\r\n  float perceptualRoughness;  // perceptually linear roughness\r\n  float roughness;            // non-perceptually linear roughness\r\n  float metallic;\r\n  float ambientOcclusion;\r\n  vec3 f0;                  // reflectance\r\n  vec2 dfg;                 // DFG1 and DFG2 terms\r\n  vec3 energyCompensation;  // energy preservation for multiscattering\r\n};\r\n\r\nstruct ShadingParameters {\r\n  // Halfway here refers to halfway between the view and light directions.\r\n  float normalDotView;\r\n  float normalDotHalfway;\r\n  float normalDotLight;\r\n  float viewDotHalfway;\r\n  float oneMinusNormalDotHalfwaySquared;\r\n\r\n  // These unit vectors are in world space and are used for the environmental\r\n  // lighting math.\r\n  vec3 worldNormalDirection;\r\n  vec3 worldReflectDirection;\r\n};\r\n\r\nin vec3 v_ViewPosition;\r\nin vec3 v_ViewNormal;\r\nin vec2 v_TexCoord;\r\n\r\nlayout(location = 0) out vec4 o_FragColor;\r\n\r\nconst float kPi = 3.14159265359;\r\n\r\nvec3 Pbr_CalculateMainLightRadiance(const ShadingParameters shading,\r\n                                    const MaterialParameters material,\r\n                                    const vec3 mainLightIntensity) {\r\n  // Lambertian diffuse\r\n  vec3 diffuseTerm = material.diffuse / kPi;\r\n\r\n  // Note that if we were not using the HDR cubemap from ARCore for specular\r\n  // lighting, we would be adding a specular contribution from the main light\r\n  // here. See the top of the file for a more detailed explanation.\r\n\r\n  return diffuseTerm * mainLightIntensity * shading.normalDotLight;\r\n}\r\n\r\nvec3 Pbr_CalculateDiffuseEnvironmentalRadiance(const vec3 normal,\r\n                                               const vec3 coefficients[9]) {\r\n  // See HelloArActivity.updateSphericalHarmonicsCoefficients() for more\r\n  // information about this calculation.\r\n  vec3 radiance = coefficients[0] + coefficients[1] * (normal.y) +\r\n                  coefficients[2] * (normal.z) + coefficients[3] * (normal.x) +\r\n                  coefficients[4] * (normal.y * normal.x) +\r\n                  coefficients[5] * (normal.y * normal.z) +\r\n                  coefficients[6] * (3.0 * normal.z * normal.z - 1.0) +\r\n                  coefficients[7] * (normal.z * normal.x) +\r\n                  coefficients[8] * (normal.x * normal.x - normal.y * normal.y);\r\n  return max(radiance, 0.0);\r\n}\r\n\r\nvec3 Pbr_CalculateSpecularEnvironmentalRadiance(\r\n    const ShadingParameters shading, const MaterialParameters material,\r\n    const samplerCube cubemap) {\r\n  // Lagarde and de Rousiers 2014, \"Moving Frostbite to PBR\"\r\n  float specularAO =\r\n      clamp(pow(shading.normalDotView + material.ambientOcclusion,\r\n                exp2(-16.0 * material.roughness - 1.0)) -\r\n                1.0 + material.ambientOcclusion,\r\n            0.0, 1.0);\r\n  // Combine DFG and LD terms\r\n  float lod =\r\n      material.perceptualRoughness * float(kNumberOfRoughnessLevels - 1);\r\n  vec3 LD = textureLod(cubemap, shading.worldReflectDirection, lod).rgb;\r\n  vec3 E = mix(material.dfg.xxx, material.dfg.yyy, material.f0);\r\n  return E * LD * specularAO * material.energyCompensation;\r\n}\r\n\r\nvec3 Pbr_CalculateEnvironmentalRadiance(\r\n    const ShadingParameters shading, const MaterialParameters material,\r\n    const vec3 sphericalHarmonicsCoefficients[9], const samplerCube cubemap) {\r\n  // The lambertian diffuse BRDF term (1/pi) is baked into\r\n  // HelloArActivity.sphericalHarmonicsFactors.\r\n  vec3 diffuseTerm =\r\n      Pbr_CalculateDiffuseEnvironmentalRadiance(\r\n          shading.worldNormalDirection, sphericalHarmonicsCoefficients) *\r\n      material.diffuse * material.ambientOcclusion;\r\n\r\n  vec3 specularTerm =\r\n      Pbr_CalculateSpecularEnvironmentalRadiance(shading, material, cubemap);\r\n\r\n  return diffuseTerm + specularTerm;\r\n}\r\n\r\nvoid Pbr_CreateShadingParameters(const in vec3 viewNormal,\r\n                                 const in vec3 viewPosition,\r\n                                 const in vec4 viewLightDirection,\r\n                                 const in mat4 viewInverse,\r\n                                 out ShadingParameters shading) {\r\n  vec3 normalDirection = normalize(viewNormal);\r\n  vec3 viewDirection = -normalize(viewPosition);\r\n  vec3 lightDirection = normalize(viewLightDirection.xyz);\r\n  vec3 halfwayDirection = normalize(viewDirection + lightDirection);\r\n\r\n  // Clamping the minimum bound yields better results with values less than or\r\n  // equal to 0, which would otherwise cause discontinuity in the geometry\r\n  // factor. Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline\r\n  // for The Order: 1886\"\r\n  shading.normalDotView = max(dot(normalDirection, viewDirection), 1e-4);\r\n  shading.normalDotHalfway =\r\n      clamp(dot(normalDirection, halfwayDirection), 0.0, 1.0);\r\n  shading.normalDotLight =\r\n      clamp(dot(normalDirection, lightDirection), 0.0, 1.0);\r\n  shading.viewDotHalfway =\r\n      clamp(dot(viewDirection, halfwayDirection), 0.0, 1.0);\r\n\r\n  // The following calculation can be proven as being equivalent to 1-(N.H)^2 by\r\n  // using Lagrange's identity.\r\n  //\r\n  // ||a x b||^2 = ||a||^2 ||b||^2 - (a . b)^2\r\n  //\r\n  // Since we're using unit vectors: ||N x H||^2 = 1 - (N . H)^2\r\n  //\r\n  // We are calculating it in this way to preserve floating point precision.\r\n  vec3 NxH = cross(normalDirection, halfwayDirection);\r\n  shading.oneMinusNormalDotHalfwaySquared = dot(NxH, NxH);\r\n\r\n  shading.worldNormalDirection = (viewInverse * vec4(normalDirection, 0.0)).xyz;\r\n  vec3 reflectDirection = reflect(-viewDirection, normalDirection);\r\n  shading.worldReflectDirection =\r\n      (viewInverse * vec4(reflectDirection, 0.0)).xyz;\r\n}\r\n\r\nvoid Pbr_CreateMaterialParameters(const in vec2 texCoord,\r\n                                  const in sampler2D dfgTexture,\r\n                                  const in ShadingParameters shading,\r\n                                  out MaterialParameters material) {\r\n  // Read the material parameters from the textures\r\n  vec3 albedo = v_ObjColor.rgb;\r\n  vec3 roughnessMetallicAmbientOcclusion = v_ObjColor.rgb;\r\n  // Roughness inputs are perceptually linear; convert them to regular roughness\r\n  // values. Roughness levels approaching 0 will make specular reflections\r\n  // completely invisible, so cap the lower bound. This value was chosen such\r\n  // that (kMinPerceptualRoughness^4) > 0 in fp16 (i.e. 2^(-14/4), rounded up).\r\n  // https://github.com/google/filament/blob/main/shaders/src/common_material.fs#L2\r\n  const float kMinPerceptualRoughness = 0.089;\r\n  material.perceptualRoughness =\r\n      max(roughnessMetallicAmbientOcclusion.r, kMinPerceptualRoughness);\r\n  material.roughness =\r\n      material.perceptualRoughness * material.perceptualRoughness;\r\n  material.metallic = roughnessMetallicAmbientOcclusion.g;\r\n  material.ambientOcclusion = roughnessMetallicAmbientOcclusion.b;\r\n\r\n  material.diffuse = albedo * (1.0 - material.metallic);\r\n  // F0 is defined as \"Fresnel reflectance at 0 degrees\", i.e. specular\r\n  // reflectance when light is grazing a surface perfectly perpendicularly. This\r\n  // value is derived from the index of refraction for a material. Most\r\n  // dielectric materials have an F0 value of 0.00-0.08, which leaves 0.04 as a\r\n  // reasonable constant for a simple roughness/metallic material workflow as\r\n  // implemented by this shader.\r\n  material.f0 = mix(vec3(0.04), albedo, material.metallic);\r\n\r\n  // The DFG texture is a simple lookup table indexed by [normal dot view,\r\n  // perceptualRoughness].\r\n  material.dfg =\r\n      textureLod(dfgTexture,\r\n                 vec2(shading.normalDotView, material.perceptualRoughness), 0.0)\r\n          .xy;\r\n\r\n  // Energy preservation for multiscattering (see\r\n  // https://google.github.io/filament/Filament.md.html#materialsystem/improvingthebrdfs)\r\n  material.energyCompensation =\r\n      1.0 + material.f0 * (1.0 / material.dfg.y - 1.0);\r\n}\r\n\r\nvec3 LinearToSrgb(const vec3 color) {\r\n  vec3 kGamma = vec3(1.0 / 2.2);\r\n  return clamp(pow(color, kGamma), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n  // Mirror texture coordinates over the X axis\r\n  vec2 texCoord = vec2(v_TexCoord.x, 1.0 - v_TexCoord.y);\r\n\r\n  // Skip all lighting calculations if the estimation is not valid.\r\n  if (!u_LightEstimateIsValid) {\r\n    o_FragColor = v_ObjColor;\r\n    return;\r\n  }\r\n\r\n  ShadingParameters shading;\r\n  Pbr_CreateShadingParameters(v_ViewNormal, v_ViewPosition,\r\n                              u_ViewLightDirection, u_ViewInverse, shading);\r\n\r\n  MaterialParameters material;\r\n  Pbr_CreateMaterialParameters(texCoord, u_DfgTexture, shading, material);\r\n\r\n  // Combine the radiance contributions of both the main light and environment\r\n  vec3 mainLightRadiance =\r\n      Pbr_CalculateMainLightRadiance(shading, material, u_LightIntensity);\r\n\r\n  vec3 environmentalRadiance = Pbr_CalculateEnvironmentalRadiance(\r\n      shading, material, u_SphericalHarmonicsCoefficients, u_Cubemap);\r\n\r\n  vec3 radiance = mainLightRadiance + environmentalRadiance;\r\n\r\n  // Convert final color to sRGB color space\r\n  o_FragColor = vec4(LinearToSrgb(radiance), 1.0);\r\n}\r\n```\r\n\r\n# 完成品\r\nスクショ下手くそ選手権\r\n\r\n![Imgur](https://imgur.com/R15xfnf.png)\r\n\r\n## ざっくり OpenGL\r\nそれぞれの関数がなんか`Win32 API`みたいでなんか慣れない (-1を返したら失敗とか)\r\n\r\n### フラグメントシェーダ / バーテックスシェーダ\r\nバーテックスシェーダってのは頂点をセットするやつらしい。  \r\nフラグメントシェーダはそれに色を付けていく。\r\n\r\n### Uniform\r\n`Uniform`を使うと、`CPU`から`GPU`へ値を渡すことができます。（今回では`Kotlin`から`OpenGL`へ値を渡すことができる）\r\n\r\n```kotlin\r\nval glslProgram = GLES20.glCreateProgram()\r\n\r\n// 省略\r\n\r\n// フラグメントシェーダの vColor変数 へ値をセットする\r\nGLES20.glGetUniformLocation(program, \"vColor\").also { color ->\r\n    // 色をOpenGL (GPU) へ渡す\r\n    GLES20.glUniform4fv(color, 1, floatArrayOf(1.0f, 0.0f, 0.0f, 1.0f), 0)\r\n}\r\n```\r\n\r\n```glsl\r\nprecision mediump float;\r\n\r\n// uniform をつけると取得できる\r\nuniform vec4 vColor;\r\n\r\nvoid main() {\r\n    gl_FragColor = vColor;\r\n}\r\n```\r\n\r\n### o_FragColor\r\nここに `vec4 型` で色をセットすることで反映されます。  \r\nグローバル変数\r\n\r\n### vec4\r\n色の指定とかで使う。  \r\n色の場合は 0f から 1f までの RGBA だと思います。  \r\n\r\n# 書き換えて遊ぶ\r\n\r\n例えば、頂点のつなぎ方を変更することで塗りつぶさない。なんかも出来ます。\r\n\r\n`Mesh.java`\r\n\r\n```java\r\nVertexBuffer[] vertexBuffers = {\r\n  new VertexBuffer(render, 3, localCoordinates),\r\n  new VertexBuffer(render, 2, textureCoordinates),\r\n  new VertexBuffer(render, 3, normals),\r\n};\r\n\r\nIndexBuffer indexBuffer = new IndexBuffer(render, vertexIndices);\r\n\r\n// LINE_STRIP にする。これは塗りつぶさない\r\nreturn new Mesh(render, PrimitiveMode.LINE_STRIP, indexBuffer, vertexBuffers);\r\n```\r\n\r\n```java\r\n// これを足す\r\nGLES30.glLineWidth(5f);\r\n\r\nGLES30.glDrawArrays(primitiveMode.glesEnum, 0, numberOfVertices);\r\nGLError.maybeThrowGLException(\"Failed to draw vertex array object\", \"glDrawArrays\");\r\n```\r\n\r\n![Imgur](https://imgur.com/jIQrGQL.png)\r\n\r\n# ソースコード\r\n多分動く。コミット一応分けておきました。\r\n\r\nhttps://github.com/takusan23/ARCoreGitHubSkyline\r\n\r\nとりあえず`APK`欲しい場合は`GitHub Releases`においておきました。\r\n\r\nhttps://github.com/takusan23/ARCoreGitHubSkyline/releases/tag/1.0.0\r\n\r\n# おわりに\r\n\r\n近くで見るとちゃんと凸凹してる\r\n\r\n![Imgur](https://imgur.com/JGt9BvS.png)\r\n\r\n## Depth API\r\n写真下手くそですがちゃんと物を検知するようになってます。  \r\n（机の下に置いたらちゃと机の下まで潜らないと描画されない）\r\n\r\n## OpenGL要素えぇ\r\nシェーダーすらパクってきたのでほぼ`Kotlin`しか書いてないです。  \r\nもしかしたら `Unity` とかのゲームエンジンがわかる人のほうが使いこなせそう！\r\n\r\n## デバッグしんどくない？\r\n`シェーダー`、これコンパイル(`GLES30.glCompileShader`)の際に使われない変数を消すのですが、これのせいで実行時に`Uniform`変数が無いよ！って言われてしまうんですよね。  \r\nあと`printf`みたいなのも(多分)ない(GPUで動いてるので...)のでまじで大変そう。  \r\n\r\n一応`GLSLで書かれたシェーダー`を`minify (最適化)`するツールがあるみたいなので、どの変数が要らなくなるかとかをコンパイル前に見ることはできるのかな...？\r\n\r\n# おわりに2\r\n\r\nそういえば、今無き とらのあな秋葉原店A でやってたこれ、行ってきました\r\n\r\n![Imgur](https://imgur.com/xQWMb7r.png)\r\n\r\n![Imgur](https://imgur.com/3ALfT8A.png)\r\n\r\n以上です。お疲れ様でした ﾉｼ 888\r\n\r\n# 追記 2023/05/05\r\n回転しないでほしい場合は、`ARCoreOpenGlRenderer.kt`へ以下のようなコードを描くと良いです。  \r\n`Pose#extractTranslation`で回転を考慮しない行列を作ってくれます。\r\n\r\n```diff\r\n         // ARオブジェクトを描画\r\n         render.clear(virtualSceneFramebuffer, 0f, 0f, 0f, 0f)\r\n         wrappedAnchors.filter { it.anchor.trackingState == TrackingState.TRACKING }.forEach { (anchor, trackable) ->\r\n-            // アンカーポーズ\r\n-            anchor.pose.toMatrix(modelMatrix, 0)\r\n+            // 描画のための行列を用意する\r\n+            // TODO extractTranslation を呼ぶと、回転（axis）を除いた行列を返してくれる。呼ばずに Post#toMatrix すると、回転も考慮される\r\n+            // anchor.pose.toMatrix(modelMatrix, 0)\r\n+            anchor.pose.extractTranslation().toMatrix(modelMatrix, 0)\r\n             // モデル、ビュー、投影行列 を計算\r\n             Matrix.multiplyMM(modelViewMatrix, 0, viewMatrix, 0, modelMatrix, 0)\r\n             Matrix.multiplyMM(modelViewProjectionMatrix, 0, projectionMatrix, 0, modelViewMatrix, 0)\t\r\n```"},{"title":"銀行系アプリにあるUSBデバッグ有効時に起動しない問題に終止符を打つ","link":"/posts/android_auto_disable_adb/","markdown":"どうもこんばんわ。  \nAndroid 12、そろそろ正式リリースだと思うんですけど まーだ時間かかりそうですかねー\n\n# 本題\n![Imgur](https://imgur.com/qRAmIBt.png)\n\n`rootアクセス`があるとか、`ブートローダーがアンロック`されているとかならわかるんだけど、  \nなんで`USBデバッグ`ついてるとだめなんや（**多分adb経由で画面録画とかができるのでそれのせい**）\n\n## 一時的にオフにすればいいじゃん\nUSBデバッグをOFFにするのって結構めんどいんだよね。  \nしかもONにするの忘れてるとか。ウィジェットを作ってUSBデバッグを有効、無効にするアプリとかクイック設定から変更できるようにしても良かったけどなんかなぁ。\n\n# だから作った\n(600KBのGIFですのでモバイルデータの方ごめんね)\n\n![Imgur](https://imgur.com/63c7UZt.gif)\n\n真っ暗の画面になってるのは、銀行系アプリが画面録画とかスクリーンショットを禁止しているせいです。  \nUSBデバッグをOFFにしろってダイアログが出てないのでそれが証拠になるかと。\n\n# 仕組み\n\nUSBデバッグをOFFにする  \n↓  \nUSBデバッグをONにしてると怒られるアプリをIntent経由で起動   \n↓  \nアプリが終了(`Activity Result API (onActivityResult)` / `onDestroy`)したらUSBデバッグをONに戻す。\n\n# ソースコード\n\n```kotlin\n/**\n * pm grant io.github.takusan23.usbdebugautohide android.permission.WRITE_SECURE_SETTINGS\n * */\nclass MainActivity : AppCompatActivity() {\n\n\n    private val PACKAGE_NAME = \"jp.co.smbc.direct\"\n    private val activityCloseCallback = registerForActivityResult(ActivityClose()) {\n        // アプリ終了時にUSBデバッグをONに戻す\n        Settings.Global.putLong(contentResolver, Settings.Global.ADB_ENABLED, 1)\n        // バックキーで戻ってきたらここに来る。アプリ閉じる\n        finishAndRemoveTask()\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // SMBC起動前にUSBデバッグをOFF\n        Settings.Global.putLong(contentResolver, Settings.Global.ADB_ENABLED, 0)\n\n        // USBデバッグを無効にしないといけないアプリを起動\n        val launchIntent = packageManager.getLaunchIntentForPackage(PACKAGE_NAME)\n        launchIntent?.flags = 0 // 勝手に Intent.FLAG_ACTIVITY_NEW_TASK を指定するので消す\n        activityCloseCallback.launch(launchIntent)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            startForegroundService(Intent(this, USBDebugAutoOnService::class.java))\n        } else {\n            startService(Intent(this, USBDebugAutoOnService::class.java))\n        }\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        stopService(Intent(this, USBDebugAutoOnService::class.java))\n    }\n\n}\n\nclass USBDebugAutoOnService : Service() {\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n\n        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        val channelId = \"usbdebug_auto_on\"\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            notificationManager.createNotificationChannel(NotificationChannel(channelId, \"USBデバックを戻すサービス\", NotificationManager.IMPORTANCE_LOW))\n        }\n        val notification = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            Notification.Builder(this, channelId)\n        } else {\n            Notification.Builder(this)\n        }.apply {\n            setContentText(\"USBデバックを戻すサービス\")\n            setContentTitle(\"アプリが終了したらUSBデバッグが有効になります\")\n            setSmallIcon(R.drawable.ic_launcher_background).build()\n        }.build()\n\n        startForeground(1, notification)\n        return START_NOT_STICKY\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        println(\"アプリ終了\")\n        Settings.Global.putLong(contentResolver, Settings.Global.ADB_ENABLED, 1)\n    }\n\n    override fun onBind(p0: Intent?): IBinder? {\n        return null;\n    }\n\n}\n\nclass ActivityClose : ActivityResultContract<Intent, Unit>() {\n    override fun createIntent(context: Context, input: Intent): Intent {\n        // launch()のIntentがinput\n        return input\n    }\n\n    override fun parseResult(resultCode: Int, intent: Intent?) {\n        // とくになし\n    }\n}\n```\n\n使う権限は以下の２つです。\n\n```xml\n<uses-permission android:name=\"android.permission.WRITE_SECURE_SETTINGS\" />\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n```\n\n# USBデバッグをアプリから有効、無効にする\nには、`WRITE_SECURE_SETTINGS`が必要なのですが、これはサードパーティアプリには開放されていません。  \nしかし何故か`pm grant <パッケージ名> android.permission.WRITE_SECURE_SETTINGS`を実行すると権限を付与することが出来ます。YATTA YATTA\n\n権限がゲットできればこっちのもんです。\n\n```kotlin\n// USBデバッグをON\nSettings.Global.putLong(contentResolver, Settings.Global.ADB_ENABLED, 1)\n\n// USBデバッグをOFF\nSettings.Global.putLong(contentResolver, Settings.Global.ADB_ENABLED, 0)\n```\n\n# アプリの終了検知\nバックキーで戻ってきたときのために、`Activity Result API (onActivityResult)`でを使います。  \n\nそれとは別に、アプリ履歴画面から終了した際のために`onDestroy`も使います。  \n\n## じゃあなんでサービス起動してるの？\n`startForegroundService`でフォアグラウンドサービスを起動してるわけですが、その理由は`onDestory`で`USBデバッグをON`に戻せなかったからです。  \nでもなんかサービスを終了させる`stopService`だけうまく動いたので、サービス側で戻すようにしました。`onDestroy`、まじで謎  \n\nなんかフォアグラウンドサービス起動中ならアプリ履歴画面から終了させても`onDestroy`でUSBデバッグを有効にできる？\n\n## registerForActivityResult の引数を自作する\n\n上記の`ActivityClose`クラスのことですね。`ActivityResultContract`を継承して、`ジェネリクス`の１個目の型は、画面遷移をする関数、`launch()`に渡す値の型です。今回はIntentを渡すので`Intent`です。  \n２個目の型はコールバック時に返す値です。ここでは特に何も返さないので`Unit`です。  \n\nそれから2つ関数がありますが、`createIntent`に関しては`引数のIntent`をそのままreturnして、`parseResult`では特に何もしません。\n\n# ソースコードです\n\nなお、`WRITE_SECURE_SETTINGS`の権限があるかのチェックはしてないので、インストールしたら、以下のコマンドを実行して権限を付与してあげてください。（よって初回起動時は強制クラッシュします）\n\n```\npm grant io.github.takusan23.usbdebugautohide android.permission.WRITE_SECURE_SETTINGS\n```\n\nhttps://github.com/takusan23/USBDebugAutoHide\n\n# おわりに\nhttps://github.com/takusan23/DeveloperHide\n\nアプリ書きました。そのうちPlayストアに出したい\n\n提出はした、審査が通るかは知らんけど：https://play.google.com/store/apps/details?id=io.github.takusan23.developerhide"},{"title":"Play ストアでバックグラウンド位置情報取得権限 ACCESS_BACKGROUND_LOCATION を使うアプリを公開してみた","link":"/posts/android_background_location_play_console/","markdown":"\r\nどうもこんにちは。  \r\n`NewRadioSupporter` の更新を配信しようとした時の話。\r\n\r\n# リリースしようとしたら\r\n**バックグラウンドで位置情報を取得する権限**を使う場合は、追加で申告をしないといけないらしい。  \r\nまぁそこそこ危険な権限だよな。。。\r\n\r\n![Imgur](https://imgur.com/G8z5jtf.png)\r\n\r\nどうやらバックグラウンド状態で位置情報にアクセスするには、アプリの審査で追加の申告をしないといけないらしい。のでメモ\r\n\r\n![Imgur](https://imgur.com/y02GXIf.png)\r\n\r\n## 文字で書く部分\r\nアプリが何なのか、とバックグラウンドで位置情報を取得する機能が何なのかを書きます。\r\n\r\n![Imgur](https://imgur.com/zL781Yc.png)\r\n\r\n![Imgur](https://imgur.com/3pxyDeD.png)\r\n\r\n## 動画\r\n\r\n使い方を表す**動画**を提出する必要がある模様。\r\n\r\nhttps://support.google.com/googleplay/android-developer/answer/9799150?hl=ja#Video%20demonstration\r\n\r\n`動画の中で機能やその影響～` ← なんか動画の中に説明も入れろ、みたいな言い方をしてるので、  \r\nバックグラウンド位置情報取得をする流れを画面録画をした上で、`AviUtl`で文字を入れて適当に作りました。~~数年前はよくニコニコ動画に投稿してたので動画作る環境はあるっちゃある~~\r\n\r\n![Imgur](https://imgur.com/FIQYmyT.png)\r\n\r\n`YouTube`に上げるのを推奨しているらしいのでそうした。別に`Google Drive`の共有でも良いらしい。  \r\n限定公開なので動画説明欄とかは適当でいいはず。\r\n\r\n![Imgur](https://imgur.com/DzcMGZv.png)\r\n\r\n限定公開で公開して  \r\n\r\n![Imgur](https://imgur.com/UdAfwq0.png)\r\n\r\nPlayConsole へ戻り申告フォームに URL を貼ります。\r\n\r\n![Imgur](https://imgur.com/ZARjWfy.png)\r\n\r\n## プライバシーポリシー\r\n元々ありましたが、プライバシーポリシーもこれに合わせて更新しました。  \r\nアプリ内からも飛べるようにしました。\r\n\r\nhttps://github.com/takusan23/NewRadioSupporter/blob/master/PRIVACY_POLICY.md\r\n\r\nもしかすると、`GitHub`のリポジトリ内にある`Markdown`だとリジェクトされるかも（後述します）\r\n\r\n# 審査出しする・・・！\r\nおねがいします\r\n\r\n![Imgur](https://imgur.com/2cdTKvC.png)\r\n\r\n## リジェクトされる 1回目\r\n\r\n![Imgur](https://imgur.com/86QiK36.png)\r\n\r\nプライバシーポリシーが甘いと判断されたらしい。`収集する項目 / 利用目的 / 共有の有無`をそれぞれ書きました。  \r\nあとプライバシーポリシーにアプリの名前をちゃんと書くようにした。  \r\n\r\n再提出～\r\n\r\n## リジェクトされる 2回目\r\n\r\n![Imgur](https://imgur.com/Mn3J415.png)\r\n\r\n<p style=\"color:red;font-size:40px\">？？？？？？？？</p>\r\n\r\nえ？`URL` 変えてないんですけど、1回目は見れたのに2回目は見れなくなっちゃったんですか？  \r\n`GitHub`のリポジトリ内にある`Markdown`へのリンクをプライバシーポリシーの`URL`として使ってたんですけど、もしかして`GitHub`のリポジトリじゃだめなの？  \r\n仕方ないので自分のドメインのこのサイトに書きました。それなら1回目でリンクが無効って言ってほしかった。。。\r\n\r\nいや～でもいままで`リポジトリにある Markdown`へのパスをプライバシーポリシーに使ったんだけど、なんで今回だけダメだったんだろう。  \r\n異議申し立てしても良かったかもだけど、早く配信したかったから飲むことにした。\r\n\r\n## とおりました\r\n\r\n![Imgur](https://imgur.com/8mVv36Y.png)\r\n\r\n# これ書いてる時に気付いた\r\n`フォアグラウンドサービス`で利用する場合、`AndroidManifest`で`<service>`の`foregroundServiceType`属性を`location`にすることで、アプリがフォアグラウンド（外アプリ利用中）でなくても位置情報が取得できるはずです。  \r\n\r\n試してないけど、フォアグラウンドサービスなら通知が出るからユーザー気付くでしょ！バックグラウンド位置情報取得権限は要らないよ！的な事が書いてある→ https://developer.android.com/training/location/permissions#foreground\r\n\r\n```xml\r\n<service\r\n    android:name=\".BackgroundLocationService\"\r\n    android:enabled=\"true\"\r\n    android:exported=\"false\"\r\n    android:foregroundServiceType=\"location\">\r\n</service>\r\n```\r\n\r\n```kotlin\r\nclass BackgroundLocationService : Service() {\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n\r\n        val notification = // 通知を作る\r\n        ServiceCompat.startForeground(this, NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION) // location\r\n\r\n    }\r\n}\r\n```\r\n\r\nあれ？じゃあバックグラウンド位置情報取得の権限要らない？と思ったんですけど、**このアプリは 5G 回線チェッカーなので、`foregroundServiceType=\"location\"`で良いのかが微妙で**、結局この方法も使えなさそう。\r\n\r\n- https://developer.android.com/about/versions/14/changes/fgs-types-required#location\r\n- https://developer.android.com/reference/android/R.attr#foregroundServiceType\r\n\r\n`WorkManager`で動かしたいとかがあれば、やっぱりこの権限が必要かも？\r\n\r\n# おわりに1\r\n電波状態にアクセスするために、位置情報の権限が必要なんですけど、これは何故かというと、  \r\n`CID`や`PCI`の値が、基地局？に対して一意の値（他と被らない、ユニークな値）らしい？？？から、おおよその位置が分かるかららしい。はえ～  \r\n\r\n# おわりに2\r\n\r\n`バックグラウンド 5G 通知機能`の修正のついでに。  \r\n`WearOS`側に通知が行くようにしました。デフォルトだと通知はサイレントなので、デフォルトにしないといけないかもしれない。\r\n\r\n![Imgur](https://imgur.com/knYSsYl.png)\r\n\r\nちなみに、フォアグラウンドサービス起動中通知が、別で出るようになってしまったのですが、これは通知チャンネルの設定から個別に消せるようにしてあります。  \r\n実行中の方をオフにしても電波状態の通知は来るようになります。\r\n\r\n![Imgur](https://imgur.com/aliGiWC.png)\r\n\r\nちなみに今までなんで来なかったかというと、フォアグラウンドサービスの起動には通知を出さないといけないのですが、この通知に電波状態を表示させてたからでした。  \r\nこの通知、サービスが動いている間は消せないんですよね。  \r\nそして、消せない通知は`WearOS`側に転送されないんですよね。  \r\n\r\nhttps://developer.android.com/training/wearables/notifications/bridger#non-bridged\r\n\r\nなので、サービス起動中通知とは別に、電波状態の通知を出すようにしてみました。電波状態の方は消せるので、`WearOS`にも出るようになりました。"},{"title":"BottomSheetDialogFragmentとかDialogでComposeViewが使えない","link":"/posts/android_bottom_fragment_use_compose_view/","markdown":"\r\n~~`alpha 12`から直ってない~~  \r\n `beta02`で修正されました。更新手順は、  \r\n`app/build.gradle`のKotlinバージョン、Composeのバージョンを以下のように変更し、\r\n\r\n```gradle\r\n// Compose関係\r\ncomposeOptions {\r\n    kotlinCompilerVersion '1.4.31'\r\n    kotlinCompilerExtensionVersion '1.0.0-beta02'\r\n}\r\n```\r\n\r\nComposeのバージョンを上げて、  \r\n`Fragment`、`AppCompat`のバージョンを`1.3`以上にすればこの問題は修正できます。\r\n\r\n```gradle\r\ndependencies {\r\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n\r\n    implementation \"androidx.compose.ui:ui:1.0.0-beta02\"\r\n    // Tooling support (Previews, etc.)\r\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\r\n    // Foundation (Border, Background, Box, Image, Scroll, shapes, animations, etc.)\r\n    implementation \"androidx.compose.foundation:foundation:1.0.0-beta02\"\r\n    // Material Design\r\n    implementation \"androidx.compose.material:material:1.0.0-beta02\"\r\n    // Integration with observables\r\n    implementation \"androidx.compose.runtime:runtime-livedata:1.0.0-beta02\"\r\n    // LayoutInspector\r\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta02\"\r\n\r\n    // fragment\r\n    implementation 'androidx.fragment:fragment-ktx:1.3.1'\r\n\r\n    // appcompat\r\n    implementation 'androidx.appcompat:appcompat:1.3.0-beta01'\r\n\r\n}\r\n```\r\n\r\n# 本題\r\n`BottomSheetDialogFragment`の`onCreateView`の返り値として`ComposeView()`を使うとエラーが出る問題\r\n\r\n```java\r\njava.lang.IllegalStateException: ViewTreeLifecycleOwner not found from DecorView@b98b3fc[MainActivity]\r\n```\r\n\r\n# 環境\r\n\r\n| name    | value        |\r\n|---------|--------------|\r\n| Compose | 1.0.0 Beta 1 |\r\n\r\n## なんで？\r\n`ViewTreeLifecycleOwner`っていう`View`から`Activity/Fragment`のライフライクルを取得できるやつがあるんですけど、  \r\n親Viewを指定して`ViewTreeLifecycleOwner.get()`を呼ぶとなぜかnullが返ってくる\r\n\r\n# 解決方法\r\nお好きな方をどうぞ\r\n- `ViewTreeLifecycleOwner`(と`Recomposer`)を指定する\r\n- `androidx.fragment`をスナップショット版にする\r\n\r\n## `ViewTreeLifecycleOwner`を指定する\r\n\r\n`Compose`で使ってる`Recomposer`を作るのに`ViewTreeLifecycleOwner`が必要だった模様。  \r\nというわけで`Recomposer`を作って渡してあげる必要があります\r\n\r\n`ViewTreeLifecycleOwner.set()`の第二引数は`Activity`の場合は`Activity`を（this）、  \r\n`Fragment`の場合は`viewLifecycleOwner`を渡してあげてください\r\n\r\n```kotlin\r\nclass BottomFragmentCompose : BottomSheetDialogFragment() {\r\n\r\n    @InternalComposeUiApi\r\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\r\n        return ComposeView(requireContext()).apply {\r\n\r\n            ViewTreeLifecycleOwner.set(this, viewLifecycleOwner)\r\n            val newRecomposer = AtomicReference(WindowRecomposerFactory.LifecycleAware).get().createRecomposer(rootView)\r\n            compositionContext = newRecomposer\r\n\r\n            setContent {\r\n                Text(\r\n                    text = \"BottomSheetDialogFragment + ComposeView\",\r\n                    modifier = Modifier.padding(10.dp)\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n`Dialog`で`ComposeView`を使う場合は`ViewTreeSavedStateRegistryOwner`の指定も必要かも\r\n\r\n```kotlin\r\n@InternalComposeUiApi\r\nprivate fun showDialog() {\r\n    Dialog(this).apply {\r\n        setContentView(ComposeView(context).apply {\r\n            ViewTreeLifecycleOwner.set(this, this@MainActivity)\r\n            ViewTreeSavedStateRegistryOwner.set(this, this@MainActivity)\r\n            val newRecomposer = AtomicReference(WindowRecomposerFactory.LifecycleAware).get().createRecomposer(this)\r\n            compositionContext = newRecomposer\r\n            setContent {\r\n                Text(\r\n                    text = \"Dialog + ComposeView\",\r\n                    modifier = Modifier.padding(10.dp)\r\n                )\r\n            }\r\n        })\r\n    }.show()\r\n}\r\n```\r\n\r\n## Fragmentをスナップショット版にする\r\nついさっき知ったんですけど、`build.gradle`から`allprojects`が消滅してた。(gradleが6.8になった影響？)  \r\n代替として、`settings.gradle`に`dependencyResolutionManagement`が追加された模様  \r\n\r\n\r\n### allprojectがある場合\r\n\r\n```gradle\r\nallprojects {\r\n    repositories {\r\n        google()\r\n        jcenter()\r\n        maven { url 'https://androidx.dev/snapshots/builds/7172350/artifacts/repository' } // これを書き足す\r\n    }\r\n}\r\n```\r\n\r\nあとは`app`フォルダにある`build.gradle`を開いて、`androidx.fragment`をアップデートします\r\n\r\n```gradle\r\ndependencies {\r\n    implementation \"androidx.fragment:fragment:1.4.0-SNAPSHOT\"\r\n}\r\n```\r\n\r\n### dependencyResolutionManagementの場合\r\n`settings.gradle`を開いて書き足す\r\n\r\n```gradle\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n        jcenter() // Warning: this repository is going to shut down soon\r\n        maven { url 'https://androidx.dev/snapshots/builds/7172350/artifacts/repository' }\r\n    }\r\n}\r\n```\r\n\r\nあとは`app`フォルダにある`build.gradle`を開いて、`androidx.fragment`をアップデートします\r\n\r\n```gradle\r\ndependencies {\r\n    implementation \"androidx.fragment:fragment:1.4.0-SNAPSHOT\"\r\n}\r\n```\r\n\r\n# おわりに\r\ndependencyResolutionManagement ってなに  \r\n\r\nあとソースコード置いておきます  \r\n\r\nhttps://github.com/takusan23/BottomFragmentComposeView\r\n\r\n# 参考にしました\r\nhttps://issuetracker.google.com/issues/180691023"},{"title":"Androidアプリのビルドした日付をアプリ側から取得できるようにする","link":"/posts/android_build_date_resource/","markdown":"どうもこんばんわ。  \r\n2月といえば次期Androidのデベロッパープレビューですよねって感じだけど、Android 12Lがある中果たしてリリースされるのか（？）\r\n\r\n# 本題\r\nAndroidアプリのビルドしたときの日付をアプリ側から表示できるようにできるらしい。  \r\n(build.gradle で `Context#getString` から参照可能なリソースを作成できるみたい)\r\n\r\n## 公式\r\n\r\nhttps://developer.android.com/studio/build/gradle-tips?hl=ja#share-custom-fields-and-resource-values-with-your-app-code\r\n\r\n## 環境\r\n\r\n| なまえ         | あたい                   |\r\n|----------------|--------------------------|\r\n| Android        | 12                       |\r\n| Android Studio | Android Studio Bumblebee |\r\n\r\n# build.gradle\r\n`app`フォルダの方の`build.gradle`を開いて、こう書きます。\r\n\r\n```java\r\nandroid {\r\n    compileSdk 31\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.androidbuilddateresource\"\r\n        minSdk 21\r\n        targetSdk 31\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        // ビルド日時を Context#getString で参照できるようにする\r\n        resValue(\"string\", \"build_date\", System.currentTimeMillis().toString())\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    // 省略...\r\n```\r\n\r\nあとは `R.string.build_date` で参照できます。 \r\nUnixTimeを日付フォーマットに変更してTextViewなんかに入れれば完成。  \r\n一度ビルドするまで<span style=\"color:red\">赤いまんま</span>かもしれないです。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val textView by lazy { findViewById<TextView>(R.id.activity_main_textview) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        // ビルド日時\r\n        val buildDate = getString(R.string.build_date).toLong()\r\n        // 日付をフォーマットする\r\n        val simpleDateFormat = SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\", Locale.getDefault())\r\n        val formatDate = simpleDateFormat.format(buildDate)\r\n        // TextViewへ\r\n        textView.text = formatDate\r\n    }\r\n}\r\n```\r\n\r\n以上です。\r\n\r\n![Imgur](https://imgur.com/yJffXni.png)\r\n\r\n### おまけ\r\n\r\n`build.gradle.kts`の場合もほとんど同じです。\r\n\r\n```kotlin\r\nandroid {\r\n    compileSdk = 31\r\n\r\n    defaultConfig {\r\n        applicationId = \"io.github.takusan23.androidbuilddateresource\"\r\n        minSdk = 21\r\n        targetSdk = 31\r\n        versionCode = 1\r\n        versionName = \"1.0\"\r\n\r\n        // ヒルド日時を Context#getString で参照可能にする\r\n        resValue(\"string\", \"build_date\", System.currentTimeMillis().toString())\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    // 省略...\r\n```"},{"title":"AndroidでCanvasから動画を作る","link":"/posts/android_canvas_to_video/","markdown":"どうもこんばんわ。\r\nD.C.5 攻略しました（ぜんねんれい作品）  \r\n全年齢だけど結構攻めたイベントCGが多かった気がする（こんなもんなんですかね  \r\n\r\n(顔つきが大人っぽくなりましたね..!)\r\n\r\n![Imgur](https://imgur.com/pxfMlhZ.png)\r\n\r\n今回の主人公、白河灯莉ちゃん以外のヒロインが同じ家にいるだと\r\n\r\n灯莉ちゃん√がめっちゃ可愛かったのでおすすめです。\r\n(自前のスクショをとるアプリの調子がわるく普通に写り込んでますが気にせず...)\r\n\r\n![Imgur](https://imgur.com/GNSMgxB.png)\r\n\r\nかわいい\r\n\r\n![Imgur](https://imgur.com/6Bldigw.png)\r\n\r\nここのお話がお気に入りです\r\n\r\n![Imgur](https://imgur.com/9ZdJGh7.png)\r\n\r\n![Imgur](https://imgur.com/UCNiB3v.png)\r\n\r\nあと個別ルートで愛乃亜ちゃんかわいいくなっていくのでぜひ。いいなあ...\r\n\r\n![Imgur](https://imgur.com/Phon90s.png)\r\n\r\n![Imgur](https://imgur.com/iNsB5sW.png)\r\n\r\nD.C.4 をやってなくても楽しめると思うのでぜひ！\r\n\r\n![Imgur](https://imgur.com/QlX9XGN.png)\r\n\r\nいくつか謎が残っていますがFDとか6とかで明かされるのでしょうか、楽しみです！  \r\n(瑞花verのめぐり逢えたね、単品でほしい)\r\n\r\n# 本題\r\n少し前に動画の上にCanvasで落書きするような記事を書きましたが、今回はそもそもCanvasから動画を作ってみようの話です。  \r\nスライドショーっぽい動画を作るアプリが作れるかも？\r\n\r\n## 環境\r\n\r\n| なまえ  | あたい       |\r\n|---------|--------------|\r\n| 端末    | Xperia Pro-I |\r\n| Android | 13           |\r\n| 言語    | Kotlin       |\r\n\r\n`OpenGL` を使いますが使わない方法もあります。  \r\nあと`Jetpack Compose`を使いますが別に使わなくても良いです。\r\n\r\n## めんどうなんだけど\r\n最新バージョンは↓から、すでに今回やったことは MavenCentral にあるので、、、  \r\n![Maven Central](https://img.shields.io/maven-central/v/io.github.takusan23/akaricore)\r\n\r\n```kotlin\r\nimplementation(\"io.github.takusan23:akaricore:1.0.0-alpha03\")\r\n```\r\n\r\nあとはいい感じに乗っかれば作れるはず\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        canvasToVideoProcessorStart()\r\n    }\r\n\r\n    private fun canvasToVideoProcessorStart() {\r\n        lifecycleScope.launch {\r\n            // 保存先\r\n            val resultFile = getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\") ?: return@launch\r\n            // エンコーダー\r\n            val videoWidth = 1280\r\n            val videoHeight = 720\r\n\r\n            val outlinePaint = Paint().apply {\r\n                color = Color.BLACK\r\n                style = Paint.Style.STROKE\r\n                textSize = 80f\r\n            }\r\n            val innerPaint = Paint().apply {\r\n                style = Paint.Style.FILL\r\n                color = Color.WHITE\r\n                textSize = 80f\r\n            }\r\n            val logoBitmap = ContextCompat.getDrawable(this@MainActivity, R.drawable.ic_launcher_foreground)?.apply {\r\n                setTint(Color.WHITE)\r\n            }?.toBitmap(300, 300)!!\r\n\r\n            // Canvas にかく\r\n            // 処理が終わるまで一時停止する\r\n            CanvasProcessor.start(\r\n                resultFile = resultFile, // エンコード後の動画ファイル\r\n                outputVideoWidth = videoWidth,\r\n                outputVideoHeight = videoHeight\r\n            ) { positionMs ->\r\n                // 適当に文字を書く\r\n                val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n                // 枠取り文字\r\n                drawText(text, 0f, 80f, outlinePaint)\r\n                // 枠無し文字\r\n                drawText(text, 0f, 80f, innerPaint)\r\n                // 画像も表示する\r\n                drawBitmap(logoBitmap, (videoWidth - logoBitmap.width).toFloat(), (videoHeight - logoBitmap.height).toFloat(), innerPaint)\r\n                positionMs < 10_000\r\n            }\r\n\r\n            // 音声の追加など\r\n            // MediaStore を使って ギャラリーに追加するとか\r\n            Toast.makeText(this@MainActivity, \"終了しました\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n# MediaCodecシリーズ\r\n\r\n- [動画をつなげる](/posts/android_mediacodec_merge_video/)\r\n- [なんちゃってライブ配信をする](/posts/android_standalone_webm_livestreaming/)\r\n- [動画の上に文字を重ねる](/posts/android_add_canvas_text_to_video/)\r\n    - 今回の記事はこれの続きみたいなところがあります\r\n\r\n# Android で Canvas から動画を作るには\r\n`MediaCodec`と`OpenGL`を使うか、難しいのを無しにして`MediaRecorder`と`Surface#lockHardwareCanvas`を使う方法があると思います。  \r\n\r\n## MediaCodec + OpenGL\r\n- MediaCodec / MediaMuxer の用意をする\r\n- MediaCodec の Surface に OpenGL で描画する\r\n    - Surface と OpenGL の橋渡しをするためのコードは書かないといけない（AOSPそのまま）\r\n- Canvas で書いて、Bitmapにして、テクスチャとして描画します。\r\n    - OpenGL のシェーダーもAOSPから借りてくることにします（ならお前は何をするんだ）\r\n- MediaCodec から出てきたエンコード済みデータを MediaMuxer を使い `mp4` （コンテナフォーマット）に格納する\r\n\r\n`OpenGL`の用意と、シェーダーを書かないといけない（ただコピペできる）ので、普通に難しい。  \r\nあとやっぱり低レベルAPIなので、`MediaRecorder`では出てこない`コーデック やら コンテナ やら`と向き合わないといけない。  \r\nが、**おそらく正規ルート感はある**。（後者は動かない端末があるらしい）\r\n\r\n## 難しいのを無しにして MediaRecorder + Surface#lockHardwareCanvas を使う\r\nというか `OpenGL` の代わりに `lockHardwareCanvas` を使う方法もあります。Android 6 以上なので、まぁ選んでも良いでしょう\r\n\r\n- MediaRecorder を初期化する\r\n- MediaRecorder の Surface を取得する\r\n- Surface にある `lockHardwareCanvas` 関数を呼ぶと `Canvas` が貰えるので、よしなに書く\r\n- `unlockCanvasAndPost` の引数に `Canvas` を入れる\r\n\r\n高レベルAPIで保守しやすそう！！！  \r\n`lockHardwareCanvas`を使わないといけないです（ハードウェアアクセラレーションされていないとだめ）  \r\nまた、一部の端末ではこの方法が使えないらしい（以下の `Issue` 参照、多分 `OpenGL` を使うしかなさそう？）  \r\nhttps://issuetracker.google.com/issues/111433520\r\n\r\n# 作ってみる\r\n`Android Studio` 更新したら `Empty Activity` が `JetpackCompose` になってる、、  \r\n適当なプロジェクトを作ってください。\r\n\r\n# MediaCodec + OpenGL を使う方法\r\n- `MediaCodec`\r\n    - エンコード / デコード するためのクラス\r\n    - H.264 / H.265 とかにエンコードできる\r\n        - パラパラ漫画にするよりも動画にするほうが容量が小さいのはコーデックが圧縮してくれているから\r\n    - エラーメッセージが役に立たない\r\n- `MediaMuxer`\r\n    - コンテナフォーマットへ保存するためのクラス\r\n        - コンテナフォーマットは音声と映像を一つのファイルにするための技術（`mp4`など）\r\n    - `MediaCodec`から出てきたエンコード済みデータを`mp4 (webM とかでも可)`に格納する\r\n        - 音声も追加したい場合はコンテナに入れる\r\n    - `addTrack`は スタート前に呼ぶ必要がある\r\n\r\n## CanvasInputSurface\r\nAOSP の以下のコードそのままです（多分 GLSurfaceView の内部でやっていること）  \r\nhttps://cs.android.com/android/platform/superproject/+/master:cts/tests/tests/media/common/src/android/media/cts/InputSurface.java\r\n\r\n↑ の Kotlin化 と若干の修正が入っているだけです。  \r\n\r\nこれは`エンコーダー MediaCodec`の入力に`OpenGL`を使えるようにするためのクラスです。わかりません。\r\n\r\n```kotlin\r\n/** MediaCodec の Surface と OpenGL の橋渡しをする */\r\nclass CanvasInputSurface(\r\n    private val surface: Surface,\r\n    private val textureRenderer: TextureRenderer,\r\n) {\r\n    private var mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n    private var mEGLContext = EGL14.EGL_NO_CONTEXT\r\n    private var mEGLSurface = EGL14.EGL_NO_SURFACE\r\n\r\n    init {\r\n        eglSetup()\r\n    }\r\n\r\n    fun createRender() {\r\n        textureRenderer.surfaceCreated()\r\n    }\r\n\r\n    /**\r\n     * Prepares EGL.  We want a GLES 2.0 context and a surface that supports recording.\r\n     */\r\n    private fun eglSetup() {\r\n        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)\r\n        if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n            throw RuntimeException(\"unable to get EGL14 display\")\r\n        }\r\n        val version = IntArray(2)\r\n        if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n            throw RuntimeException(\"unable to initialize EGL14\")\r\n        }\r\n        // Configure EGL for recording and OpenGL ES 2.0.\r\n        val attribList = intArrayOf(\r\n            EGL14.EGL_RED_SIZE, 8,\r\n            EGL14.EGL_GREEN_SIZE, 8,\r\n            EGL14.EGL_BLUE_SIZE, 8,\r\n            EGL14.EGL_ALPHA_SIZE, 8,\r\n            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\r\n            EGL_RECORDABLE_ANDROID, 1,\r\n            EGL14.EGL_NONE\r\n        )\r\n        val configs = arrayOfNulls<EGLConfig>(1)\r\n        val numConfigs = IntArray(1)\r\n        EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.size, numConfigs, 0)\r\n        checkEglError(\"eglCreateContext RGB888+recordable ES2\")\r\n\r\n        // Configure context for OpenGL ES 2.0.\r\n        val attrib_list = intArrayOf(\r\n            EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLContext = EGL14.eglCreateContext(\r\n            mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT,\r\n            attrib_list, 0\r\n        )\r\n        checkEglError(\"eglCreateContext\")\r\n\r\n        // Create a window surface, and attach it to the Surface we received.\r\n        val surfaceAttribs = intArrayOf(\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], surface, surfaceAttribs, 0)\r\n        checkEglError(\"eglCreateWindowSurface\")\r\n    }\r\n\r\n    /**\r\n     * Canvasに描画してOpenGLに描画する\r\n     *\r\n     * @param onCanvasDrawRequest Canvasを渡すので描画して返してください\r\n     */\r\n    fun drawCanvas(onCanvasDrawRequest: (Canvas) -> Unit) {\r\n        textureRenderer.prepareDraw()\r\n        textureRenderer.drawCanvas(onCanvasDrawRequest)\r\n        textureRenderer.invokeGlFinish()\r\n    }\r\n\r\n    /**\r\n     * Discards all resources held by this class, notably the EGL context.  Also releases the\r\n     * Surface that was passed to our constructor.\r\n     */\r\n    fun release() {\r\n        if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n            EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT)\r\n            EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface)\r\n            EGL14.eglDestroyContext(mEGLDisplay, mEGLContext)\r\n            EGL14.eglReleaseThread()\r\n            EGL14.eglTerminate(mEGLDisplay)\r\n        }\r\n        surface.release()\r\n        mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n        mEGLContext = EGL14.EGL_NO_CONTEXT\r\n        mEGLSurface = EGL14.EGL_NO_SURFACE\r\n    }\r\n\r\n    /**\r\n     * Makes our EGL context and surface current.\r\n     */\r\n    fun makeCurrent() {\r\n        EGL14.eglMakeCurrent(mEGLDisplay, mEGLSurface, mEGLSurface, mEGLContext)\r\n        checkEglError(\"eglMakeCurrent\")\r\n    }\r\n\r\n    /**\r\n     * Calls eglSwapBuffers.  Use this to \"publish\" the current frame.\r\n     */\r\n    fun swapBuffers(): Boolean {\r\n        val result = EGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface)\r\n        checkEglError(\"eglSwapBuffers\")\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Sends the presentation time stamp to EGL.  Time is expressed in nanoseconds.\r\n     */\r\n    fun setPresentationTime(nsecs: Long) {\r\n        EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs)\r\n        checkEglError(\"eglPresentationTimeANDROID\")\r\n    }\r\n\r\n    /**\r\n     * Checks for EGL errors.  Throws an exception if one is found.\r\n     */\r\n    private fun checkEglError(msg: String) {\r\n        val error = EGL14.eglGetError()\r\n        if (error != EGL14.EGL_SUCCESS) {\r\n            throw RuntimeException(\"$msg: EGL error: 0x${Integer.toHexString(error)}\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val EGL_RECORDABLE_ANDROID = 0x3142\r\n    }\r\n}\r\n```\r\n\r\n## TextureRenderer\r\n`OpenGL`で`Canvas`を`Bitmap`にしてテクスチャとして描画するためのクラス。  \r\n`OpenGL`、、何もわからん（アルファブレンド設定が有効だと真っ暗な映像が出来た...）\r\n\r\n```kotlin\r\n/**\r\n * Canvas の内容を OpenGL で描画するため\r\n *\r\n * @param outputVideoWidth 動画の幅\r\n * @param outputVideoHeight 動画の高さ\r\n */\r\nclass TextureRenderer(\r\n    private val outputVideoWidth: Int,\r\n    private val outputVideoHeight: Int,\r\n) {\r\n\r\n    private var mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.size * FLOAT_SIZE_BYTES).run {\r\n        order(ByteOrder.nativeOrder())\r\n        asFloatBuffer().apply {\r\n            put(mTriangleVerticesData)\r\n            position(0)\r\n        }\r\n    }\r\n\r\n    private val mMVPMatrix = FloatArray(16)\r\n    private val mSTMatrix = FloatArray(16)\r\n\r\n    /** Canvasで書いたBitmap。Canvasの内容をOpenGLのテクスチャとして利用 */\r\n    private val canvasBitmap by lazy { Bitmap.createBitmap(outputVideoWidth, outputVideoHeight, Bitmap.Config.ARGB_8888) }\r\n\r\n    /** Canvas。これがエンコーダーに行く */\r\n    private val canvas by lazy { Canvas(canvasBitmap) }\r\n\r\n    // ハンドルたち\r\n    private var mProgram = 0\r\n    private var muMVPMatrixHandle = 0\r\n    private var muSTMatrixHandle = 0\r\n    private var maPositionHandle = 0\r\n    private var maTextureHandle = 0\r\n    private var uCanvasTextureHandle = 0\r\n\r\n    /** キャンバスの画像を渡すOpenGLのテクスチャID */\r\n    private var canvasTextureID = -1\r\n\r\n    init {\r\n        Matrix.setIdentityM(mSTMatrix, 0)\r\n    }\r\n\r\n    /** 描画前に呼び出す */\r\n    fun prepareDraw() {\r\n        // glError 1282 の原因とかになる\r\n        GLES20.glUseProgram(mProgram)\r\n        checkGlError(\"glUseProgram\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n\r\n        // Snapdragon だと glClear が無いと映像が乱れる\r\n        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT or GLES20.GL_COLOR_BUFFER_BIT)\r\n    }\r\n\r\n    /**\r\n     * Canvas に書いて OpenGL で描画する。\r\n     * [drawFrame]のあとに呼び出す必要あり。\r\n     *\r\n     * @param onCanvasDrawRequest Canvasを渡すので描画して返してください\r\n     */\r\n    fun drawCanvas(onCanvasDrawRequest: (Canvas) -> Unit) {\r\n        checkGlError(\"drawCanvas start\")\r\n        // コンテキストをCanvasのテクスチャIDに切り替える\r\n        // テクスチャ設定\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, canvasTextureID)\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)\r\n        // 前回のを消す\r\n        canvas.drawColor(0, PorterDuff.Mode.CLEAR)\r\n        // Canvasで書く\r\n        onCanvasDrawRequest(canvas)\r\n        // glActiveTexture したテクスチャへCanvasで書いた画像を転送する\r\n        // 更新なので texSubImage2D\r\n        GLUtils.texSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, canvasBitmap)\r\n        checkGlError(\"GLUtils.texSubImage2D canvasTextureID\")\r\n        // Uniform 変数へテクスチャを設定\r\n        // 第二引数は GLES20.GL_TEXTURE0 なので 0\r\n        GLES20.glUniform1i(uCanvasTextureHandle, 0)\r\n        checkGlError(\"glUniform1i uCanvasTextureHandle\")\r\n        // アスペクト比の調整はいらないのでリセット（エンコーダーの出力サイズにCanvasを合わせて作っているため）\r\n        Matrix.setIdentityM(mMVPMatrix, 0)\r\n        // それとは別に、OpenGLの画像は原点が左下なので（普通は左上）、行列を反転させる\r\n        // すいませんよくわかりません。\r\n        Matrix.setIdentityM(mSTMatrix, 0)\r\n        Matrix.scaleM(mSTMatrix, 0, 1f, -1f, 1f)\r\n        // 描画する\r\n        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0)\r\n        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0)\r\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)\r\n        checkGlError(\"glDrawArrays Canvas\")\r\n    }\r\n\r\n    /** glFinish をよびだす */\r\n    fun invokeGlFinish() {\r\n        GLES20.glFinish()\r\n    }\r\n\r\n    fun surfaceCreated() {\r\n        mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER)\r\n        if (mProgram == 0) {\r\n            throw RuntimeException(\"failed creating program\")\r\n        }\r\n        maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\")\r\n        checkGlError(\"glGetAttribLocation aPosition\")\r\n        if (maPositionHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aPosition\")\r\n        }\r\n        maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\")\r\n        checkGlError(\"glGetAttribLocation aTextureCoord\")\r\n        if (maTextureHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aTextureCoord\")\r\n        }\r\n        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\")\r\n        checkGlError(\"glGetUniformLocation uMVPMatrix\")\r\n        if (muMVPMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uMVPMatrix\")\r\n        }\r\n        muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\")\r\n        checkGlError(\"glGetUniformLocation uSTMatrix\")\r\n        if (muSTMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uSTMatrix\")\r\n        }\r\n        uCanvasTextureHandle = GLES20.glGetUniformLocation(mProgram, \"uCanvasTexture\")\r\n\r\n        // Canvas のテクスチャID を払い出してもらう\r\n        val textures = IntArray(1)\r\n        GLES20.glGenTextures(1, textures, 0)\r\n\r\n        // Canvasテクスチャ\r\n        canvasTextureID = textures[0]\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, canvasTextureID)\r\n        checkGlError(\"glBindTexture canvasTextureID\")\r\n\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)\r\n\r\n        // テクスチャを初期化\r\n        // 更新の際はコンテキストを切り替えた上で texSubImage2D を使う\r\n        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, canvasBitmap, 0)\r\n        checkGlError(\"glTexParameter canvasTextureID\")\r\n    }\r\n\r\n    private fun loadShader(shaderType: Int, source: String): Int {\r\n        var shader = GLES20.glCreateShader(shaderType)\r\n        checkGlError(\"glCreateShader type=$shaderType\")\r\n        GLES20.glShaderSource(shader, source)\r\n        GLES20.glCompileShader(shader)\r\n        val compiled = IntArray(1)\r\n        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0)\r\n        if (compiled[0] == 0) {\r\n            GLES20.glDeleteShader(shader)\r\n            shader = 0\r\n        }\r\n        return shader\r\n    }\r\n\r\n    private fun createProgram(vertexSource: String, fragmentSource: String): Int {\r\n        val vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource)\r\n        if (vertexShader == 0) {\r\n            return 0\r\n        }\r\n        val pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource)\r\n        if (pixelShader == 0) {\r\n            return 0\r\n        }\r\n        var program = GLES20.glCreateProgram()\r\n        checkGlError(\"glCreateProgram\")\r\n        if (program == 0) {\r\n            return 0\r\n        }\r\n        GLES20.glAttachShader(program, vertexShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glAttachShader(program, pixelShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glLinkProgram(program)\r\n        val linkStatus = IntArray(1)\r\n        GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0)\r\n        if (linkStatus[0] != GLES20.GL_TRUE) {\r\n            GLES20.glDeleteProgram(program)\r\n            program = 0\r\n        }\r\n        return program\r\n    }\r\n\r\n    private fun checkGlError(op: String) {\r\n        val error = GLES20.glGetError()\r\n        if (error != GLES20.GL_NO_ERROR) {\r\n            throw RuntimeException(\"$op: glError $error\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        private val mTriangleVerticesData = floatArrayOf(\r\n            -1.0f, -1.0f, 0f, 0f, 0f,\r\n            1.0f, -1.0f, 0f, 1f, 0f,\r\n            -1.0f, 1.0f, 0f, 0f, 1f,\r\n            1.0f, 1.0f, 0f, 1f, 1f\r\n        )\r\n\r\n        private const val FLOAT_SIZE_BYTES = 4\r\n        private const val TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES\r\n        private const val TRIANGLE_VERTICES_DATA_POS_OFFSET = 0\r\n        private const val TRIANGLE_VERTICES_DATA_UV_OFFSET = 3\r\n\r\n        /** バーテックスシェーダー。座標などを決める */\r\n        private const val VERTEX_SHADER = \"\"\"\r\n            uniform mat4 uMVPMatrix;\r\n            uniform mat4 uSTMatrix;\r\n            attribute vec4 aPosition;\r\n            attribute vec4 aTextureCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            void main() {\r\n              gl_Position = uMVPMatrix * aPosition;\r\n              vTextureCoord = (uSTMatrix * aTextureCoord).xy;\r\n            }\r\n        \"\"\"\r\n\r\n        /** フラグメントシェーダー。実際の色を返す */\r\n        private const val FRAGMENT_SHADER = \"\"\"\r\n            #extension GL_OES_EGL_image_external : require\r\n\r\n            precision mediump float;\r\n            varying vec2 vTextureCoord;\r\n            uniform sampler2D uCanvasTexture;\r\n        \r\n            void main() {\r\n                gl_FragColor = texture2D(uCanvasTexture, vTextureCoord);\r\n            }\r\n        \"\"\"\r\n    }\r\n}\r\n```\r\n\r\n## CanvasProcessor\r\nこれが`Canvas`から動画にするためのクラスですね。  \r\n記事冒頭に書いたライブラリと同じやつです。  \r\n\r\n- エンコーダー（`MediaCodec`）を用意\r\n- `OpenGL`の用意\r\n- エンコーダーを開始し\r\n- 終わるまで以下の作業をループ\r\n    - エンコーダーからエンコードしたデータがあれば取り出す\r\n        - `MediaMuxer`に入れてコンテナフォーマットに格納\r\n            - `MediaMuxer`に始めていれる場合は`addTrack`する（おそらくエンコードしたデータよりも先に呼ばれる）\r\n    - `Canvas` に好きなように描く\r\n        - 関数を引数にしているので、呼び出し側で好きなように描けます\r\n    - `OpenGL`で描画し、`swapBuffers`でエンコーダーに渡す？\r\n    - もう描画しない場合はループを抜ける\r\n- 後片付け\r\n\r\n多分他の`MediaCodecシリーズ`と同じようなコードだと思う。\r\n\r\n```kotlin\r\n/** Canvas から動画を作る */\r\nobject CanvasProcessor {\r\n\r\n    /** タイムアウト */\r\n    private const val TIMEOUT_US = 10000L\r\n\r\n    /** トラック番号が空の場合 */\r\n    private const val UNDEFINED_TRACK_INDEX = -1\r\n\r\n    /**\r\n     * 処理を開始する\r\n     *\r\n     * @param resultFile エンコード先のファイル\r\n     * @param videoCodec 動画コーデック\r\n     * @param containerFormat コンテナフォーマット\r\n     * @param bitRate ビットレート\r\n     * @param frameRate フレームレート\r\n     * @param outputVideoWidth 動画の高さ\r\n     * @param outputVideoHeight 動画の幅\r\n     * @param onCanvasDrawRequest Canvasの描画が必要になったら呼び出される。trueを返している間、動画を作成する\r\n     */\r\n    suspend fun start(\r\n        resultFile: File,\r\n        videoCodec: String = MediaFormat.MIMETYPE_VIDEO_AVC,\r\n        containerFormat: Int = MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4,\r\n        bitRate: Int = 1_000_000,\r\n        frameRate: Int = 30,\r\n        outputVideoWidth: Int = 1280,\r\n        outputVideoHeight: Int = 720,\r\n        onCanvasDrawRequest: Canvas.(positionMs: Long) -> Boolean,\r\n    ) = withContext(Dispatchers.Default) {\r\n        // エンコード用（生データ -> H.264）MediaCodec\r\n        val encodeMediaCodec = MediaCodec.createEncoderByType(videoCodec).apply {\r\n            // エンコーダーにセットするMediaFormat\r\n            // コーデックが指定されていればそっちを使う\r\n            val videoMediaFormat = MediaFormat.createVideoFormat(videoCodec, outputVideoWidth, outputVideoHeight).apply {\r\n                setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n                setInteger(MediaFormat.KEY_FRAME_RATE, frameRate)\r\n                setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)\r\n                setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n            }\r\n            configure(videoMediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n\r\n        // エンコーダーのSurfaceを取得して、OpenGLを利用してCanvasを重ねます\r\n        val canvasInputSurface = CanvasInputSurface(\r\n            encodeMediaCodec.createInputSurface(),\r\n            TextureRenderer(\r\n                outputVideoWidth = outputVideoWidth,\r\n                outputVideoHeight = outputVideoHeight\r\n            )\r\n        )\r\n        // OpenGL\r\n        canvasInputSurface.makeCurrent()\r\n        encodeMediaCodec.start()\r\n        canvasInputSurface.createRender()\r\n\r\n        // 保存先\r\n        var videoTrackIndex = UNDEFINED_TRACK_INDEX\r\n        val mediaMuxer = MediaMuxer(resultFile.path, containerFormat)\r\n\r\n        // メタデータ格納用\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n        var outputDone = false\r\n        val startMs = System.currentTimeMillis()\r\n\r\n        while (!outputDone) {\r\n\r\n            // コルーチンキャンセル時は強制終了\r\n            if (!isActive) break\r\n\r\n            // Surface経由でデータを貰って保存する\r\n            val encoderStatus = encodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n            if (encoderStatus >= 0) {\r\n                val encodedData = encodeMediaCodec.getOutputBuffer(encoderStatus)!!\r\n                if (bufferInfo.size > 1) {\r\n                    if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                        // MediaMuxer へ addTrack した後\r\n                        mediaMuxer.writeSampleData(videoTrackIndex, encodedData, bufferInfo)\r\n                    }\r\n                }\r\n                encodeMediaCodec.releaseOutputBuffer(encoderStatus, false)\r\n            } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                // MediaMuxerへ映像トラックを追加するのはこのタイミングで行う\r\n                // このタイミングでやると固有のパラメーターがセットされたMediaFormatが手に入る(csd-0 とか)\r\n                // 映像がぶっ壊れている場合（緑で塗りつぶされてるとか）は多分このあたりが怪しい\r\n                val newFormat = encodeMediaCodec.outputFormat\r\n                videoTrackIndex = mediaMuxer.addTrack(newFormat)\r\n                mediaMuxer.start()\r\n            }\r\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                continue\r\n            }\r\n            // OpenGLで描画する\r\n            // Canvas の入力をする\r\n            val presentationTimeUs = (System.currentTimeMillis() - startMs) * 1000\r\n            var isRunning = false\r\n            canvasInputSurface.drawCanvas { canvas ->\r\n                isRunning = onCanvasDrawRequest(canvas, presentationTimeUs / 1000L)\r\n            }\r\n            canvasInputSurface.setPresentationTime(presentationTimeUs * 1000)\r\n            canvasInputSurface.swapBuffers()\r\n            if (!isRunning) {\r\n                outputDone = true\r\n                encodeMediaCodec.signalEndOfInputStream()\r\n            }\r\n        }\r\n\r\n        // OpenGL開放\r\n        canvasInputSurface.release()\r\n        // エンコーダー終了\r\n        encodeMediaCodec.stop()\r\n        encodeMediaCodec.release()\r\n        // MediaMuxerも終了\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n    }\r\n}\r\n```\r\n\r\n## MainActivity\r\n呼び出し側で`Canvas`にお絵かきをします  \r\n`Jetpack Compose`でプロジェクトを作ったために使ってますが、別に使う必要はないです  \r\n（むしろエンコードは時間がかかるので`Acitivty`ではなく、`Foreground Service`などにやらせるべきです。）  \r\n\r\nまーでも記事を書く側としては、`xml`側のコードをわざわざ載せなくても、一つの`kt`ファイルを記事に乗せておけば良いというのは結構良いですね。\r\n\r\n保存先ですが、`getExternalFilesDir`なので、`/sdcard/Android/data/{アプリケーションID}/files`の中にあるはずです。\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            CanvasToVideoTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\r\n                    MainScreen()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// TODO 別に Compose を使う必要はない。\r\n@Composable\r\nfun MainScreen() {\r\n    val isRunning = remember { mutableStateOf(false) }\r\n    val context = LocalContext.current\r\n\r\n    LaunchedEffect(key1 = Unit) {\r\n        // 適当なファイルを作成\r\n        val resultFile = context.getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\") ?: return@LaunchedEffect\r\n        val outlinePaint = Paint().apply {\r\n            color = Color.BLACK\r\n            style = Paint.Style.STROKE\r\n            textSize = 80f\r\n        }\r\n        val innerPaint = Paint().apply {\r\n            style = Paint.Style.FILL\r\n            color = Color.WHITE\r\n            textSize = 80f\r\n        }\r\n        isRunning.value = true\r\n        CanvasProcessor.start(resultFile) { positionMs ->\r\n            // this は Canvas\r\n            drawColor(Color.LTGRAY)\r\n            // positionMs は現在の動画の時間\r\n            val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n            // 枠取り文字\r\n            drawText(text, 0f, 80f, outlinePaint)\r\n            // 枠無し文字\r\n            drawText(text, 0f, 80f, innerPaint)\r\n            // true を返している間は動画を作成する。とりあえず 10 秒\r\n            positionMs < 10_000\r\n        }\r\n        isRunning.value = false\r\n    }\r\n\r\n    Text(text = if (isRunning.value) \"エンコード中です\" else \"終わりました\")\r\n\r\n}\r\n```\r\n\r\n保存先↓  \r\n`Android`標準のファイラー（Files by Google の事ではない） `com.android.documentsui` の方のアプリを使うことで多分 `/sdcard/Android/data` を開くことが出来ると思います。\r\n（ただホーム画面にアイコンがないので、`Intent`を投げるアプリが別途必要（ショートカットを作れるアプリなど））  \r\nまた`X-plore`でも権限を渡すことで見れます。\r\n\r\n![Imgur](https://imgur.com/lZsG3in.png)\r\n\r\nどうでしょう、動画ちゃんと出来ていますか！？\r\n\r\n![Imgur](https://imgur.com/ZMv4zcq.png)\r\n\r\n\r\n# もう一つの MediaRecorder + lockHardwareCanvas を利用する方法\r\nこっちは高レベルAPIなので、難しいことは無いと思う。\r\n\r\n## CanvasProcessorHighLevelApi\r\n命名センスが終わっている。`OpenGL`版をもとに作りました。合ってるかはわからないです。  \r\nコードを見てもらえるとなんですが、`MediaRecorder`と`Canvas`を使っています。`OpenGL`と`MediaCodec / MediaMuxer`の難しいコードはありません。  \r\n\r\n```kotlin\r\n/** OpenGL と MediaCodec を使わずに [CanvasProcessor] をする */\r\n@RequiresApi(Build.VERSION_CODES.M)\r\nobject CanvasProcessorHighLevelApi {\r\n\r\n    /**\r\n     * 処理を開始する\r\n     *\r\n     * @param context [Context]\r\n     * @param resultFile エンコード先のファイル\r\n     * @param videoCodec 動画コーデック\r\n     * @param containerFormat コンテナフォーマット\r\n     * @param bitRate ビットレート\r\n     * @param frameRate フレームレート\r\n     * @param outputVideoWidth 動画の高さ\r\n     * @param outputVideoHeight 動画の幅\r\n     * @param onCanvasDrawRequest Canvasの描画が必要になったら呼び出される。trueを返している間、動画を作成する\r\n     */\r\n    suspend fun start(\r\n        context: Context,\r\n        resultFile: File,\r\n        videoCodec: Int = MediaRecorder.VideoEncoder.H264,\r\n        containerFormat: Int = MediaRecorder.OutputFormat.MPEG_4,\r\n        bitRate: Int = 1_000_000,\r\n        frameRate: Int = 30,\r\n        outputVideoWidth: Int = 1280,\r\n        outputVideoHeight: Int = 720,\r\n        onCanvasDrawRequest: Canvas.(positionMs: Long) -> Boolean,\r\n    ) = withContext(Dispatchers.Default) {\r\n        val mediaRecorder = (if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) MediaRecorder(context) else MediaRecorder()).apply {\r\n            // メソッド呼び出しには順番があります\r\n            setVideoSource(MediaRecorder.VideoSource.SURFACE)\r\n            setOutputFormat(containerFormat)\r\n            setVideoEncoder(videoCodec)\r\n            setVideoEncodingBitRate(bitRate)\r\n            setVideoFrameRate(frameRate)\r\n            setVideoSize(outputVideoWidth, outputVideoHeight)\r\n            setAudioEncodingBitRate(128_000)\r\n            setAudioSamplingRate(44_100)\r\n            setOutputFile(resultFile.path)\r\n            prepare()\r\n        }\r\n        val inputSurface = mediaRecorder.surface\r\n        val startTime = System.currentTimeMillis()\r\n        mediaRecorder.start()\r\n        while (isActive) {\r\n            val positionMs = System.currentTimeMillis() - startTime\r\n            val canvas = inputSurface.lockHardwareCanvas()\r\n            val isRunning = onCanvasDrawRequest(canvas, positionMs)\r\n            inputSurface.unlockCanvasAndPost(canvas)\r\n            if (!isRunning) {\r\n                break\r\n            }\r\n        }\r\n        mediaRecorder.stop()\r\n        mediaRecorder.release()\r\n    }\r\n}\r\n```\r\n\r\n## MainActivity\r\n呼び出し側もあんまり変わってないです。  \r\n（`Context`が必要になったぐらいで、APIはだいたい同じ）\r\n\r\nただ、私の作りが悪いのか、少しずつ時間がずれていっている気がします、、、改善したほうが良さそう。\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            CanvasToVideoTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {\r\n                    MainScreen()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// TODO 別に Compose を使う必要はない。\r\n@Composable\r\nfun MainScreen() {\r\n    val isRunning = remember { mutableStateOf(false) }\r\n    val context = LocalContext.current\r\n\r\n    LaunchedEffect(key1 = Unit) {\r\n        // 適当なファイルを作成\r\n        val resultFile = context.getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\") ?: return@LaunchedEffect\r\n        val outlinePaint = Paint().apply {\r\n            color = Color.BLACK\r\n            style = Paint.Style.STROKE\r\n            textSize = 80f\r\n        }\r\n        val innerPaint = Paint().apply {\r\n            style = Paint.Style.FILL\r\n            color = Color.WHITE\r\n            textSize = 80f\r\n        }\r\n        isRunning.value = true\r\n        CanvasProcessorHighLevelApi.start(context, resultFile) { positionMs ->\r\n            // this は Canvas\r\n            drawColor(Color.LTGRAY)\r\n            // positionMs は現在の動画の時間\r\n            val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n            // 枠取り文字\r\n            drawText(text, 0f, 80f, outlinePaint)\r\n            // 枠無し文字\r\n            drawText(text, 0f, 80f, innerPaint)\r\n            // true を返している間は動画を作成する。とりあえず 10 秒\r\n            positionMs < 10_000\r\n        }\r\n        isRunning.value = false\r\n    }\r\n\r\n    Text(text = if (isRunning.value) \"エンコード中です\" else \"終わりました\")\r\n\r\n}\r\n```\r\n\r\nAPI はだいたい同じなので、以下のように実行時に切り替えるみたいなことも出来ると思います（誰得？）\r\n\r\n```kotlin\r\n// CanvasProcessor / CanvasProcessorHighLevelApi どっちを使うか\r\nval isUseLowLevelApi = true\r\n// 描画時に呼び出される関数\r\nval onCanvasDrawRequest: Canvas.(Long) -> Boolean = { positionMs ->\r\n    // this は Canvas\r\n    drawColor(Color.LTGRAY)\r\n    // positionMs は現在の動画の時間\r\n    val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n    // 枠取り文字\r\n    drawText(text, 0f, 80f, outlinePaint)\r\n    // 枠無し文字\r\n    drawText(text, 0f, 80f, innerPaint)\r\n    // true を返している間は動画を作成する。とりあえず 10 秒\r\n    positionMs < 10_000\r\n}\r\nif (isUseLowLevelApi) {\r\n    CanvasProcessor.start(resultFile, onCanvasDrawRequest = onCanvasDrawRequest)\r\n} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n    CanvasProcessorHighLevelApi.start(context, resultFile, onCanvasDrawRequest = onCanvasDrawRequest)\r\n}\r\n```\r\n\r\n# 端末の動画フォルダに保存して欲しい\r\nこのままだと毎回ファイルマネージャーを開かないといけないので、端末の動画フォルダー（`/sdcard/Movies`）に移動するようにしましょう。  \r\nここに移動することで、Googleフォト等の写真ビューアーで見ることが出来ます。\r\n\r\n```kotlin\r\nobject MediaStoreTool {\r\n\r\n    /**\r\n     * 端末の動画フォルダーへコピーする\r\n     *\r\n     * @param context [Context]\r\n     * @param file コピーするファイル\r\n     */\r\n    suspend fun copyToMovieFolder(\r\n        context: Context,\r\n        file: File\r\n    ) = withContext(Dispatchers.IO) {\r\n        val contentValues = contentValuesOf(\r\n            MediaStore.MediaColumns.DISPLAY_NAME to file.name,\r\n            // RELATIVE_PATH（ディレクトリを掘る） は Android 10 以降のみです\r\n            MediaStore.MediaColumns.RELATIVE_PATH to \"${Environment.DIRECTORY_MOVIES}/CanvasToVideo\"\r\n        )\r\n        val uri = context.contentResolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, contentValues) ?: return@withContext\r\n        context.contentResolver.openOutputStream(uri)?.use { outputStream ->\r\n            file.inputStream().use { inputStream ->\r\n                inputStream.copyTo(outputStream)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nこれをエンコーダーの下に描けば良いはず\r\n\r\n```kotlin\r\n// TODO 別に Compose を使う必要はない。\r\n@Composable\r\nfun MainScreen() {\r\n    val isRunning = remember { mutableStateOf(false) }\r\n    val context = LocalContext.current\r\n\r\n    LaunchedEffect(key1 = Unit) {\r\n        // 適当なファイルを作成\r\n        val resultFile = context.getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\") ?: return@LaunchedEffect\r\n        val outlinePaint = Paint().apply {\r\n            color = Color.BLACK\r\n            style = Paint.Style.STROKE\r\n            textSize = 80f\r\n        }\r\n        val innerPaint = Paint().apply {\r\n            style = Paint.Style.FILL\r\n            color = Color.WHITE\r\n            textSize = 80f\r\n        }\r\n        isRunning.value = true\r\n        // CanvasProcessor / CanvasProcessorHighLevelApi どっちを使うか\r\n        val isUseLowLevelApi = false\r\n        // 描画時に呼び出される関数\r\n        val onCanvasDrawRequest: Canvas.(Long) -> Boolean = { positionMs ->\r\n            // this は Canvas\r\n            drawColor(Color.LTGRAY)\r\n            // positionMs は現在の動画の時間\r\n            val text = \"動画の時間 = ${\"%.2f\".format(positionMs / 1000f)}\"\r\n            // 枠取り文字\r\n            drawText(text, 0f, 80f, outlinePaint)\r\n            // 枠無し文字\r\n            drawText(text, 0f, 80f, innerPaint)\r\n            // true を返している間は動画を作成する。とりあえず 10 秒\r\n            positionMs < 10_000\r\n        }\r\n        if (isUseLowLevelApi) {\r\n            CanvasProcessor.start(resultFile, onCanvasDrawRequest = onCanvasDrawRequest)\r\n        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            CanvasProcessorHighLevelApi.start(context, resultFile, onCanvasDrawRequest = onCanvasDrawRequest)\r\n        }\r\n        // コピーして元データを消す\r\n        MediaStoreTool.copyToMovieFolder(context, resultFile)\r\n        resultFile.delete()\r\n        isRunning.value = false\r\n    }\r\n\r\n    Text(text = if (isRunning.value) \"エンコード中です\" else \"終わりました\")\r\n\r\n}\r\n```\r\n\r\nこれで動画フォルダーに保存されるようになったはず。\r\nというかこれ前も書いた気がする\r\n\r\n![Imgur](https://imgur.com/03vHmPf.png)\r\n\r\n# ベンチマーク（動作確認）\r\n時間測ってみます。三回くらい試しました。リリースビルドではないので正しくは無いかも？  \r\n測ってみましたが差がないのでどっちを使ってもいいと思いました。\r\n\r\n| たんまつ                              | OpenGL 版                      | lockHardwareCanvas 版          |\r\n|---------------------------------------|--------------------------------|--------------------------------|\r\n| Xperia Pro-I (SDM 888)                | 10111 ms / 10109 ms / 10121 ms | 10161 ms / 10133 ms / 10121 ms |\r\n| Google Pixel 6 Pro (Google Tensor G1) | 10185 ms / 10131 ms / 10117 ms | 10717 ms / 10649 ms / 10654 ms |\r\n| Google Pixel 3 XL (SDM 845)           | 10381 ms / 10133 ms / 10099 ms | 10552 ms / 10404 ms / 10391 ms |\r\n| Xperia XZ1 Compact (SDM 835)          | 10932 ms / 10204 ms / 10186 ms | 10420 ms / 10412 ms / 10435 ms |\r\n| Xperia Z3 Compact (SDM 801)           | 10634 ms / 10559 ms / 10419 ms | Android 5 なので使えない       |\r\nたまたま Z3 Compact の電源が入っていたのでついでにやってみました、もう9年くらい前になるの...！？\r\n\r\n## ファイルサイズ\r\n速度はあんまり変わらないのですが、できた動画サイズが全部バラバラなんですよね（なぜ？）\r\nOpenGL -> lockHardwareCanvas を三回繰り返したので、偶数がOpenGL、奇数がlockHardwareCanvasになります  \r\nうーん、`OpenGL 版`のほうが若干ファイルサイズが小さい？\r\n\r\n- Xperia Pro-I\r\n    - ![Imgur](https://imgur.com/e9iA6gJ.png)\r\n- Google Pixel 6 Pro\r\n    - ![Imgur](https://imgur.com/pstJVP9.png)\r\n- Google Pixel 3 XL\r\n    - ![Imgur](https://imgur.com/WkQ0P0x.png)\r\n- Xperia XZ1 Compact\r\n    - ![Imgur](https://imgur.com/oczGiJk.png)\r\n- Xperia Z3 Compact\r\n    - ![Imgur](https://imgur.com/TOHnqZQ.png)\r\n\r\n他にも Xiaomi とかでも見てみましたが特に問題なくどっちでも動いていそうです。（Issueの件再現せず）\r\n\r\n# スライドショーの動画を作るアプリを作る\r\n`Jetpack Compose`でUIを作ります。  \r\n画像を選択するボタンと、エンコードボタンを設置しました。  \r\n押したらエンコードするようにしています。多分 UI に書くことじゃないと思います（時間がかかるので`Service`でやるべきですねはい。）  \r\n特に難しいことはしてない（`Canvas`に書いてるだけ）ので、詳しくはコードのコメント見てください。  \r\n\r\n`Bitmap`を`Canvas`の真ん中に描くのが地味に面倒だった。  \r\n`Uri から Bitmap`はなんか面倒だったので`Glide`とか`Coil`とか入れて楽しても良いかも。  \r\n\r\n```kotlin\r\nprivate const val TIME_MS = 3_000\r\nprivate const val VIDEO_WIDTH = 1280\r\nprivate const val VIDEO_HEIGHT = 720\r\n\r\n/** スライドショーを作る */\r\n@Composable\r\nfun SlideShowScreen() {\r\n    val context = LocalContext.current\r\n    // 実行中フラグ\r\n    val isRunning = remember { mutableStateOf(false) }\r\n    val scope = rememberCoroutineScope()\r\n    // 取得した画像を入れる配列\r\n    val imageList = remember { mutableStateListOf<Uri>() }\r\n    val imagePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.GetMultipleContents()) {\r\n        imageList.addAll(it)\r\n    }\r\n\r\n    // エンコードする\r\n    fun encode() {\r\n        scope.launch {\r\n            isRunning.value = true\r\n            val resultFile = context.getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\")!!\r\n            val paint = Paint()\r\n\r\n            var prevBitmapPathPair: Pair<Uri, Bitmap>? = null\r\n            CanvasProcessor.start(\r\n                resultFile = resultFile,\r\n                outputVideoWidth = VIDEO_WIDTH,\r\n                outputVideoHeight = VIDEO_HEIGHT\r\n            ) { positionMs ->\r\n                // 再生位置から表示すべき画像の配列の添え字を計算\r\n                val index = (positionMs / TIME_MS).toInt()\r\n                val uri = imageList.getOrNull(index) ?: return@start false\r\n                // 前回と違う画像の場合\r\n                if (prevBitmapPathPair?.first != uri) {\r\n                    val bitmap = createBitmapFromUri(context, uri).aspectResize(VIDEO_WIDTH, VIDEO_HEIGHT)\r\n                    // 前の Bitmap を破棄してから\r\n                    prevBitmapPathPair?.second?.recycle()\r\n                    prevBitmapPathPair = uri to bitmap\r\n                }\r\n\r\n                // 真ん中に Bitmap\r\n                val bitmap = prevBitmapPathPair!!.second\r\n                drawBitmap(bitmap, ((VIDEO_WIDTH / 2f) - (bitmap.width / 2f)), 0f, paint)\r\n\r\n                // true を返している間\r\n                positionMs < TIME_MS * imageList.size\r\n            }\r\n\r\n            // コピーして元データを消す\r\n            MediaStoreTool.copyToMovieFolder(context, resultFile)\r\n            resultFile.delete()\r\n\r\n            isRunning.value = false\r\n        }\r\n    }\r\n\r\n    Column {\r\n        // 画像のパスを表示\r\n        imageList.forEach { Text(text = it.toString()) }\r\n\r\n        // 選択ボタン\r\n        Button(\r\n            modifier = Modifier.padding(10.dp),\r\n            onClick = {\r\n                imageList.clear()\r\n                imagePicker.launch(\"image/*\")\r\n            }\r\n        ) { Text(text = \"画像を選ぶ\") }\r\n\r\n        // 実行中はエンコードボタンを塞ぐ\r\n        if (isRunning.value) {\r\n            Text(text = \"エンコード中です\")\r\n        } else {\r\n            Button(\r\n                modifier = Modifier.padding(10.dp),\r\n                onClick = { encode() }\r\n            ) { Text(text = \"エンコードする\") }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/** アスペクト比を保持してリサイズする */\r\nprivate fun Bitmap.aspectResize(targetWidth: Int, targetHeight: Int): Bitmap {\r\n    val width = width\r\n    val height = height\r\n    val aspectBitmap = width.toFloat() / height.toFloat()\r\n    val aspectTarget = targetWidth.toFloat() / targetHeight.toFloat()\r\n    var calcWidth = targetWidth\r\n    var calcHeight = targetHeight\r\n    if (aspectTarget > aspectBitmap) {\r\n        calcWidth = (targetHeight.toFloat() * aspectBitmap).toInt()\r\n    } else {\r\n        calcHeight = (targetWidth.toFloat() / aspectBitmap).toInt()\r\n    }\r\n    return scale(calcWidth, calcHeight, true)\r\n}\r\n\r\n/** Uri から Bitmap を作る。 */\r\nprivate fun createBitmapFromUri(context: Context, uri: Uri): Bitmap {\r\n    // これだと ハードウェア Bitmap が出来てしまうので、 SOFTWARE をつけて、ソフトウェア Bitmap を作る必要がある（編集可能）\r\n    // API が Android 9 以降なので、古いバージョンをサポートしたい場合は古い方法を使うか、いっその事画像を読み込むライブラリ Glide とかを入れるのもありだと思います\r\n    return ImageDecoder.createSource(context.contentResolver, uri)\r\n        .let { src -> ImageDecoder.decodeDrawable(src) { decoder, info, s -> decoder.allocator = ImageDecoder.ALLOCATOR_SOFTWARE } }\r\n        .toBitmap()\r\n}\r\n```\r\n![Imgur](https://imgur.com/SFXmTmb.png)\r\n\r\nまぁ切り替えアニメーションがないんで、見た目があれですが面倒そうなので、、、  \r\n（今思ったけどアニメーションなくてもスライドショーって呼んで良いのか・・・？）  \r\n\r\n<video src=\"https://user-images.githubusercontent.com/32033405/235321119-e8391d46-9fbd-4ed2-9cc7-5a2dd72b7d10.mp4\" width=\"80%\" controls></video>\r\n\r\n# エンドロール？スタッフロール？の動画も作れます\r\nエンディングのあれも作れそう、作ります。  \r\n適当に画像を選ぶボタンと、エンコードボタンと、エンドロール？で流す文字を入力するテキストボックスを置きました。  \r\nこれも`Canvas`にいい感じに書いてるだけなので、特に難しいことはしてないはず。`positionMs`を見てそれっぽく上に文字を移動させているだけです、、  \r\n\r\n\r\n```kotlin\r\nprivate const val VIDEO_DURATION_MS = 20_000\r\nprivate const val VIDEO_WIDTH = 1280\r\nprivate const val VIDEO_HEIGHT = 720\r\n\r\n/** エンドロールをつくる */\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun EndRollScreen() {\r\n    val context = LocalContext.current\r\n    val scope = rememberCoroutineScope()\r\n    // 実行中フラグ\r\n    val isRunning = remember { mutableStateOf(false) }\r\n\r\n    // エンドロールの文字\r\n    val endRollText = remember { mutableStateOf(\"\") }\r\n\r\n    // 画像\r\n    val bitmap = remember { mutableStateOf<Bitmap?>(null) }\r\n    DisposableEffect(key1 = Unit) {\r\n        onDispose { bitmap.value?.recycle() } // Bitmap を破棄する\r\n    }\r\n    val imagePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.GetContent()) {\r\n        val uri = it ?: return@rememberLauncherForActivityResult\r\n        bitmap.value = createBitmapFromUri(context, uri).aspectResize(200, 200)\r\n    }\r\n\r\n    // エンコードする\r\n    fun encode() {\r\n        scope.launch {\r\n            isRunning.value = true\r\n            val resultFile = context.getExternalFilesDir(null)?.resolve(\"${System.currentTimeMillis()}.mp4\")!!\r\n            val bitmapPaint = Paint()\r\n            val textPaint = Paint().apply {\r\n                style = Paint.Style.FILL\r\n                color = Color.WHITE\r\n                textSize = 50f\r\n            }\r\n\r\n            CanvasProcessor.start(\r\n                resultFile = resultFile,\r\n                outputVideoWidth = VIDEO_WIDTH,\r\n                outputVideoHeight = VIDEO_HEIGHT\r\n            ) { positionMs ->\r\n\r\n                // 背景は真っ黒\r\n                drawColor(Color.BLACK)\r\n\r\n                // アイコンを描く\r\n                var textLeftPos = 100f\r\n                bitmap.value?.also { bitmap ->\r\n                    drawBitmap(bitmap, textLeftPos, ((VIDEO_HEIGHT / 2f) - (bitmap.height / 2f)), bitmapPaint)\r\n                    textLeftPos += bitmap.width\r\n                }\r\n\r\n                // 適当に移動させる\r\n                // 複数行描けないので行単位で drawText する\r\n                endRollText.value.lines().forEachIndexed { index, text ->\r\n                    drawText(text, textLeftPos + 100f, ((VIDEO_HEIGHT + (textPaint.textSize * (index + 1))) - (positionMs / 10f)), textPaint)\r\n                }\r\n\r\n                positionMs < VIDEO_DURATION_MS\r\n            }\r\n\r\n            // コピーして元データを消す\r\n            MediaStoreTool.copyToMovieFolder(context, resultFile)\r\n            resultFile.delete()\r\n\r\n            isRunning.value = false\r\n        }\r\n    }\r\n\r\n    Column {\r\n        // 選択ボタン\r\n        bitmap.value?.also {\r\n            Text(text = \"Bitmap width = ${it.width}\")\r\n        }\r\n        Button(\r\n            modifier = Modifier.padding(10.dp),\r\n            onClick = { imagePicker.launch(\"image/*\") }\r\n        ) { Text(text = \"画像を選ぶ\") }\r\n\r\n        // 文字\r\n        OutlinedTextField(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(10.dp),\r\n            value = endRollText.value,\r\n            onValueChange = { endRollText.value = it },\r\n            label = { Text(text = \"エンドロールのテキスト\") }\r\n        )\r\n\r\n        Spacer(modifier = Modifier.height(50.dp))\r\n\r\n        // 実行中はエンコードボタンを塞ぐ\r\n        if (isRunning.value) {\r\n            Text(text = \"エンコード中です\")\r\n        } else {\r\n            Button(\r\n                modifier = Modifier.padding(10.dp),\r\n                onClick = { encode() }\r\n            ) { Text(text = \"エンコードする\") }\r\n        }\r\n    }\r\n}\r\n\r\n/** アスペクト比を保持してリサイズする */\r\nprivate fun Bitmap.aspectResize(targetWidth: Int, targetHeight: Int): Bitmap {\r\n    val width = width\r\n    val height = height\r\n    val aspectBitmap = width.toFloat() / height.toFloat()\r\n    val aspectTarget = targetWidth.toFloat() / targetHeight.toFloat()\r\n    var calcWidth = targetWidth\r\n    var calcHeight = targetHeight\r\n    if (aspectTarget > aspectBitmap) {\r\n        calcWidth = (targetHeight.toFloat() * aspectBitmap).toInt()\r\n    } else {\r\n        calcHeight = (targetWidth.toFloat() / aspectBitmap).toInt()\r\n    }\r\n    return scale(calcWidth, calcHeight, true)\r\n}\r\n\r\n/** Uri から Bitmap を作る。 */\r\nprivate fun createBitmapFromUri(context: Context, uri: Uri): Bitmap {\r\n    // これだと ハードウェア Bitmap が出来てしまうので、 SOFTWARE をつけて、ソフトウェア Bitmap を作る必要がある（編集可能）\r\n    // API が Android 9 以降なので、古いバージョンをサポートしたい場合は古い方法を使うか、いっその事画像を読み込むライブラリ Glide とかを入れるのもありだと思います\r\n    return ImageDecoder.createSource(context.contentResolver, uri)\r\n        .let { src -> ImageDecoder.decodeDrawable(src) { decoder, info, s -> decoder.allocator = ImageDecoder.ALLOCATOR_SOFTWARE } }\r\n        .toBitmap()\r\n}\r\n```\r\n\r\nこんな感じのUIになるはず\r\n\r\n![Imgur](https://imgur.com/wzlAcX0.png)\r\n\r\n実際に作るとこんな感じです。\r\n\r\n<video src=\"https://user-images.githubusercontent.com/32033405/235225944-748106f4-89a0-48c0-b14d-7edfd2698b96.mp4\" width=\"80%\" controls ></video>\r\n\r\n![Imgur](https://imgur.com/h7fPexc.png)\r\n\r\n![Imgur](https://imgur.com/oaGiDld.png)\r\n\r\n# そーすこーど\r\n最低限のUIを作りました、スライドショーとエンドロールを作成する画面を開くことができるはずです。\r\n\r\nhttps://github.com/takusan23/CanvasToVideo\r\n\r\n# おわりに\r\n`Windows 用 Nearby Share`、めっちゃ便利ですね。  \r\n`USB`にしても`USB接続をファイル転送`にしないといけないし、`adb`だとプレビューないからファイルの名前を知らないと行けないから、結構どれを取っても面倒だったんですよね。  \r\n少し前なら Googleフォト へバックアップしてパソコンでダウンロードする方法がありましたが、無制限じゃなくなったからなあ。  \r\nすごく便利です。"},{"title":"COCOAの電波を検知してみる","link":"/posts/android_cocoa_ble_checker/","markdown":"これ高校卒業前にやっとけば面白かったのでは\n\n<img src=\"https://imgur.com/6EC4Hng.png\" width=\"200\">\n\nテレビちゃんに卒業式でつける花（なんていうの？）をつけた\n\n# 本題\nどうやら`COCOA`の電波を拾えるらしい？試してみる  \nちな一回も通知来たことない（いいことじゃん）\n\n# 環境\n\n| なまえ  | あたい  |\n|---------|---------|\n| Android | 12 DP 2 |\n\n# 公式ドキュメント\n日本語版は`BluetoothAdapter#startLeScan()`を使ってますが、これは非推奨なので英語版を見ましょう。  \nhttps://developer.android.com/guide/topics/connectivity/use-ble\n\n# つくる\n\n## AndroidManifest.xml\nブルートゥースの権限が必要であることを示します。  \n特に一番下の`android.permission.ACCESS_FINE_LOCATION`は、ユーザーに許可を求めるタイプの権限です。\n\n```xml\n<uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n<uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/>\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n```\n\n## appフォルダ内のbuild.gradle\n権限を求めるため、今までの`onActivityResult()`を使ってもいいんですけど、今回は`Activity Result API`を使いたい。  \nので`Activity`と`Fragment`のバージョンをあげます\n\n```kotlin\ndependencies {\n\n    // Activity Result API\n    implementation \"androidx.activity:activity-ktx:1.2.1\"\n    implementation \"androidx.fragment:fragment-ktx:1.3.1\"\n\n    // 省略\n}\n```\n\n\n## MainActivity.kt\n\n### BLEに対応しているか\nBLEに対応しているかを返す関数を書いて\n\n```kotlin\n/** BLE対応時はtrueを返す */\nprivate fun isSupportedBLE(): Boolean {\n    return packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)\n}\n```\n\n### BluetoothAdapter\nが必要らしいので\n\n```kotlin\nprivate val bluetoothAdapter by lazy {\n    val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n    bluetoothManager.adapter\n}\n```\n\n### Bluetoothが有効？\nブルートゥースがONになっているかを確認します\n\n```kotlin\n/** Bluetoothが有効ならtrue */\nprivate fun isEnableBluetooth(): Boolean {\n    return bluetoothAdapter.isEnabled\n}\n```\n\n### BLE端末が検出したら呼ばれるコールバック\nを書きます。\n\n```kotlin\n/** BLE端末を検出したら呼ばれるコールバック */\nprivate val bleCallBack = object : ScanCallback() {\n    override fun onScanResult(callbackType: Int, result: ScanResult?) {\n        super.onScanResult(callbackType, result)\n        println(\"検出\")\n        println(result)\n    }\n}\n```\n### 検出を始める\n10秒後に検出を終了するようにしときました。  \nとりあえずはUUIDの制限を掛けずにスキャンしてみます\n\n```kotlin\n/** BLE端末の検出を始める。10秒後に終了する */\nprivate fun start() {\n    bluetoothAdapter.bluetoothLeScanner.startScan(bleCallBack)\n    // 10秒後に終了\n    Handler(Looper.getMainLooper()).postDelayed(10 * 1000) {\n        bluetoothAdapter.bluetoothLeScanner.stopScan(bleCallBack)\n    }\n}\n```\n\n### 権限を求める\n`Activity Result API`のおかげで簡単になった。  \n\n```kotlin\n/** 権限コールバック */\nprivate val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n    if (isGranted) {\n        // お許しをもらった\n        start()\n    }\n}\n\n/** android.permission.ACCESS_FINE_LOCATION 権限があるかどうか */\nprivate fun isGrantedAccessFineLocationPermission(): Boolean {\n    return ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED\n}\n\n/** android.permission.ACCESS_FINE_LOCATION 権限を貰いに行く */\nprivate fun requestAccessFineLocationPermission(){\n    permissionCallBack.launch(android.Manifest.permission.ACCESS_FINE_LOCATION)\n}\n```\n\n\n### onCreate()\n`onCreate()`でそれぞれ呼べばいいかな\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n    when {\n        !isSupportedBLE() -> {\n            // BLE非対応\n            finish()\n            Toast.makeText(this, \"BLE未対応端末では利用できません\", Toast.LENGTH_SHORT).show()\n        }\n        !isEnableBluetooth() -> {\n            // BluetoothがOFF\n            finish()\n            Toast.makeText(this, \"Bluetoothを有効にしてください\", Toast.LENGTH_SHORT).show()\n        }\n        !isGrantedAccessFineLocationPermission() -> {\n            // パーミッションがない。リクエストする\n            requestAccessFineLocationPermission()\n        }\n        else -> {\n            // 検出開始\n            start()\n        }\n    }\n}\n```\n\n## ここまで\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val bluetoothAdapter by lazy {\n        val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n        bluetoothManager.adapter\n    }\n\n    /** 権限コールバック */\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n        if (isGranted) {\n            // お許しをもらった\n            start()\n        }\n    }\n\n    /** BLE端末を検出したら呼ばれるコールバック */\n    private val bleCallBack = object : ScanCallback() {\n        override fun onScanResult(callbackType: Int, result: ScanResult?) {\n            super.onScanResult(callbackType, result)\n            println(\"検出\")\n            println(result)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        when {\n            !isSupportedBLE() -> {\n                // BLE非対応\n                finish()\n                Toast.makeText(this, \"BLE未対応端末では利用できません\", Toast.LENGTH_SHORT).show()\n            }\n            !isEnableBluetooth() -> {\n                // BluetoothがOFF\n                finish()\n                Toast.makeText(this, \"Bluetoothを有効にしてください\", Toast.LENGTH_SHORT).show()\n            }\n            !isGrantedAccessFineLocationPermission() -> {\n                // パーミッションがない。リクエストする\n                requestAccessFineLocationPermission()\n            }\n            else -> {\n                // 検出開始\n                start()\n            }\n        }\n    }\n\n    /** BLE端末の検出を始める。10秒後に終了する */\n    private fun start() {\n        bluetoothAdapter.bluetoothLeScanner.startScan(bleCallBack)\n        // 10秒後に終了\n        Handler(Looper.getMainLooper()).postDelayed(10 * 1000) {\n            bluetoothAdapter.bluetoothLeScanner.stopScan(bleCallBack)\n            Toast.makeText(this, \"検出終了\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    /** android.permission.ACCESS_FINE_LOCATION 権限があるかどうか */\n    private fun isGrantedAccessFineLocationPermission(): Boolean {\n        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED\n    }\n\n    /** android.permission.ACCESS_FINE_LOCATION 権限を貰いに行く */\n    private fun requestAccessFineLocationPermission(){\n        permissionCallBack.launch(android.Manifest.permission.ACCESS_FINE_LOCATION)\n    }\n\n    /** Bluetoothが有効ならtrue */\n    private fun isEnableBluetooth(): Boolean {\n        return bluetoothAdapter.isEnabled\n    }\n\n    /** BLE対応時はtrueを返す */\n    private fun isSupportedBLE(): Boolean {\n        return packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)\n    }\n\n}\n```\n\n## どれがCOCOAの電波ですか？\nこのままではすべての電波を取得してしまうので、`COCOA`の電波に限定してあげる必要があるのですが、ここらへんはよく知りません。  \n２つの方法でこの問題を解決することが出来ます。\n\n## 電波強度\n`ScanResult#rssi`で取れます。単位は謎\n\n### start()関数を書き換える方法\n眺めてると`0000fd6f-0000-1000-8000-00805f9b34fb`がCOCOAのUUID？らしいのでこれに限定してあげればいいと思います。\n\n```kotlin\n/** BLE端末の検出を始める。10秒後に終了する */\nprivate fun start() {\n    // COCOAの電波のみ\n    val uuidFilter = listOf(\n            ScanFilter.Builder().apply { setServiceUuid(ParcelUuid.fromString(\"0000fd6f-0000-1000-8000-00805f9b34fb\")) }.build()\n    )\n    val scanSettings = ScanSettings.Builder().build()\n    bluetoothAdapter.bluetoothLeScanner.startScan(uuidFilter, scanSettings, bleCallBack)\n    // 10秒後に終了\n    Handler(Looper.getMainLooper()).postDelayed(10 * 1000) {\n        bluetoothAdapter.bluetoothLeScanner.stopScan(bleCallBack)\n        Toast.makeText(this, \"検出終了\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n\n## コールバックで限定する\n\nもしくは、すべての電波を取得したあとにUUIDでフィルターしてもいいと思います\n\n```kotlin\n/** BLE端末を検出したら呼ばれるコールバック */\nprivate val bleCallBack = object : ScanCallback() {\n    override fun onScanResult(callbackType: Int, result: ScanResult?) {\n        super.onScanResult(callbackType, result)\n        if (result?.scanRecord?.serviceUuids?.get(0)?.uuid?.toString() == \"0000fd6f-0000-1000-8000-00805f9b34fb\"){\n            println(\"みつけた\")\n        }\n    }\n}\n```\n\n## UIも作る\n`ViewBinding`を有効にしてください。  \n日本語版ドキュメントには`viewBinding { enable = true }`しろって書いてありますが、これは古くて以下の方法が正解です\n\n`app/build.gradle`を開いて\n\n```gradle\nandroid {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"io.github.takusan23.cocoablechecker\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    // これ\n    buildFeatures {\n        viewBinding true\n    }\n    // ここまで\n}\n```\n\n```\nbuildFeatures {\n        viewBinding true\n}\n```\n\nが正解です。\n\n### activity_main.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <ProgressBar\n        android:id=\"@+id/activity_main_progress_bar\"\n        style=\"?android:attr/progressBarStyle\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"16dp\"\n        android:visibility=\"gone\"\n        app:layout_constraintBottom_toTopOf=\"@+id/activity_main_count_text_view\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\" />\n\n    <TextView\n        android:id=\"@+id/activity_main_count_text_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:gravity=\"center\"\n        android:textSize=\"24sp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/activity_main_start_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"16dp\"\n        android:text=\"計測開始\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/activity_main_count_text_view\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n### MainActivity.kt\n電波強度も表示してみたけど見方がわからん\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val bluetoothAdapter by lazy {\n        val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n        bluetoothManager.adapter\n    }\n\n    /** 権限コールバック */\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n        if (isGranted) {\n            // お許しをもらった\n            start()\n        }\n    }\n\n    /** ViewBinding */\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(viewBinding.root)\n\n        when {\n            !isSupportedBLE() -> {\n                // BLE非対応\n                finish()\n                Toast.makeText(this, \"BLE未対応端末では利用できません\", Toast.LENGTH_SHORT).show()\n            }\n            !isEnableBluetooth() -> {\n                // BluetoothがOFF\n                finish()\n                Toast.makeText(this, \"Bluetoothを有効にしてください\", Toast.LENGTH_SHORT).show()\n            }\n            !isGrantedAccessFineLocationPermission() -> {\n                // パーミッションがない。リクエストする\n                requestAccessFineLocationPermission()\n            }\n            else -> {\n                // 検出開始\n                viewBinding.activityMainStartButton.setOnClickListener {\n                    start()\n                }\n            }\n        }\n    }\n\n    /** BLE端末の検出を始める。10秒後に終了する */\n    private fun start() {\n        // 結果を入れる配列\n        val resultList = arrayListOf<ScanResult>()\n        // BLE端末を検出したら呼ばれるコールバック\n        val bleCallBack = object : ScanCallback() {\n            override fun onScanResult(callbackType: Int, result: ScanResult?) {\n                super.onScanResult(callbackType, result)\n                // 配列に追加\n                if (result?.scanRecord?.serviceUuids?.get(0)?.uuid?.toString() == \"0000fd6f-0000-1000-8000-00805f9b34fb\") {\n                    resultList.add(result)\n                }\n            }\n        }\n        // スキャン開始\n        bluetoothAdapter.bluetoothLeScanner.startScan(bleCallBack)\n        // くるくる\n        viewBinding.activityMainProgressBar.isVisible = true\n        // 10秒後に終了\n        Handler(Looper.getMainLooper()).postDelayed(10 * 1000) {\n            // 止める\n            bluetoothAdapter.bluetoothLeScanner.stopScan(bleCallBack)\n            // 重複を消す\n            val finalList = resultList.distinctBy { scanResult -> scanResult.device?.address }\n            // 結果\n            viewBinding.activityMainProgressBar.isVisible = false\n            // 電波強度\n            val singalText = finalList.joinToString(separator = \"\\n\") { scanResult -> \"${scanResult.rssi} dBm\" }\n            // TextViewに表示\n            viewBinding.activityMainCountTextView.text = \"\"\"\nCOCOAインストール台数\nおよそ ${finalList.size} 台\n--- 電波強度 ---\n$singalText\n            \"\"\".trimIndent()\n        }\n    }\n\n    /** android.permission.ACCESS_FINE_LOCATION 権限があるかどうか */\n    private fun isGrantedAccessFineLocationPermission(): Boolean {\n        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED\n    }\n\n    /** android.permission.ACCESS_FINE_LOCATION 権限を貰いに行く */\n    private fun requestAccessFineLocationPermission() {\n        permissionCallBack.launch(android.Manifest.permission.ACCESS_FINE_LOCATION)\n    }\n\n    /** Bluetoothが有効ならtrue */\n    private fun isEnableBluetooth(): Boolean {\n        return bluetoothAdapter.isEnabled\n    }\n\n    /** BLE対応時はtrueを返す */\n    private fun isSupportedBLE(): Boolean {\n        return packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)\n    }\n\n}\n```\n\n<img src=\"https://imgur.com/YlcCf5d.png\" width=300>\n\n# そーすこーど\n間違ってたらごめんね\n\nhttps://github.com/takusan23/CocoaBLECheckerSample\n\n\n# 参考にしました\nhttps://qiita.com/Rabbit_Program/items/3c1aec6e30eb646d78a1  \nhttps://engineer.dena.com/posts/2021.02/web-bluetooth-cocoa-checker/  \nhttps://qiita.com/jp-96/items/3e5e5a12d42ba246b8c3  \nhttps://qiita.com/coppercele/items/fef9eacee05b752ed982"},{"title":"Androidアプリ側でキーボードの学習機能を無効にしたい","link":"/posts/android_disable_keybord_learning/","markdown":"\r\nどうもこんばんわ。  \r\nこれは D.C.4 の 白河ひより ちゃん ↘\r\n\r\n![Imgur](https://imgur.com/8dvXL9p.png)\r\n\r\n# 本題\r\nアプリ側でIMEの学習機能をOFFに出来ます。  \r\nChromeとかFirefoxのプライベートモードで~~やましい事を~~検索しようとする際に有効になったりする。\r\n\r\n全てのキーボードアプリが対応してるかは分からん...\r\n\r\n# 作り方\r\n\r\n`EditText`に`android:imeOptions=\"flagNoPersonalizedLearning\"`を指定するだけです、はい\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <EditText\r\n        android:id=\"@+id/edit_text_disable_leaning\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:hint=\"IMEの学習機能がOFFです\"\r\n        android:imeOptions=\"flagNoPersonalizedLearning\"\r\n        android:minHeight=\"48dp\"\r\n        android:text=\"\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <EditText\r\n        android:id=\"@+id/edit_text\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:hint=\"IMEの学習機能がONです\"\r\n        android:minHeight=\"48dp\"\r\n        android:text=\"\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/edit_text_disable_leaning\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\nこれで実行すると、EditTextが2つ出てると思います。  \r\n上のEditTextでは何回同じキーワードを入れても学習しない（入力候補に出るが優先順位が変わらない）が、下のEditTextでは特に指定していないため、  \r\n2回目以降は入力候補に優先的に表示されていると思います。\r\n\r\n![Imgur](https://imgur.com/7jRK3ff.png)\r\n若干キーボードのUIが変わる。\r\n\r\n![Imgur](https://imgur.com/TmbubM2.png)\r\n\r\n以上です。\r\n\r\n# おわりに\r\n最近ねむい"},{"title":"BottomNavigationViewを置いたらエラーが出た","link":"/posts/android_drawable_v24/","markdown":"\r\n自分用メモ\r\n\r\n## 本題\r\n```\r\nError inflating class com.google.android.material.bottomnavigation.BottomNavigationView\r\n```\r\n\r\nAndroid 11 / 10 では動くが、Android 5で動かそうとしたら落ちた\r\n\r\n`app:menu`属性を消すと実行できるようになったので、どうやらメニューが怪しい\r\n\r\nてなわけでメニュー消したんだけど、今度は`Button`でエラーが\r\n\r\n## 原因\r\n`app:icon`に指定した`drawable`が`drawable-v24`フォルダに入ってた。  \r\n\r\n使う`drawable-v24`にある`xml`をすべて`drawable`に入れたら起動するようになった。良かった。"},{"title":"Fragmentが作れない","link":"/posts/android_fragment_tukurenai/","markdown":"\r\nFragmentを作ろうとすると謎のメソッドを生成しないといけなくなってた。しかも何返せばいいんだこれ\r\n\r\n```kotlin\r\nclass BlogListFragment : Fragment() {\r\n\r\n    override fun <I : Any?, O : Any?> prepareCall(\r\n        contract: ActivityResultContract<I, O>,\r\n        callback: ActivityResultCallback<O>\r\n    ): ActivityResultLauncher<I> {\r\n\r\n    }\r\n\r\n    override fun <I : Any?, O : Any?> prepareCall(\r\n        contract: ActivityResultContract<I, O>,\r\n        registry: ActivityResultRegistry,\r\n        callback: ActivityResultCallback<O>\r\n    ): ActivityResultLauncher<I> {\r\n\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 解決\r\nFragmentのバージョンを上げます。  \r\n`app`フォルダにある`build.gradle`を開いて、`dependencies`に一行足します。\r\n\r\n```\r\ndependencies {\r\n    // Fragmentを作ろうとすると謎のメソッドをオーバーライドさせようとするので\r\n    implementation 'androidx.fragment:fragment-ktx:1.3.0-rc01'\r\n}\r\n```\r\n\r\n## 参考にしました\r\nhttps://stackoverflow.com/questions/65342763/unable-to-create-fragment-class-in-jetpack-compose"},{"title":"Android で前面と背面を同時に撮影できるカメラを作りたい","link":"/posts/android_front_back_camera/","markdown":"\r\nどうもこんばんわ  \r\n新社会人へ、新人らしくないとか言われたので新人らしくしましょうね。（声をワントーン上げるとか）  \r\n同期は大事にしよう。転職してしまいましたがいつの間にか同期はいなくなってました、、、  \r\n\r\nあとzipファイルを解凍と言われたら展開のことです。\r\n# ほんだい\r\n前面カメラと背面カメラを同時に開いて、ワイプカメラ？マルチカメラ？出来るアプリを作ってみようと思います。  \r\nすでにありそうだけど、、、\r\n\r\n![Imgur](https://imgur.com/PACr0Zx.png)\r\n\r\n![Imgur](https://imgur.com/2mjyEvn.png)\r\n\r\n# かんきょう\r\n\r\n| なまえ        | あたい                                                                                      |\r\n|---------------|---------------------------------------------------------------------------------------------|\r\n| 言語          | Kotlin と OpenGL を使うため GLSL                                                            |\r\n| 端末          | Pixel 6 Pro / Xperia Pro-I (プリインストール時点で Android 11 以上を搭載した端末が必要多分) |\r\n| minSdkVersion | 30                                                                                          |\r\n\r\n`Jetpack Compose`をUI構築に使いますが、`SurfaceView`を主に使うことになるので別に`View`でもいいです。  \r\nあと Kotlin Coroutine も使います。便利\r\n\r\n## minSdk\r\n同時にカメラをオープンする機能が、SDK バージョン 30（Android 11）からです。  \r\nただ、Androidのアップデートをすればよいわけではなく、おそらくハードウェアレベルで同時にカメラを開く機能が実装されている必要があると思うので、  \r\n**Android 11以降がプリインストールされている端末でないとダメだと思います。**  \r\n以下の関数で同時に開くことが出来るカメラ（カメラID）の組み合わせが取得できます。返ってこない場合は対応していません！\r\n\r\nhttps://developer.android.com/reference/android/hardware/camera2/CameraManager#getConcurrentCameraIds()\r\n\r\nそれ以外は特に記述されていないので？多分`Camera2 API`で前面背面カメラを普通に開けばいいんじゃないかなと思っています。\r\n\r\n[https://dic.nicovideo.jp/a/windows 8#h2-4](https://dic.nicovideo.jp/a/windows%208#h2-4)\r\n\r\n## しくみ\r\n今回は録画機能をつけたいため、`SurfaceView` を2つ利用して前面と背面を表示するのではなく、一つの `SurfaceView` に前面と背面のカメラ映像を合成した状態で表示させようと思います。  \r\nその、カメラ映像を合成するために `OpenGL` を利用します。カメラ映像は `SurfaceTexture` を使うことで、フラグメントシェーダーからテクスチャ（画像）として利用できます。  \r\n`SurfaceTexture`のコールバックに新しいフレームが来たことを通知してくれるので、来たら`glDrawArrays`して描画します。\r\n\r\n![Imgur](https://imgur.com/s0Qtjhx.png)\r\n\r\n今回もOpenGL周りはAOSPのコードをパクって来ようと思います、、、（Apache License 2.0）  \r\nまた、今回も CameraX は使わずに Camera2 API をそのまま叩こうと思います、CameraX API めちゃモダンなAPIで気になるけど、SurfaceTexture + OpenGL みたいなことって出来るのかな、、、。\r\n\r\n流石にやりませんが、静止画撮影だけなら、`SurfaceView`を2つ使ってAndroidの`PixelCopy`を使う手もあると思いますが、、、  \r\n~~Bitmap重ねるよりはマシ~~\r\n\r\n## つくる\r\nTarget SDK 30 以上で作ります  \r\n割と初めて真面目にカメラアプリを作るかもしれない、、、\r\n\r\n![Imgur](https://imgur.com/BsCga8R.png)\r\n\r\n# AndroidManifest.xml\r\nカメラ権限と録画で使うマイク権限を\r\n\r\n```xml\r\n    <uses-permission android:name=\"android.permission.CAMERA\" />\r\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\r\n```\r\n\r\n# カメラ編\r\n`Camera2 API`なので長々しいコードが続きます、、、\r\n\r\n## 前面、背面カメラを管理するクラス\r\n今回は、前面と背面カメラ、それぞれこのクラスのインスタンスを作ることにします。  \r\nクラスの名前どうにかしろよ、、、\r\n\r\n```kotlin\r\n/**\r\n * カメラを開けたり閉じたりする処理を隠蔽するクラス\r\n * \r\n * @param context [Context]\r\n * @param cameraId カメラID、前面 or 背面\r\n * @param previewSurface プレビューSurface\r\n */\r\nclass CameraControl(\r\n    private val context: Context,\r\n    private val cameraId: String,\r\n    private val previewSurface: Surface,\r\n) {\r\n    private val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n    private val cameraExecutor = Executors.newSingleThreadExecutor()\r\n    private var cameraDevice: CameraDevice? = null\r\n\r\n    /** カメラを開く */\r\n    suspend fun openCamera() {\r\n        cameraDevice = waitOpenCamera()\r\n    }\r\n\r\n    /** プレビューを出す */\r\n    fun startPreview() {\r\n        val cameraDevice = cameraDevice ?: return\r\n        val captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW).apply {\r\n            addTarget(previewSurface)\r\n        }.build()\r\n        val outputList = buildList {\r\n            add(OutputConfiguration(previewSurface))\r\n        }\r\n        SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n            override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                captureSession.setRepeatingRequest(captureRequest, null, null)\r\n            }\r\n\r\n            override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n                // do nothing\r\n            }\r\n        }).apply { cameraDevice.createCaptureSession(this) }\r\n    }\r\n\r\n    /** 終了時に呼び出す */\r\n    fun destroy() {\r\n        cameraDevice?.close()\r\n    }\r\n\r\n    /** [cameraId]のカメラを開く */\r\n    @SuppressLint(\"MissingPermission\")\r\n    suspend private fun waitOpenCamera() = suspendCoroutine {\r\n        cameraManager.openCamera(cameraId, cameraExecutor, object : CameraDevice.StateCallback() {\r\n            override fun onOpened(camera: CameraDevice) {\r\n                it.resume(camera)\r\n            }\r\n\r\n            override fun onDisconnected(camera: CameraDevice) {\r\n                // do nothing\r\n            }\r\n\r\n            override fun onError(camera: CameraDevice, error: Int) {\r\n                // do nothing\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n```\r\nカメラIDに対応したカメラを開いて、Surfaceに映像を出力するように設定して、ライフサイクルが `onDestroy` になったら終了するようになっています。\r\n\r\n## カメラIDを取得する関数\r\n`cameraIdList`でカメラが取得できるので、`CameraCharacteristics.LENS_FACING`で 前面 or 背面 どっちのカメラか取得できます。  \r\nなんか`cameraIdList`、フロントとカメラで2つしか帰ってこないと思ってたんだけど (Pixel 6 Pro) 、なんかいっぱいある端末もある (Xperia Pro-I の場合は 超広角 広角 通常 カメラにもそれぞれ カメラID が割り当てられてる？)\r\n\r\n```kotlin\r\nobject CameraTool {\r\n\r\n    /** 前面、背面 カメラのIDを返す */\r\n    fun getCameraId(context: Context): Pair<String, String> {\r\n        val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n        val backCameraId = cameraManager.cameraIdList.first { cameraManager.getCameraCharacteristics(it).get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK }\r\n        val frontCameraId = cameraManager.cameraIdList.first { cameraManager.getCameraCharacteristics(it).get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT }\r\n        return backCameraId to frontCameraId\r\n    }\r\n\r\n}\r\n```\r\n\r\n# OpenGL 編\r\n参考にした AOSP のコード置いておきます。thx  \r\nhttps://cs.android.com/android/platform/superproject/+/master:cts/tests/tests/media/common/src/android/media/cts/InputSurface.java;l=1\r\n\r\n## GLSurface\r\n`GLSurfaceView` を利用すると、いきなりシェーダー書くところから始めることができます。しかも、今回`GLSurfaceView`を利用しても問題ないはずです。  \r\nでもなんで今回は使ってないかというと、今回は録画機能をつけるためです。静止画撮影なら`GLSurfaceView`で出来るはずです。（`glReadPixels`使うなら）  \r\n\r\n`GLSurfaceView`を録画できる便利な機能なんて無いため、`MediaRecorder`で録画する必要があります。  \r\nしかし、`MediaRecorder`の入力には`GLSurfaceView (SurfaceView)`ではなく、`Surface`しか受け付けません。  \r\nなので、入力用`Surface`に`OpenGL`のレンダリング結果を出力するようにする必要があるのですが、それには`OpenGL`の出力を`Surface`にするための処理を1から書く必要があります。  \r\n`SurfaceView`と`OpenGL`をまとめたものが`GLSurfaceView`なのですが、今回ほしいのは`Surface`と`OpenGL`をまとめたものなのです。でも`GLSurface`クラスなんて無いので作ります、、、  \r\n\r\n`Surface`が取れればいいので、`SurfaceView`でももちろん使えます。\r\n\r\n以下がコードです。おそらく`GLSurfaceView`内部でやってることをやってるだけだと思います。\r\n\r\n```kotlin\r\n// 参考にした AOSP のコード : https://cs.android.com/android/platform/superproject/+/master:cts/tests/tests/media/common/src/android/media/cts/InputSurface.java\r\n\r\n/**\r\n * [Surface]とOpenGLを連携させるためのクラス\r\n * 本来 [android.opengl.GLSurfaceView] を利用することで EGL のセットアップを省略することができますが、\r\n * 今回は [android.view.SurfaceView] ではなく [Surface] だけで OpenGL を利用したいため、EGLのセットアップから記述している。\r\n */\r\nclass GLSurface(\r\n    private val surface: Surface,\r\n    private val renderer: CameraGLRenderer\r\n) {\r\n    private var mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n    private var mEGLContext = EGL14.EGL_NO_CONTEXT\r\n    private var mEGLSurface = EGL14.EGL_NO_SURFACE\r\n\r\n    init {\r\n        eglSetup()\r\n    }\r\n\r\n    /**\r\n     * Prepares EGL.  We want a GLES 2.0 context and a surface that supports recording.\r\n     */\r\n    private fun eglSetup() {\r\n        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)\r\n        if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n            throw RuntimeException(\"unable to get EGL14 display\")\r\n        }\r\n        val version = IntArray(2)\r\n        if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n            throw RuntimeException(\"unable to initialize EGL14\")\r\n        }\r\n        // Configure EGL for recording and OpenGL ES 2.0.\r\n        val attribList = intArrayOf(\r\n            EGL14.EGL_RED_SIZE, 8,\r\n            EGL14.EGL_GREEN_SIZE, 8,\r\n            EGL14.EGL_BLUE_SIZE, 8,\r\n            EGL14.EGL_ALPHA_SIZE, 8,\r\n            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\r\n            EGL_RECORDABLE_ANDROID, 1,\r\n            EGL14.EGL_NONE\r\n        )\r\n        val configs = arrayOfNulls<EGLConfig>(1)\r\n        val numConfigs = IntArray(1)\r\n        EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.size, numConfigs, 0)\r\n        checkEglError(\"eglCreateContext RGB888+recordable ES2\")\r\n\r\n        // Configure context for OpenGL ES 2.0.\r\n        val attrib_list = intArrayOf(\r\n            EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLContext = EGL14.eglCreateContext(\r\n            mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT,\r\n            attrib_list, 0\r\n        )\r\n        checkEglError(\"eglCreateContext\")\r\n\r\n        // Create a window surface, and attach it to the Surface we received.\r\n        val surfaceAttribs = intArrayOf(\r\n            EGL14.EGL_NONE\r\n        )\r\n        mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], surface, surfaceAttribs, 0)\r\n        checkEglError(\"eglCreateWindowSurface\")\r\n    }\r\n\r\n    /** 描画する */\r\n    fun drawFrame() {\r\n        renderer.onDrawFrame()\r\n    }\r\n\r\n    /**\r\n     * Discards all resources held by this class, notably the EGL context.\r\n     */\r\n    fun release() {\r\n        if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {\r\n            EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT)\r\n            EGL14.eglDestroySurface(mEGLDisplay, mEGLSurface)\r\n            EGL14.eglDestroyContext(mEGLDisplay, mEGLContext)\r\n            EGL14.eglReleaseThread()\r\n            EGL14.eglTerminate(mEGLDisplay)\r\n        }\r\n        // surface.release() // GLは破棄しない\r\n        mEGLDisplay = EGL14.EGL_NO_DISPLAY\r\n        mEGLContext = EGL14.EGL_NO_CONTEXT\r\n        mEGLSurface = EGL14.EGL_NO_SURFACE\r\n    }\r\n\r\n    /**\r\n     * Makes our EGL context and surface current.\r\n     */\r\n    fun makeCurrent() {\r\n        EGL14.eglMakeCurrent(mEGLDisplay, mEGLSurface, mEGLSurface, mEGLContext)\r\n        checkEglError(\"eglMakeCurrent\")\r\n    }\r\n\r\n    /**\r\n     * Calls eglSwapBuffers.  Use this to \"publish\" the current frame.\r\n     */\r\n    fun swapBuffers(): Boolean {\r\n        val result = EGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface)\r\n        checkEglError(\"eglSwapBuffers\")\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Sends the presentation time stamp to EGL.  Time is expressed in nanoseconds.\r\n     */\r\n    fun setPresentationTime(nsecs: Long) {\r\n        EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs)\r\n        checkEglError(\"eglPresentationTimeANDROID\")\r\n    }\r\n\r\n    /**\r\n     * Checks for EGL errors.  Throws an exception if one is found.\r\n     */\r\n    private fun checkEglError(msg: String) {\r\n        val error = EGL14.eglGetError()\r\n        if (error != EGL14.EGL_SUCCESS) {\r\n            throw RuntimeException(\"$msg: EGL error: 0x${Integer.toHexString(error)}\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val EGL_RECORDABLE_ANDROID = 0x3142\r\n    }\r\n}\r\n```\r\n\r\n## CameraGLRenderer\r\nカメラ映像をレンダリングする処理を書きます。  \r\nバーテックスシェーダ、フラグメントシェーダもここに書きます（別に .glsl にしてもいいですが）。\r\n\r\n```kotlin\r\n/**\r\n * カメラ映像をレンダリングする\r\n * フロント、バックではなく、メイン、サブにしている。後で切り替え機能を作るため\r\n *\r\n * @param rotation 映像を回転する\r\n * @param mainSurfaceTexture メイン映像\r\n * @param subSurfaceTexture サブ映像。ワイプカメラ\r\n */\r\nclass CameraGLRenderer(\r\n    private val rotation: Float,\r\n    private val mainSurfaceTexture: () -> SurfaceTexture,\r\n    private val subSurfaceTexture: () -> SurfaceTexture,\r\n) {\r\n\r\n    private val mMVPMatrix = FloatArray(16)\r\n    private val mSTMatrix = FloatArray(16)\r\n    private val mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.size * FLOAT_SIZE_BYTES).run {\r\n        order(ByteOrder.nativeOrder())\r\n        asFloatBuffer().apply {\r\n            put(mTriangleVerticesData)\r\n            position(0)\r\n        }\r\n    }\r\n\r\n    // ハンドルたち\r\n    private var mProgram = 0\r\n    private var muMVPMatrixHandle = 0\r\n    private var muSTMatrixHandle = 0\r\n    private var maPositionHandle = 0\r\n    private var maTextureHandle = 0\r\n\r\n    // テクスチャID\r\n    // SurfaceTexture に渡す\r\n    private var mainCameraTextureId = 0\r\n    private var subCameraTextureId = 0\r\n\r\n    // テクスチャのハンドル\r\n    private var uMainCameraTextureHandle = 0\r\n    private var uSubCameraTextureHandle = 0\r\n    private var uDrawMainCameraHandle = 0\r\n\r\n    /** 描画する */\r\n    fun onDrawFrame() {\r\n        prepareDraw()\r\n        drawMainCamera(mainSurfaceTexture())\r\n        drawSubCamera(subSurfaceTexture())\r\n        GLES20.glFinish()\r\n    }\r\n\r\n    /**\r\n     * シェーダーの用意をする。\r\n     * テクスチャIDを返すので、SurfaceTexture のコンストラクタ入れてね。\r\n     *\r\n     * @return メイン映像、サブ映像のテクスチャID。SurfaceTexture のコンストラクタ に入れる。\r\n     */\r\n    fun setupProgram(): Pair<Int, Int> {\r\n        mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER)\r\n        if (mProgram == 0) {\r\n            throw RuntimeException(\"failed creating program\")\r\n        }\r\n        maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\")\r\n        checkGlError(\"glGetAttribLocation aPosition\")\r\n        if (maPositionHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aPosition\")\r\n        }\r\n        maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\")\r\n        checkGlError(\"glGetAttribLocation aTextureCoord\")\r\n        if (maTextureHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for aTextureCoord\")\r\n        }\r\n        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\")\r\n        checkGlError(\"glGetUniformLocation uMVPMatrix\")\r\n        if (muMVPMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uMVPMatrix\")\r\n        }\r\n        muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\")\r\n        checkGlError(\"glGetUniformLocation uSTMatrix\")\r\n        if (muSTMatrixHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uSTMatrix\")\r\n        }\r\n        uMainCameraTextureHandle = GLES20.glGetUniformLocation(mProgram, \"uMainCameraTexture\")\r\n        checkGlError(\"glGetUniformLocation uMainCameraTextureHandle\")\r\n        if (uMainCameraTextureHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uMainCameraTextureHandle\")\r\n        }\r\n        uSubCameraTextureHandle = GLES20.glGetUniformLocation(mProgram, \"uSubCameraTexture\")\r\n        checkGlError(\"glGetUniformLocation uSubCameraTexture\")\r\n        if (uSubCameraTextureHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uSubCameraTexture\")\r\n        }\r\n        uDrawMainCameraHandle = GLES20.glGetUniformLocation(mProgram, \"uDrawMainCamera\")\r\n        checkGlError(\"glGetUniformLocation uDrawMainCameraHandle\")\r\n        if (uDrawMainCameraHandle == -1) {\r\n            throw RuntimeException(\"Could not get attrib location for uDrawMainCameraHandle\")\r\n        }\r\n\r\n        // カメラ2つなので、2つ分のテクスチャを作成\r\n        val textures = IntArray(2)\r\n        GLES20.glGenTextures(2, textures, 0)\r\n\r\n        // メイン映像\r\n        mainCameraTextureId = textures[0]\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mainCameraTextureId)\r\n        checkGlError(\"glBindTexture mainCameraTextureId\")\r\n\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST.toFloat())\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR.toFloat())\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)\r\n        checkGlError(\"glTexParameteri mainCameraTexture\")\r\n\r\n        // サブ映像\r\n        subCameraTextureId = textures[1]\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, subCameraTextureId)\r\n        checkGlError(\"glBindTexture subCameraTextureId\")\r\n\r\n        // 縮小拡大時の補間設定\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST.toFloat())\r\n        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR.toFloat())\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)\r\n        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)\r\n        checkGlError(\"glTexParameteri subCameraTexture\")\r\n\r\n        // アルファブレンドを有効\r\n        // これにより、透明なテクスチャがちゃんと透明に描画される\r\n        GLES20.glEnable(GLES20.GL_BLEND)\r\n        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA)\r\n        checkGlError(\"glEnable BLEND\")\r\n\r\n        return subCameraTextureId to mainCameraTextureId\r\n    }\r\n\r\n    /** 描画前に呼び出す */\r\n    private fun prepareDraw() {\r\n        // glError 1282 の原因とかになる\r\n        GLES20.glUseProgram(mProgram)\r\n        checkGlError(\"glUseProgram\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n\r\n        // Snapdragon だと glClear が無いと映像が乱れる\r\n        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT or GLES20.GL_COLOR_BUFFER_BIT)\r\n    }\r\n\r\n    /** メイン映像の [SurfaceTexture] を描画する */\r\n    private fun drawMainCamera(surfaceTexture: SurfaceTexture) {\r\n        // テクスチャ更新。呼ばないと真っ黒\r\n        surfaceTexture.updateTexImage()\r\n        checkGlError(\"drawMainCamera start\")\r\n        surfaceTexture.getTransformMatrix(mSTMatrix)\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, subCameraTextureId)\r\n        // メイン映像のテクスチャIDは GLES20.GL_TEXTURE0 なので 0\r\n        GLES20.glUniform1i(uMainCameraTextureHandle, 0)\r\n        // サブ映像のテクスチャIDは GLES20.GL_TEXTURE1 なので 1\r\n        GLES20.glUniform1i(uSubCameraTextureHandle, 1)\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n        // ----\r\n        // メイン映像を描画するフラグを立てる\r\n        // ----\r\n        GLES20.glUniform1i(uDrawMainCameraHandle, 1)\r\n        // Matrix.XXX のユーティリティー関数で行列の操作をする場合、適用させる順番に注意する必要があります\r\n        Matrix.setIdentityM(mMVPMatrix, 0)\r\n        // 画面回転している場合は回転する\r\n        Matrix.rotateM(mMVPMatrix, 0, rotation, 0f, 0f, 1f)\r\n\r\n        // 描画する\r\n        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0)\r\n        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0)\r\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)\r\n        checkGlError(\"glDrawArrays drawMainCamera\")\r\n    }\r\n\r\n    /** サブ映像の [SurfaceTexture] を描画する */\r\n    private fun drawSubCamera(surfaceTexture: SurfaceTexture) {\r\n        // テクスチャ更新。呼ばないと真っ黒\r\n        surfaceTexture.updateTexImage()\r\n        checkGlError(\"drawSubCamera start\")\r\n        surfaceTexture.getTransformMatrix(mSTMatrix)\r\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)\r\n        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mainCameraTextureId)\r\n        // メイン映像のテクスチャIDは GLES20.GL_TEXTURE0 なので 0\r\n        GLES20.glUniform1i(uMainCameraTextureHandle, 0)\r\n        // サブ映像のテクスチャIDは GLES20.GL_TEXTURE1 なので 1\r\n        GLES20.glUniform1i(uSubCameraTextureHandle, 1)\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET)\r\n        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maPosition\")\r\n        GLES20.glEnableVertexAttribArray(maPositionHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maPositionHandle\")\r\n        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET)\r\n        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false, TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices)\r\n        checkGlError(\"glVertexAttribPointer maTextureHandle\")\r\n        GLES20.glEnableVertexAttribArray(maTextureHandle)\r\n        checkGlError(\"glEnableVertexAttribArray maTextureHandle\")\r\n        // ----\r\n        // メイン映像を描画するフラグを下ろしてサブ映像を描画する\r\n        // ----\r\n        GLES20.glUniform1i(uDrawMainCameraHandle, 0)\r\n        // Matrix.XXX のユーティリティー関数で行列の操作をする場合、適用させる順番に注意する必要があります\r\n        Matrix.setIdentityM(mMVPMatrix, 0)\r\n        // 右上に移動させる\r\n        Matrix.translateM(mMVPMatrix, 0, 1f - 0.3f, 1f - 0.3f, 1f)\r\n        // 半分ぐらいにする\r\n        Matrix.scaleM(mMVPMatrix, 0, 0.3f, 0.3f, 1f)\r\n        // 画面回転している場合は回転する\r\n        Matrix.rotateM(mMVPMatrix, 0, rotation, 0f, 0f, 1f)\r\n\r\n        // 描画する\r\n        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0)\r\n        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0)\r\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)\r\n        checkGlError(\"glDrawArrays drawSubCamera\")\r\n    }\r\n\r\n    private fun createProgram(vertexSource: String, fragmentSource: String): Int {\r\n        val vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource)\r\n        if (vertexShader == 0) {\r\n            return 0\r\n        }\r\n        val pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource)\r\n        if (pixelShader == 0) {\r\n            return 0\r\n        }\r\n        var program = GLES20.glCreateProgram()\r\n        checkGlError(\"glCreateProgram\")\r\n        if (program == 0) {\r\n            return 0\r\n        }\r\n        GLES20.glAttachShader(program, vertexShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glAttachShader(program, pixelShader)\r\n        checkGlError(\"glAttachShader\")\r\n        GLES20.glLinkProgram(program)\r\n        val linkStatus = IntArray(1)\r\n        GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0)\r\n        if (linkStatus[0] != GLES20.GL_TRUE) {\r\n            GLES20.glDeleteProgram(program)\r\n            program = 0\r\n        }\r\n        return program\r\n    }\r\n\r\n    private fun loadShader(shaderType: Int, source: String): Int {\r\n        var shader = GLES20.glCreateShader(shaderType)\r\n        checkGlError(\"glCreateShader type=$shaderType\")\r\n        GLES20.glShaderSource(shader, source)\r\n        GLES20.glCompileShader(shader)\r\n        val compiled = IntArray(1)\r\n        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0)\r\n        if (compiled[0] == 0) {\r\n            GLES20.glDeleteShader(shader)\r\n            shader = 0\r\n        }\r\n        return shader\r\n    }\r\n\r\n    private fun checkGlError(op: String) {\r\n        val error = GLES20.glGetError()\r\n        if (error != GLES20.GL_NO_ERROR) {\r\n            throw RuntimeException(\"$op: glError $error\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private val mTriangleVerticesData = floatArrayOf(\r\n            -1.0f, -1.0f, 0f, 0f, 0f,\r\n            1.0f, -1.0f, 0f, 1f, 0f,\r\n            -1.0f, 1.0f, 0f, 0f, 1f,\r\n            1.0f, 1.0f, 0f, 1f, 1f\r\n        )\r\n\r\n        private const val FLOAT_SIZE_BYTES = 4\r\n        private const val TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES\r\n        private const val TRIANGLE_VERTICES_DATA_POS_OFFSET = 0\r\n        private const val TRIANGLE_VERTICES_DATA_UV_OFFSET = 3\r\n\r\n        /** バーテックスシェーダー。位置を決める */\r\n        private const val VERTEX_SHADER = \"\"\"\r\n            uniform mat4 uMVPMatrix;\r\n            uniform mat4 uSTMatrix;\r\n            attribute vec4 aPosition;\r\n            attribute vec4 aTextureCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            void main() {\r\n              gl_Position = uMVPMatrix * aPosition;\r\n              vTextureCoord = (uSTMatrix * aTextureCoord).xy;\r\n            }\r\n        \"\"\"\r\n\r\n        /** フラグメントシェーダー。色を決める */\r\n        private const val FRAGMENT_SHADER = \"\"\"\r\n            #extension GL_OES_EGL_image_external : require\r\n            precision mediump float;\r\n            varying vec2 vTextureCoord;\r\n            uniform samplerExternalOES uMainCameraTexture;        \r\n            uniform samplerExternalOES uSubCameraTexture;        \r\n            \r\n            // メイン映像を描画する場合は 1\r\n            uniform int uDrawMainCamera;\r\n        \r\n            void main() {\r\n                vec4 mainCameraTexture = texture2D(uMainCameraTexture, vTextureCoord);\r\n                vec4 subCameraTexture = texture2D(uSubCameraTexture, vTextureCoord);\r\n                \r\n                if (bool(uDrawMainCamera)) {\r\n                    gl_FragColor = mainCameraTexture;                \r\n                } else {\r\n                    gl_FragColor = subCameraTexture;\r\n                }\r\n            }\r\n        \"\"\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n詳しくは`MainActivity`に書くときに、、\r\n\r\n# MainActivity.kt\r\n\r\n## 権限を求める\r\n特に記述することはなく...\r\n\r\n```\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    private val isPermissionGranted: Boolean\r\n        get() = ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED\r\n                && ContextCompat.checkSelfPermission(this, android.Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED\r\n\r\n    private val surfaceView by lazy { SurfaceView(this) }\r\n\r\n    private val permissionRequest = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) {\r\n        if (it.all { it.value }) {\r\n            // onResume で代替\r\n            // setup()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(surfaceView)\r\n    }\r\n\r\n    private fun setup() {\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## SurfaceView の準備を待つ関数\r\n`MainActivity`に`SurfaceView`の用意が終わるまで待つ関数を書きます。\r\n\r\n```\r\n/** Surface の用意が終わるまで一時停止する */\r\nprivate suspend fun waitSurface() = suspendCoroutine { continuation ->\r\n    surfaceView.holder.apply {\r\n        if (surface.isValid) {\r\n            continuation.resume(this)\r\n        } else {\r\n            addCallback(object : SurfaceHolder.Callback {\r\n                override fun surfaceCreated(holder: SurfaceHolder) {\r\n                    continuation.resume(holder)\r\n                }\r\n                override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {\r\n                    // do nothing\r\n                }\r\n                override fun surfaceDestroyed(holder: SurfaceHolder) {\r\n                    // do nothing\r\n                }\r\n            })\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## カメラを開いてプレビューする\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity(), SurfaceTexture.OnFrameAvailableListener {\r\n\r\n    /** 生成した [GLSurface] */\r\n    private val glSurfaceList = arrayListOf<GLSurface>()\r\n\r\n    /** 利用中の [CameraControl] */\r\n    private val cameraControlList = arrayListOf<CameraControl>()\r\n\r\n    /** プレビュー用に生成した [SurfaceTexture] */\r\n    private val previewSurfaceTexture = arrayListOf<SurfaceTexture>()\r\n\r\n    /** onFrameAvailable が呼ばれたら +1 していく */\r\n    private var unUsedFrameCount = 0L\r\n\r\n    /** updateTexImage を呼んだら +1 していく */\r\n    private var usedFrameCount = 0L\r\n\r\n    /** カメラ用コルーチンJob */\r\n    private var cameraJob: Job? = null\r\n\r\n    // 省略...\r\n\r\n    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {\r\n        // 更新を通知するため、値を更新する\r\n        latestUpdateCount++\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        if (isPermissionGranted) {\r\n            setup()\r\n        }\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        // リソース開放\r\n        cameraJob?.cancel()\r\n        previewSurfaceTexture.forEach {\r\n            it.setOnFrameAvailableListener(null)\r\n            it.release()\r\n        }\r\n        glSurfaceList.clear()\r\n        previewSurfaceTexture.forEach { it.release() }\r\n        previewSurfaceTexture.clear()\r\n        cameraControlList.forEach { it.destroy() }\r\n        cameraControlList.clear()\r\n    }\r\n\r\n    private fun setup() {\r\n        cameraJob = lifecycleScope.launch(Dispatchers.IO) {\r\n            // SurfaceView を待つ\r\n            val previewSurface = waitSurface()\r\n\r\n            // CameraRenderer を作る\r\n            val cameraGLRenderer = CameraGLRenderer(\r\n                rotation = if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 90f else 0f, // 画面回転\r\n                mainSurfaceTexture = { previewSurfaceTexture[0] },\r\n                subSurfaceTexture = { previewSurfaceTexture[1] }\r\n            )\r\n            // GLSurface を作る\r\n            val glSurface = GLSurface(\r\n                surface = previewSurface,\r\n                renderer = cameraGLRenderer,\r\n            )\r\n            glSurface.makeCurrent()\r\n            glSurfaceList += glSurface\r\n\r\n            // プレビューで利用する SurfaceTexture を用意\r\n            // SurfaceTexture の場合は setDefaultBufferSize で解像度の設定ができる\r\n            val previewSurfaceTexturePair = cameraGLRenderer.setupProgram().let { (mainCameraTextureId, subCameraTextureId) ->\r\n                // メイン映像\r\n                val main = SurfaceTexture(mainCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                // サブ映像\r\n                val sub = SurfaceTexture(subCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                main to sub\r\n            }\r\n            previewSurfaceTexture.addAll(previewSurfaceTexturePair.toList())\r\n\r\n            // どっちのカメラをメイン映像にするか\r\n            // 今回はメイン映像をバックカメラ、サブ映像（ワイプ）をフロントカメラに指定\r\n            val previewMainSurfaceTexture = previewSurfaceTexturePair.first\r\n            val previewSubSurfaceTexture = previewSurfaceTexturePair.second\r\n            // カメラを開く\r\n            val (backCameraId, frontCameraId) = CameraTool.getCameraId(this@MainActivity)\r\n            cameraControlList += CameraControl(this@MainActivity, backCameraId, Surface(previewMainSurfaceTexture))\r\n            cameraControlList += CameraControl(this@MainActivity, frontCameraId, Surface(previewSubSurfaceTexture))\r\n            cameraControlList.forEach { it.openCamera() }\r\n            // プレビューする\r\n            cameraControlList.forEach { it.startPreview() }\r\n\r\n            // OpenGL のレンダリングを行う\r\n            // isActive でこの cameraJob が終了されるまでループし続ける\r\n            // ここで行う理由ですが、makeCurrent したスレッドでないと glDrawArray できない？ + onFrameAvailable が UIスレッド なので重たいことはできないためです。\r\n            // ただ、レンダリングするタイミングは onFrameAvailable が更新されたタイミングなので、\r\n            // while ループを回して 新しいフレームが来ているか確認しています。\r\n            while (isActive) {\r\n                // OpenGL の描画よりも onFrameAvailable の更新のほうが早い？ため、更新が追いついてしまう\r\n                // そのため、消費したフレームとまだ消費していないフレームを比較するようにした\r\n                // https://stackoverflow.com/questions/14185661\r\n                if (unUsedFrameCount != usedFrameCount) {\r\n                    glSurfaceList.forEach {\r\n                        it.makeCurrent() // 多分いる\r\n                        it.drawFrame()\r\n                        it.swapBuffers()\r\n                    }\r\n                    usedFrameCount += 2 // メイン映像とサブ映像で2つ\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 省略...\r\n\r\n    companion object {\r\n\r\n        /** 720P 解像度 幅 */\r\n        private const val CAMERA_RESOLTION_WIDTH = 1280\r\n\r\n        /** 720P 解像度 高さ */\r\n        private const val CAMERA_RESOLTION_HEIGHT = 720\r\n\r\n    }\r\n```\r\n\r\n`SurfaceTexture.OnFrameAvailableListener`を実装します。これで`MainActivity`に新しいカメラの映像フレームが来たことを知ることができます。  \r\n映像が更新されたら、`drawFrame`と`swapBuffers`を呼び出すのですが、`makeCurrent`したスレッドの中で呼び出す必要があるみたいです？？？。  \r\nというわけで、`while`ループ内でどうにか処理しないといけないのですが、単純にフラグを持ってるだけだと描画されなくなります。  \r\n多分これと同じです：https://stackoverflow.com/questions/14185661/\r\n\r\nどうやら、`OpenGL`の描画中に`OnFrameAvailableListener`が呼ばれる？（`OnFrameAvailableListener`のほうが早いらしい？）のが原因らしいです。  \r\n直す方法ですが、`OnFrameAvailableListener`の呼ばれた回数をまず変数に持つようにしておきます。つまりまだ消費していないフレーム数ですね。  \r\nそして今度は`SurfaceTexture#updateTexImage`を呼んだ回数をまた変数に持つようにします。つまり消費したフレーム数ですね。  \r\nあとはこれが違う間はずっと描画するようにするととりあえず治っていそうです。  \r\n**が、なんかまぐれで動いてる気もしなくはない、、**\r\n\r\n```kotlin\r\nif (unUsedFrameCount != usedFrameCount) {\r\n    glSurfaceList.forEach {\r\n        it.makeCurrent() // 多分いる\r\n        it.drawFrame()\r\n        it.swapBuffers()\r\n    }\r\n    usedFrameCount += 2 // メイン映像とサブ映像で2つ\r\n    println(\"未利用フレーム = $unUsedFrameCount / 消費フレーム = $usedFrameCount\")\r\n}\r\n```\r\n\r\n```\r\n未利用フレーム = 6550 / 消費フレーム = 6572\r\n未利用フレーム = 6554 / 消費フレーム = 6574\r\n未利用フレーム = 6558 / 消費フレーム = 6576\r\n未利用フレーム = 6562 / 消費フレーム = 6578\r\n未利用フレーム = 6562 / 消費フレーム = 6580\r\n```\r\n\r\nちなみに`OnFrameAvailableListener`は引数を省略した場合はUIスレッドっぽいです。Handlerが渡せるので別スレッドでも出来るんかな。  \r\n多分`drawFrame`と`swapBuffers`をUIスレッドでやったら重たくなると思う、、、\r\n\r\n`CameraGLRenderer`の`rotation`で映像の回転をしています。これで画面回転しても映像が引き伸ばされたりしません！多分。\r\n映像の解像度ですが、`SurfaceTexture`の場合は`SurfaceTexture#setDefaultBufferSize`で指定できます。  \r\n\r\nあとはリソース開放ですね、`onResume`でカメラを開き`onPause`で後片付けをします。カメラは他アプリも利用するためちゃんと使ったら後片付けしましょう。\r\n\r\n# SurfaceViewが引き伸ばされている\r\n縦画面なら、横幅いっぱいに縦を調整する。横画面なら縦いっぱいにして横を調整する。ようなコードを書けばいいのですが、面倒なので、  \r\n`View`なら`ConstraintLayout`の`layout_constraintDimensionRatio`、`JetpackCompose`なら`Modifier.aspect`があるので使うといいと思います。\r\n\r\n```kotlin\r\nsetContent {\r\n    Box(modifier = Modifier.fillMaxSize()) {\r\n        AndroidView(\r\n            modifier = Modifier\r\n                .align(Alignment.Center)\r\n                // 16:9 のアスペクト比にする\r\n                .aspectRatio(\r\n                    if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                        CAMERA_RESOLTION_WIDTH.toFloat() / CAMERA_RESOLTION_HEIGHT.toFloat()\r\n                    } else {\r\n                        CAMERA_RESOLTION_HEIGHT.toFloat() / CAMERA_RESOLTION_WIDTH.toFloat()\r\n                    }\r\n                ),\r\n            factory = { surfaceView }\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n# システムバーを消したい\r\nはい。\r\n\r\n```kotlin\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n\r\n    // これ\r\n    WindowCompat.getInsetsController(window, window.decorView).apply {\r\n        hide(WindowInsetsCompat.Type.systemBars())\r\n        systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\r\n    }\r\n    \r\n    setContent {\r\n        // 省略...\r\n    }\r\n}\r\n```\r\n\r\nまた、ノッチやパンチホールがある場合は追加で以下を書き足すことで消すことができます。\r\n\r\n```kotlin\r\nwindow.setDecorFitsSystemWindows(false)\r\nwindow.attributes.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\r\n```\r\n\r\n# 撮影機能\r\nとりあえず撮影ボタンを置きます。話はそれから\r\n\r\n```kotlin\r\nBox(\r\n    modifier = Modifier\r\n        .background(Color.Black)\r\n        .fillMaxSize()\r\n) {\r\n    AndroidView(\r\n        modifier = Modifier\r\n            .align(Alignment.Center)\r\n            // 16:9 のアスペクト比にする\r\n            .aspectRatio(\r\n                if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                    CAMERA_RESOLTION_WIDTH.toFloat() / CAMERA_RESOLTION_HEIGHT.toFloat()\r\n                } else {\r\n                    CAMERA_RESOLTION_HEIGHT.toFloat() / CAMERA_RESOLTION_WIDTH.toFloat()\r\n                }\r\n            ),\r\n        factory = { surfaceView }\r\n    )\r\n    Button(\r\n        modifier = Modifier.align(Alignment.BottomCenter),\r\n        onClick = { /* TODO */ }\r\n    ) { Text(text = \"撮影する\") }\r\n}\r\n```\r\n\r\n## 2つの方法で撮影できる\r\n1つ目が、今描画している `SurfaceView` をキャプチャする方法。  \r\n`OpenGL`に標準装備している`glReadPixels`を使うか、`SurfaceView`を`PixelCopy`で`Bitmap`にしてもいいと思います。  \r\n`PixelCopy`の例はいっぱいあると思うので、`OpenGL`の方で作ってみます。\r\n\r\nもう一つは、`ImageReader`を利用する方法。  \r\nこれは`Surface`の入力から画像を生成できるやつです。多分こっちを使うのが正攻法な気がします。\r\n\r\n### glReadPixels する\r\n`MainActivity`に書きました。\r\n\r\n```kotlin\r\n/** glReadPixels する場合は true。処理を受け付けたら false */\r\nprivate var isCaptureRequest = false\r\n\r\n/** SurfaceView のサイズ */\r\nprivate var size: IntRect? = null\r\n\r\n// 省略\r\n\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n\r\n    WindowCompat.getInsetsController(window, window.decorView).apply {\r\n        hide(WindowInsetsCompat.Type.systemBars())\r\n        systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\r\n    }\r\n    window.setDecorFitsSystemWindows(false)\r\n    window.attributes.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\r\n\r\n    setContent {\r\n        Box(\r\n            modifier = Modifier\r\n                .background(Color.Black)\r\n                .fillMaxSize()\r\n        ) {\r\n            AndroidView(\r\n                modifier = Modifier\r\n                    .align(Alignment.Center)\r\n                    .onGloballyPositioned {\r\n                        // サイズをとる\r\n                        size = it.size.toIntRect()\r\n                    }\r\n                    // 16:9 のアスペクト比にする\r\n                    .aspectRatio(\r\n                        if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                            CAMERA_RESOLTION_WIDTH.toFloat() / CAMERA_RESOLTION_HEIGHT.toFloat()\r\n                        } else {\r\n                            CAMERA_RESOLTION_HEIGHT.toFloat() / CAMERA_RESOLTION_WIDTH.toFloat()\r\n                        }\r\n                    ),\r\n                factory = { surfaceView }\r\n            )\r\n            Button(\r\n                modifier = Modifier.align(Alignment.BottomCenter),\r\n                onClick = {\r\n                    // 撮影フラグを立てる\r\n                    isCaptureRequest = true\r\n                }\r\n            ) { Text(text = \"撮影する\") }\r\n        }\r\n    }\r\n}\r\n\r\n// 省略\r\n\r\nprivate fun setup() {\r\n    cameraJob = lifecycleScope.launch(Dispatchers.IO) {\r\n\r\n        // 省略\r\n\r\n        while (isActive) {\r\n\r\n            // 省略...\r\n\r\n            // 撮影リクエストがあった場合\r\n            if (isCaptureRequest) {\r\n                isCaptureRequest = false\r\n                val bitmap = capture(size!!.width, size!!.height)\r\n                insertPhoto(\"${System.currentTimeMillis()}.jpg\", bitmap)\r\n                bitmap.recycle()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** ギャラリーに登録する */\r\nfun insertPhoto(name: String, bitmap: Bitmap) {\r\n    val contentResolver = contentResolver\r\n    val contentValues = contentValuesOf(\r\n        MediaStore.Images.Media.DISPLAY_NAME to name,\r\n        MediaStore.Images.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_PICTURES}/ArisaDroid\"\r\n    )\r\n    val uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues) ?: return\r\n    contentResolver.openOutputStream(uri).use { outputStream ->\r\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)\r\n    }\r\n}\r\n\r\n/** OpenGLの描画内容を Bitmap にする */\r\nfun capture(width: Int, height: Int): Bitmap {\r\n    val pixels = IntArray(width * height)\r\n    val buffer = IntBuffer.wrap(pixels)\r\n    buffer.position(0)\r\n    GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer)\r\n    val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\r\n    bitmap.copyPixelsFromBuffer(buffer)\r\n    return bitmap\r\n}\r\n\r\n// 省略\r\n\r\n```\r\n\r\nどうしても`makeCurrent`したスレッドでないと呼び出せない関係上、雑な処理になってしまった。  \r\n手軽？にキャプチャ出来る一方、問題点としては解像度ではなく、`SurfaceView`のサイズになってしまう点ですね。あと反転してるし回転もしているのでめんどい！！！  \r\nプログラムもきたねえし。\r\n\r\n### もう一つの方法、ImageReader\r\n多分こっちで撮影するのが正解だと思います。  \r\n`ImageReader`を利用すると、`Surface`の出力をキャプチャすることができます。カメラの映像や`MediaCodec`の出力先`Surface`として`ImageReader`を利用すると、画像の`JPEG`とかで取得できるんだと思います。  \r\nなので、今回は`プレビュー用SurfaceView`とは別に`静止画撮影用Surface`を作ることにします。  \r\n絵にするとこんなイメージですね。\r\n\r\n![Imgur](https://imgur.com/IbiX9B3.png)\r\n\r\n#### ImageReader で撮影する\r\n\r\n##### CameraControl\r\n`Surface`をプレビューと撮影用で2つ取るようにしました。  \r\n`captureSurface`が引数に増えている点、`startCamera`に`captureSurface`を追加する処理がふえてます。\r\n\r\n```kotlin\r\n/**\r\n * カメラを開けたり閉じたりする処理を隠蔽するクラス\r\n *\r\n * @param context [Context]\r\n * @param cameraId カメラID、前面 or 背面\r\n * @param previewSurface プレビューSurface\r\n * @param captureSurface 撮影、録画 用Surface\r\n */\r\nclass CameraControl(\r\n    context: Context,\r\n    private val cameraId: String,\r\n    private val previewSurface: Surface,\r\n    private val captureSurface: Surface\r\n) {\r\n    private val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n    private val cameraExecutor = Executors.newSingleThreadExecutor()\r\n    private var cameraDevice: CameraDevice? = null\r\n\r\n    /** カメラを開く */\r\n    suspend fun openCamera() {\r\n        cameraDevice = waitOpenCamera()\r\n    }\r\n\r\n    /** カメラを開始する */\r\n    fun startCamera() {\r\n        val cameraDevice = cameraDevice ?: return\r\n        val captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE).apply {\r\n            addTarget(previewSurface)\r\n            addTarget(captureSurface)\r\n        }.build()\r\n        val outputList = buildList {\r\n            add(OutputConfiguration(previewSurface))\r\n            add(OutputConfiguration(captureSurface))\r\n        }\r\n        SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n            override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                captureSession.setRepeatingRequest(captureRequest, null, null)\r\n            }\r\n\r\n            override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n                // do nothing\r\n            }\r\n        }).apply { cameraDevice.createCaptureSession(this) }\r\n    }\r\n\r\n    /** 終了時に呼び出す */\r\n    fun destroy() {\r\n        cameraDevice?.close()\r\n    }\r\n\r\n    /** [cameraId]のカメラを開く */\r\n    @SuppressLint(\"MissingPermission\")\r\n    suspend private fun waitOpenCamera() = suspendCoroutine {\r\n        cameraManager.openCamera(cameraId, cameraExecutor, object : CameraDevice.StateCallback() {\r\n            override fun onOpened(camera: CameraDevice) {\r\n                it.resume(camera)\r\n            }\r\n\r\n            override fun onDisconnected(camera: CameraDevice) {\r\n                // do nothing\r\n            }\r\n\r\n            override fun onError(camera: CameraDevice, error: Int) {\r\n                // do nothing\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n```\r\n\r\n##### MainActivity\r\n`setup`で、プレビュー用のSurface、撮影用のSurfaceの2つ分、セットアップするように修正します。  \r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity(), SurfaceTexture.OnFrameAvailableListener {\r\n\r\n    // 省略...\r\n\r\n    private val isLandscape: Boolean\r\n        get() = resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE\r\n\r\n    /** 静止画撮影  */\r\n    private var imageReader: ImageReader? = null\r\n\r\n    // 省略...\r\n\r\n    private fun setup() {\r\n        cameraJob = lifecycleScope.launch(Dispatchers.IO) {\r\n            // SurfaceView を待つ\r\n            val previewSurface = waitSurface()\r\n            // 静止画撮影で利用する ImageReader\r\n            // Surface の入力から画像を生成できる\r\n            val imageReader = ImageReader.newInstance(\r\n                if (isLandscape) CAMERA_RESOLTION_WIDTH else CAMERA_RESOLTION_HEIGHT,\r\n                if (isLandscape) CAMERA_RESOLTION_HEIGHT else CAMERA_RESOLTION_WIDTH,\r\n                PixelFormat.RGBA_8888, // JPEG は OpenGL 使ったせいなのか利用できない\r\n                2\r\n            )\r\n            this@MainActivity.imageReader = imageReader\r\n\r\n            // CameraRenderer を作る\r\n            val previewCameraGLRenderer = CameraGLRenderer(\r\n                rotation = if (isLandscape) 90f else 0f, // 画面回転\r\n                mainSurfaceTexture = { previewSurfaceTexture[0] },\r\n                subSurfaceTexture = { previewSurfaceTexture[1] }\r\n            )\r\n            val captureCameraGLRenderer = CameraGLRenderer(\r\n                rotation = if (isLandscape) 90f else 0f, // 画面回転\r\n                mainSurfaceTexture = { previewSurfaceTexture[2] },\r\n                subSurfaceTexture = { previewSurfaceTexture[3] }\r\n            )\r\n            // GLSurface を作る\r\n            val previewGlSurface = GLSurface(\r\n                surface = previewSurface,\r\n                renderer = previewCameraGLRenderer,\r\n            )\r\n            val captureGlSurface = GLSurface(\r\n                surface = imageReader.surface,\r\n                renderer = captureCameraGLRenderer\r\n            )\r\n            glSurfaceList += previewGlSurface\r\n            glSurfaceList += captureGlSurface\r\n\r\n            // プレビュー / 静止画撮影 で利用する SurfaceTexture を用意\r\n            // SurfaceTexture の場合は setDefaultBufferSize でカメラの解像度の設定ができる (720P など)\r\n            previewGlSurface.makeCurrent()\r\n            val previewSurfaceTexturePair = previewCameraGLRenderer.setupProgram().let { (mainCameraTextureId, subCameraTextureId) ->\r\n                // メイン映像\r\n                val main = SurfaceTexture(mainCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                // サブ映像\r\n                val sub = SurfaceTexture(subCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                main to sub\r\n            }\r\n            captureGlSurface.makeCurrent()\r\n            val captureSurfaceTexturePair = captureCameraGLRenderer.setupProgram().let { (mainCameraTextureId, subCameraTextureId) ->\r\n                // メイン映像\r\n                val main = SurfaceTexture(mainCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                // サブ映像\r\n                val sub = SurfaceTexture(subCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                main to sub\r\n            }\r\n            previewSurfaceTexture.addAll(previewSurfaceTexturePair.toList())\r\n            previewSurfaceTexture.addAll(captureSurfaceTexturePair.toList())\r\n\r\n            // どっちのカメラをメイン映像にするか\r\n            // 今回はメイン映像をバックカメラ、サブ映像（ワイプ）をフロントカメラに指定\r\n            // 以下のリストは メイン/ザブ 映像に指定する SurfaceTexture のリスト\r\n            val mainSurfaceTexture = listOf(previewSurfaceTexturePair.first, captureSurfaceTexturePair.first)\r\n            val subSurfaceTexture = listOf(previewSurfaceTexturePair.second, captureSurfaceTexturePair.second)\r\n\r\n            // カメラを開く\r\n            val (backCameraId, frontCameraId) = CameraTool.getCameraId(this@MainActivity)\r\n            cameraControlList += CameraControl(this@MainActivity, backCameraId, Surface(mainSurfaceTexture[0]), Surface(mainSurfaceTexture[1]))\r\n            cameraControlList += CameraControl(this@MainActivity, frontCameraId, Surface(subSurfaceTexture[0]), Surface(subSurfaceTexture[1]))\r\n            cameraControlList.forEach { it.openCamera() }\r\n            // プレビューする\r\n            cameraControlList.forEach { it.startCamera() }\r\n\r\n            // OpenGL のレンダリングを行う\r\n            // isActive でこの cameraJob が終了されるまでループし続ける\r\n            // ここで行う理由ですが、makeCurrent したスレッドでないと glDrawArray できない？ + onFrameAvailable が UIスレッド なので重たいことはできないためです。\r\n            // ただ、レンダリングするタイミングは onFrameAvailable が更新されたタイミングなので、\r\n            // while ループを回して 新しいフレームが来ているか確認しています。\r\n            while (isActive) {\r\n                // OpenGL の描画よりも onFrameAvailable の更新のほうが早い？ため、更新が追いついてしまう\r\n                // そのため、消費したフレームとまだ消費していないフレームを比較するようにした\r\n                // https://stackoverflow.com/questions/14185661\r\n                if (unUsedFrameCount != usedFrameCount) {\r\n                    glSurfaceList.forEach {\r\n                        it.makeCurrent() // 多分いる\r\n                        it.drawFrame()\r\n                        it.swapBuffers()\r\n                    }\r\n                    usedFrameCount += 2 // メイン映像とサブ映像で2つ\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** [imageReader]から取り出して保存する */\r\n    private fun capture() {\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            // ImageReader から取り出す\r\n            val image = imageReader?.acquireLatestImage() ?: return@launch\r\n            val width = image.width\r\n            val height = image.height\r\n            val planes = image.planes\r\n            val buffer = planes[0].buffer\r\n            // なぜか ImageReader のサイズに加えて、何故か Padding が入っていることを考慮する必要がある\r\n            val pixelStride = planes[0].pixelStride\r\n            val rowStride = planes[0].rowStride\r\n            val rowPadding = rowStride - pixelStride * width\r\n            // Bitmap 作成\r\n            val readBitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888)\r\n            readBitmap.copyPixelsFromBuffer(buffer)\r\n            // 余分な Padding を消す\r\n            val originWidth = if (isLandscape) CAMERA_RESOLTION_WIDTH else CAMERA_RESOLTION_HEIGHT\r\n            val originHeight = if (isLandscape) CAMERA_RESOLTION_HEIGHT else CAMERA_RESOLTION_WIDTH\r\n            val editBitmap = Bitmap.createBitmap(readBitmap, 0, 0, originWidth, originHeight)\r\n            readBitmap.recycle()\r\n            // ギャラリーに登録する\r\n            val contentResolver = contentResolver\r\n            val contentValues = contentValuesOf(\r\n                MediaStore.Images.Media.DISPLAY_NAME to \"${System.currentTimeMillis()}.jpg\",\r\n                MediaStore.Images.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_PICTURES}/ArisaDroid\"\r\n            )\r\n            val uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues) ?: return@launch\r\n            contentResolver.openOutputStream(uri).use { outputStream ->\r\n                editBitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)\r\n            }\r\n            editBitmap.recycle()\r\n            image.close()\r\n        }\r\n    }\r\n\r\n```\r\n\r\nあとは`capture`関数を呼ぶ部分を作り、リソース開放のための呼び出しを追加する。\r\n\r\n```kotlin\r\nButton(\r\n    modifier = Modifier\r\n        .padding(bottom = 30.dp)\r\n        .align(Alignment.BottomCenter),\r\n    onClick = { capture() }\r\n) { Text(text = \"撮影する\") }\r\n```\r\n\r\n```kotlin\r\noverride fun onPause() {\r\n    super.onPause()\r\n    // リソース開放\r\n    cameraJob?.cancel()\r\n    previewSurfaceTexture.forEach {\r\n        it.setOnFrameAvailableListener(null)\r\n        it.release()\r\n    }\r\n    imageReader?.close()\r\n    previewSurfaceTexture.clear()\r\n    glSurfaceList.forEach { it.release() }\r\n    glSurfaceList.clear()\r\n    cameraControlList.forEach { it.destroy() }\r\n    cameraControlList.clear()\r\n}\r\n```\r\n\r\nこれで縦でも横でも撮影ができているはずです、、、！どうでしょう？  \r\n`glReadPixels`と違い、撮影の写真サイズを指定できます。（まぁ後述しますが`ImageReader`のせいで`Bitmap`を加工する必要はありますが）（`glReadPixels`でも`Bitmap`を加工すればサイズ変更できますが、、、）  \r\n\r\nわなとしては、`ImageReader`から取得した画像に黒帯が何故か追加されるのがあります。  \r\n何故か`newInstance`したときに指定したサイズと、生成した`Bitmap`のサイズが一致していません。（`Bitmap.createBitmap`に渡すサイズは厳守する必要があります。乱れます）  \r\nよく分からんので`Bitmap.createBitmap(加工前Bitmap , left , top , right , bottom )`で要らない部分を削りました。OOMなりそうで怖い  \r\n\r\nあとそのまま`JPEG`として取り出す機能が`ImageReader`にあるみたいですが、`OpenGL`とかで加工しているせいか、以下のエラーで利用できませんでした。  \r\n（`rgba override blob format buffer should have height == width`）  \r\n`PixelFormat.RGBA_8888`を使い、`Bitmap.createBitmap`で`Bitmap`にしたあと、`Bitmap#compress`を呼び出すことで`JPEG`画像にできます。\r\n\r\n# 録画機能をつける (つまり最終的な MainActivity )\r\n`ImageReader`のように、プレビュー用Surface以外に録画用Surfaceを用意することで利用できます。  \r\n録画用Surfaceは`MediaRecorder`から取得できるやつです。低レベルの`MediaCodec`でも録画できますがわざわざ難しい方使う必要もないと思います。  \r\n\r\n![Imgur](https://imgur.com/PsDLFGR.png)\r\n\r\nいか実装例。`MainActivity`に全部書きました。差分も多いので全部のせます。解説は後で  \r\n静止画撮影と動画撮影はどっちかしか利用できない用になってます（まぁええやろ）。  \r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity(), SurfaceTexture.OnFrameAvailableListener {\r\n\r\n    private val isPermissionGranted: Boolean\r\n        get() = ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED\r\n                && ContextCompat.checkSelfPermission(this, android.Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED\r\n\r\n    private val isLandscape: Boolean\r\n        get() = resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE\r\n\r\n    private val surfaceView by lazy { SurfaceView(this) }\r\n\r\n    private val permissionRequest = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) {\r\n        if (it.all { it.value }) {\r\n            // onResume で代替\r\n            // setup()\r\n        }\r\n    }\r\n\r\n    /** 生成した [GLSurface] */\r\n    private val glSurfaceList = arrayListOf<GLSurface>()\r\n\r\n    /** 利用中の [CameraControl] */\r\n    private val cameraControlList = arrayListOf<CameraControl>()\r\n\r\n    /** 生成した [SurfaceTexture] */\r\n    private val previewSurfaceTexture = arrayListOf<SurfaceTexture>()\r\n\r\n    /** onFrameAvailable が呼ばれたら +1 していく */\r\n    private var unUsedFrameCount = 0L\r\n\r\n    /** updateTexImage を呼んだら +1 していく */\r\n    private var usedFrameCount = 0L\r\n\r\n    /** カメラ用スレッド */\r\n    private var cameraJob: Job? = null\r\n\r\n    /**\r\n     * 撮影モード\r\n     *\r\n     * 静止画撮影なら[imageReader]、動画撮影なら[mediaRecorder]が使われます\r\n     */\r\n    private var currentCaptureMode = CameraCaptureMode.VIDEO\r\n\r\n    /** 静止画撮影  */\r\n    private var imageReader: ImageReader? = null\r\n\r\n    /** 録画機能 */\r\n    private var mediaRecorder: MediaRecorder? = null\r\n\r\n    /** 録画中か */\r\n    private var isRecording = false\r\n\r\n    /** 録画中ファイル */\r\n    private var saveVideoFile: File? = null\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        // これ\r\n        WindowCompat.getInsetsController(window, window.decorView).apply {\r\n            hide(WindowInsetsCompat.Type.systemBars())\r\n            systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\r\n        }\r\n        window.setDecorFitsSystemWindows(false)\r\n        window.attributes.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\r\n\r\n        setContent {\r\n            Box(\r\n                modifier = Modifier\r\n                    .background(Color.Black)\r\n                    .fillMaxSize()\r\n            ) {\r\n                AndroidView(\r\n                    modifier = Modifier\r\n                        .align(Alignment.Center)\r\n                        // 16:9 のアスペクト比にする\r\n                        .aspectRatio(\r\n                            if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                                CAMERA_RESOLTION_WIDTH.toFloat() / CAMERA_RESOLTION_HEIGHT.toFloat()\r\n                            } else {\r\n                                CAMERA_RESOLTION_HEIGHT.toFloat() / CAMERA_RESOLTION_WIDTH.toFloat()\r\n                            }\r\n                        ),\r\n                    factory = { surfaceView }\r\n                )\r\n                Button(\r\n                    modifier = Modifier\r\n                        .padding(bottom = 30.dp)\r\n                        .align(Alignment.BottomCenter),\r\n                    onClick = { capture() }\r\n                ) { Text(text = \"撮影 録画 する\") }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {\r\n        // 更新を通知するため、値を更新する\r\n        unUsedFrameCount++\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        if (isPermissionGranted) {\r\n            setup()\r\n        } else {\r\n            permissionRequest.launch(arrayOf(android.Manifest.permission.CAMERA, android.Manifest.permission.RECORD_AUDIO))\r\n        }\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            cameraDestroy()\r\n        }\r\n    }\r\n\r\n    /** リソース開放。サスペンド関数なので終わるまで一時停止する */\r\n    private suspend fun cameraDestroy() {\r\n        // キャンセル待ちをすることでGLのループを抜けるのを待つ（多分描画中に終了すると落ちる）\r\n        cameraJob?.cancelAndJoin()\r\n        previewSurfaceTexture.forEach {\r\n            it.setOnFrameAvailableListener(null)\r\n            it.release()\r\n        }\r\n        previewSurfaceTexture.clear()\r\n        imageReader?.close()\r\n        glSurfaceList.forEach { it.release() }\r\n        glSurfaceList.clear()\r\n        cameraControlList.forEach { it.destroy() }\r\n        cameraControlList.clear()\r\n        if (isRecording) {\r\n            mediaRecorder?.stop()\r\n        }\r\n        mediaRecorder?.release()\r\n        mediaRecorder = null\r\n    }\r\n\r\n    private fun setup() {\r\n        cameraJob = lifecycleScope.launch(Dispatchers.IO) {\r\n            // SurfaceView を待つ\r\n            val previewSurface = waitSurface()\r\n            // 撮影モードに合わせた Surface を作る（静止画撮影、動画撮影）\r\n            val captureSurface = if (currentCaptureMode == CameraCaptureMode.PICTURE) {\r\n                // 静止画撮影で利用する ImageReader\r\n                // Surface の入力から画像を生成できる\r\n                val imageReader = ImageReader.newInstance(\r\n                    if (isLandscape) CAMERA_RESOLTION_WIDTH else CAMERA_RESOLTION_HEIGHT,\r\n                    if (isLandscape) CAMERA_RESOLTION_HEIGHT else CAMERA_RESOLTION_WIDTH,\r\n                    PixelFormat.RGBA_8888, // JPEG は OpenGL 使ったせいなのか利用できない\r\n                    2\r\n                )\r\n                this@MainActivity.imageReader = imageReader\r\n                imageReader.surface\r\n            } else {\r\n                // メソッド呼び出しには順番があります\r\n                val mediaRecorder = (if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) MediaRecorder(this@MainActivity) else MediaRecorder()).apply {\r\n                    setAudioSource(MediaRecorder.AudioSource.MIC)\r\n                    setVideoSource(MediaRecorder.VideoSource.SURFACE)\r\n                    setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)\r\n                    setVideoEncoder(MediaRecorder.VideoEncoder.H264)\r\n                    setAudioEncoder(MediaRecorder.AudioEncoder.AAC)\r\n                    setAudioChannels(2)\r\n                    setVideoEncodingBitRate(1_000_000)\r\n                    setVideoFrameRate(30)\r\n                    if (isLandscape) {\r\n                        setVideoSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    } else {\r\n                        setVideoSize(CAMERA_RESOLTION_HEIGHT, CAMERA_RESOLTION_WIDTH)\r\n                    }\r\n                    setAudioEncodingBitRate(128_000)\r\n                    setAudioSamplingRate(44_100)\r\n                    saveVideoFile = File(getExternalFilesDir(null), \"${System.currentTimeMillis()}.mp4\")\r\n                    setOutputFile(saveVideoFile!!)\r\n                    prepare()\r\n                }\r\n                this@MainActivity.mediaRecorder = mediaRecorder\r\n                mediaRecorder.surface\r\n            }\r\n\r\n            // CameraRenderer を作る\r\n            val previewCameraGLRenderer = CameraGLRenderer(\r\n                rotation = if (isLandscape) 90f else 0f, // 画面回転\r\n                mainSurfaceTexture = { previewSurfaceTexture[0] },\r\n                subSurfaceTexture = { previewSurfaceTexture[1] }\r\n            )\r\n            val captureCameraGLRenderer = CameraGLRenderer(\r\n                rotation = if (isLandscape) 90f else 0f, // 画面回転\r\n                mainSurfaceTexture = { previewSurfaceTexture[2] },\r\n                subSurfaceTexture = { previewSurfaceTexture[3] }\r\n            )\r\n            // GLSurface を作る\r\n            val previewGlSurface = GLSurface(\r\n                surface = previewSurface,\r\n                renderer = previewCameraGLRenderer,\r\n            )\r\n            val captureGlSurface = GLSurface(\r\n                surface = captureSurface,\r\n                renderer = captureCameraGLRenderer\r\n            )\r\n            glSurfaceList += previewGlSurface\r\n            glSurfaceList += captureGlSurface\r\n\r\n            // プレビュー / 静止画撮影 で利用する SurfaceTexture を用意\r\n            // SurfaceTexture の場合は setDefaultBufferSize でカメラの解像度の設定ができる (720P など)\r\n            previewGlSurface.makeCurrent()\r\n            val previewSurfaceTexturePair = previewCameraGLRenderer.setupProgram().let { (mainCameraTextureId, subCameraTextureId) ->\r\n                // メイン映像\r\n                val main = SurfaceTexture(mainCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                // サブ映像\r\n                val sub = SurfaceTexture(subCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                main to sub\r\n            }\r\n            captureGlSurface.makeCurrent()\r\n            val captureSurfaceTexturePair = captureCameraGLRenderer.setupProgram().let { (mainCameraTextureId, subCameraTextureId) ->\r\n                // メイン映像\r\n                val main = SurfaceTexture(mainCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                // サブ映像\r\n                val sub = SurfaceTexture(subCameraTextureId).apply {\r\n                    setDefaultBufferSize(CAMERA_RESOLTION_WIDTH, CAMERA_RESOLTION_HEIGHT)\r\n                    setOnFrameAvailableListener(this@MainActivity)\r\n                }\r\n                main to sub\r\n            }\r\n            previewSurfaceTexture.addAll(previewSurfaceTexturePair.toList())\r\n            previewSurfaceTexture.addAll(captureSurfaceTexturePair.toList())\r\n\r\n            // どっちのカメラをメイン映像にするか\r\n            // 今回はメイン映像をバックカメラ、サブ映像（ワイプ）をフロントカメラに指定\r\n            // Pair は メイン映像に指定する SurfaceTexture のリスト\r\n            val mainSurfaceTexture = listOf(previewSurfaceTexturePair.first, captureSurfaceTexturePair.first)\r\n            val subSurfaceTexture = listOf(previewSurfaceTexturePair.second, captureSurfaceTexturePair.second)\r\n\r\n            // カメラを開く\r\n            val (backCameraId, frontCameraId) = CameraTool.getCameraId(this@MainActivity)\r\n            cameraControlList += CameraControl(this@MainActivity, backCameraId, Surface(mainSurfaceTexture[0]), Surface(mainSurfaceTexture[1]))\r\n            cameraControlList += CameraControl(this@MainActivity, frontCameraId, Surface(subSurfaceTexture[0]), Surface(subSurfaceTexture[1]))\r\n            cameraControlList.forEach { it.openCamera() }\r\n            // プレビューする\r\n            cameraControlList.forEach { it.startCamera() }\r\n\r\n            // OpenGL のレンダリングを行う\r\n            // isActive でこの cameraJob が終了されるまでループし続ける\r\n            // ここで行う理由ですが、makeCurrent したスレッドでないと glDrawArray できない？ + onFrameAvailable が UIスレッド なので重たいことはできないためです。\r\n            // ただ、レンダリングするタイミングは onFrameAvailable が更新されたタイミングなので、\r\n            // while ループを回して 新しいフレームが来ているか確認しています。\r\n            while (isActive) {\r\n                // OpenGL の描画よりも onFrameAvailable の更新のほうが早い？ため、更新が追いついてしまう\r\n                // そのため、消費したフレームとまだ消費していないフレームを比較するようにした\r\n                // https://stackoverflow.com/questions/14185661\r\n                if (unUsedFrameCount != usedFrameCount && isActive) {\r\n                    glSurfaceList.forEach {\r\n                        it.makeCurrent() // 多分いる\r\n                        it.drawFrame()\r\n                        it.swapBuffers()\r\n                    }\r\n                    usedFrameCount += 2 // メイン映像とサブ映像で2つ\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** 撮影、録画ボタンを押したとき */\r\n    private fun capture() {\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            if (currentCaptureMode == CameraCaptureMode.VIDEO) {\r\n                // 録画モード\r\n                if (!isRecording) {\r\n                    mediaRecorder?.start()\r\n                } else {\r\n                    // 多分 MediaRecorder を作り直さないといけない\r\n                    cameraDestroy()\r\n                    // 動画フォルダ に保存する\r\n                    val contentResolver = contentResolver\r\n                    val contentValues = contentValuesOf(\r\n                        MediaStore.Video.Media.DISPLAY_NAME to saveVideoFile?.name,\r\n                        MediaStore.Video.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_MOVIES}/ArisaDroid\"\r\n                    )\r\n                    contentResolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, contentValues)?.also { uri ->\r\n                        contentResolver.openOutputStream(uri)?.use { outputStream ->\r\n                            saveVideoFile?.inputStream()?.use { inputStream ->\r\n                                inputStream.copyTo(outputStream)\r\n                            }\r\n                        }\r\n                    }\r\n                    setup()\r\n                }\r\n                isRecording = !isRecording\r\n            } else {\r\n                // 静止画モード\r\n                // ImageReader から取り出す\r\n                val image = imageReader?.acquireLatestImage() ?: return@launch\r\n                val width = image.width\r\n                val height = image.height\r\n                val planes = image.planes\r\n                val buffer = planes[0].buffer\r\n                // なぜか ImageReader のサイズに加えて、何故か Padding が入っていることを考慮する必要がある\r\n                val pixelStride = planes[0].pixelStride\r\n                val rowStride = planes[0].rowStride\r\n                val rowPadding = rowStride - pixelStride * width\r\n                // Bitmap 作成\r\n                val readBitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888)\r\n                readBitmap.copyPixelsFromBuffer(buffer)\r\n                // 余分な Padding を消す\r\n                val originWidth = if (isLandscape) CAMERA_RESOLTION_WIDTH else CAMERA_RESOLTION_HEIGHT\r\n                val originHeight = if (isLandscape) CAMERA_RESOLTION_HEIGHT else CAMERA_RESOLTION_WIDTH\r\n                val editBitmap = Bitmap.createBitmap(readBitmap, 0, 0, originWidth, originHeight)\r\n                readBitmap.recycle()\r\n                // ギャラリーに登録する\r\n                val contentResolver = contentResolver\r\n                val contentValues = contentValuesOf(\r\n                    MediaStore.Images.Media.DISPLAY_NAME to \"${System.currentTimeMillis()}.jpg\",\r\n                    MediaStore.Images.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_PICTURES}/ArisaDroid\"\r\n                )\r\n                val uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues) ?: return@launch\r\n                contentResolver.openOutputStream(uri).use { outputStream ->\r\n                    editBitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)\r\n                }\r\n                editBitmap.recycle()\r\n                image.close()\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Surface の用意が終わるまで一時停止する */\r\n    private suspend fun waitSurface() = suspendCoroutine { continuation ->\r\n        surfaceView.holder.apply {\r\n            if (surface.isValid) {\r\n                continuation.resume(this.surface)\r\n            } else {\r\n                var callback: SurfaceHolder.Callback? = null\r\n                callback = object : SurfaceHolder.Callback {\r\n                    override fun surfaceCreated(holder: SurfaceHolder) {\r\n                        continuation.resume(holder.surface)\r\n                        removeCallback(callback)\r\n                    }\r\n\r\n                    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {\r\n                        // do nothing\r\n                    }\r\n\r\n                    override fun surfaceDestroyed(holder: SurfaceHolder) {\r\n                        // do nothing\r\n                    }\r\n                }\r\n                addCallback(callback)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** 撮影モード */\r\n    private enum class CameraCaptureMode {\r\n        PICTURE,\r\n        VIDEO,\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** 720P 解像度 幅 */\r\n        private const val CAMERA_RESOLTION_WIDTH = 1280\r\n\r\n        /** 720P 解像度 高さ */\r\n        private const val CAMERA_RESOLTION_HEIGHT = 720\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## ついでに 最終的な CameraControl \r\n\r\n```kotlin\r\n/**\r\n * カメラを開けたり閉じたりする処理を隠蔽するクラス\r\n *\r\n * @param context [Context]\r\n * @param cameraId カメラID、前面 or 背面\r\n * @param previewSurface プレビューSurface\r\n * @param captureSurface 撮影、録画 用Surface\r\n */\r\nclass CameraControl(\r\n    context: Context,\r\n    private val cameraId: String,\r\n    private val previewSurface: Surface,\r\n    private val captureSurface: Surface\r\n) {\r\n    private val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n    private val cameraExecutor = Executors.newSingleThreadExecutor()\r\n    private var cameraDevice: CameraDevice? = null\r\n\r\n    /** カメラを開く */\r\n    suspend fun openCamera() {\r\n        cameraDevice = waitOpenCamera()\r\n    }\r\n\r\n    /** カメラを開始する */\r\n    fun startCamera() {\r\n        val cameraDevice = cameraDevice ?: return\r\n        val captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE).apply {\r\n            addTarget(previewSurface)\r\n            addTarget(captureSurface)\r\n        }.build()\r\n        val outputList = buildList {\r\n            add(OutputConfiguration(previewSurface))\r\n            add(OutputConfiguration(captureSurface))\r\n        }\r\n        SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n            override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                captureSession.setRepeatingRequest(captureRequest, null, null)\r\n            }\r\n\r\n            override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n                // do nothing\r\n            }\r\n        }).apply { cameraDevice.createCaptureSession(this) }\r\n    }\r\n\r\n    /** 終了時に呼び出す */\r\n    fun destroy() {\r\n        cameraDevice?.close()\r\n    }\r\n\r\n    /** [cameraId]のカメラを開く */\r\n    @SuppressLint(\"MissingPermission\")\r\n    suspend private fun waitOpenCamera() = suspendCoroutine {\r\n        cameraManager.openCamera(cameraId, cameraExecutor, object : CameraDevice.StateCallback() {\r\n            override fun onOpened(camera: CameraDevice) {\r\n                it.resume(camera)\r\n            }\r\n\r\n            override fun onDisconnected(camera: CameraDevice) {\r\n                // do nothing\r\n            }\r\n\r\n            override fun onError(camera: CameraDevice, error: Int) {\r\n                // do nothing\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 解説\r\n`currentCaptureMode`は静止画が動画どっちなのかが入ってます。`setup()`の呼び出し前のみ変更できます。  \r\n`MediaRecorder`のコーデック指定に`H.264`を使ったのですが、`H.264`なのでビットレートを割りと高めにしないと残念な画質になると思います（今回は`1Mbps`にしてみたけど残念な画質）  \r\n\r\n静止画撮影と違い、録画を終了すると`MediaRecorder`を作り直す必要があるのですが、、部分的に作り直すのは（多分）できないのでプレビューから作り直す必要があります。  \r\nなので、`onPause`以外でもリソース開放出来るよう`cameraDestory()`関数に切り出し、録画停止時に全部作り直すようにしています。（正解なのかは知らない、、、そして若干時間がかかる）  \r\n \r\n`cameraJob.cancelAndJoin()`することで、キャンセルが完了するまで待ってくれます。`cancel`だと直ちには終了しないらしい。  \r\n`OpenGL の while ループ`を抜けた後にカメラとかのリソースを開放しないと`EGL`がなんとかで落ちてしまうので気をつけよう  \r\n（もろもろリソース開放後に`whileループ`が生き残ってたらしく落ちた）\r\n\r\n# そーすこーど\r\nすぐ使えると思う\r\n\r\n- https://github.com/takusan23/MultiCamera\r\n    - この記事時点のコード\r\n- https://github.com/takusan23/ArisaDroid\r\n    - 真面目に作ろうとしたけど考えること多すぎて作るか迷ってる\r\n    - 記述時時点からソースコード変更してると思うから前者の方を使ってください\r\n\r\n# そのほか\r\n## eglSwapBuffers: EGL error: 0x300d\r\n- `makeCurrent`呼んでますか？\r\n- `Surface`を破棄した後に`eglSwapBuffers`を呼び出していませんか？\r\n\r\n## Surface が終了したら リソース開放する\r\n書いてませんが、やらないといけないと思います。\r\n\r\n# 参考にしました\r\nthx!!!\r\n\r\n- https://github.com/android/camera-samples\r\n- https://stackoverflow.com/questions/14185661\r\n- https://cs.android.com/android/platform/superproject/+/master:cts/tests/media/common/src/android/mediav2/common/cts/InputSurface.java;l=1?\r\n- https://techbooster.org/android/application/17026/\r\n- https://medium.com/@itometeam/camera2-apiを使いこなす-part-1-プレビューの表示-e5e799a7b4dd\r\n\r\n# おまけ ズームする 前提編\r\nせっかくなのでズーム機能をつけようと思います。  \r\n`Camera 2 API`では`Android 11`以前から使える`SCALER_CROP_REGION`と以降で利用できる`CONTROL_ZOOM_RATIO_RANGE`があるっぽいです。  \r\n今回は後者の`CONTROL_ZOOM_RATIO_RANGE`を試します。なんか前者はズーム範囲を自前で計算？（四角形の座標を自前で用意する？）する必要があるらしく、  \r\n後者はそのまま 1f~ (広角搭載時は .7f ~ でしょうか) のような指定ができるようです。  \r\n\r\n`Pixel 6 Pro`だと望遠カメラ（ペリスコープ）も広角カメラも`CONTROL_ZOOM_RATIO_RANGE`を変更することで変更した値によって適切なカメラが自動で選択されるらしいです。（20を入れたら望遠、0.6を入れたら広角 みたいな）\r\n\r\nが、↑の方法が使えるのは、**論理カメラ**の場合のみです。（`getCameraIdList`でフロント、バックでそれぞれ一個ずつ配列に入っている場合）  \r\n**それとは別に**`Camera 2 API`の`getCameraIdList`でバックカメラの数だけ返ってくる場合（標準、広角、望遠 それぞれにIDが振られている）、選択中のカメラのズームのみが利用できます。  \r\n（標準カメラの場合は標準カメラが使えるズーム範囲のみ。もし標準→望遠にしたい場合はカメラを開き直すところからやる必要がある。）  \r\n（端末によっては録画中は物理カメラを変更できないやつがありますがこの辺が影響していそうですね。）  \r\n（今回は面倒なのでやらないです、、、）  \r\n\r\n## ズームする\r\n`CameraControl`内にズームできる範囲を取得できるプロパティを用意しました。  \r\n`Pixel 6 Pro`のバックカメラの場合は`0.6704426..20.0`が返ってきました。20倍ズーム！！ペリスコープすごい。可動部品を載せる勇気！！  \r\n（ペリスコープのせいでスマホを振るとカタカタ音が鳴るんだけどちょっと怖い。`pixel 6 pro rattle`で検索検索）\r\n\r\n```kotlin\r\nclass CameraControl(\r\n    context: Context,\r\n    private val cameraId: String,\r\n    private val previewSurface: Surface,\r\n    private val captureSurface: Surface\r\n) {\r\n\r\n    /** ズーム出来る値の範囲を返す */\r\n    val zoomRange = cameraManager.getCameraCharacteristics(cameraId)?.get(CameraCharacteristics.CONTROL_ZOOM_RATIO_RANGE)?.let {\r\n        // Pixel 6 Pro の場合は 0.6704426..20.0 のような値になる\r\n        it.lower..it.upper\r\n    } ?: 0f..0f\r\n\r\n```\r\n\r\n後はカメラ開始時にズームする値を渡せるようにします。  \r\n差分が面倒なので全部張ります。`captureRequest`と`currentCaptureSession`を他の構成でも使えるように移動させました。  \r\n`setRepeatingRequest`でズーム後の構成でカメラを利用できます。\r\n\r\n```kotlin\r\nclass CameraControl(\r\n    context: Context,\r\n    private val cameraId: String,\r\n    private val previewSurface: Surface,\r\n    private val captureSurface: Surface\r\n) {\r\n    private val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n    private val cameraExecutor = Executors.newSingleThreadExecutor()\r\n    private var cameraDevice: CameraDevice? = null\r\n\r\n    private var captureRequest: CaptureRequest.Builder? = null\r\n    private var currentCaptureSession: CameraCaptureSession? = null\r\n    private val outputList = buildList {\r\n        add(OutputConfiguration(previewSurface))\r\n        add(OutputConfiguration(captureSurface))\r\n    }\r\n\r\n    /** ズーム出来る値の範囲を返す */\r\n    val zoomRange = cameraManager.getCameraCharacteristics(cameraId)?.get(CameraCharacteristics.CONTROL_ZOOM_RATIO_RANGE)?.let {\r\n        // Pixel 6 Pro の場合は 0.6704426..20.0 のような値になる\r\n        it.lower..it.upper\r\n    } ?: 0f..0f\r\n\r\n    /** カメラを開く */\r\n    suspend fun openCamera() {\r\n        cameraDevice = waitOpenCamera()\r\n    }\r\n\r\n    /** カメラを開始する */\r\n    fun startCamera() {\r\n        val cameraDevice = cameraDevice ?: return\r\n        if (captureRequest == null) {\r\n            captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE).apply {\r\n                addTarget(previewSurface)\r\n                addTarget(captureSurface)\r\n            }\r\n        }\r\n        SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n            override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                currentCaptureSession = captureSession\r\n                captureSession.setRepeatingRequest(captureRequest!!.build(), null, null)\r\n            }\r\n\r\n            override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n                // do nothing\r\n            }\r\n        }).apply { cameraDevice.createCaptureSession(this) }\r\n    }\r\n\r\n    /**\r\n     * ズームする\r\n     * [startCamera]を呼び出した後のみ利用可能\r\n     */\r\n    fun zoom(zoom: Float = 1f) {\r\n        val captureRequest = captureRequest ?: return\r\n        val currentCaptureSession = currentCaptureSession ?: return\r\n\r\n        captureRequest.set(CaptureRequest.CONTROL_ZOOM_RATIO, zoom)\r\n        currentCaptureSession.setRepeatingRequest(captureRequest.build(), null, null)\r\n    }\r\n\r\n    /** 終了時に呼び出す */\r\n    fun destroy() {\r\n        cameraDevice?.close()\r\n    }\r\n\r\n    /** [cameraId]のカメラを開く */\r\n    @SuppressLint(\"MissingPermission\")\r\n    suspend private fun waitOpenCamera() = suspendCoroutine {\r\n        cameraManager.openCamera(cameraId, cameraExecutor, object : CameraDevice.StateCallback() {\r\n            override fun onOpened(camera: CameraDevice) {\r\n                it.resume(camera)\r\n            }\r\n\r\n            override fun onDisconnected(camera: CameraDevice) {\r\n                // do nothing\r\n            }\r\n\r\n            override fun onError(camera: CameraDevice, error: Int) {\r\n                // do nothing\r\n            }\r\n        })\r\n    }\r\n}\r\n```\r\n\r\nあとはシークバーのUI部品を置いて完成。  \r\nカメラを配列で管理するの、良くなかったですね。\r\n\r\n```kotlin\r\nval zoomValue = remember { mutableStateOf(1f) }\r\nval zoomRange = remember { mutableStateOf(0f..1f) }\r\nSideEffect {\r\n    // 非 Compose なコードので若干違和感\r\n    zoomRange.value = cameraControlList.firstOrNull()?.zoomRange ?: 0f..1f\r\n}\r\n\r\nSlider(\r\n    value = zoomValue.value,\r\n    valueRange = zoomRange.value,\r\n    onValueChange = {\r\n        zoomValue.value = it\r\n        // 前面カメラ は最初\r\n        cameraControlList.first().zoom(it)\r\n    }\r\n)\r\n```\r\nこれでちゃんとズームできるはず、。標準アプリ以外でもペリスコープカメラが使えてすごい。\r\n\r\n# おわりに1\r\nおそらく、静止画撮影の場合は`CameraCaptureSession#setRepeatingRequest`ではなく、`CameraCaptureSession#capture`を呼び出すべきですね。めんどいのでやってませんが。  \r\nそれと`CameraX`が使えたらとても楽だと思いサンプルコードをクローンした後、`前面、背面`カメラを同時に開こうとしましたが、、、  \r\n残念ながらできない？っぽいので、今回のような同時にカメラを利用する場合は`Cameara2 API`を使うしかなさそうですね。誰もしないでしょうが  \r\n\r\n```plaintext\r\nE/CameraXBasic: Use case binding failed\r\n    java.lang.IllegalArgumentException: Multiple LifecycleCameras with use cases are registered to the same LifecycleOwner.\r\n```\r\n\r\nあと`CameraX`でも`SurfaceTexture`も多分使えそう？だけど、`ImageAnalysis`？とか言うので`Bitmap`が取れるらしい？のでそれを`OpenGL`に転送すれば良さそうです。  \r\n何も分からん。\r\n\r\n# おわりに2\r\nつかれた  \r\nこうしてカメラアプリを作ってみると、プレビューを出すまでなのにすごい大変だなあというところです。（`CameraX`を使えるなら使えよという話ではある）  \r\n\r\nそれなのに電池残量が10%を切ったら使えなくなるとかで騒がれてて流石にかわいそうだと思いました。（というかこれで記事にするんか？）  \r\nhttps://www.itmedia.co.jp/news/articles/2302/17/news190.html\r\n\r\n老舗メーカーなので黎明期に10%あってもいきなり電池が切れるとかあっただろうし、  \r\nカメラよりも重要なプロセスが存在するような気がするし（キャリア端末だからなおさら）で、安全な方に倒しているので全然問題ないと思うんですが。。。。  \r\n\r\n動画撮影ならなおさらですね。途中で電池が切れて再生できないファイルが出来るより予め利用できない方へ倒すべきですね。シャットダウンまでの間に保存できるか分からん、、、  \r\n（最後に`moov atom`を動画ファイルに書き込むらしい（要検証）ので間に合わない可能性もある？書き込めなかったら動画ファイルとして認識されないので、、、）  \r\n\r\n以上です。お疲れ様でした。8888"},{"title":"NewRadioSupporter にウィジェットを追加するため Glance を使ってみた","link":"/posts/android_glance_new_radio_supporter/","markdown":"\r\nどうもこんばんわ。  \r\n\r\nスタディ§ステディ2 攻略しました、えちえちでした  \r\n\r\n![Imgur](https://imgur.com/QAZ5pFC.png)\r\n\r\nE-mote 搭載だから立ち絵がめっちゃ動く、  \r\n本編関係ないけど UI もアニメーション頑張っててすごいと思った（こなみかん、大変そう\r\n\r\n![Imgur](https://imgur.com/b5hbK9R.png)\r\n\r\n![Imgur](https://imgur.com/5Mo4atS.png)\r\n\r\nやえちゃん！！  \r\n前作ヒロイン?とのやりとりがあったんですけどやえちゃんルートのが好み  \r\nなまりかわいい\r\n\r\n![Imgur](https://imgur.com/VqPDyZ2.png)\r\n\r\n\r\n由乃ちゃんかわいいのでぜひ！！！\r\n\r\n![Imgur](https://imgur.com/oTgUbyj.png)\r\n\r\n![Imgur](https://imgur.com/yktGFri.png)\r\n\r\nこの目すき\r\n\r\n![Imgur](https://imgur.com/lWfNy23.png)\r\n\r\n![Imgur](https://imgur.com/Jb0694m.png)\r\n\r\nイベントCG貼るわけには行かないけどヒロインも背景もめっちゃきれいでした、すごい  \r\n過去の話とかちょろっと出てくるので由乃ちゃんルートは最後が良いかも？\r\n\r\n# 本題\r\n`NewRadioSupporter` にウィジェットを追加しました！お待たせしちゃいました  \r\nホーム画面からすぐ確認できます！！！\r\n\r\n![Imgur](https://imgur.com/NswvS41.png)\r\n\r\n大きいサイズも作りました、  \r\n後述しますが`Jetpack Glance`が面倒なことを全部肩代りしてくれたので大きいサイズも難しくないです。\r\n\r\n![Imgur](https://imgur.com/vpC9HXU.png)\r\n\r\n（小さいアプリみたいで結構気に入ってる）\r\n\r\nどうでもいいけどドコモの`n28`見つけた、わーい  \r\n\r\n高いキャリア版買ってよかった（まぁミリ波アンテナほしかったし...）\r\n\r\nで、今回はこの`NewRadioSupporter`でウィジェットを作るために使った`Jetpack Glance`のお話です。\r\n\r\n# Android Jetpack Glance\r\nhttps://developer.android.com/jetpack/compose/glance\r\n\r\n`Jetpack Compose`な文法で、`Android`の`ホーム画面ウィジェット`が作れる。 \r\nうーん`xml + RemoteViews`でウィジェットを作ったことがある身からすると現実味が無いんだけど、確かに動いているんですよね。  \r\n\r\n```kotlin\r\nclass MyAppWidget : GlanceAppWidget() {\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        provideContent {\r\n            Text(\"Hello World\")\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**なんで動いてるか分からんくて本当に魔法みたい**  \r\n不思議でたまらないけど、、、もしこれなら難しすぎて地獄の`xml + RemoteViews`から開放されるってことでいい？\r\n\r\n# Android のウィジェットは難しい\r\nレビューに来てたし私も欲しかったんですけど、、、  \r\nあ、この部分は読んでも読まなくてもどっちでもいいです。\r\n\r\n## Android 2 とかから存在するのでメソッドが古いまんま\r\nしばらく放置されていたイメージ、、あと後方互換のために下手に手を出せなかった可能性。  \r\n古いから情報があるのかと思うとあんまり...。  \r\n実際公式ドキュメントの日本語版はいつのスクリーンショットだよって言いたくなる、、はぁ\r\n- https://developer.android.com/guide/topics/appwidgets?hl=ja\r\n- https://developer.android.com/guide/topics/appwidgets/overview?hl=ja\r\n\r\n（日本語版なんて見るなという話ではある\r\n\r\n## RemoteViews で使える View のみ\r\n決まった`View`しか使えない！  \r\nhttps://developer.android.com/reference/android/widget/RemoteViews\r\n\r\n`ConstraintLayout`も使えません。`RelativeLayout`とか今更やるくらいなら`LinearLayout`とか`FrameLayout`使ったほうが良さそう。  \r\nあと、`xml`がベースなので、ちょっと凝った事するとめんどいです。角を丸くしたい場合は`カスタムDrawable`を作らないと行けない、`Jetpack Compose`だと一発なのにつらいね。\r\n\r\nまた、`findViewById`は使えない。じゃあどうやってテキストや画像をセットするんだって話ですが、  \r\n`RemoteViews`にテキスト設定メソッド、画像設定メソッドがあるので、`xml`の`android:id`と値をそれぞれセットしていく形になります。  \r\nhttps://developer.android.com/reference/android/widget/RemoteViews#setTextViewText(int,%20java.lang.CharSequence)\r\n\r\n```kotlin\r\nval views = RemoteViews(context.packageName, R.layout.music_control_widget).apply {\r\n    setTextViewText(R.id.widget_title, \"title\")\r\n    setTextViewText(R.id.widget_album, \"album\")\r\n    setTextViewText(R.id.widget_artist, \"artist\")\r\n}\r\n```\r\n\r\n`Visibility`変更や、`Drawable`セットなんかの基本的なやつはありますが、あんまり凝ったメソッドまではないので出来ない事もある。  \r\n一応、リフレクションじみた事ができますが、、、これも万能ではないらしく、`LinearLayout`の`setOrientation`しようとしたら落ちた  \r\nhttps://developer.android.com/develop/ui/views/appwidgets/enhance#use-runtime-mod-of-remoteviews\r\n\r\n**あとつらいのがリスト系**。`Gmail`とか`Google Keep`とかのリストでアイテム増やしたりできるやつ。あれが難しい  \r\n最近はドキュメントが充実してて良い感じなのですが、リストの各アイテムを押せるようにするためには、あらかじめメソッドを呼び出す必要があるとか、  \r\nリストへデータを渡すためのクラス、なんかよくわからないやつを継承するんだけど、実装しないといけないメソッドが多く圧倒される。\r\n\r\n- https://developer.android.com/develop/ui/views/appwidgets/collections#behavior\r\n- https://developer.android.com/develop/ui/views/appwidgets/collections#implement-collections\r\n\r\n## すぐ壊れる\r\nレイアウトを変更させると？、**ウィジェットは利用できません**みたいな表示になって、置き直さないといけない  \r\nアプリアイコン長押し→`ウィジェット`を押すとすぐ再設置できます（時短テク  \r\n\r\nhttps://support.google.com/android/answer/9450271?hl=ja#zippy=%2Cウィジェットを追加するサイズ変更する\r\n\r\n`Logcat`追ってったらクラッシュするようなコード書いてたうわーみたいな。\r\n\r\n## ボタンを押したときの処理が難しい\r\nワナが多すぎる\r\n\r\n前述の通り`findViewById`が使えないので、`setOnClickListener { }`なんてものは使えない。  \r\nなので、あらかじめ`PendinIntent`という押した時に発行する`Intent`を設定しておきます。（すぐ使うわけじゃないので`Pending`な`Intent`）  \r\nアプリの画面を開く`PendingIntent.getActivity`、サービスを起動する`PendingIntent.getService`、任意のコードを呼ぶためのコールバックを受け取る`PendinIntent.getBroadcast`など。\r\n\r\n任意のコードを呼ぶためのコールバックを受け取るやつは`AppWidgetProvider#onReceive`に書く。すぐブロードキャストレシーバーが使える状態にはなってる。  \r\n`PendingIntent`を作る際は、このクラス（以下の例だと`ExampleWidget`）に向けた`PendingIntent`を作ってセットすれば良い。\r\n`context`がもらえるけど、`Activity`の`context`ではないのでダイアログは出せない。  \r\n`Kotlin Coroutines の suspend 関数`を呼びだければ`goAsync()`メソッドを見てみてください。\r\n\r\n```kotlin\r\nclass ExampleWidget : AppWidgetProvider() {\r\n\r\n    /** ブロードキャスト受け取り */\r\n    override fun onReceive(context: Context?, intent: Intent?) {\r\n        // Intent に PendinIntent でセットした Intent があるはず\r\n        // 押したら Toast を出すなど\r\n        // ここでは Context#startActivity は使えないので、PendingIntent.getActivity を使う\r\n    }\r\n\r\n}\r\n```\r\n\r\nぱっと見何も難しいことはないように見えるが、、、なんか**たまによく反応しない時**がたまによくあるんですよね。  \r\n`PendingIntent`の引数に渡した`requestCode`が重複していると押しても`BroadcastReceiver`が反応しない・・・から重複しないようにすれば直るとか...  \r\n**ウィジェットを再設置するとボタンが反応するようになる時がある...とか。**  \r\n難しすぎる\r\n\r\n書き出してみるとそんなに無いな...確かにしんどかった記憶はあるんだけど。\r\n\r\n# Android Jetpack Glance\r\nこれらの問題が結構解決します！！\r\n\r\n## Jetpack Compose の文法で書ける\r\n`xml`で書く必要がないのでとても見やすい。やっぱレイアウトと行き来するのつらいよな。  \r\n使えるコンポーネントは`androidx.glance`パッケージ傘下にある`Composable 関数`に限定される。最終的には`RemoteViews`に変換するため致し方ない。  \r\n（なので、よって`Jetpack Compose`と`UIコンポーネント`を相互利用できるわけではない）\r\n\r\nただ、`UI`関係ない`Composable 関数`は使えちゃいます！  \r\n`Flow#collectAsState`とか`LaunchedEffect { }`とか。なんで動くのか本当に不思議\r\n\r\nそして何より嬉しいのが、**リスト系がめちゃめちゃ簡単**に作れるようになった  \r\n`LazyColumn`が`Glance`でも動く。本当に感動。こんな楽していいのか？\r\n\r\n## ウィジェットを少しの間動的にできる\r\nどういうことかというと、`Jetpack Glance`は`Jetpack Compose`の文法で書かれた`UI`を`RemoteViews`に変換するために、`Composable 関数`を監視しておく必要があるわけで、  \r\nその監視のための時間があるわけです。その間は動的なので、`remember { mutableStateOf() }`なんかも使えちゃうわけです。\r\n\r\n```kotlin\r\nclass GlanceCountWidget : GlanceAppWidget() {\r\n\r\n    override suspend fun provideGlance(\r\n        context: Context,\r\n        id: GlanceId\r\n    ) = provideContent {\r\n\r\n        // カウンター\r\n        // TODO 再起動とかで値をロストするので、永続化が必要\r\n        var counter by remember { mutableStateOf(0) }\r\n\r\n        // テーマの設定\r\n        GlanceTheme(colors = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) GlanceTheme.colors else colors) {\r\n            \r\n            // 横並び\r\n            Row(\r\n                modifier = GlanceModifier\r\n                    .fillMaxSize()\r\n                    .padding(5.dp)\r\n                    .background(GlanceTheme.colors.secondaryContainer)\r\n                    .cornerRadius(16.dp),\r\n                horizontalAlignment = Alignment.Horizontal.CenterHorizontally,\r\n                verticalAlignment = Alignment.Vertical.CenterVertically\r\n            ) {\r\n\r\n                Button(\r\n                    modifier = GlanceModifier.size(50.dp),\r\n                    text = \"-1\",\r\n                    onClick = { counter-- }\r\n                )\r\n\r\n                Text(\r\n                    modifier = GlanceModifier.defaultWeight(),\r\n                    text = counter.toString(),\r\n                    style = TextStyle(\r\n                        fontSize = 20.sp,\r\n                        textAlign = TextAlign.Center\r\n                    )\r\n                )\r\n\r\n                Button(\r\n                    modifier = GlanceModifier.size(50.dp),\r\n                    text = \"+1\",\r\n                    onClick = { counter++ }\r\n                )\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** ウィジェットの色 */\r\n        val colors = ColorProviders(\r\n            light = LightColorScheme,\r\n            dark = DarkColorScheme\r\n        )\r\n\r\n    }\r\n}\r\n```\r\n\r\n完全なコード→ https://github.com/takusan23/GlanceCountWidget  \r\n最新の Android Studio でビルドできるはずです。  \r\n\r\n![Imgur](https://imgur.com/QuivkuX.png)\r\n\r\n`Jetpack Glance`で`Flow#collectAsState`や`LaunchedEffect { }`が動くのは、この動的な間が存在するからなんですね。  \r\nちなみに、数十秒間の間しか動かないので、もし状態を保持しておきたい（上の例だとカウントを引き継ぎたい）場合は`SharedPreferences`や`DataStore`等の保存するためのシステムを用意する必要があります。  \r\n\r\n詳しくは：https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ActionAppWidget.kt\r\n\r\n## そこそこ新しい技術で動いている\r\n`Jetpack Compose`から`RemoteViews`に変換する部分で`WorkManager`？が使われていたり、非同期処理に`Kotlin Coroutines`が使われています。神！！！\r\n\r\n## Modifier\r\n`Jetpack Glance`専用の`GlanceModifier`が用意されています。  \r\n角を丸くする処理が`Jetpack Compose`と同じく一行で書けます。  \r\n\r\nもう`カスタムDrawable`作らずに済みます・・・！\r\n\r\n## 押したときの処理\r\nこれもめっちゃ簡略化されていて、なんと`GlanceModifier.clickable { }`を使うだけです。  \r\n内部では`BroadcastReceiver`が動いているため、`Context#startActivity`が呼び出せない等の成約があるものの、`BroadcastReceiver#onReceive`にクリックイベントを書くより何倍も分かりやすい！！！  \r\nもちろん`Activity`を開く方法もちゃんとあります。\r\n\r\n# 実際に作ってみる！！\r\n今回は写真を一覧表示するウィジェットでも作ってみましょう。  \r\nただ、それだと既にあると思うので、写真を押したらウィジェット内で表示するように（一覧表示から1つだけ）してみます。  \r\n本当にミニアプリを目指していきます。\r\n\r\nいや～～～これ`RemoteViews`でやろうとするとめっちゃだるいやろなぁ\r\n\r\n<video src=\"https://user-images.githubusercontent.com/32033405/270123308-7dee0de2-5ab1-4621-9af0-33a9168d28dd.mp4\" width=\"200\" controls></video>\r\n\r\n## 環境\r\n\r\nこうしき https://developer.android.com/jetpack/compose/glance\r\n\r\n| なまえ         | あたい                                  |\r\n|----------------|-----------------------------------------|\r\n| Android Studio | Android Studio Giraffe 2022.3.1 Patch 1 |\r\n| 端末           | Xperia 1 V / Google Pixel 6 Pro         |\r\n| targetSdk      | 34 (Android 14)                         |\r\n\r\n## 適当にプロジェクトを作る\r\n`Jetpack Compose`が入っているプロジェクトである必要があります。新規に作るなら`Empty Compose Project`？  \r\n`Jetpack Compose`ない場合はまず入れるところからですね\r\n\r\n`Empty Compose Project`で、後は適当に、  \r\n`Android`最低バージョンは`6`が良いらしい（`Jetpack Glance`が`5`をサポートしてないとかなんとか）\r\n\r\n![Imgur](https://imgur.com/qPEIStn.png)\r\n\r\n`kts`を使うかはおまかせします、新規で作るなら`kts`で良いかも、今あるプロジェクトを書き換えてまではメリットなさそう。\r\n\r\n## Jetpack Glance を入れる\r\n\r\n`app`の中の`build.gradle.kts`（もしくは`build.gradle`）で、以下を足す  \r\n`glance`と、画像読み込みライブラリの`Glide`です。\r\n\r\n```kotlin\r\n\r\ndependencies {\r\n\r\n    // これら\r\n    // For AppWidgets support\r\n    implementation (\"androidx.glance:glance-appwidget:1.0.0\")\r\n    // For interop APIs with Material 3\r\n    implementation (\"androidx.glance:glance-material3:1.0.0\")\r\n    // 画像読み込みライブラリ\r\n    implementation(\"com.github.bumptech.glide:glide:4.16.0\")\r\n\r\n    // 以下省略...\r\n\r\n\r\n```\r\n\r\nあとは、`targetSdk`を`34`にします。\r\n\r\n```kotlin\r\nandroid {\r\n    namespace = \"io.github.takusan23.touchphotowidget\"\r\n    compileSdk = 34 // ここ\r\n\r\n    defaultConfig {\r\n        applicationId = \"io.github.takusan23.touchphotowidget\"\r\n        minSdk = 23\r\n        targetSdk = 34 // ここ\r\n        versionCode = 1\r\n        versionName = \"1.0\"\r\n\r\n    // 以下省略...\r\n```\r\n\r\n## xmlを書く\r\nウィジェットのメタデータ（最小幅とか、ウィジェット設定用 Activity の指定）を書く。\r\n\r\n`res`の中に`xml`があるはずなので、そこに適当に`touch_photo_widget_info.xml`みたいなのを置く\r\n\r\n![Imgur](https://imgur.com/YcQfzr8.png)\r\n\r\n後は適当にコピペします。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:description=\"@string/app_name\"\r\n    android:minWidth=\"40dp\"\r\n    android:minHeight=\"40dp\"\r\n    android:previewImage=\"@drawable/ic_launcher_foreground\"\r\n    android:resizeMode=\"horizontal|vertical\"\r\n    android:targetCellWidth=\"1\"\r\n    android:targetCellHeight=\"1\"\r\n    android:updatePeriodMillis=\"86400000\"\r\n    android:widgetCategory=\"home_screen\" />\r\n```\r\n\r\nこれらのメタデータの詳細は以下。  \r\nhttps://developer.android.com/develop/ui/views/appwidgets#other-attributes  \r\n\r\n`description`とか`previewImage`はちゃんとしておいたほうが良い\r\n\r\n## Jetpack Glance のクラスを用意する\r\n2つ用意します。  \r\nまずは `GlanceAppWidget`を継承したクラスを作ります。\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        // TODO この後すぐ！\r\n    }\r\n\r\n}\r\n```\r\n\r\n次に、`GlanceAppWidgetReceiver`を継承したクラスも作ります。  \r\n`glanceAppWidget`は、↑で作った`GlanceAppWidget`を継承したクラスのインスタンスを渡せば大丈夫\r\n\r\n```kotlin\r\nclass TouchPhotoWidgetReceiver : GlanceAppWidgetReceiver() {\r\n\r\n    override val glanceAppWidget: GlanceAppWidget\r\n        get() = TouchPhotoWidget()\r\n\r\n}\r\n```\r\n\r\n多分こうなってるはず。\r\n\r\n![Imgur](https://imgur.com/4uaG1JW.png)\r\n\r\n## AndroidManifest を書く\r\n`<receiver>`を書きます。  \r\n`android:name=\".TouchPhotoWidgetReceiver\"`と、`android:resource=\"@xml/touch_photo_widget_info\"`は各自違う値になるはず！\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\r\n        android:fullBackupContent=\"@xml/backup_rules\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.TouchPhotoWidget\"\r\n        tools:targetApi=\"31\">\r\n\r\n        <!-- 詳細は... -->\r\n\r\n        <!-- <application> の中に↓を書く -->\r\n        <receiver\r\n            android:name=\".TouchPhotoWidgetReceiver\"\r\n            android:exported=\"true\">\r\n            <intent-filter>\r\n                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\r\n            </intent-filter>\r\n            <meta-data\r\n                android:name=\"android.appwidget.provider\"\r\n                android:resource=\"@xml/touch_photo_widget_info\" />\r\n        </receiver>\r\n\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n## ウィジェットのレイアウトを書く\r\n`TouchPhotoWidget`（`GlanceAppWidget`を継承したクラス）を開き、`provideGlance`の中で、`provideContent { }`を呼び出します。  \r\n`provideContent`のブロック内は`Composable`なので、あとはここにレイアウトを書いていくだけです！  \r\nまじで魔法みたいに動く。\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        provideContent {\r\n            // Composable\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n適当に、`Hello World`と、あと押したらアプリを起動するようにするにはこんな感じで。  \r\n前述の通り、`Glance`用のコンポーネントを呼び出す必要があるので、`import`の際は注意してください  \r\n（`GlanceModifier`が引数に入っているか、パッケージ名が`androidx.glance`で始まっているか）\r\n\r\n![Imgur](https://imgur.com/mWiqkEt.png)\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        provideContent {\r\n            Box(\r\n                modifier = GlanceModifier\r\n                    // match_parent\r\n                    .fillMaxSize()\r\n                    // 背景色\r\n                    .background(Color.White)\r\n                    // 押したら Activity 起動\r\n                    .clickable(actionStartActivity<MainActivity>()),\r\n                contentAlignment = Alignment.Center\r\n            ) {\r\n\r\n                Text(\r\n                    text = \"Hello World\",\r\n                    style = TextStyle(fontSize = 24.sp)\r\n                )\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nあとは実行して、実際にウィジェットを置いてみてください、  \r\nどうでしょう、ちゃんと`Hello World`が出て、押して起動しますか？\r\n\r\n`RemoteViews`時代よりずっっっっっっっと簡単になりましたね、感動\r\n\r\n# いよいよ写真ウィジェットを作る\r\nが、その前に写真の取得の話をしないとなんですよね。\r\n\r\n## 写真を取得する READ_EXTERNAL_STORAGE / READ_MEDIA_IMAGES\r\n`Android 13`以上をターゲットにする場合（今回は`14`なのでもちろんこちらの対象）、`READ_EXTERNAL_STORAGE`ではなく`READ_MEDIA_IMAGES`の権限を宣言してリクエストする必要があるそう。  \r\nただし、この権限は`13`からなので、それ以前の`Android`をサポートする場合は引き続き`READ_EXTERNAL_STORAGE`を宣言してリクエストする必要がある。  \r\n\r\n（ちなみにドキュメントに書いてあるかわかんないですが、自分が作った写真（自分のアプリから`ContentResolver#insert`）の場合は↑の権限無しで取得できたはず。。。）\r\n\r\n### 写真を取り出すには\r\nパスを渡す方法は取れません（`Android 10`からの`Scoped Storage`のせい）。つまり、以下のような方法は取れません  \r\n`val file = File(\"sdcard/DCIM/Example.jpg\")`\r\n\r\nじゃあどうするんだって話ですが、`Android`では`画像`等のメディアはデータベースみたいなやつに問い合わせると取得できるようになります。  \r\n`MediaStore`とか`ContentResolver`とか言われてるやつです。  \r\n\r\n#### MediaStore から Uri を取り出す\r\n例です、こんな感じだと思う。  \r\n`SQL`っぽいやつで取得したいメディアを取り出して、`cursor`で上から舐めていきます。  \r\nもちろん、これを実行する前に権限があるかのチェックが必要です。\r\n\r\n`(0 until 10).map { }`とかで指定した数の配列を作れます。書いてて楽しい`Kotlin`\r\n\r\n```kotlin\r\nval uriList: List<Uri> = context.contentResolver.query(\r\n    // 保存先、SDカードとかもあったはず\r\n    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\r\n    // 今回はメディアの ID を取得。他にもタイトルとかあります\r\n    // 実際のデータの取得には、まず ID を取得する必要があります\r\n    arrayOf(MediaStore.MediaColumns._ID),\r\n    // SQL の WHERE。ユーザー入力が伴う場合はプレースホルダーを使いましょう\r\n    null,\r\n    // SQL の WHERE のプレースホルダーの値\r\n    null,\r\n    // SQL の ORDER BY\r\n    null\r\n)?.use { cursor ->\r\n    // 一応最初に移動しておく\r\n    cursor.moveToFirst()\r\n    // 配列を返す\r\n    (0 until cursor.count)\r\n        .map {\r\n            // ID 取得\r\n            val id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))\r\n            // Uri の取得\r\n            val uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)\r\n            // 次のレコードに移動\r\n            cursor.moveToNext()\r\n            // 返す\r\n            uri\r\n        }\r\n} ?: emptyList()\r\n```\r\n\r\n# 写真ウィジェットを作る\r\n\r\n## 権限\r\n`AndroidManifest.xml`に書き足します。  \r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <!-- Android 12 まではこちらの権限が必要 -->\r\n    <uses-permission\r\n        android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\r\n        android:maxSdkVersion=\"32\" />\r\n\r\n    <!-- Android 13 からはこちら -->\r\n    <uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" />\r\n\r\n    <!-- 以下省略 -->\r\n```\r\n\r\n## 権限を要求する\r\n`MainActivity`に書きます。  \r\n権限がなければ要求するボタンを出します。簡単になりましたね。\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    @OptIn(ExperimentalMaterial3Api::class)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        setContent {\r\n            val context = LocalContext.current\r\n            val isGranted = remember {\r\n                // 初期値は権限があるか\r\n                mutableStateOf(ContextCompat.checkSelfPermission(context, REQUEST_PERMISSION) == PackageManager.PERMISSION_GRANTED)\r\n            }\r\n            // 権限コールバック\r\n            val requestPermission = rememberLauncherForActivityResult(contract = ActivityResultContracts.RequestPermission()) {\r\n                isGranted.value = it\r\n            }\r\n\r\n            TouchPhotoWidgetTheme {\r\n                Scaffold(\r\n                    topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) }\r\n                ) {\r\n                    Column(\r\n                        modifier = Modifier\r\n                            .fillMaxSize()\r\n                            .padding(it),\r\n                        verticalArrangement = Arrangement.Center,\r\n                        horizontalAlignment = Alignment.CenterHorizontally\r\n                    ) {\r\n\r\n                        if (isGranted.value) {\r\n                            Text(text = \"ホーム画面を長押しして、ウィジェットを追加してください\")\r\n                        } else {\r\n                            Text(text = \"写真を取得する権限が必要です\")\r\n                            Button(onClick = {\r\n                                requestPermission.launch(REQUEST_PERMISSION)\r\n                            }) { Text(text = \"権限をリクエストする\") }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** 必要な権限 */\r\n        val REQUEST_PERMISSION = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n            android.Manifest.permission.READ_MEDIA_IMAGES\r\n        } else {\r\n            android.Manifest.permission.READ_EXTERNAL_STORAGE\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 画像の取得処理\r\n画像を読み込むユーティリティクラスを用意します！！！  \r\n`ID`をとって、`Uri`にして、`Bitmap`を取得する感じです。\r\n\r\n、、、と思ってたんですけど、メモリ使い過ぎで怒られたため、`Glide`というライブラリで`Bitmap`を読み込むようにしました。\r\n\r\n```kotlin\r\nobject PhotoTool {\r\n\r\n    /**\r\n     * 写真を取得する\r\n     *\r\n     * @param context [Context]\r\n     * @param limit 上限\r\n     * @param size [Bitmap] の大きさ\r\n     * @return [PhotoData] の配列\r\n     */\r\n    suspend fun getLatestPhotoBitmap(\r\n        context: Context,\r\n        limit: Int = 20,\r\n        size: Int = 200\r\n    ): List<PhotoData> = withContext(Dispatchers.IO) {\r\n        val contentResolver = context.contentResolver\r\n        val uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI\r\n        val selection = arrayOf(MediaStore.MediaColumns._ID)\r\n        val sortOrder = \"${MediaStore.MediaColumns.DATE_ADDED} DESC\"\r\n\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            // LIMIT が使える\r\n            contentResolver.query(\r\n                uri,\r\n                selection,\r\n                bundleOf(\r\n                    ContentResolver.QUERY_ARG_LIMIT to limit,\r\n                    ContentResolver.QUERY_ARG_SQL_SORT_ORDER to sortOrder\r\n                ),\r\n                null\r\n            )\r\n        } else {\r\n            // 使えないので、取り出す際にやる\r\n            contentResolver.query(\r\n                uri,\r\n                selection,\r\n                null,\r\n                null,\r\n                sortOrder\r\n            )\r\n        }?.use { cursor ->\r\n            cursor.moveToFirst()\r\n            // 返す\r\n            (0 until min(cursor.count, limit))\r\n                .map {\r\n                    // コンテンツの ID を取得\r\n                    val id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))\r\n                    cursor.moveToNext()\r\n                    id\r\n                }\r\n                .map { id ->\r\n                    // ID から Uri を取得\r\n                    ContentUris.withAppendedId(uri, id)\r\n                }\r\n                .map { uri ->\r\n                    // Uri から Bitmap を返す\r\n                    // Glide で小さくしてから Bitmap を取得する\r\n                    PhotoData(getBitmap(context, uri, size), uri)\r\n                }\r\n        } ?: emptyList()\r\n    }\r\n\r\n    /**\r\n     * 画像をロードする\r\n     * Glide を使うので小さくして Bitmap を返せます\r\n     *\r\n     * @param context [Context]\r\n     * @param uri [Uri]\r\n     * @param size サイズ\r\n     * @return [Bitmap]\r\n     */\r\n    suspend fun getBitmap(\r\n        context: Context,\r\n        uri: Uri,\r\n        size: Int,\r\n    ): Bitmap = withContext(Dispatchers.IO) {\r\n        Glide.with(context)\r\n            .asBitmap()\r\n            .load(uri)\r\n            .submit(size, size)\r\n            .get()\r\n    }\r\n\r\n    /**\r\n     * [Bitmap] と [Uri] のデータクラス\r\n     */\r\n    data class PhotoData(\r\n        val bitmap: Bitmap,\r\n        val uri: Uri\r\n    )\r\n\r\n}\r\n```\r\n\r\n## ウィジェットに入れる\r\nあとはウィジェット上で画像を表示するだけ！  \r\n`Jetpack Compose`みたいな感じで書いていけば良いはず。`LocalContext`はなさそうなので、引数にある`Context`をバケツリレーすると良さそう\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        provideContent {\r\n\r\n            // 押した画像、選択していない場合は null\r\n            val selectPhoto = remember { mutableStateOf<PhotoTool.PhotoData?>(null) }\r\n            // 画像一覧\r\n            val bitmapList = remember { mutableStateOf(emptyList<PhotoTool.PhotoData>()) }\r\n\r\n            // 画像をロード\r\n            LaunchedEffect(key1 = Unit) {\r\n                bitmapList.value = PhotoTool.getLatestPhotoBitmap(context)\r\n            }\r\n\r\n            Box(\r\n                modifier = GlanceModifier\r\n                    .fillMaxSize()\r\n                    .background(Color.White)\r\n            ) {\r\n                if (selectPhoto.value != null) {\r\n                    // 選択した画像がある\r\n                    PhotoDetail(\r\n                        photoData = selectPhoto.value!!,\r\n                        onBack = { selectPhoto.value = null }\r\n                    )\r\n                } else {\r\n                    // 一覧表示\r\n                    PhotoGridList(\r\n                        photoDataList = bitmapList.value,\r\n                        onClick = { bitmap -> selectPhoto.value = bitmap }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * グリッド表示で写真を表示する\r\n     *\r\n     * @param context [Context]\r\n     * @param onClick 写真を押したら呼ばれる\r\n     */\r\n    @Composable\r\n    fun PhotoGridList(\r\n        photoDataList: List<PhotoTool.PhotoData>,\r\n        onClick: (PhotoTool.PhotoData) -> Unit\r\n    ) {\r\n        LazyVerticalGrid(\r\n            modifier = GlanceModifier.fillMaxSize(),\r\n            gridCells = GridCells.Fixed(4)\r\n        ) {\r\n            items(photoDataList) { photoData ->\r\n                Image(\r\n                    modifier = GlanceModifier\r\n                        .fillMaxWidth()\r\n                        .height(100.dp)\r\n                        .clickable { onClick(photoData) },\r\n                    provider = ImageProvider(photoData.bitmap),\r\n                    contentScale = ContentScale.Crop,\r\n                    contentDescription = null\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 写真の詳細画面\r\n     *\r\n     * @param photoData [PhotoTool.PhotoData]\r\n     * @param onBack 戻る押した時\r\n     */\r\n    @Composable\r\n    fun PhotoDetail(\r\n        photoData: PhotoTool.PhotoData,\r\n        onBack: () -> Unit\r\n    ) {\r\n        // 画像アプリで開くための Intent\r\n        // data に Uri を渡すことで対応しているアプリをあぶり出す\r\n        val intent = remember { Intent(Intent.ACTION_VIEW, photoData.uri) }\r\n\r\n        Column(modifier = GlanceModifier.fillMaxSize()) {\r\n            Row(\r\n                modifier = GlanceModifier\r\n                    .fillMaxWidth()\r\n                    .padding(5.dp)\r\n            ) {\r\n                Button(\r\n                    modifier = GlanceModifier.padding(10.dp),\r\n                    text = \"戻る\",\r\n                    onClick = onBack\r\n                )\r\n                Spacer(modifier = GlanceModifier.defaultWeight())\r\n                Button(\r\n                    modifier = GlanceModifier.padding(10.dp),\r\n                    text = \"開く\",\r\n                    onClick = actionStartActivity(intent)\r\n                )\r\n            }\r\n            Image(\r\n                modifier = GlanceModifier.fillMaxSize(),\r\n                provider = ImageProvider(photoData.bitmap),\r\n                contentDescription = null\r\n            )\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 使ってみる\r\nこんな感じに一覧表示されてて、\r\n\r\n![Imgur](https://imgur.com/uPnmC3M.png)\r\n\r\n押すと一枚だけ表示されます！\r\n\r\n![Imgur](https://imgur.com/XuFaZJt.png)\r\n\r\n`戻る`ボタンを押すと戻れます。あと`開く`を押すとアプリを選択する画面が出ます！  \r\n`Intent(Intent.ACTION_VIEW, photoData.uri)`←この`第2引数`に`Uri`を入れるやつ\r\n\r\n![Imgur](https://imgur.com/WsHKYrd.png)\r\n\r\nちな`Android 14`で押したら落ちた  \r\n`PendingIntent`の引数を`FLAG_IMMUTABLE`にしないといけないんだけど、現状は`Glance`が内部で`PendingIntent`を作っているので直せない。  \r\n`RemoteViews`を作って、`PendingIntent`を渡して、その`RemoteViews`を`Glance`で使う（相互利用ができる）しかなさそう・・・\r\n\r\n```plaintext\r\nUnrecognized Action: androidx.glance.appwidget.action.StartActivityIntentAction@3cb3c84\r\n    java.lang.IllegalArgumentException: io.github.takusan23.touchphotowidget: Targeting U+ (version 34 and above) disallows creating or retrieving a PendingIntent with FLAG_MUTABLE, an implicit Intent within and without FLAG_NO_CREATE and FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT for security reasons. To retrieve an already existing PendingIntent, use FLAG_NO_CREATE, however, to create a new PendingIntent with an implicit Intent use FLAG_IMMUTABLE.\r\n    at android.os.Parcel.createExceptionOrNull(Parcel.java:3061)\r\n    at android.os.Parcel.createException(Parcel.java:3041)\r\n    at android.os.Parcel.readException(Parcel.java:3024)\r\n    at android.os.Parcel.readException(Parcel.java:2966)\r\n    at android.app.IActivityManager$Stub$Proxy.getIntentSenderWithFeature(IActivityManager.java:6568)\r\n    at android.app.PendingIntent.getActivityAsUser(PendingIntent.java:571)\r\n    at android.app.PendingIntent.getActivity(PendingIntent.java:552)\r\n    at androidx.glance.appwidget.action.ApplyActionKt.getPendingIntentForAction(ApplyAction.kt:82)\r\n    at androidx.glance.appwidget.action.ApplyActionKt.getPendingIntentForAction$default(ApplyAction.kt:73)\r\n```\r\n\r\n## 見た目を整える\r\n\r\n### 色\r\n\r\nまず`GlanceTheme`が使えるように、親を`GlanceTheme`で囲います。\r\n\r\n```kotlin\r\n// テーマ機能\r\nGlanceTheme(\r\n    colors = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n        GlanceTheme.colors\r\n    } else {\r\n        colors\r\n    }\r\n) {\r\n    Box(\r\n        modifier = GlanceModifier\r\n            .fillMaxSize()\r\n            .background(GlanceTheme.colors.secondaryContainer)\r\n    ) {\r\n        if (selectPhoto.value != null) {\r\n            // 選択した画像がある\r\n            PhotoDetail(\r\n                photoData = selectPhoto.value!!,\r\n                onBack = { selectPhoto.value = null }\r\n            )\r\n        } else {\r\n            // 一覧表示\r\n            PhotoGridList(\r\n                photoDataList = bitmapList.value,\r\n                onClick = { bitmap -> selectPhoto.value = bitmap }\r\n            )\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Android 12`以降は`Dynamic Color ( Material You )`を使います。  \r\nそれ以下で使うための`colors`は、`Empty Compose Project`書いた時に付いてきたやつを使うことにします。\r\n\r\n```kotlin\r\ncompanion object {\r\n    val colors = ColorProviders(\r\n        light = LightColorScheme,\r\n        dark = DarkColorScheme\r\n    )\r\n}\r\n```\r\n\r\n背景の色は、`secondaryContainer`にすると良さそうです。\r\n\r\n```kotlin\r\nBox(\r\n    modifier = GlanceModifier\r\n        .fillMaxSize()\r\n        .background(GlanceTheme.colors.secondaryContainer)\r\n) { }\r\n```\r\n\r\nボタンの色は、アイコンだけのやつだと`primary`っぽい。  \r\n塗りつぶしアイコンの場合は、塗りつぶしが`primary`で、アイコンの色が`primaryContainer`っぽい（`Container`が逆転！？）  \r\n\r\nあと適当にアイコンを持ってきました。`Icon`は多分なさそうなので、`Image`を使うであってそう。\r\n\r\n```kotlin\r\nRow(\r\n    modifier = GlanceModifier\r\n        .fillMaxWidth()\r\n        .padding(5.dp)\r\n) {\r\n    // 戻るボタン\r\n    Image(\r\n        modifier = GlanceModifier\r\n            .size(40.dp)\r\n            .padding(5.dp)\r\n            .cornerRadius(10.dp)\r\n            .clickable(onBack),\r\n        provider = ImageProvider(resId = R.drawable.outline_arrow_back_24),\r\n        contentDescription = null,\r\n        colorFilter = ColorFilter.tint(GlanceTheme.colors.primary)\r\n    )\r\n    Spacer(modifier = GlanceModifier.defaultWeight())\r\n    // アプリを開く\r\n    // 塗りつぶし\r\n    Image(\r\n        modifier = GlanceModifier\r\n            .size(40.dp)\r\n            .padding(5.dp)\r\n            .background(GlanceTheme.colors.primary)\r\n            .cornerRadius(10.dp)\r\n            .clickable(actionStartActivity(intent)),\r\n        provider = ImageProvider(resId = R.drawable.outline_open_in_new_24),\r\n        contentDescription = null,\r\n        colorFilter = ColorFilter.tint(GlanceTheme.colors.primaryContainer)\r\n    )\r\n}\r\n```\r\n\r\nこんな感じにしてみた。他のウィジェットも同じ感じの色使いしてそう！\r\n\r\n![Imgur](https://imgur.com/SZ2wqhi.png)\r\n\r\nちなみに、`primaryContainer`は実際には`Android`のカラーリソースの`ID`を指している（`android.R.color.xxxxx`みたいな）ので、以下の`colors.xml`を見ると実際の`ID`を見ることが出来ます。\r\n\r\nhttps://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance/src/main/res/values-v31/colors.xml;l=1\r\n\r\n`primary`は`@android:color/system_accent1_600`を指定するのと同じ働きをするみたいですね！\r\n\r\n## レスポンシブデザイン\r\nこれだと、横幅に関係なく`4つ`表示しているので、幅がないときは`2`とかにしたい！みたいなことが出来ます。  \r\nこれも`Jetpack Glance`なら簡単にできるのでやります。（`RemoteViews`だったらやりたくない\r\n\r\nまずは大きさを定義して\r\n\r\n```kotlin\r\ncompanion object {\r\n\r\n    /** 小さいサイズ */\r\n    private val SMALL = DpSize(width = 100.dp, height = 100.dp)\r\n\r\n    /** 大きいサイズ */\r\n    private val LARGE = DpSize(width = 250.dp, height = 100.dp)\r\n    \r\n}\r\n```\r\n\r\n次に、`GlanceAppWidget`の`sizeMode`をオーバーライドして、`SizeMode.Responsive`を作って返してあげます。\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    /** ウィジェットの利用可能なサイズ。通常と横に長いサイズ */\r\n    override val sizeMode = SizeMode.Responsive(setOf(SMALL, LARGE))\r\n\r\n```\r\n\r\nあとは、`LocalSize`が使えるようになるので、グリッド表示コンポーネントの横並びセル数の部分で使います。\r\n\r\n```kotlin\r\n/**\r\n * グリッド表示で写真を表示する\r\n *\r\n * @param context [Context]\r\n * @param onClick 写真を押したら呼ばれる\r\n */\r\n@Composable\r\nfun PhotoGridList(\r\n    photoDataList: List<PhotoTool.PhotoData>,\r\n    onClick: (PhotoTool.PhotoData) -> Unit\r\n) {\r\n    // ウィジェットの大きさによって横に並べる数を変える\r\n    val gridSize = if (LocalSize.current.width >= LARGE.width) 4 else 2\r\n\r\n    LazyVerticalGrid(\r\n        modifier = GlanceModifier.fillMaxSize(),\r\n        gridCells = GridCells.Fixed(gridSize)\r\n    ) {\r\n        // 以下省略...\r\n```\r\n\r\nこれで、横幅が小さいときは横並びが2つになりました。  \r\n多分もっと刻むことができるはずです。いや～～楽ですねこれ\r\n\r\n![Imgur](https://imgur.com/l0X4b6s.png)\r\n\r\nちなみに、普通にこーゆーこともできるので、レイアウト全体を変えることも出来ます。  \r\n本当になんで動いてるか不思議だ...\r\n\r\n```kotlin\r\nval size = LocalSize.current\r\n// サイズによってレイアウトを切り替える\r\nif (size.width >= LARGE.width) {\r\n    LargeWidgetContent()\r\n} else {\r\n    SmallWidgetContent()\r\n}\r\n```\r\n\r\n# ここまでコード全部\r\n\r\n```kotlin\r\nclass TouchPhotoWidget : GlanceAppWidget() {\r\n\r\n    /** ウィジェットの利用可能なサイズ。通常と横に長いサイズ */\r\n    override val sizeMode = SizeMode.Responsive(setOf(SMALL, LARGE))\r\n\r\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\r\n        provideContent {\r\n\r\n            // 押した画像、選択していない場合は null\r\n            val selectPhoto = remember { mutableStateOf<PhotoTool.PhotoData?>(null) }\r\n            // 画像一覧\r\n            val bitmapList = remember { mutableStateOf(emptyList<PhotoTool.PhotoData>()) }\r\n\r\n            // 画像をロード\r\n            LaunchedEffect(key1 = Unit) {\r\n                bitmapList.value = PhotoTool.getLatestPhotoBitmap(context)\r\n            }\r\n\r\n            // テーマ機能\r\n            GlanceTheme(\r\n                colors = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n                    GlanceTheme.colors\r\n                } else {\r\n                    colors\r\n                }\r\n            ) {\r\n                Box(\r\n                    modifier = GlanceModifier\r\n                        .fillMaxSize()\r\n                        .background(GlanceTheme.colors.secondaryContainer)\r\n                ) {\r\n                    if (selectPhoto.value != null) {\r\n                        // 選択した画像がある\r\n                        PhotoDetail(\r\n                            photoData = selectPhoto.value!!,\r\n                            onBack = { selectPhoto.value = null }\r\n                        )\r\n                    } else {\r\n                        // 一覧表示\r\n                        PhotoGridList(\r\n                            photoDataList = bitmapList.value,\r\n                            onClick = { bitmap -> selectPhoto.value = bitmap }\r\n                        )\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * グリッド表示で写真を表示する\r\n     *\r\n     * @param context [Context]\r\n     * @param onClick 写真を押したら呼ばれる\r\n     */\r\n    @Composable\r\n    fun PhotoGridList(\r\n        photoDataList: List<PhotoTool.PhotoData>,\r\n        onClick: (PhotoTool.PhotoData) -> Unit\r\n    ) {\r\n        // ウィジェットの大きさによって横に並べる数を変える\r\n        val gridSize = if (LocalSize.current.width >= LARGE.width) 4 else 2\r\n\r\n        LazyVerticalGrid(\r\n            modifier = GlanceModifier.fillMaxSize(),\r\n            gridCells = GridCells.Fixed(gridSize)\r\n        ) {\r\n            items(photoDataList) { photoData ->\r\n                Image(\r\n                    modifier = GlanceModifier\r\n                        .fillMaxWidth()\r\n                        .height(100.dp)\r\n                        .clickable { onClick(photoData) },\r\n                    provider = ImageProvider(photoData.bitmap),\r\n                    contentScale = ContentScale.Crop,\r\n                    contentDescription = null\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 写真の詳細画面\r\n     *\r\n     * @param photoData [PhotoTool.PhotoData]\r\n     * @param onBack 戻る押した時\r\n     */\r\n    @Composable\r\n    fun PhotoDetail(\r\n        photoData: PhotoTool.PhotoData,\r\n        onBack: () -> Unit\r\n    ) {\r\n        // 画像アプリで開くための Intent\r\n        // data に Uri を渡すことで対応しているアプリをあぶり出す\r\n        val intent = remember { Intent(Intent.ACTION_VIEW, photoData.uri) }\r\n\r\n        Column(modifier = GlanceModifier.fillMaxSize()) {\r\n            Row(\r\n                modifier = GlanceModifier\r\n                    .fillMaxWidth()\r\n                    .padding(5.dp)\r\n            ) {\r\n                // 戻るボタン\r\n                Image(\r\n                    modifier = GlanceModifier\r\n                        .size(40.dp)\r\n                        .padding(5.dp)\r\n                        .cornerRadius(10.dp)\r\n                        .clickable(onBack),\r\n                    provider = ImageProvider(resId = R.drawable.outline_arrow_back_24),\r\n                    contentDescription = null,\r\n                    colorFilter = ColorFilter.tint(GlanceTheme.colors.primary)\r\n                )\r\n                Spacer(modifier = GlanceModifier.defaultWeight())\r\n                // アプリを開く\r\n                // 塗りつぶし\r\n                Image(\r\n                    modifier = GlanceModifier\r\n                        .size(40.dp)\r\n                        .padding(5.dp)\r\n                        .background(GlanceTheme.colors.primary)\r\n                        .cornerRadius(10.dp)\r\n                        .clickable(actionStartActivity(intent)),\r\n                    provider = ImageProvider(resId = R.drawable.outline_open_in_new_24),\r\n                    contentDescription = null,\r\n                    colorFilter = ColorFilter.tint(GlanceTheme.colors.primaryContainer)\r\n                )\r\n            }\r\n            Image(\r\n                modifier = GlanceModifier.fillMaxSize(),\r\n                provider = ImageProvider(photoData.bitmap),\r\n                contentDescription = null\r\n            )\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** Material You が使えない用 */\r\n        val colors = ColorProviders(\r\n            light = LightColorScheme,\r\n            dark = DarkColorScheme\r\n        )\r\n\r\n        /** 小さいサイズ */\r\n        private val SMALL = DpSize(width = 100.dp, height = 100.dp)\r\n\r\n        /** 大きいサイズ */\r\n        private val LARGE = DpSize(width = 250.dp, height = 100.dp)\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Android Jetpack Glance 知見\r\n最後にこれ作ってたり、`NewRadioSupporter`のウィジェット作ってたときの知見を残します。\r\n\r\n- `provideContent { }`は`45`秒間動き続ける？\r\n    - ↑ の間、`collectAsState`とかが動くのか\r\n    - `GlanceAppWidget#provideGlance`のドキュメントを見てください。\r\n- ウィジェットを更新する関数があります。\r\n    - `TouchPhotoWidget().update()`とか`TouchPhotoWidget().updateAll()`とか\r\n    - これらは、`provideContent { }`が動いているときは特に何もしなさそう\r\n        - `WorkManager`が動いている間？は既にウィジェット動いてるので特に何もしない？\r\n- `GlanceModifier.clickable { }`の際、`provideContent { }`が起動していなかったら起動するぽい\r\n    - `WorkManager`が裏で動く\r\n        - ボタンを追加で押すと、`45`秒のタイムアウトも延長するらしい\r\n- 多分レイアウト変更時に再設置が必要なのは変わってないと思う、`RemoteViews`だから仕方ないのかも\r\n\r\n# おわりに\r\nこれも`iOS`でウィジェットが入った影響みたいなのがあるんですかね？  \r\nもしも入らなければ、`Android`もウィジェット周りの改修が入らず地獄のままだったのでしょうか・・・ありがとう`iOS`  \r\n\r\nソースコード置いておきます。最新の`Android Studio`で実行できるはずです。  \r\nhttps://github.com/takusan23/TouchPhotoWidget\r\n\r\n# おわりに2\r\n`BroadcastReceiver`で思い出した、レシーバーのスペル、たまに`Reciever`って書いちゃう\r\n\r\n# おわりに3\r\n`NewRadioSupporter` 審査出ししました\r\n\r\n![Imgur](https://imgur.com/XxAV4Y9.png)"},{"title":"Glideでクロスフェード","link":"/posts/android_glide_crossfade/","markdown":"\r\n[公式に乗ってますがメモで](https://bumptech.github.io/glide/doc/options.html#transitionoptions)\r\n\r\n# クロスフェードして表示\r\n\r\n```kotlin\r\nGlide.with(imageView)\r\n    .load(\"URL\")\r\n    .transition(DrawableTransitionOptions.withCrossFade()) // これ\r\n    .into(imageView)\r\n```\r\n\r\n## おまけ 角を丸くする\r\n\r\n```kotlin\r\nGlide.with(imageView)\r\n    .load(\"URL\")\r\n    .apply(RequestOptions.bitmapTransform(RoundedCorners(10))) // これ\r\n    .into(imageView)\r\n```"},{"title":"Android Studio Bumblebee でトップレベルの build.gradle の書き方が変わったみたい","link":"/posts/android_gradle_bumblebee/","markdown":"\r\nどうもこんばんわ。  \r\n\r\n# 本題\r\n書き方変わってる\r\n\r\n```java\r\n// 今までのトップレベル build.gradle (appじゃない方)\r\n\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nbuildscript {\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        classpath \"com.android.tools.build:gradle:7.0.4\"\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10\"\r\n\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n\r\ntask clean(type: Delete) {\r\n    delete rootProject.buildDir\r\n}\r\n```\r\n\r\n```java\r\n// Android Studio Bumblebee 以降\r\n\r\nbuildscript {\r\n    ext {\r\n        compose_version = '1.1.0-rc03'\r\n    }\r\n}// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    id 'com.android.application' version '7.1.0' apply false\r\n    id 'com.android.library' version '7.1.0' apply false\r\n    id 'org.jetbrains.kotlin.android' version '1.6.10' apply false\r\n}\r\n\r\ntask clean(type: Delete) {\r\n    delete rootProject.buildDir\r\n}\r\n```\r\n\r\n# 公式に案内あるやん\r\n\r\nhttps://developer.android.com/studio/releases/gradle-plugin#settings-gradle\r\n\r\n`buildscript`の`repositories`が`settings.gradle`へ移動したみたい\r\n\r\n```java\r\n// Android Studio Bumblebee 以降 の settings.gradle\r\n\r\npluginManagement {\r\n    repositories {\r\n        gradlePluginPortal()\r\n        google()\r\n        mavenCentral()\r\n    }\r\n}\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n}\r\nrootProject.name = \"JetpackComposeParentClickEvent\"\r\ninclude ':app'\r\n```\r\n\r\n# おまけ build.gradle.kts するなら\r\n\r\n`Gradle 7.2`にすれば既存プロジェクトでも書き換えできるのかな？  \r\n\r\n```\r\n# gradle-wrapper.properties\r\n\r\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-7.2-bin.zip # ここを 7.2  \r\n```\r\n\r\n## build.gradle.kts (appフォルダじゃない方)\r\n\r\n```kotlin\r\nbuildscript {\r\n    val kotlinVersion: String by extra(\"1.6.10\")\r\n    val composeVersion: String by extra(\"1.1.0-rc03\")\r\n}\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    id(\"com.android.application\").version(\"7.1.0\").apply(false)\r\n    id(\"com.android.library\").version(\"7.1.0\").apply(false)\r\n    id(\"org.jetbrains.kotlin.android\").version(\"1.6.10\").apply(false)\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\n## settings.gradle.kts\r\n\r\n```kotlin\r\npluginManagement {\r\n    repositories {\r\n        gradlePluginPortal()\r\n        google()\r\n        mavenCentral()\r\n    }\r\n}\r\n\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n        jcenter() // Warning: this repository is going to shut down soon\r\n    }\r\n}\r\n// ここから下は各自書き換えて\r\nrootProject.name = \"ChocoDroid\"\r\ninclude(\":app\")\r\n```\r\n\r\n# 終わりに\r\nソフトバンクがAndroid/iPhone別のSIMを発行するの辞めたらしい"},{"title":"build.gradle.ktsへ移行してついでにGradleタスク入門","link":"/posts/android_gradle_to_kts/","markdown":"\r\n(Android Studio Bumblebee 以降書き方変わったので一番最後も参照にしてください)\r\n\r\nどうもこんばんわ。  \r\nAndroid 12、あんま評判よくないな？1画面で見れる情報量が減った感はあると思う。  \r\nオーバースクロール時の挙動は賛否両論？\r\n\r\n# 本題\r\nbuild.gradleをbuild.gradle.ktsへ書き換えます。  \r\n自分用です。\r\n\r\n移行するメリットは、どうだろう。\r\n\r\n## 移行前\r\n\r\n`build.gradle`\r\n\r\n```java\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nbuildscript {\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:7.0.3'\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.31\"\r\n\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n\r\ntask clean(type: Delete) {\r\n    delete rootProject.buildDir\r\n}\r\n```\r\n\r\n`app/build.gradle`\r\n\r\n```java\r\nplugins {\r\n    id 'com.android.application'\r\n    id 'kotlin-android'\r\n}\r\n\r\nandroid {\r\n    compileSdk 31\r\n    buildToolsVersion \"30.0.3\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.mobilestatuswidget\"\r\n        minSdk 24\r\n        targetSdk 31\r\n        versionCode 2\r\n        versionName \"1.1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n    }\r\n}\r\n\r\ndependencies {\r\n    // グラフ\r\n    implementation 'com.github.PhilJay:MPAndroidChart:v3.1.0'\r\n    // Activity Result API\r\n    implementation 'androidx.activity:activity-ktx:1.4.0-rc01'\r\n    implementation 'androidx.fragment:fragment-ktx:1.3.6'\r\n    // Coroutine\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\"\r\n\r\n    implementation 'androidx.core:core-ktx:1.6.0'\r\n    implementation 'androidx.appcompat:appcompat:1.3.1'\r\n    implementation 'com.google.android.material:material:1.4.0'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.1'\r\n    testImplementation 'junit:junit:4.13.2'\r\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\r\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\r\n}\r\n```\r\n\r\n# 移行する\r\n名前を`build.gradle`から`build.gradle.kts`にします。  \r\nファイルを選んで`Shift`+`F6`で名前変更画面を呼び出せます。  \r\n\r\n移行したらとりあえず`Sync now`押しましょう。直すべき項目が赤くなって出るはず。\r\n\r\n## build.gradle.kts 移行例\r\n\r\n```kotlin\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nbuildscript {\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        classpath(\"com.android.tools.build:gradle:7.0.3\")\r\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.31\")\r\n\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\n一番最後の`tasks.register`は他にも書き方あるみたいなので調べてみてください。\r\n\r\n## app/build.gradle.kts 移行例\r\n\r\n```kotlin\r\nplugins {\r\n    id(\"com.android.application\")\r\n    id(\"kotlin-android\")\r\n}\r\n\r\nandroid {\r\n    compileSdk = 31\r\n    buildToolsVersion = \"30.0.3\"\r\n\r\n    defaultConfig {\r\n        applicationId = \"io.github.takusan23.mobilestatuswidget\"\r\n        minSdk = 24\r\n        targetSdk = 31\r\n        versionCode = 2\r\n        versionName = \"1.1.0\"\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildFeatures {\r\n        viewBinding = true\r\n    }\r\n    buildTypes {\r\n        release {\r\n            isMinifyEnabled = false\r\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility = JavaVersion.VERSION_1_8\r\n        targetCompatibility = JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n}\r\n\r\ndependencies {\r\n    // グラフ\r\n    implementation(\"com.github.PhilJay:MPAndroidChart:v3.1.0\")\r\n    // Activity Result API\r\n    implementation(\"androidx.activity:activity-ktx:1.4.0-rc01\")\r\n    implementation(\"androidx.fragment:fragment-ktx:1.3.6\")\r\n    // Coroutine\r\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\")\r\n\r\n    implementation(\"androidx.core:core-ktx:1.6.0\")\r\n    implementation(\"androidx.appcompat:appcompat:1.3.1\")\r\n    implementation(\"com.google.android.material:material:1.4.0\")\r\n    implementation(\"androidx.constraintlayout:constraintlayout:2.1.1\")\r\n    testImplementation(\"junit:junit:4.13.2\")\r\n    androidTestImplementation(\"androidx.test.ext:junit:1.1.3\")\r\n    androidTestImplementation(\"androidx.test.espresso:espresso-core:3.4.0\")\r\n}\r\n```\r\n\r\n`Kotlin`っぽい書き方になって謎が減ったような気がする。\r\n\r\n## 変数を使っている場合\r\n`Jetpack Compose` ~~（略してJC）~~ を使っている例では、build.gradleでComposeのバージョンを変数で宣言して、`app/build.gradle`で参照しているのがよくあると思いますが、  \r\nこのままでは移行できないので書き直します。\r\n\r\n### build.gralde.kts で変数を宣言します。\r\n\r\n```kotlin\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nbuildscript {\r\n    \r\n    /** Kotlinのバージョン */\r\n    val kotlinVersion by extra(\"1.5.31\")\r\n\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        classpath(\"com.android.tools.build:gradle:7.0.3\")\r\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlinVersion}\")\r\n\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\n文字列に埋め込む場合は`\"${変数名}\"`で出来ます。ここらへんはさすがKotlin\r\n\r\n### app/build.gradle.kts で使う\r\nさて、他のモジュールから参照する方法ですが、`rootProject.extra`で出来ます。\r\n\r\n```kotlin\r\nval kotlinVersion: String by rootProject.extra\r\n\r\nplugins {\r\n    id(\"com.android.application\")\r\n    id(\"kotlin-android\")\r\n}\r\n\r\nandroid {\r\n    compileSdk = 31\r\n    buildToolsVersion = \"30.0.3\"\r\n\r\n    // 省略\r\n```\r\n\r\nその他詳しく知りたい場合は：https://docs.gradle.org/current/userguide/kotlin_dsl.html\r\n\r\n# おまけ\r\n\r\nせっかくKotlinで`Gradle`かけるようになったんだし`Gradle Task`に入門してみた。  \r\n\r\n## どういうこと？\r\n![Imgur](https://imgur.com/sEs48Eb.png)\r\n\r\nを押したときの処理が、`build.gradle.kts`の一番下に書いてある内容なんだけど、  \r\n\r\n↓これ\r\n```kotlin\r\ntasks.register(\"clean\") {\r\n    println(\"run clean !!!!!\")\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\nこれを自分でかけるよって話。しかもKotlinでかける\r\n\r\n## 新しいタスクを作成\r\n\r\n```kotlin\r\ntasks.register(\"helloWorld\"){\r\n    doFirst {\r\n        println(\"Hello World\")\r\n    }\r\n}\r\n```\r\n\r\nこれではろーわーるどしてくれるタスクが完成です。`Sync now`しますかって上の方に出てると思うので、`Sync now`して、  \r\n早速実行してみましょう。右上にある`Gradle`を押して、🐘のアイコンを押してmacOSのSpotlightみたいな入力欄が出たら、`gradle helloWorld`と打ちます。これで出るはず。\r\n\r\n![Imgur](https://imgur.com/D2KXZ6q.png)\r\n\r\nこれで挨拶してくれれば成功\r\n\r\n```\r\n> Task :helloWorld\r\nHello World\r\n```\r\n\r\n## もう少し実用的なのを頼む\r\n\r\n`app/build.gradle.kts`で追加しているライブラリ一覧を`libraryList.txt`として書き出すタスクです。\r\n\r\n```kotlin\r\ntasks.register(\"exportDependency\") {\r\n    doFirst {\r\n        // テキストファイル保存先\r\n        val libraryListFile = File(rootDir, \"libraryList.txt\")\r\n        libraryListFile.createNewFile()\r\n        // 書き込む文字列\r\n        val libraryListText = project(\"app\")\r\n            .configurations[\"implementationDependenciesMetadata\"]\r\n            .resolvedConfiguration\r\n            .firstLevelModuleDependencies\r\n            .joinToString(separator = \"\\n-----\\n\") {\r\n                \"\"\"\r\n                name = ${it.name}\r\n                version = ${it.moduleVersion}\r\n                \"\"\".trimIndent()\r\n            }\r\n        // 書き込む\r\n        libraryListFile.writeText(libraryListText) // Kotlinの拡張関数も呼べる！？\r\n    }\r\n}\r\n```\r\n\r\nかけたら`Sync now`して実行してみます。\r\n\r\n![Imgur](https://imgur.com/pnfG0CG.png)\r\n\r\n実行すると、ファイルが出来ているはずです。\r\n\r\n![Imgur](https://imgur.com/kH4LTbg.png)\r\n\r\nオープンソースライブラリ一覧画面を作るときに役に立ちそうですね！\r\n\r\n# おまけ 2021/11/23\r\n`build.gradle.kts`後に謎のエラーが出る場合（文法とかはあってるのに）\r\n\r\n![Imgur](https://imgur.com/pZA4RPN.png)\r\n\r\nまずプロジェクトを閉じるかAndroid Studio自体を閉じます。  \r\nその後、プロジェクトをエクスプローラー（macOSならあの顔のやつ。Finderだっけ？）で開いて、`.idea`を消すか、適当に名前を変えます。  \r\n\r\nそのあと再度Android Studioでプロジェクトを開き、実行ボタンの近くにある`Make Project`ボタン（Ctrl+F9）を押せば治りました。  \r\n\r\n# おまけ 2022/01/30 追記\r\nAndroid Studio Bumblebee 以降書き方変わったので置いておきます\r\n\r\n## トップレベル build.gradle.kts\r\n\r\n```kotlin\r\nbuildscript {\r\n    val kotlinVersion: String by extra(\"1.6.10\")\r\n    val composeVersion: String by extra(\"1.1.0-rc03\")\r\n}\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    id(\"com.android.application\").version(\"7.1.0\").apply(false)\r\n    id(\"com.android.library\").version(\"7.1.0\").apply(false)\r\n    id(\"org.jetbrains.kotlin.android\").version(\"1.6.10\").apply(false)\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\n## settings.gradle.kts\r\n\r\n```kotlin\r\npluginManagement {\r\n    repositories {\r\n        gradlePluginPortal()\r\n        google()\r\n        mavenCentral()\r\n    }\r\n}\r\n\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n        jcenter() // Warning: this repository is going to shut down soon\r\n    }\r\n}\r\n// ここから下は各自書き換えて\r\nrootProject.name = \"ChocoDroid\"\r\ninclude(\":app\")\r\n```\r\n\r\n\r\n# 終わりに\r\n`buildSrc`の話じゃなくてごめん。"},{"title":"少し前のアプリの改修をしたときのメモ","link":"/posts/android_hisasiburi_dev/","markdown":"どうもこんばんわ。   \r\n`kotlin-android-extensions`が現役の頃のアプリです。\r\n\r\n# 本題\r\n少し前に作ったアプリにレビューがついてたので改修しようとしたときに遭遇したことなど。\r\n\r\n# Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8.\r\n\r\nGradleのバージョンを`7.x`系にすると言われる。\r\n\r\n`build.gradle`(appじゃない)を開いて、`com.android.tools.build:gradle:7.0.0`にして、`gradle-wapper.properties`も`7.x`系にすると言われます。このエラー\r\n\r\n```gradle\r\nbuildscript {\r\n    ext.kotlin_version = '1.5.10'\r\n    repositories {\r\n        google()\r\n        jcenter()\r\n    }\r\n    dependencies {\r\n        // これ7.xへ\r\n        classpath 'com.android.tools.build:gradle:7.0.0'\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n```\r\n\r\n```properties\r\n#Sat Aug 07 02:47:13 JST 2021\r\ndistributionBase=GRADLE_USER_HOME\r\n#これ7.x系へ\r\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-7.0.2-bin.zip\r\ndistributionPath=wrapper/dists\r\nzipStorePath=wrapper/dists\r\nzipStoreBase=GRADLE_USER_HOME\r\n```\r\n\r\nこのエラーの解決方法ですが、`IDEA`の設定を開き、`Build, Execution, Deployment`へ進み、`Build Tools`の中の`Gradle`を選び、`Gradle JDK`を`Java 11以降`にすればいいです。\r\n\r\n![Imgur](https://imgur.com/G3obZ0x.png)\r\n\r\n# Execution failed for task ':app:kaptDebugKotlin'.\r\n\r\n```\r\nExecution failed for task ':app:kaptDebugKotlin'.\r\n> A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask$KaptExecutionWorkAction\r\n   > java.lang.reflect.InvocationTargetException (no error message)\r\n```\r\n\r\nこれはプロジェクトを一旦閉じて、プロジェクトをエクスプローラーで開いた後、`.idea`フォルダを消して、再度プロジェクトを開くとなんか治りました。なぜ？\r\n\r\n以上です。\r\n\r\n# 終わりに\r\n緊急速報メールはSIMカードが刺さっていれば契約の有無に関係なく受信出来るらしい。"},{"title":"Jetpack Composeを既存アプリへ導入","link":"/posts/android_jc/","markdown":"\nどうもこんばんわ。ニコ生でCLANNAD一挙見てます。  \n本編で流れてるBGMすきすき\n\n# 前提\n- `Kotlin Android Extensions`は使えない模様。`ViewBinding`へ乗り換えて。  \n\n# 環境\n\n| なまえ           | あたい                                          |\n|------------------|-------------------------------------------------|\n| `Android Studio` | `Android Studio Arctic Fox \\ 2020.3.1 Canary 3` |\n| minSdkVersion    | 21                                              |\n\n\n# 遭遇した問題 2021/01/03 現在\n\n- Android 5でリソースが見つからないエラーでクラッシュ\n今までの方法でDrawableを取得してBitmapへ変換してComposeで扱えるBitmapへ変換すれば取れる。\n\n```kotlin\nval icon = AmbientContext.current.getDrawable(R.drawable.android)?.toBitmap()?.asImageBitmap()\nif (icon != null) {\n    Icon(\n        modifier = Modifier.padding(5.dp),\n        bitmap = icon\n    )\n}\n```\n\n- ~~`ScrollableRow`で`AndroidView`がずれる~~ **Beta03で修正されました。**\n    - Android 7以前で観測\n    - ~~直し方はわからん~~**Beta03に上げればおｋ(Kotlinは1.4.31)**\n\n- そもそもAndroid StudioでJDKのパスが間違ってるとか言われてビルドまで進めない\n    - `.idea`を消してみる(か適当に名前を変える)と直りました。\n\n\n# 既存アプリへ導入\n\n割と頻繁にアップデートが入るので、[こっちも見て](/posts/android_jc_recipe/)\n\n## AGPのアップデート\n必要かどうかはわかりませんが、たしかサンプルコードいじってるときもAGPのバージョンがなんとかみたいな感じでアップデートした記憶があるので更新しておきましょう。  \n家のWi-Fi遅くてつらい  \n\n多分右下にアップデートする？みたいな通知が出てると思うのでそこから\n\n![Imgur](https://imgur.com/PzEdNV0.png)\n\n## Kotlinのアップデート\n`app`フォルダじゃない方の`build.gradle`を開いて、書き換えていきます。\n\n```java\nbuildscript {\n    ext.kotlin_version = '1.4.21'\n    repositories {\n        google()\n        jcenter()\n        \n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.0.0-alpha03'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n```\n\n`ext.kotlin_version`を`1.4.21`へ変えます。  \n`classpath 'com.android.tools.build:gradle:7.0.0-alpha03'`はバージョンを上げるとそうなると思う。\n\n### app/build.gradle\n`app`フォルダの方の`build.gradle`を開いて、必要なライブラリを書いていきます。  \n以下は一例です。\n\n```java\napply plugin: 'com.android.application'\n\napply plugin: 'kotlin-android'\n\n// apply plugin: 'kotlin-android-extensions' さよなら\n\napply plugin: 'kotlin-kapt' // Room使うときのなにか。一番上に\n\nandroid {\n\n    compileSdkVersion 30\n    defaultConfig {\n        applicationId \"io.github.takusan23.tatimidroid\"\n        minSdkVersion 22\n        targetSdkVersion 30\n        versionCode 78\n        versionName \"12.2.1\"\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    // Kotlinを書くきっかけになった Kotlin Android Extensions がいよいよ非推奨になってしまった\n    // のでViewBindingに乗り換える\n    buildFeatures {\n        // ViewBinding有効\n        viewBinding true\n        // Jetpack Compose有効\n        compose true\n    }\n\n    compileOptions {\n        targetCompatibility 1.8\n        sourceCompatibility 1.8\n    }\n\n    kotlinOptions {\n        jvmTarget = '1.8'\n        useIR = true\n    }\n\n    composeOptions {\n        kotlinCompilerVersion kotlin_version // 1.4.21が入ると思う\n        kotlinCompilerExtensionVersion '1.0.0-alpha09'\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    // Jetpack Compose --- ここから\n\n    implementation 'androidx.compose.ui:ui:1.0.0-alpha09'\n    // Tooling support (Previews, etc.)\n    implementation 'androidx.compose.ui:ui-tooling:1.0.0-alpha09'\n    // Foundation (Border, Background, Box, Image, Scroll, shapes, animations, etc.)\n    implementation 'androidx.compose.foundation:foundation:1.0.0-alpha09'\n    // Material Design\n    implementation 'androidx.compose.material:material:1.0.0-alpha09'\n    // Material design icons\n    implementation 'androidx.compose.material:material-icons-core:1.0.0-alpha09'\n    implementation 'androidx.compose.material:material-icons-extended:1.0.0-alpha09'\n    // Integration with observables\n    implementation 'androidx.compose.runtime:runtime-livedata:1.0.0-alpha09'\n\n    // Jetpack Compose --- ここまで\n\n}\n```\n\n`buildFeatures`とか`kotlinOptions`、`composeOptions`と  \n`dependencies`に書き足す感じですかね\n\nできたら`Sync`して`Build`します。\n\n# Jetpack Compose を試す\n\n適当にクラスを作って書いていきます。\n\n```kotlin\n/**\n * Jetpack Compose 略してJC\n * */\n\n@Composable\nfun VideoInfoCard() {\n    Card(modifier = Modifier.padding(10.dp)) {\n        Text(text = \"Hello World\")\n    }\n}\n\n@Preview\n@Composable\nfun PreviewVideoInfoCard() {\n    VideoInfoCard()\n}\n```\n\n`@Preview`をつけることで隣のプレビューに表示されるようになります。`@Preview`を付けた関数には引数を設定してはいけません。\n\n## Activityに置く\n\nsetContentView()の代わりに`setContent { }`を置いてその中にさっき書いた`VideoInfoCard()`を書きましょう\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            VideoInfoCard()\n        }\n    }\n}\n```\n\n他にも`@Preview`のついた関数のところで実機プレビューが使えますが、  \n私の環境ではうまく動かなかったので`Activity`に置いたほうがいいと思います。\n\n## Modifierについて\nよく登場する`Modifier`、多分すべての`Compose`で共通する`height`とか`width`とか`padding`とかを設定するときに使う。  \nxmlでレイアウト組んでたときも共通で使えた属性あったから多分そんなやつ  \n\n連結して設定していきます\n\n```kotlin\nImage(\n    imageVector = Icons.Outlined.Book,\n    modifier = Modifier.height(50.dp).width(50.dp),\n)\n```\n\n# レシピ集\nJetpack Composeが流行ると願って  \n手を動かそう\n\n## カウンターアプリを作る\n`var count by remember { mutableStateOf(0) }`を使うことでカウント値を保持できます。  \n`var count = 0`は動きませんでした。\n\n```kotlin\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TestCompose()\n        }\n    }\n}\n\n@Composable\nfun TestCompose() {\n    // 押した回数を保持する\n    var count by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = Modifier.padding(10.dp), // スペース確保\n        horizontalAlignment = Alignment.CenterHorizontally, // 真ん中にする\n    ) {\n        Text(\n            text = \"押した回数 $count\",\n        )\n        Button(\n            onClick = {\n                // おしたとき\n                count += 1\n            },\n            colors = ButtonDefaults.textButtonColors(backgroundColor = Color.White)\n        ) {\n            Text(text = \"ここをおせ！\")\n        }\n    }\n}\n\n@Preview\n@Composable\nfun TestComposePreview() {\n    TestCompose()\n}\n```\n\n実行結果\n\n![Imgur](https://imgur.com/MHExL7O.png)\n\n\n## 好きなUIにクリックイベントを置きたい（`Button { }`以外で押せるようにしたい）\nModifierにクリックするやつがあります。`Ripple`（波みたいなやつ）もできます。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            ClickableCompose()\n        }\n    }\n}\n\n@Composable\nfun ClickableCompose() {\n    // 押した回数を保持する\n    var count by remember { mutableStateOf(0) }\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = Modifier\n            .width(150.dp)\n            .height(100.dp)\n            .clickable(\n                onClick = { count++ },\n                indication = rememberRipple(color = Color.Blue),\n                interactionSource = remember { MutableInteractionSource() },\n            )\n    ) {\n        Text(text = \"おせますよ～ $count\")\n        Image(imageVector = Icons.Outlined.Add)\n    }\n}\n```\n実行結果\n\n![Imgur](https://imgur.com/dHQELFC.png)\n\n## アイコンを表示 + 押せるようにする\n\n今まで、マテリアルアイコンを使う際は`Asset Studio`からアイコンを持ってくると思うんですが、  \n\n![Imgur](https://imgur.com/QEgIZ6J.png)\n\nなんと！`Jetpack Compose`を使うことでコード一行でアイコンを用意できます。`Outlined`以外も用意できます。\n\n```kotlin\nIcon(imageVector = Icons.Outlined.Android)\n```\n\n```kotlin\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            TestCompose()\n        }\n    }\n}\n\n@Composable\nfun TestCompose() {\n    // 押した回数を保持する\n    var count by remember { mutableStateOf(0) }\n\n    Row(\n        modifier = Modifier.padding(10.dp), // スペース確保\n        verticalAlignment = Alignment.CenterVertically, // まんなかに\n    ) {\n        Text(\n            text = \"押した回数 $count\",\n        )\n        IconButton(onClick = {\n            // カウントアップ\n            count++\n        }) {\n            Icon(imageVector = Icons.Outlined.Home)\n        }\n    }\n}\n\n@Preview\n@Composable\nfun TestComposePreview() {\n    TestCompose()\n}\n```\n\n実行結果\n\n![Imgur](https://imgur.com/srZwt5e.png)\n\n## 動画説明文見え隠れするやつ\n\n```kotlin\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            VideoInfo()\n        }\n    }\n}\n\n@Composable\nfun VideoInfo() {\n    // 表示するか\n    var isShow by remember { mutableStateOf(false) }\n    Card(\n        modifier = Modifier.padding(10.dp)\n    ) {\n        Column(modifier = Modifier.padding(10.dp)) {\n            Row {\n                Text(text = \"動画タイトル\", modifier = Modifier.weight(1f)) // アイコンまでずっと伸ばす\n                IconButton(onClick = {\n                    isShow = !isShow\n                }) {\n                    // アイコンも変更\n                    Icon(imageVector = if (isShow) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore)\n                }\n            }\n\n            // 表示するか\n            if (isShow) {\n                Text(\n                    text = \"\"\"\n                    ニコ動にもサムネ登録機能ついてから最後一瞬だけサムネ用の画像を表示させるやつも見なくなりましたね。\n                    \"\"\".trimIndent()\n                )\n            }\n\n        }\n    }\n}\n```\n\n実行結果\n\n![Imgur](https://imgur.com/wwflXdr.png)\n\n## リスト表示\n\n`RecyclerView`みたいに画面外は表示しない`LazyColumn`ってのがありますのでこれを使っていきます\n\nまずRecyclerViewのAdapterみたいに一つだけのやつを用意します。\n\n```kotlin\n@Composable\nfun BlogCard(blogTitle: String) {\n    // 押した回数を保持する\n    var count by remember { mutableStateOf(0) }\n\n    Card(\n        modifier = Modifier.padding(10.dp),\n        elevation = 10.dp\n    ) {\n        Column(\n            modifier = Modifier.padding(10.dp), // スペース確保\n            verticalArrangement = Arrangement.Center, // まんなかに\n        ) {\n            Row(\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Image(\n                    imageVector = Icons.Outlined.Book,\n                    modifier = Modifier.height(50.dp).width(50.dp),\n                )\n                Text(\n                    text = blogTitle,\n                    modifier = Modifier.weight(1f)\n                )\n            }\n            Divider(modifier = Modifier.padding(0.dp, 10.dp, 0.dp, 0.dp)) // 区切り線\n            IconButton(onClick = {\n                // カウントアップ\n                count++\n            }) {\n                Row(\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Icon(imageVector = Icons.Outlined.FavoriteBorder)\n                    Text(text = \"$count\")\n                }\n            }\n        }\n    }\n}\n```\n\n\nそしたら一覧表示を作って完成\n\n```kotlin\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            BlogCardList()\n        }\n    }\n}\n\n@Composable\nfun BlogCardList() {\n    val blogList = listOf(\n        \"Jetpack Compose 略して？\",\n        \"MotionLayoutでミニプレイヤー\",\n        \"2020年おすすめボカロ\",\n        \"ボカロバラードいいよね\",\n    )\n    Surface(Modifier.fillMaxSize()) {\n        LazyColumn(content = {\n            items(blogList) {\n                BlogCard(it)\n            }\n        })\n    }\n}\n\n@Preview\n@Composable\nfun TestComposePreview() {\n    BlogCardList()\n}\n```\n\nこんな感じになると思う。`RecyclerView`より一覧表示がかんたんで嬉しい。  \n(Vue.jsの`v-for`みたいで使いやすい)\n\n![Imgur](https://imgur.com/gh2VjIL.png)\n\n# Fragment に設置する\n\nとりあえず一つにFragmentからJetpack Compose使ってみようかなって。そんな方に\n\n## 今（2020/12/30現在）だけ？\nFragmentを作るにはFragmentのバージョンを上げる必要があります。あげないと、`prepareCall`とか言う謎のメソッドを書かないといけなくなります（正体不明）  \n`app`フォルダにある`build.gradle`を開いて`dependencies`に書き足します\n\n```java\ndependencies {\n    // Fragmentを作ろうとすると謎のメソッドをオーバーライドさせようとするので\n    implementation 'androidx.fragment:fragment-ktx:1.3.0-rc01'\n}\n```\n\nそしたら`BlogListFragment.kt`を作成してコピペ\n\n```kotlin\nclass BlogListFragment : Fragment() {\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                MaterialTheme {\n                    Scaffold(\n                        topBar = {\n                            TopAppBar() {\n                                Column(\n                                    horizontalAlignment = Alignment.CenterHorizontally,\n                                    verticalArrangement = Arrangement.Center,\n                                    modifier = Modifier.fillMaxHeight().padding(10.dp),\n                                ) {\n                                    Text(text = \"ブログ一覧\")\n                                }\n                            }\n                        }\n                    ) {\n                        BlogCardList()\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n`BlogCardList()`どこから出てきたんだって話ですが、`MainActivity.kt`に書いてあるのをそのまま使いました。  \n本来はComposeのUI用クラスを用意すべきです。  \n\nあと`BlogCardList()`関数？メソッド？はどこのクラスにも所属していない（class { } の中に書いてない）  \n**トップレベル関数**ってやつなので、どこでもかけます？。注意点ですが**名前がかぶる**とエラーになります。\n\n後はActivityに置きましょう。今までのXMLな感じで  \nサンプルコードではxml使わず(R.layout.activity_main)、動的にFrameLayoutを置いてますが別にXMLでFrameLayout置いてid設定してもいいです。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // レイアウト作るのめんどいので動的に作る。別にXMLでレイアウト置いてもいい\n        val fragmentHostLayout = FrameLayout(this)\n        fragmentHostLayout.id = View.generateViewId()\n        setContentView(fragmentHostLayout)\n\n        supportFragmentManager.beginTransaction().replace(fragmentHostLayout.id, BlogListFragment()).commit()\n\n    }\n}\n```\n\nちなみに`Navigation`は使ったことがないです。`argument`渡すのが楽になるとかなんとか\n\n## 真ん中に表示させたい\n一番実用性がありそう\n\n### Row（横並び編）\n\n注意点としては`verticalAlignment`と`horizontalArrangement`で指定している値のスペルが若干似てるってことですかね。\n\n| なまえ                | あたい                         |\n|-----------------------|--------------------------------|\n| verticalAlignment     | **Alignment**.CenterVertically |\n| horizontalArrangement | **Arrangement**.Center         |\n\n### Column（縦並び編）\n`Row`とは逆になります。\n\n| なまえ              | あたい                           |\n|---------------------|----------------------------------|\n| verticalArrangement | **Arrangement**.Center           |\n| horizontalAlignment | **Alignment**.CenterHorizontally |\n\n以下サンプルコード\n\n```kotlin\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n        CardCenterText()\n    }\n}\n\n@Composable\nfun CardCenterText() {\n    Column {\n        Card(\n            modifier = Modifier.padding(10.dp).fillMaxWidth().height(100.dp),\n            backgroundColor = Color.Cyan,\n        ) {\n            Row(\n                horizontalArrangement = Arrangement.Center,\n                verticalAlignment = Alignment.CenterVertically,\n            ) {\n                Text(text = \"まんなかに居座る Row\")\n                Icon(imageVector = Icons.Outlined.Android)\n            }\n        }\n        Card(\n            modifier = Modifier.padding(10.dp).fillMaxWidth().height(100.dp),\n            backgroundColor = Color.Cyan,\n        ) {\n            Column(\n                verticalArrangement = Arrangement.Center,\n                horizontalAlignment = Alignment.CenterHorizontally,\n            ) {\n                Text(text = \"まんなかに居座る Column\")\n                Icon(imageVector = Icons.Outlined.Android)\n            }\n        }\n    }\n}\n```\n\nこんな感じ\n\n![Imgur](https://imgur.com/ejw6EYv.png)\n\n\n# 遭遇したエラー\n\n## R.jar: プロセスはファイルにアクセスできません。別のプロセスが使用中です。\n\n`@Preview`から実行しようとすると失敗する。ので、`ActivityとかFragment`に置いていつもどおり実行したほうがいい。てかプレビューより早くない？\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            VideoInfo()\n        }\n    }\n}\n```\n\nどうしても`@Preview`から実行したければ\n\n`Make Project`した後に実行させるとうまくいく？\n\n![Imgur](https://imgur.com/QwiEqH5.png)\n\n## Type 'TypeVariable(T)' has no method 'getValue(Nothing?, KProperty<*>)' and thus it cannot serve as a delegate\n\n### by remember { } じゃないもう一つの方法\n\n```kotlin\n// プロパティデリゲート とか言う書き方\nvar selectTabIndex_ by remember { mutableStateOf(0) }\n// アクセス\nselectTabIndex_ = 0\n\n// 割り当て演算子\nvar selectTabIndex = remember { mutableStateOf(0) }\nselectTabIndex.value = 0\n```\n\n上も下も同じことができるので、だめな場合は下の方を試してみてください。アクセスの際に`value`を付ける必要がありますが\n\n\n### else\n\nなんかコピペし直したら治った。一応使ってる`import`書いておきますね\n\n```kotlin\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.material.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.outlined.Book\nimport androidx.compose.material.icons.outlined.FavoriteBorder\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.setContent\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n```\n\n## Caused by: java.lang.ClassNotFoundException: Composable Method ~\n\n`@Preview`のついた関数を消してそのまま実行すると出る。切り替えてあげよう\n\n![Imgur](https://imgur.com/VXetpSK.png)\n\n\n## java.lang.NoSuchMethodError: No static method ~\n\n関数有るのに無いとか言ってくるやつ。\n\nツールバーの`Build`から`Clean Project`を実行した後に再度実行すると直るんじゃないかな\n\n![Imgur](https://imgur.com/O8goR2b.png)\n\n## なんか真っ赤になった。Importしてもなんか別なのがImportされるんだけど？\n\n`Sync Project`したらなんかアップデートしませんか？(Android Gradle Pluginだと思われ)って聞かれたのでアプデしたらなんか治った。難しいね\n\n![Imgur](https://imgur.com/ZSiRS9T.png)\n\n# ソースコード\n`Android Studio Arctic Fox | 2020.3.1 Canary 3`で動作確認済です。  \nとりあえずブログ一覧を表示させた状態の画面が開くようになってるはずです。\n\nhttps://github.com/takusan23/BlogListCompose\n\n# 終わりに\n- CPUとかメモリとかのリソースくっっっそ持っていくなこいつ。メモリも16GBあるのに無くなりそう()  \n- あとプレビューまだ不十分感。なんかずれたりするし。\n    - Activityに置いて普通に実行したほうが(私は)はやかった\n- アイコンがすでに用意されているのは嬉しい。取り込む作業がなくなった\n    - ただAndroid StudioのDrawable表示機能が便利だったのでちょっとつらい\n\nあと`margin`ってないのかな。見つけられなかったんだけど  \n"},{"title":"Jetpack Composeで真ん中にする","link":"/posts/android_jc_center/","markdown":"\r\nどうもこんばんわ。  \r\nゆびさきコネクション、攻略しました。  \r\n\r\n![Imgur](https://imgur.com/LAo5lKO.png)\r\n\r\nこの子かわいい（お酒の話分からんかったけど）\r\n\r\nあとヒロインカスタムパッチを夏歩ちゃんにしたときのクイックロードの音声可愛かった\r\n\r\n# 本題\r\nJetpack Composeで`gravity=\"center\"`する方法です  \r\n今更ながらメモ\r\n\r\n# その前に\r\n`Android Studio`のテンプレート？から`Empty Compose`を選択してプロジェクトを作成すると、実行できません。  \r\n`Jetpack Compose`のバージョンを`1.0.0-rc01`へ、`Kotlin`のバージョンを`1.5.10`へ設定してください。\r\n\r\n(appフォルダではない方の`build.gradle`)\r\n\r\n```gradle\r\nbuildscript {\r\n    ext {\r\n        compose_version = '1.0.0-rc01' // ここを1.0.0-rc01へ\r\n    }\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        classpath \"com.android.tools.build:gradle:7.0.0-beta05\"\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.10\" // ここを1.5.10へ\r\n\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n```\r\n\r\n(appフォルダの`build.gradle`)\r\n\r\n```gradle\r\ncomposeOptions {\r\n    kotlinCompilerExtensionVersion compose_version\r\n    kotlinCompilerVersion '1.5.10' // 1.5.10へ\r\n}\r\n```\r\n\r\n# Layout 編\r\nここで言う`Layout`は、`Column`、`Row`、`Box`みたいなやつです。  \r\n`Alignment.Center`以外にも`Start`とかあったと思うのでどうぞ\r\n\r\n## Box\r\nView時代の`FrameLayout`に当たるやつ。重ねられます。\r\n\r\n```kotlin\r\nBox(\r\n    modifier = Modifier.fillMaxSize(),\r\n    contentAlignment = Alignment.Center\r\n) {\r\n    Text(text = \"Android\")\r\n    Text(text = \"Jetpack\")\r\n    Text(text = \"Compose\")\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/WS0R8dv.png)\r\n\r\n## Column\r\n縦積みLinearLayout\r\n\r\n```kotlin\r\nColumn(\r\n    modifier = Modifier.fillMaxSize(),\r\n    horizontalAlignment = Alignment.CenterHorizontally, // 横方向\r\n    verticalArrangement = Arrangement.Center // 縦方向\r\n) {\r\n    Text(text = \"Android\")\r\n    Text(text = \"Jetpack\")\r\n    Text(text = \"Compose\")\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/SvrEPky.png)\r\n\r\n\r\n## Row\r\n横並べLinearLayout  \r\nColumnのときと逆になりますね。\r\n\r\n```kotlin\r\nRow(\r\n    modifier = Modifier.fillMaxSize(),\r\n    horizontalArrangement = Arrangement.Center,\r\n    verticalAlignment = Alignment.CenterVertically\r\n) {\r\n    Text(text = \"Android\")\r\n    Text(text = \"Jetpack\")\r\n    Text(text = \"Compose\")\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/43hkYm7.png)\r\n\r\n# 全部真ん中である必要はないときのための\r\n`Box`、`Column`、`Row`の子供のときだけ使える`Modifier`の関数があります。\r\n\r\n## Box\r\n\r\n```kotlin\r\nBox(modifier = Modifier.fillMaxSize()) {\r\n    Text(text = \"Android\", modifier = Modifier.align(alignment = Alignment.TopStart)) // 左上\r\n    Text(text = \"Jetpack\", modifier = Modifier.align(alignment = Alignment.Center)) // 真ん中\r\n    Text(text = \"Compose\", modifier = Modifier.align(alignment = Alignment.BottomEnd)) // 右下\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/u8sk2nm.png)\r\n\r\n## Column\r\n\r\n```kotlin\r\nColumn(\r\n    modifier = Modifier.fillMaxSize(),\r\n) {\r\n    Text(text = \"Android\",modifier = Modifier.align(alignment = Alignment.Start)) // 左\r\n    Text(text = \"Jetpack\",modifier = Modifier.align(alignment = Alignment.CenterHorizontally)) // 真ん中\r\n    Text(text = \"Compose\",modifier = Modifier.align(alignment = Alignment.End)) // 右\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/UYfAYOz.png)\r\n\r\n## Row\r\n\r\n```kotlin\r\nRow(\r\n    modifier = Modifier.fillMaxSize(),\r\n) {\r\n    Text(text = \"Android\",modifier = Modifier.align(Alignment.Top)) // 上\r\n    Text(text = \"Jetpack\",modifier = Modifier.align(Alignment.CenterVertically)) // 真ん中\r\n    Text(text = \"Compose\",modifier = Modifier.align(Alignment.Bottom)) // 下\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/cEHpKIy.png)\r\n\r\nなお、上記の方法は`Modifier`が引数に取ってあることが必須なため、  \r\nオリジナル`@Composable`な関数の場合は引数に`Modifier`を取るようにしよう。\r\n\r\n```kotlin\r\nRow(\r\n    modifier = Modifier.fillMaxSize(),\r\n) {\r\n    Text(text = \"Android\", modifier = Modifier.align(Alignment.Top)) // 上\r\n    Text(text = \"Jetpack\", modifier = Modifier.align(Alignment.CenterVertically)) // 真ん中\r\n    Text(text = \"Compose\", modifier = Modifier.align(Alignment.Bottom)) // 下\r\n    \r\n    ComposeHelloWorldText(Modifier.align(Alignment.Top))\r\n}\r\n\r\n// 省略\r\n\r\n@Composable\r\nfun ComposeHelloWorldText(modifier: Modifier = Modifier) {\r\n    Text(\r\n        text = \"Hello World\",\r\n        modifier = modifier\r\n    )\r\n}\r\n```\r\n\r\nちなみに`ColumnScope`、`RowScope`、`BoxScope`の拡張関数とした`@Composable`な関数も作れないわけじゃないけどなんか自由度が減るのでやめとこう？\r\n\r\n```kotlin\r\nRow(\r\n    modifier = Modifier.fillMaxSize(),\r\n) {\r\n    Text(text = \"Android\", modifier = Modifier.align(Alignment.Top)) // 上\r\n    Text(text = \"Jetpack\", modifier = Modifier.align(Alignment.CenterVertically)) // 真ん中\r\n    Text(text = \"Compose\", modifier = Modifier.align(Alignment.Bottom)) // 下\r\n\r\n    // 親がRow限定\r\n    ComposeHelloWorldText2()\r\n}\r\n\r\n// 省略\r\n\r\n@Composable\r\nfun RowScope.ComposeHelloWorldText2() {\r\n    Text(\r\n        text = \"Hello World\",\r\n        modifier = Modifier.align(Alignment.Top),\r\n    )\r\n}\r\n```\r\n\r\n\r\n# 終わりに\r\n`comp`まで入力すれば`@Composable`な関数を一瞬で作れます。\r\n\r\n![Imgur](https://imgur.com/GbDP9rT.png)\r\n\r\n![Imgur](https://imgur.com/LJZx5Wq.png)\r\n\r\nあとクソどうでもいいんだけど、エロゲをリモートデスクトップでスマホから遊ぶときは`Steam Link`を使うといいかも。ルーターを超えられる(同じネットワークにいる必要がない)ので外からでも出来るのが強い。  "},{"title":"Jetpack Composeでカスタムレイアウト","link":"/posts/android_jc_custom_layout/","markdown":"\r\n<img src=\"https://imgur.com/fQzaLrQ.png\" width=400>\r\n\r\nかわいい（曲もいい）\r\n\r\n# 本題\r\nJetpackComposeで折り返すレイアウトがほしいので作った。 \r\n\r\n<img src=\"https://imgur.com/AgAFKs6.png\" width=300>\r\n\r\n# 完成品（ライブラリ）はこちら\r\n\r\nライブラリにしたのでこの記事読まなくていいよ\r\n\r\nhttps://github.com/takusan23/ComposeOrigamiLayout\r\n\r\n導入方法はREADME読んで（特に変わったことはしてない）\r\n\r\n## 環境\r\n最新の開発環境を使おう\r\n\r\n|なまえ|あたい|\r\n|---|---|\r\n|Android Studio|Android Studio Arctic Fox 2020.3.1 Canary 9|\r\n|JetpackCompose|1.0.0-beta01|\r\n\r\n## JetpackCompose 導入\r\n\r\nappフォルダ内のbuild.gradleを開いて\r\n\r\n```gradle\r\nandroid {\r\n    // 省略\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n        useIR = true\r\n    }\r\n    buildFeatures {\r\n        compose true\r\n    }\r\n    composeOptions {\r\n        kotlinCompilerExtensionVersion '1.0.0-beta01'\r\n        kotlinCompilerVersion '1.4.30'\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    implementation \"androidx.compose.ui:ui:1.0.0-beta01\"\r\n    implementation \"androidx.compose.material:material:1.0.0-beta01\"\r\n    implementation \"androidx.compose.ui:ui-tooling:1.0.0-beta01\"\r\n\r\n}\r\n```\r\n\r\n# 作成\r\n適当なKotlinファイルを作成してComposeな関数を作っていきましょう\r\n\r\n```kotlin\r\n@Composable\r\nfun OrigamiLayout() {\r\n    \r\n}\r\n```\r\n\r\n## カスタムLayout\r\n`View`で言うところの`ViewGroup`ですね。  \r\nとりあえず引数をセットしてあげて、`Layout()`を置きます。\r\n\r\n```kotlin\r\n/**\r\n * 折り返すLayout\r\n *\r\n * @param modifier Paddingなど\r\n * @param content 表示したい部品\r\n * */\r\n@Composable\r\nfun OrigamiLayout(\r\n    modifier: Modifier = Modifier,\r\n    content: @Composable () -> Unit,\r\n) {\r\n    Layout(\r\n        content = content,\r\n        modifier = modifier\r\n    ) { measurables, constraints ->\r\n\r\n    }\r\n}\r\n```\r\n\r\nこれから返り値を書いてあげます\r\n\r\n## measurables と constraints\r\n\r\n- constraints\r\n\r\n`constraints`ってのは親の部品の大きさとかが取れるやつですね。\r\n\r\nどういうことかというと、\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            ComposeOrigamiLayoutTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(color = MaterialTheme.colors.background) {\r\n                    \r\n                    Column(\r\n                        modifier = Modifier.width(200.dp) // これと\r\n                    ) {\r\n                        Layout(content = {\r\n                            Text(text = \"Hello World\")\r\n                        }) { measurables, constraints ->\r\n\r\n                            println(200.dp.toPx())\r\n                            println(constraints.maxWidth) // これ\r\n\r\n                            layout(constraints.maxWidth, constraints.maxHeight) {\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nこれと　これ　って書いてある部分は同じ値になるということです。  \r\n一応200dpの値をpxにして出力しましたが同じ値になると思います。\r\n\r\n- measurables\r\nこいつは`content`引数に入れたUI部品の大きさを測定するときに使う。  \r\n最大値と最小値の情報を渡すと大きさが入ったデータを返してくれる。\r\n\r\n## これから置く部品の大きさを測定する\r\n`Measurable#measure()`は一度しか呼べません。（多分）\r\n\r\n```kotlin\r\n/**\r\n * 折り返すLayout\r\n *\r\n * @param modifier Paddingなど\r\n * @param content 表示したい部品\r\n * */\r\n@Composable\r\nfun OrigamiLayout(\r\n    modifier: Modifier = Modifier,\r\n    content: @Composable () -> Unit,\r\n) {\r\n    Layout(\r\n        content = content,\r\n        modifier = modifier\r\n    ) { measurables, constraints ->\r\n        // この中に入るCompose（子供Compose）の幅とかの情報の配列にする\r\n        val placeableList = measurables.map { it.measure(Constraints(0, constraints.maxWidth, 0, constraints.maxHeight)) }.toMutableList()\r\n    }\r\n}\r\n```\r\n\r\n## おけるかどうか（折り返すかどうか）\r\n折り返すかどうかの計算をここで行います。とりまコピペ  \r\nデータクラスにしても良かったけど３つだったのでTripleにX座標、Y座標、placeableをそれぞれ入れた\r\n\r\n```kotlin\r\nLayout(\r\n    content = content,\r\n    modifier = modifier\r\n) { measurables, constraints ->\r\n    // この中に入る部品の幅とかの情報の配列にする\r\n    val placeableList = measurables.map { it.measure(Constraints(0, constraints.maxWidth, 0, constraints.maxHeight)) }.toMutableList()\r\n    // 最終的に入れるときに使うやつ\r\n    val childrenDataList = arrayListOf<Triple<Int, Int, Placeable>>()\r\n    // このComposeの幅\r\n    val origamiWidth = constraints.maxWidth\r\n    // 高さ計算\r\n    var origamiHeight = 0\r\n    // 列に入ってるComposeの合計の幅\r\n    var lineWidth = 0\r\n    // 子供Composeがの位置を決定する\r\n    placeableList.forEach { placeable ->\r\n        if (lineWidth + placeable.width < origamiWidth) {\r\n            // 今の行の幅が足りている場合\r\n            // width / height / placeable\r\n            childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n            lineWidth += placeable.width\r\n        } else {\r\n            // 足りてない\r\n            // 次はもう入らないので次の行へ\r\n            lineWidth = 0\r\n            origamiHeight += placeable.height\r\n            // width / height / placeable\r\n            childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n            // 幅を足す\r\n            lineWidth = placeable.width\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 配置する\r\n`layout()`を呼んで、`placeRelative()`を呼ぶことで部品が配置されます。  \r\n\r\n```kotlin\r\nLayout(\r\n    content = content,\r\n    modifier = modifier\r\n) { measurables, constraints ->\r\n    // この中に入る部品の幅とかの情報の配列にする\r\n    val placeableList = measurables.map { it.measure(Constraints(0, constraints.maxWidth, 0, constraints.maxHeight)) }.toMutableList()\r\n    // 最終的に入れるときに使うやつ\r\n    val childrenDataList = arrayListOf<Triple<Int, Int, Placeable>>()\r\n    // このComposeの幅\r\n    val origamiWidth = constraints.maxWidth\r\n    // 高さ計算\r\n    var origamiHeight = 0\r\n    // 列に入ってるComposeの合計の幅\r\n    var lineWidth = 0\r\n    // 子供Composeがの位置を決定する\r\n    placeableList.forEach { placeable ->\r\n        if (lineWidth + placeable.width < origamiWidth) {\r\n            // 今の行の幅が足りている場合\r\n            // width / height / placeable\r\n            childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n            lineWidth += placeable.width\r\n        } else {\r\n            // 足りてない\r\n            // 次はもう入らないので次の行へ\r\n            lineWidth = 0\r\n            origamiHeight += placeable.height\r\n            // width / height / placeable\r\n            childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n            // 幅を足す\r\n            lineWidth = placeable.width\r\n        }\r\n    }\r\n    // origamiHeightは、部品を置く際の座標（左上）になりますので、高さとして使うにはもう一度部品の高さを足してあげないといけない\r\n    val lastItemHeight = if (placeableList.isEmpty()) 0 else placeableList.last().height\r\n    layout(width = constraints.maxWidth, height = origamiHeight + lastItemHeight) {\r\n        childrenDataList.forEach { triple ->\r\n            val xPos = triple.first\r\n            val yPos = triple.second\r\n            val placeable = triple.third\r\n            // 設置\r\n            placeable.placeRelative(xPos, yPos)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 置いて使ってみる\r\n\r\n```kotlin\r\n@Composable\r\nfun HomeScreen() {\r\n    Column(\r\n        modifier = Modifier.fillMaxHeight(),\r\n    ) {\r\n        // 文字列配列\r\n        val list = remember { mutableStateListOf<String>() }\r\n        // テキストボックスに入れてる文字列\r\n        val editTextValue = remember { mutableStateOf(\"\") }\r\n        // 折り返すやつ\r\n        OrigamiLayout {\r\n            // テキスト配置\r\n            list.forEach { text ->\r\n                OutlinedButton(\r\n                    onClick = { },\r\n                    modifier = Modifier.padding(2.dp)\r\n                ) {\r\n                    Text(\r\n                        text = text\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        // 追加\r\n        Row {\r\n            // テキストボックス\r\n            TextField(\r\n                modifier = Modifier.weight(1f),\r\n                value = editTextValue.value,\r\n                onValueChange = { editTextValue.value = it }\r\n            )\r\n            // 追加ボタン\r\n            Button(\r\n                onClick = {\r\n                    list.add(editTextValue.value)\r\n                },\r\n                modifier = Modifier\r\n                    .padding(10.dp)\r\n            ) {\r\n                Text(text = \"Add Text\")\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nあとはMainActivityなんかに置いて完成\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            ComposeOrigamiLayoutTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(color = MaterialTheme.colors.background) {\r\n                    HomeScreen()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n説明すっとばちゃったけどこんな感じになります。\r\n\r\n![Imgur](https://imgur.com/OnLimT7.png)\r\n\r\n## 短い順にしてスペースを有効活用させる\r\n**並び替えしても問題ないなら**の話ですが  \r\nこの小さい順に並び替えるやつ(`ArrayList#sort{ }`)便利\r\n\r\n```kotlin\r\n/**\r\n * 折り返すLayout\r\n *\r\n * @param modifier Paddingなど\r\n * @param isAcceptSort 並び替えしてもいいならtrue\r\n * @param content 表示したい部品\r\n * */\r\n@Composable\r\nfun OrigamiLayout(\r\n    modifier: Modifier = Modifier,\r\n    isAcceptSort: Boolean = false,\r\n    content: @Composable () -> Unit,\r\n) {\r\n    Layout(\r\n        content = content,\r\n        modifier = modifier\r\n    ) { measurables, constraints ->\r\n        // この中に入るCompose（子供Compose）の幅とかの情報の配列にする\r\n        // なんかConstraints()のmaxのところはMAX_VALUE入れといてminには0を入れてあげれば大きさが取れるようになる\r\n        val placeableList = measurables.map { it.measure(Constraints(0, constraints.maxWidth, 0, constraints.maxHeight)) }.toMutableList()\r\n        // 最終的に入れるときに使うやつ\r\n        val childrenDataList = arrayListOf<Triple<Int, Int, Placeable>>()\r\n        // このComposeの幅\r\n        val origamiWidth = constraints.maxWidth\r\n        // 高さ計算\r\n        var origamiHeight = 0\r\n        // 列に入ってるComposeの合計の幅\r\n        var lineWidth = 0\r\n        // 並び替えを許可している場合は並び替える\r\n        if(isAcceptSort){\r\n            placeableList.sortBy { placeable -> placeable.width }\r\n        }\r\n        // 子供Composeがの位置を決定する\r\n        placeableList.forEach { placeable ->\r\n            if (lineWidth + placeable.width < origamiWidth) {\r\n                // 今の行の幅が足りている場合\r\n                // width / height / placeable\r\n                childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n                lineWidth += placeable.width\r\n            } else {\r\n                // 足りてない\r\n                // 次はもう入らないので次の行へ\r\n                lineWidth = 0\r\n                origamiHeight += placeable.height\r\n                // width / height / placeable\r\n                childrenDataList.add(Triple(lineWidth, origamiHeight, placeable))\r\n                // 次の行に移動して幅を足す\r\n                lineWidth = placeable.width\r\n            }\r\n        }\r\n        // 子Composeを置いていく\r\n        // origamiHeightは、部品を置く際の座標（左上）になりますので、高さとして使うにはもう一度部品の高さを足してあげないといけない\r\n        val lastItemHeight = if (placeableList.isEmpty()) 0 else placeableList.last().height\r\n        layout(width = constraints.maxWidth, height = origamiHeight + lastItemHeight) {\r\n            childrenDataList.forEach { triple ->\r\n                val xPos = triple.first\r\n                val yPos = triple.second\r\n                val placeable = triple.third\r\n                // 設置\r\n                placeable.placeRelative(xPos, yPos)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使う方で`true`してあげる。\r\n\r\n```kotlin\r\n@Composable\r\nfun HomeScreen() {\r\n    Column(\r\n        modifier = Modifier.fillMaxHeight(),\r\n    ) {\r\n        // 文字列配列\r\n        val list = remember { mutableStateListOf<String>() }\r\n        // テキストボックスに入れてる文字列\r\n        val editTextValue = remember { mutableStateOf(\"\") }\r\n        // 折り返すやつ\r\n        OrigamiLayout(\r\n            isAcceptSort = true // ソート有効\r\n        ) {\r\n            // テキスト配置\r\n            list.forEach { text ->\r\n                OutlinedButton(\r\n                    onClick = { },\r\n                    modifier = Modifier.padding(2.dp)\r\n                ) {\r\n                    Text(\r\n                        text = text\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        // 追加\r\n        Row {\r\n            // テキストボックス\r\n            TextField(\r\n                modifier = Modifier.weight(1f),\r\n                value = editTextValue.value,\r\n                onValueChange = { editTextValue.value = it }\r\n            )\r\n            // 追加ボタン\r\n            Button(\r\n                onClick = {\r\n                    list.add(editTextValue.value)\r\n                },\r\n                modifier = Modifier\r\n                    .padding(10.dp)\r\n            ) {\r\n                Text(text = \"Add Text\")\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nこれで短い順に上から入っていきます。  \r\n\r\n![Imgur](https://imgur.com/AgAFKs6.png)\r\n\r\n# おわりに\r\nソースコードです。  \r\n\r\n\r\n\r\n参考にしました。ありがとうございます。\r\n\r\nhttps://qiita.com/takahirom/items/c6625cbc7ebdda49de2f\r\n\r\nhttps://developer.android.com/jetpack/compose/layout?hl=ja"},{"title":"Jetpack Compose ダークモード時に真っ白","link":"/posts/android_jc_darkmode_white/","markdown":"\r\nどうもこんばんわ。\r\n\r\n# 本題\r\nダークモード時に黒くならない\r\n\r\n![Imgur](https://imgur.com/tHm9Hog.png)\r\n\r\n# 直し方\r\n\r\n`Surface`で囲ってあげます。`material3`を入れている場合は`material3`の方の`Surface`で囲ってあげてください。\r\n\r\n```kotlin\r\nSurface {\r\n    Column(modifier = Modifier.padding(10.dp)) {\r\n        SetupButtons(\r\n            modifier = Modifier\r\n                .fillMaxWidth(),\r\n            text = stringResource(id = R.string.launch_server),\r\n            icon = painterResource(id = R.drawable.ic_outline_file_download_24),\r\n            description = stringResource(id = R.string.launch_server_description),\r\n            onClick = { onNavigate(NavigationLinkList.ServerSetupScreen) }\r\n        )\r\n        SetupButtons(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(top = 10.dp),\r\n            text = stringResource(id = R.string.launch_client),\r\n            icon = painterResource(id = R.drawable.ic_outline_file_upload_24),\r\n            onClick = { onNavigate(NavigationLinkList.ClientSetupScreen) }\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/EnBTZRz.png)\r\n\r\n以上です。お疲れさまでした。"},{"title":"Jetpack ComposeにMaterial3を入れてダイナミックカラー使う","link":"/posts/android_jc_dynamic_color/","markdown":"どうもこんばんわ。\r\n\r\nアインシュタインより愛を込めて 攻略しました。  \r\n\r\nなんか色々思うことはあるけど最後のタイトル回収とED曲で許した感ある。  \r\nあとこの子かわいい。\r\n\r\n![Imgur](https://imgur.com/u03dpx2.png)\r\n\r\nサブヒロインの扱い雑すぎて悲しくなっちゃった\r\n\r\n↓  \r\n↓  \r\n↓  \r\n\r\nアインシュタインより愛を込めて APOLLOCRISIS 攻略しました。  \r\n今月のエロゲの日から無料配信されるみたいなので**前作やった人は絶対やろう**。やってロミちゃんを助けてあげて、、、\r\n\r\n![Imgur](https://imgur.com/ilgmLD0.png)\r\n\r\n野上さんいい人\r\n\r\n# 本題\r\n`Jetpack Compose`にも`Material3`ライブラリがリリースされました。  \r\nダイナミックカラーが使えるようになります。ちなみに`BottomNavigationBar`の高さは`56.dp`？から`80.dp`と大きくなりました。\r\n\r\n![Imgur](https://imgur.com/S1bWXYG.png)\r\n\r\n# 環境\r\n\r\n| なまえ         | あたい                             |\r\n|----------------|------------------------------------|\r\n| Android        | 12 (ダイナミックカラー使うなら必須) |\r\n| Android Stuido | Arctic Fox 2020.3.1 Patch 3        |\r\n| targetSdk      | 31                                 |\r\n\r\n# 公式ドキュメント\r\n\r\n## 導入\r\n\r\nhttps://developer.android.com/jetpack/compose/themes/material#material3\r\n\r\n## Material3\r\n\r\nhttps://m3.material.io/\r\n\r\n## 1. 導入\r\n\r\n`app/build.gradle`に書き足すだけです。（新世界の）α版なので安定しないかもらしいです。\r\n\r\n```\r\ndependencies {\r\n\r\n    // Jetpack Compose\r\n    implementation(\"androidx.compose.ui:ui:1.1.0-beta01\")\r\n    implementation(\"androidx.compose.material:material:1.1.0-beta01\")\r\n    implementation(\"androidx.compose.ui:ui-tooling-preview:1.1.0-beta01\")\r\n    androidTestImplementation(\"androidx.compose.ui:ui-test-junit4:1.1.0-beta01\")\r\n    debugImplementation(\"androidx.compose.ui:ui-tooling:1.1.0-beta01\")\r\n\r\n    // ↓これ\r\n    implementation(\"androidx.compose.material3:material3:1.0.0-alpha01\")\r\n\r\n}\r\n```\r\n\r\n## 2. Theme.kt (MaterialTheme)を書き換える\r\n次に`Theme.kt`か`MaterialTheme`を書き換えます。  \r\nプロジェクト作成時から`Composeプロジェクト`を選んだ場合は`Theme.kt`って名前で`MaterialTheme`をカスタマイズしている関数があるはずです。\r\n\r\n以下は一例です。  \r\nなんか色の扱いが変わってるので以下のサイトで色を吐き出してもらってもいいかも？  \r\n\r\nhttps://material-foundation.github.io/material-theme-builder/\r\n\r\n```kotlin\r\nval PrimaryColor = Color(0xff8c9bde)\r\nval DarkColor = Color(0xff7873c2)\r\nval LightColor = Color(0xffd1f7e3)\r\n\r\n@SuppressLint(\"NewApi\")\r\n@Composable\r\nfun ComposeDynamicColorTheme(\r\n    darkTheme: Boolean = isSystemInDarkTheme(),\r\n    isEnableDynamicColor: Boolean = true,\r\n    content: @Composable () -> Unit,\r\n) {\r\n    val context = LocalContext.current\r\n    // ダイナミックカラー使う？\r\n    val isUseDynamicColor = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S\r\n            && isEnableDynamicColor\r\n\r\n    // Android 12以降で\r\n    val colorScheme = when {\r\n        isUseDynamicColor && darkTheme -> dynamicDarkColorScheme(context)\r\n        isUseDynamicColor && !darkTheme -> dynamicLightColorScheme(context)\r\n        darkTheme -> darkColorScheme(\r\n            primary = PrimaryColor,\r\n            secondary = LightColor,\r\n            tertiary = DarkColor,\r\n        )\r\n        else -> lightColorScheme(\r\n            primary = PrimaryColor,\r\n            secondary = LightColor,\r\n            tertiary = DarkColor,\r\n        )\r\n    }\r\n\r\n    MaterialTheme(\r\n        colorScheme = colorScheme,\r\n        content = content\r\n    )\r\n}\r\n```\r\n\r\n`MaterialTheme`は`androidx.compose.material3.MaterialTheme`をインポートするようにしてください。\r\n\r\n```kotlin\r\nimport android.annotation.SuppressLint\r\nimport android.os.Build\r\nimport androidx.compose.foundation.isSystemInDarkTheme\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.platform.LocalContext\r\n```\r\n\r\n#### 注意点？\r\n\r\n`(androidx.compose.material.)MaterialTheme.colors`は使えなくなります。   \r\n`(androidx.compose.material3.)MaterialTheme.colorScheme`を使ってください。ない場合は`import`間違えてます。\r\n\r\n`backgroundColor`は`containerColor`に変わった模様？\r\n\r\n## 3. ひたすら `import androidx.compose.material`から`import androidx.compose.material3`に書き換えてく\r\n\r\n対応しているコンポーネントは以下です。  \r\n\r\nhttps://developer.android.com/jetpack/androidx/releases/compose-material3  \r\n\r\n`Text`、`Icon`なんかも`Material3`で用意されている方を使う必要があります。  \r\n\r\n選ぶ際は`material3`って書いてある方を。  \r\n\r\n![Imgur](https://imgur.com/1CMjVPr.png)\r\n\r\n以下例です。  \r\nコピペする際は、`ic_android_black_24dp`を`Android Studio`の`Vector Asset`から追加してください。\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    @OptIn(ExperimentalMaterial3Api::class)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            ComposeDynamicColorTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(color = MaterialTheme.colorScheme.background) {\r\n\r\n                    Scaffold(\r\n                        topBar = { MediumTopAppBar(title = { Text(text = \"タイトルバー\") }) },\r\n                        bottomBar = {\r\n                            NavigationBar {\r\n                                NavigationBarItem(\r\n                                    selected = true,\r\n                                    icon = { Icon(painter = painterResource(id = R.drawable.ic_android_black_24dp), contentDescription = null) },\r\n                                    label = { Text(text = \"Android\") },\r\n                                    onClick = { }\r\n                                )\r\n                            }\r\n                        },\r\n                        floatingActionButton = {\r\n                            ExtendedFloatingActionButton(\r\n                                text = { Text(text = \"ExtendedFAB\") },\r\n                                icon = { Icon(painter = painterResource(id = R.drawable.ic_android_black_24dp), contentDescription = null) },\r\n                                onClick = { }\r\n                            )\r\n                        },\r\n                        content = {\r\n                            Button(onClick = { }) {\r\n                                Text(text = \"Hello World\")\r\n                            }\r\n                        },\r\n                    )\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nよーこそMaterial3の世界へ...\r\n\r\n![Imgur](https://imgur.com/fa8uwGI.png)\r\n\r\n# つまずいた点\r\n\r\n## ScaffoldにSnackbarHostが無い\r\n\r\n`Scaffold`を使うといい感じに`Snackbar`を表示できるんですけど、`Material3`の`Scaffold`には`Snackbar`を表示する機能が現状ないです。   `Snackbar`をComposeで表示させるには、`SnackbarHost`を追加すればいいので、`Scaffold`に`SnackbarHost`を追加したコンポーネントを作ります。\r\n\r\n```kotlin\r\n/**\r\n * Material3のScaffoldにSnackBar無いので適当に作る\r\n *\r\n * [Scaffold]に[SnackbarHost]を追加してるだけです。\r\n * */\r\n@ExperimentalMaterial3Api\r\n@Composable\r\nfun M3Scaffold(\r\n    modifier: Modifier = Modifier,\r\n    scaffoldState: ScaffoldState = rememberScaffoldState(),\r\n    snackbarHostState: SnackbarHostState = remember { SnackbarHostState() },\r\n    topBar: @Composable () -> Unit = {},\r\n    bottomBar: @Composable () -> Unit = {},\r\n    floatingActionButton: @Composable () -> Unit = {},\r\n    floatingActionButtonPosition: FabPosition = FabPosition.End,\r\n    drawerContent: @Composable (ColumnScope.() -> Unit)? = null,\r\n    drawerGesturesEnabled: Boolean = true,\r\n    drawerShape: Shape = RoundedCornerShape(16.dp),\r\n    drawerTonalElevation: Dp = DrawerDefaults.Elevation,\r\n    drawerContainerColor: Color = MaterialTheme.colorScheme.surface,\r\n    drawerContentColor: Color = contentColorFor(drawerContainerColor),\r\n    drawerScrimColor: Color = DrawerDefaults.scrimColor,\r\n    containerColor: Color = MaterialTheme.colorScheme.background,\r\n    contentColor: Color = contentColorFor(containerColor),\r\n    content: @Composable (PaddingValues) -> Unit,\r\n) {\r\n    Scaffold(\r\n        modifier = modifier,\r\n        scaffoldState = scaffoldState,\r\n        topBar = topBar,\r\n        bottomBar = bottomBar,\r\n        floatingActionButton = floatingActionButton,\r\n        floatingActionButtonPosition = floatingActionButtonPosition,\r\n        drawerContent = drawerContent,\r\n        drawerGesturesEnabled = drawerGesturesEnabled,\r\n        drawerShape = drawerShape,\r\n        drawerTonalElevation = drawerTonalElevation,\r\n        drawerContainerColor = drawerContainerColor,\r\n        drawerContentColor = drawerContentColor,\r\n        drawerScrimColor = drawerScrimColor,\r\n        containerColor = containerColor,\r\n        contentColor = contentColor,\r\n        content = {\r\n            Box {\r\n                content(it)\r\n                SnackbarHost(\r\n                    modifier = Modifier\r\n                        .padding(it)\r\n                        .align(Alignment.BottomCenter),\r\n                    hostState = snackbarHostState\r\n                )\r\n            }\r\n        }\r\n    )\r\n}\r\n```\r\n\r\n使う際はこんなふうに\r\n\r\n\r\n```kotlin\r\nval scaffoldState = rememberScaffoldState()\r\nval snackbarHostState = remember { SnackbarHostState() }\r\n\r\nLaunchedEffect(key1 = Unit, block = {\r\n    snackbarHostState.showSnackbar(\"Hello World\")\r\n})\r\n\r\nM3Scaffold(\r\n    scaffoldState = scaffoldState,\r\n    snackbarHostState = snackbarHostState,\r\n    content = {\r\n        // components...\r\n    },\r\n)\r\n```\r\n\r\n## @ExperimentalMaterial3Api vs @OptIn(ExperimentalMaterial3Api::class)\r\n\r\nどっち使うかって話\r\n\r\n- @ExperimentalMaterial3Api\r\n    - 呼び出し先にも書かないといけない（伝搬する）\r\n    - ライブラリ開発者が警告を出したいときに使う\r\n\r\n- @OptIn(ExperimentalMaterial3Api::class)\r\n    - 呼び出し先には書かなくていい（伝搬しない）\r\n    - ライブラリ利用者が警告を飲んだ場合はこっちを使う\r\n\r\n多分こんな感じだと思う。\r\n\r\n## Material3版Surface の tonalElevation\r\n`Surface`の引数の説明見るとこうです。\r\n\r\n```\r\nカラーがColorScheme.surfaceの場合、標高が高いほどライトテーマでは色が濃くなり、ダークテーマでは色が薄くなります。\r\n\r\nDeepL翻訳\r\n```\r\n\r\nというわけで`Surface`の背景色が`ColorScheme.surface`の場合は`tonalElevation`を考慮する必要があるわけです。え？そんなのどうでもいいだって？\r\n\r\n### NavigationBarの色にナビゲーションバーの色を設定したい\r\n\r\n`NavigationBar`の色は`ColorScheme.surface`な訳ですが、`tonalElevation`が設定されているのでそのままでは同じ色には出来ません。\r\n\r\n```kotlin\r\nval context = LocalContext.current\r\nval surfaceColor = MaterialTheme.colorScheme.surface\r\nLaunchedEffect(key1 = surfaceColor, block = {\r\n    (context as? Activity)?.window?.navigationBarColor = Color.argb(\r\n        surfaceColor.toArgb().alpha,\r\n        surfaceColor.toArgb().red,\r\n        surfaceColor.toArgb().green,\r\n        surfaceColor.toArgb().blue,\r\n    )\r\n})\r\n```\r\n\r\nそのために`ColorScheme.surfaceColorAtElevation`の実装をお借りします。  \r\n`surfaceColorAtElevation`自体を使えればいいんですけど`internal`で保護されていて無理でした。\r\n\r\n```kotlin\r\nfun ColorScheme.applyTonalElevation(\r\n    elevation: Dp,\r\n): androidx.compose.ui.graphics.Color {\r\n    if (elevation == 0.dp) return surface\r\n    val alpha = ((4.5f * ln(elevation.value + 1)) + 2f) / 100f\r\n    return primary.copy(alpha = alpha).compositeOver(surface)\r\n}\r\n```\r\n\r\nあとは書き換えて\r\n\r\n```kotlin\r\nval context = LocalContext.current\r\nval bottomNavColor = MaterialTheme.colorScheme.applyTonalElevation(3.dp)\r\nLaunchedEffect(key1 = bottomNavColor, block = {\r\n    (context as? Activity)?.window?.navigationBarColor = Color.argb(\r\n        bottomNavColor.toArgb().alpha,\r\n        bottomNavColor.toArgb().red,\r\n        bottomNavColor.toArgb().green,\r\n        bottomNavColor.toArgb().blue,\r\n    )\r\n})\r\n```\r\n\r\nこれでナビゲーションバーの色を設定できました。  \r\n\r\n![Imgur](https://imgur.com/F2wVIwz.png)\r\n\r\n# 終わりに\r\n\r\nAndroid 12L ってのが発表されたみたいですね。え？Android 3.0？知らないですね？（国産全盛期？）"},{"title":"Jetpack Composeでも背景押したらTextFieldのフォーカスを外す","link":"/posts/android_jc_focus_requester/","markdown":"\r\n#DroidKaigiの荷物届きました。ドロイド君かわいい\r\n\r\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">ドロイド君かわいい<a href=\"https://twitter.com/hashtag/DroidKaigi?src=hash&amp;ref_src=twsrc%5Etfw\">#DroidKaigi</a> <a href=\"https://t.co/zKheIh1M6F\">pic.twitter.com/zKheIh1M6F</a></p>&mdash; たくさん (@takusan__23) <a href=\"https://twitter.com/takusan__23/status/1448877475254079488?ref_src=twsrc%5Etfw\">October 15, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\r\n\r\nAndroid Developersのシール、貴重では\r\n\r\n# コード\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            ReleaseTextFieldFocusTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(color = MaterialTheme.colors.background) {\r\n\r\n                    // 親コンポーネントにフォーカスを移動させるのに使う\r\n                    val focusRequester = remember { FocusRequester() }\r\n                    val interactionSource = remember { MutableInteractionSource() }\r\n\r\n                    Column(\r\n                        modifier = Modifier\r\n                            .fillMaxSize()\r\n                            .clickable(\r\n                                interactionSource = interactionSource,\r\n                                enabled = true,\r\n                                indication = null,\r\n                                onClick = { focusRequester.requestFocus() } // 押したら外す\r\n                            )\r\n                            .focusRequester(focusRequester) // フォーカス操作するやつをセット\r\n                            .focusTarget(), // フォーカス当たるように\r\n                        verticalArrangement = Arrangement.Center,\r\n                        horizontalAlignment = Alignment.CenterHorizontally\r\n                    ) {\r\n\r\n                        val text = remember { mutableStateOf(\"\") }\r\n\r\n                        OutlinedTextField(\r\n                            modifier = Modifier\r\n                                .fillMaxWidth()\r\n                                .padding(10.dp),\r\n                            value = text.value,\r\n                            label = { Text(text = \"フォーカス外すサンプル\") },\r\n                            onValueChange = { text.value = it }\r\n                        )\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Modifier.clickable()`の引数が多い理由はRipple効果を無くすためです。  \r\n以上です。お疲れさまでした。"},{"title":"他の人が作ったJetpack Composeのサンプルアプリがビルドできなかった話","link":"/posts/android_jc_gradle_err/","markdown":"\r\nWWDCの季節ですね。WWDCを見るときはいつも**macwebcasterの同時翻訳**が居たのですが、今年からは居ません。  \r\nなので今回の発表会で気になるプロダクトのアンケートもありません。寂しいね。\r\n\r\n# 本題\r\nhttps://github.com/Gurupreet/ComposeCookBook\r\n\r\nをCloneしてビルドしたいんだけどなんかできなかった。\r\n\r\n# 今北産業\r\n\r\n`Android Studio`左上の`File`から、`Project Structure...`を選び、`Gradle Version`をバージョンアップして、`Try Again`したあと、バージョンを戻したらビルドが通るようになった。\r\n\r\n![Imgur](https://imgur.com/WYJR2kZ.png)\r\n\r\n# 第一関門\r\n\r\n```\r\nUnsupported Kotlin plugin version.\r\nUnresolved reference: compileSdk\r\n```\r\n\r\nこれは、`Android Studio`左上の`File`から、`Project Structure...`を選択して、`Gradle Version`を上げたらなんか直った。\r\n\r\n# 第二関門\r\n\r\nエラーの数は減りましたがまだ通りません。\r\n\r\n```\r\nMultiple builders are available to build a model of type 'org.jetbrains.plugins.gradle.model.internal.DummyModel'.\r\n```\r\n\r\n今度は`Gradle Version`をもとに戻したらビルドが通るようになりました。\r\n\r\n# 終わりに\r\n`build.gradle.kts`に移行すべきなのかな。`ext`の変数は補充効かないし。  \r\n`buildSrc`によるライブラリの管理良さそう。\r\n\r\n# おまけ\r\nシステムドライブが容量不足になったので以下を消した。\r\n\r\n- `C:\\Users\\ユーザー名\\.gradle\\wrapper\\dists`\r\n    - 使ってない`Gradle`を消そう。\r\n- `C:\\Users\\ユーザー名\\AppData\\Local\\Android\\Sdk\\system-images`\r\n    - 古いAndroidのバージョンとか使ってないから消そう。\r\n\r\nあとシステムドライブだけじゃなくてRAMも足りなくてしんどい。16GBで足りなくなるとかマジ？\r\n\r\n![Imgur](https://imgur.com/Jtqw95M.png)"},{"title":"Jetpack Composeの練習","link":"/posts/android_jc_hihyou_kuukan_client/","markdown":"どうもこんばんわ。  \n\nアオナツラインを完走しました。  \n\nことねちゃんが可愛かったです。続きが気になるから後日談みたいなのが欲しいと思った。      \nBGMモードでOPの曲が聞けないので初回限定版を買えばよかったかなってちょっと後悔してたりもする。  \n\n<img src=\"https://imgur.com/CNT3gWS.png\" width=\"500\">\n\n# 本題\nJetpackComposeでErogameScapeの情報を表示するアプリを作ってみます。\n\n## 環境\n| なまえ          | あたい |\n|-----------------|--------|\n| Jetpack Compose | Beta05 |\n\n## 今回の仕組み的な\n[ErogameScape](https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/sql_for_erogamer_form.php)っていうエロゲ専門サイトがあるんですが、これSQLを書いてPOSTするとなんとデータが返ってきます。このサイトやばい\n\n```sql\nSELECT * FROM gamelist WHERE gamename = '彼女のセイイキ'\n```\n\n<img src=\"https://imgur.com/BfK6Eea.png\" width=\"500\">\n\n### 使うテーブル\n- gamelist\n    - ゲーム情報が入っている\n- brandlist\n    - gamelistにはブランド名が入ってないので別に取得\n- campaign_game、campaignlist\n    - （ついでなので）セール中のゲームが入ってる\n\n`campaign_game`テーブルなんですが、なんか[ここのテーブル一覧](https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/sql_for_erogamer_tablelist.php)には乗っていないのですが、他の人が書いたSQLではなぜかセール中のゲームが取得できるんですよね。  \nそれでテーブル一覧を返すSQLを書いて見るとたしかにあるんですね。テーブル一覧のサイトが更新されていないだけかな。\n\n```sql\nSELECT * FROM pg_tables\n```\n\n### 今回使うSQL文\nJetpackComposeが本題なのに時間がかかってしまった。  \nゲームの情報のほか、ブランド名、セール中ならセール情報を表示するようにしました。\n\n```sql\nSELECT DISTINCT g.id,\n    g.gamename,\n    c.content,\n    c.name,\n    c.end_timestamp,\n    g.furigana,\n    g.sellday,\n    g.brandname,\n    b.brandname,\n    g.model,\n    COALESCE(g.median, -1) AS median,\n    COALESCE(g.average2, -1) AS average2,\n    COALESCE(g.stdev, -1) AS stdev,\n    COALESCE(g.count2, -1) AS count2,\n    g.dmm,\n    COALESCE(g.max2, -1) AS max2,\n    COALESCE(g.min2, -1) AS min2,\n    g.shoukai\nFROM gamelist g\n    INNER JOIN brandlist b ON g.brandname = b.id\n    LEFT OUTER JOIN (\n        SELECT g.content,\n            l.name,\n            g.game,\n            l.end_timestamp\n        FROM campaign_game g\n            INNER JOIN campaignlist l ON g.campaign = l.id\n        WHERE l.end_timestamp > now()\n    ) c ON g.id = c.game\nWHERE g.gamename = 'アオナツライン'\n```\n\n<div style=\"overflow-y:scroll\">\n<table>\n<tbody><tr><th>id</th><th>gamename</th><th>content</th><th>name</th><th>end_timestamp</th><th>furigana</th><th>sellday</th><th>brandname</th><th>brandname</th><th>model</th><th>median</th><th>average2</th><th>stdev</th><th>count2</th><th>dmm</th><th>max2</th><th>min2</th><th>shoukai</th></tr>\n<tr><td>27418</td><td>アオナツライン</td><td></td><td></td><td></td><td>アオナツライン</td><td>2019-03-29</td><td>84</td><td>戯画</td><td>PC</td><td>82</td><td>80</td><td>13</td><td>348</td><td>eg_0012</td><td>100</td><td>0</td><td>http://products.web-giga.com/aonatsu/</td></tr>\n<tr><td>29203</td><td>アオナツライン</td><td></td><td></td><td></td><td>アオナツライン</td><td>2020-04-23</td><td>781</td><td>エンターグラム</td><td>PS4</td><td>78</td><td>78</td><td>18</td><td>2</td><td></td><td>90</td><td>65</td><td>http://www.entergram.co.jp/aonatsu/</td></tr>\n<tr><td>29204</td><td>アオナツライン</td><td></td><td></td><td></td><td>アオナツライン</td><td>2020-04-23</td><td>781</td><td>エンターグラム</td><td>PSV</td><td>87</td><td>87</td><td>3</td><td>3</td><td></td><td>90</td><td>85</td><td>http://www.entergram.co.jp/aonatsu/</td></tr>\n</tbody></table>\n</div >\n\nセール中ならこうなります。\n\n<div style=\"overflow-y:scroll\">\n<table>\n<tbody><tr><th>id</th><th>gamename</th><th>content</th><th>name</th><th>end_timestamp</th><th>furigana</th><th>sellday</th><th>brandname</th><th>brandname</th><th>model</th><th>median</th><th>average2</th><th>stdev</th><th>count2</th><th>dmm</th><th>max2</th><th>min2</th><th>shoukai</th></tr>\n<tr><td>20228</td><td>彼女のセイイキ</td><td>1,017円 50%OFF</td><td>  スプリングセール 2021</td><td>2021-05-10 17:00:00</td><td>カノジョノセイイキ</td><td>2014-12-19</td><td>702</td><td>feng</td><td>PC</td><td>75</td><td>74</td><td>9</td><td>665</td><td>feng_0003</td><td>100</td><td>10</td><td>http://www.feng.jp/seiiki/</td></tr>\n</tbody></table>\n</div>\n\n#### 簡単に解説\n`SELECT`は取り出す列を書き出していきます。  \n`FROM`はどこのテーブルから取り出すかです。まずはゲームの情報の入ってるテーブルですね。  \nそれから、`INNER JOIN`を利用してブランド名テーブルを結合します。`ON`のあとの条件式に当てはまれば結合されます。  \n複数のテーブルを扱う場合はテーブル名のあとに名前をつけることが出来ます（この例では`g`とか`b`とか）  \n\n`COALESCE`ってのはNULLのときに変わりに表示する値をセットできるやつです。今回はNULLの場合`-1`を入れるようにしてあります。  \n`AS 名前`は列の名前を変えるときに使うんですが今回はスクレイピングしちゃうのであんまり関係ない。\n\n#### セール中ならセール情報を取る\n`LEFT OUTER JOIN`っていうのは、`ON`の条件式が当てはまらないときには代わりにNULLを入れてくれるやつです。  \n`INNER JOIN`を使ってしまうとセールしてるときは表示されますが、セールしてないときは表示されなくなってしまいます。  \n\nで、`LEFT OUTER JOIN`のあとの`SELECT`ですが、これはサブクエリって呼ばれるやつでクエリ内で使う値をクエリを使って取り出すときに使います。  \n\n```sql\nSELECT g.content,\n    l.name,\n    g.game,\n    l.end_timestamp\nFROM campaign_game g\n    INNER JOIN campaignlist l ON g.campaign = l.id\nWHERE l.end_timestamp > now()\n```\n\nこのクエリを実行すると、以下のような内容が返ってきます。`campaign_game`と`campaignlist`のテーブルを結合して、セール中であるものを取得するクエリです。  \n\n| content        | name                  | game  | end_timestamp       |\n|----------------|-----------------------|-------|---------------------|\n| 1,017円 50%OFF | スプリングセール 2021 | 20228 | 2021-05-10 17:00:00 |\n\nこの結果を、`LEFT OUTER JOIN`で結合します。上のサンプルでは`c`をクエリ結果の名前として指定しているため、`c.content`でセールの値段を取得することが出来ます。\n\n`WHERE g.gamename = 'アオナツライン'`はゲーム名が「アオナツライン」と一致するものを取得するという意味です。\n\n疲れたのであとは各自調べて。\n\nその他使うものとしては\n\n- ViewModel / LiveData\n    - SQLをPOSTする処理をActivityに書くわけに行かないので\n- OkHttp\n    - POSTするときに使う\n- Jsoup\n    - POSTした結果を取り出すため\n- Glide\n    - 画像読み込み\n- Coroutine\n    - 非同期処理お助け\n\n## ライブラリ入れる\n\n```gradle\ndependencies {\n\n    // OkHttp\n    implementation(\"com.squareup.okhttp3:okhttp:4.9.1\")\n    // HTML Parser\n    implementation 'org.jsoup:jsoup:1.13.1'\n    // CoroutineとLifeCycle考えてくれるやつ\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.3.1\"\n    // Coroutines\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3\"\n    // ViewModel\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1\"\n    // LiveData\n    implementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.3.1\"\n    // Glide\n    implementation 'com.github.bumptech.glide:glide:4.11.0'\n    // ComposeでLiveData\n    implementation \"androidx.compose.runtime:runtime-livedata:$compose_version\"\n    \n    // 以下省略\n\n}\n```\n\n## AndroidManifest.xml\nインターネットパーミッションを忘れずに\n\n## データクラス\n\n`GameData.kt`\n\n```kotlin\n/**\n * ゲーム情報\n *\n * https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/sql_for_erogamer_tablelist.php\n *\n * @param id ID\n * @param gamename 名前\n * @param brandname_id ブランドのID\n * @param brandname ブランド名\n * @param content セール情報\n * @param endTimeStamp セール終了日時\n * @param model PCとかPSVとか\n * @param name セール名\n * @param furigana 名前のふりがな\n * @param sellday 発売日\n * @param median 得点中央値\n * @param average2 平均値\n * @param stdev 標準偏差\n * @param count2 得点データ数\n * @param dmm DMM（FANZA）のURLの一部\n * @param max2 最高得点\n * @param min2 最低得点\n * @param shoukai オフィシャルHPのURL\n * */\ndata class GameData(\n    val id: Int,\n    val gamename: String,\n    val content: String,\n    val name: String,\n    val endTimeStamp: String,\n    val furigana: String,\n    val sellday: String,\n    val brandname_id: Int,\n    val brandname: String,\n    val model: String,\n    val median: Int,\n    val average2: Int,\n    val stdev: Int,\n    val count2: Int,\n    val dmm: String,\n    val max2: Int,\n    val min2: Int,\n    val shoukai: String,\n)\n```\n\n## データ取得関数を書く\n\n\n`ErogameScape.kt`\n\n```kotlin\n/**\n * https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/sql_for_erogamer_tablelist.php\n * */\nobject ErogameScape {\n\n    private val okHttpClient = OkHttpClient()\n\n    /**\n     * ゲーム情報を取得する\n     *\n     * @param gameName ゲーム名。「彼女のセイイキ」など\n     * @return 成功すれば[GameData]の配列（コンシューマー移植などがあるため）\n     * */\n    suspend fun getGameInfo(gameName: String) = withContext(Dispatchers.Default) {\n        // ゲーム情報配列\n        val gameInfoList = arrayListOf<GameData>()\n        // POST内容\n        val sql = \"\"\" \n SELECT DISTINCT g.id,\n    g.gamename,\n    c.content,\n    c.name,\n    c.end_timestamp,\n    g.furigana,\n    g.sellday,\n    g.brandname,\n    b.brandname,\n    g.model,\n    COALESCE(g.median, -1) AS median,\n    COALESCE(g.average2, -1) AS average2,\n    COALESCE(g.stdev, -1) AS stdev,\n    COALESCE(g.count2, -1) AS count2,\n    g.dmm,\n    COALESCE(g.max2, -1) AS max2,\n    COALESCE(g.min2, -1) AS min2,\n    g.shoukai\nFROM gamelist g\n    INNER JOIN brandlist b ON g.brandname = b.id\n    LEFT OUTER JOIN (\n        SELECT g.content,\n            l.name,\n            g.game,\n            l.end_timestamp\n        FROM campaign_game g\n            INNER JOIN campaignlist l ON g.campaign = l.id\n        WHERE l.end_timestamp > now()\n    ) c ON g.id = c.game\nWHERE g.gamename = '$gameName'\n \"\"\"\n        val formData = FormBody.Builder().apply {\n            add(\"sql\", sql)\n        }.build()\n        val request = Request.Builder().apply {\n            url(\"https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/sql_for_erogamer_form.php\")\n            post(formData)\n        }.build()\n        // POSTリクエストを飛ばす\n        val response = okHttpClient.newCall(request).execute()\n        // スクレイピング\n        if (response.isSuccessful) {\n            val document = Jsoup.parse(response.body!!.string())\n            val trElementList = document.getElementsByTag(\"tr\")\n            repeat(trElementList.size - 1) {\n                // テーブル一行目はいらない\n                val index = it + 1\n                val trElement = trElementList[index]\n                val tdList = trElement.getElementsByTag(\"td\")\n                val id = tdList[0].text().toInt()\n                val gamename = tdList[1].text()\n                val content = tdList[2].text()\n                val name = tdList[3].text()\n                val end_time_stamp = tdList[4].text()\n                val furigana = tdList[5].text()\n                val sellday = tdList[6].text()\n                val brandname_id = tdList[7].text().toInt()\n                val brandname = tdList[8].text()\n                val model = tdList[9].text()\n                val median = tdList[10].text().toInt()\n                val average2 = tdList[11].text().toInt()\n                val stdev = tdList[12].text().toInt()\n                val count2 = tdList[13].text().toInt()\n                val dmm = tdList[14].text()\n                val max2 = tdList[15].text().toInt()\n                val min2 = tdList[16].text().toInt()\n                val shoukai = tdList[17].text()\n                // データクラスへ\n                val gameData = GameData(\n                    id,\n                    gamename,\n                    content,\n                    name,\n                    end_time_stamp,\n                    furigana,\n                    sellday,\n                    brandname_id,\n                    brandname,\n                    model,\n                    median,\n                    average2,\n                    stdev,\n                    count2,\n                    dmm,\n                    max2,\n                    min2,\n                    shoukai,\n                )\n                gameInfoList.add(gameData)\n            }\n        }\n        return@withContext gameInfoList\n    }\n\n}\n```\n\n## ViewModel\n`MainViewModel.kt`\n\n通信はここでやってる。\n\n```kotlin\n/**\n * [MainActivity]で使うViewModel\n * */\nclass MainViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val context = application.applicationContext\n\n    private val _gameInfoLiveData = MutableLiveData<GameData>()\n\n    /** 結果を送信するLiveData */\n    val gameInfoLiveData = _gameInfoLiveData as LiveData<GameData>\n\n    /**\n     * ゲームの情報を取得する関数\n     * @param gameName ゲーム名。「彼女のセイイキ」など\n     * */\n    fun getGameInfo(gameName: String) {\n        viewModelScope.launch {\n            val data = ErogameScape.getGameInfo(gameName)\n            if (data != null) {\n                _gameInfoLiveData.postValue(data!!)\n            }\n        }\n    }\n\n}\n```\n\n# JetpackCompose\nViewModelで取得したデータを表示するようにしましょう。\n\n## 各種部品を用意する\n検索ボックスと、インターネット上の画像を表示するための部品を\n\n`GameInfoUI.kt`\n\n```kotlin\n/**\n * 検索ボックス\n * */\n@Composable\nfun SearchBox(\n    searchText: String,\n    onChangeSearchText: (String) -> Unit,\n    onClickSearchButton: () -> Unit,\n) {\n    Card(\n        modifier = Modifier.padding(5.dp),\n        elevation = 10.dp,\n        shape = RoundedCornerShape(10.dp)\n    ) {\n        Row(modifier = Modifier.padding(start = 10.dp, end = 10.dp)) {\n            TextField(\n                modifier = Modifier.weight(1f),\n                trailingIcon = {\n                    IconButton(onClick = { onClickSearchButton() }) {\n                        Icon(\n                            painter = painterResource(R.drawable.ic_baseline_search_24),\n                            contentDescription = \"search\"\n                        )\n                    }\n                },\n                value = searchText,\n                onValueChange = { text -> onChangeSearchText(text) },\n                placeholder = { Text(text = \"ギャルゲ、エロゲのタイトルを入力\") },\n                maxLines = 1,\n                colors = TextFieldDefaults.textFieldColors(\n                    backgroundColor = Color.Transparent,\n                    focusedIndicatorColor = Color.Transparent,\n                    disabledIndicatorColor = Color.Transparent,\n                    errorIndicatorColor = Color.Transparent,\n                    unfocusedIndicatorColor = Color.Transparent,\n                )\n            )\n        }\n    }\n}\n\n/**\n * インターネット上の画像を表示する\n * */\n@Composable\nfun InternetImage(url: String) {\n    val bitmap = remember { mutableStateOf<Bitmap?>(null) }\n    Glide.with(LocalContext.current).asBitmap().load(url).into(object : CustomTarget<Bitmap>() {\n        override fun onResourceReady(resource: Bitmap, transition: Transition<in Bitmap>?) {\n            bitmap.value = resource\n        }\n\n        override fun onLoadCleared(placeholder: Drawable?) {\n\n        }\n    })\n    if (bitmap.value != null) {\n        Image(\n            bitmap = bitmap.value!!.asImageBitmap(),\n            contentDescription = \"写真\",\n            modifier = Modifier\n                .clip(RoundedCornerShape(10.dp))\n                .width(200.dp)\n                .height(200.dp)\n        )\n    }\n}\n\n/**\n * 二段のText。上の段のほうが文字が大きい\n * */\n@Composable\nfun RankText(modifier: Modifier, title: String, value: String) {\n    Column(modifier, horizontalAlignment = Alignment.CenterHorizontally) {\n        Text(\n            text = value,\n            fontSize = 20.sp,\n            fontWeight = FontWeight.W500,\n            textAlign = TextAlign.Center,\n        )\n        Text(text = title)\n    }\n}\n```\n\n## 結果画面\n\nUI作るの難しい。  \nあとアイコンを https://fonts.google.com/icons から持ってきたので各自入れてね\n\n`GameInfoScreen.kt`\n\n```kotlin\n/**\n * ゲーム情報表示画面\n * */\n@Composable\nfun GameInfoScreen(viewModel: MainViewModel) {\n    val context = LocalContext.current\n    // 検索ワード\n    val searchText = remember { mutableStateOf(\"\") }\n    // ゲーム情報LiveDataを変換する\n    val gameInfoList = viewModel.gameInfoLiveDataList.observeAsState()\n\n    Scaffold(\n        topBar = {\n            SearchBox(searchText = searchText.value, onChangeSearchText = { searchText.value = it }) {\n                // 検索ボタン押したとき\n                viewModel.getGameInfo(searchText.value)\n            }\n        }\n    ) {\n        if (gameInfoList.value != null) {\n            // 今回は一個だけ表示\n            val gameInfo = gameInfoList.value!![0]\n            // 写真URL\n            val imgUrl = \"https://pics.dmm.co.jp/digital/pcgame/${gameInfo.dmm}/${gameInfo.dmm}ps.jpg\"\n\n            Column {\n                // 情報\n                Row {\n                    InternetImage(url = imgUrl)\n                    Column {\n                        Text(text = gameInfo.gamename, fontSize = 25.sp)\n                        Text(text = gameInfo.furigana)\n                        Text(text = gameInfo.brandname, fontSize = 20.sp)\n                        Text(text = \"発売日\\n${gameInfo.sellday}\")\n                    }\n                }\n                // セール情報があれば\n                if (gameInfo.content.isNotEmpty()) {\n                    Card(\n                        border = BorderStroke(1.dp, MaterialTheme.colors.primaryVariant),\n                        elevation = 0.dp,\n                        modifier = Modifier\n                            .padding(10.dp)\n                            .fillMaxWidth()\n                    ) {\n                        Column(modifier = Modifier.padding(10.dp)) {\n                            Text(text = \"${gameInfo.name} (${gameInfo.end_time_stamp} まで)\")\n                            Text(text = gameInfo.content, fontSize = 20.sp)\n                        }\n                    }\n                }\n                // DMMで購入するボタン\n                Button(\n                    modifier = Modifier\n                        .padding(10.dp)\n                        .fillMaxWidth(),\n                    onClick = {\n                        context.startActivity(Intent(Intent.ACTION_VIEW, \"https://dlsoft.dmm.co.jp/detail/${gameInfo.dmm}/\".toUri()))\n                    },\n                ) {\n                    Icon(painter = painterResource(id = R.drawable.ic_store_black_24dp), contentDescription = \"shop\")\n                    Text(text = \"DMMで購入する\")\n                }\n                // 評価など\n                Divider()\n                Row {\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"最高得点\",\n                        gameInfo.max2.toString()\n                    )\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"得点中央値\",\n                        gameInfo.median.toString()\n                    )\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"最低得点\",\n                        gameInfo.min2.toString()\n                    )\n                }\n                Row {\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"得点データ数\",\n                        gameInfo.count2.toString()\n                    )\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"平均値\",\n                        gameInfo.average2.toString()\n                    )\n                    RankText(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(5.dp),\n                        \"標準偏差\",\n                        gameInfo.stdev.toString()\n                    )\n                }\n                Divider()\n                // ErogameScapeで開く\n                OutlinedButton(\n                    modifier = Modifier\n                        .padding(10.dp)\n                        .fillMaxWidth(),\n                    onClick = {\n                        context.startActivity(Intent(Intent.ACTION_VIEW, \"https://erogamescape.dyndns.org/~ap2/ero/toukei_kaiseki/game.php?game=${gameInfo.id}\".toUri()))\n                    },\n                ) {\n                    Icon(painter = painterResource(id = R.drawable.ic_open_in_browser_black_24dp), contentDescription = \"shop\")\n                    Text(text = \"ErogameScapeで開く\")\n                }\n            }\n        }\n    }\n}\n```\n\n## MainActivity\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n\n    private val viewModel by viewModels<MainViewModel>()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            ErogameScapeDroidTheme {\n                Surface(color = MaterialTheme.colors.background) {\n                    // ゲーム詳細画面\n                    GameInfoScreen(viewModel = viewModel)\n                }\n            }\n        }\n    }\n}\n```\n\n動かすとこんな感じ\n\n<img src=\"https://imgur.com/SYlsfEY.png\" width=\"300\">\n<img src=\"https://imgur.com/pzYjBlU.png\" width=\"300\">\n\nUI作るのって難しいよな\n\n# 終わりに\nソースコードあります。  \n\nhttps://github.com/takusan23/ErogameScapeDroid/tree/efa4137b777c4e069ebc7fa3eda5fcbccdba7500"},{"title":"JetpackComposeで親のコンポーネントでもクリックイベントがほしい","link":"/posts/android_jc_parent_component_click/","markdown":"\r\nどうもこんばんわ。  \r\nどうでもいいんですけどNext.jsで作り直したこのサイト、Googleに無事嫌われている模様\r\n\r\n![Imgur](https://imgur.com/UD5eqeu.png)\r\n\r\n![Imgur](https://imgur.com/JQOKdAD.png)\r\n\r\n# 本題\r\nJetpackComposeで子コンポーネントでクリックされると親のコンポーネントではタッチイベントが貰えません。  \r\n子コンポーネントで消費されても親コンポーネントでクリックイベントが来てほしい。\r\n\r\nので作った\r\n\r\n# 環境\r\n\r\n| なまえ         | あたい     |\r\n|----------------|------------|\r\n| Android        | 12         |\r\n| Android Studio | Bumblebee  |\r\n| Kotlin         | 1.6.10     |\r\n| Compose        | 1.1.0-rc03 |\r\n\r\n# 作る\r\n\r\n## ParentPointerEvent.kt\r\nファイル名は何でもいいですがとりあえず一つKtを作成します。\r\n\r\nそして中身はこれ(ごめんコメント部分はあってるかどうか分からん)\r\n\r\n```kotlin\r\n/**\r\n * 子要素でタップが消費の有無に関わらず親要素へタッチイベントが行くようにしたもの\r\n *\r\n * @param onTap 押したとき\r\n * */\r\nsuspend fun PointerInputScope.detectParentComponentTapGestures(onTap: ((Offset) -> Unit)? = null) = coroutineScope {\r\n    forEachGesture {\r\n        awaitPointerEventScope {\r\n            // awaitPointerEvent を使うことでクリックが消費されてるかどうか関係なくクリックイベントを待機\r\n            awaitPointerEvent()\r\n            var upOrCancel: PointerInputChange? = null\r\n            try {\r\n                upOrCancel = withTimeout(Long.MAX_VALUE / 2) {\r\n                    // ここでタップ判定をしている。長押しとか画面外タッチはnullになる\r\n                    waitForUpIgnoreOrCancellation()\r\n                }\r\n                upOrCancel?.consumeDownChange()\r\n            } catch (_: PointerEventTimeoutCancellationException) {\r\n                consumeUntilUp()\r\n            }\r\n            if (upOrCancel != null) {\r\n                onTap?.invoke(upOrCancel.position)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * クリックするかキャンセルするまで一時停止する。\r\n * [AwaitPointerEventScope.waitForUpOrCancellation]では他でクリックイベントが消費されたらキャンセルされますが、\r\n * これはクリックイベントの消費されていてもキャンセル扱いしません。\r\n *\r\n * @return クリックしたら[PointerInputChange]。ドラッグ操作やキャンセルならnull\r\n * */\r\nprivate suspend fun AwaitPointerEventScope.waitForUpIgnoreOrCancellation(): PointerInputChange? {\r\n    while (true) {\r\n        val event = awaitPointerEvent(PointerEventPass.Main)\r\n        // クリックイベントが消費されてもされてなくてもいいやつ\r\n        if (event.changes.all { it.changedToUpIgnoreConsumed() }) {\r\n            // All pointers are up\r\n            return event.changes[0]\r\n        }\r\n\r\n        if (event.changes.any { it.consumed.downChange || it.isOutOfBounds(size, extendedTouchPadding) }) {\r\n            return null // Canceled\r\n        }\r\n\r\n        // Check for cancel by position consumption. We can look on the Final pass of the\r\n        // existing pointer event because it comes after the Main pass we checked above.\r\n        val consumeCheck = awaitPointerEvent(PointerEventPass.Final)\r\n        if (consumeCheck.changes.any { it.positionChangeConsumed() }) {\r\n            return null\r\n        }\r\n    }\r\n}\r\n\r\n/** クリックイベントをすべて消費する */\r\nprivate suspend fun AwaitPointerEventScope.consumeUntilUp() {\r\n    do {\r\n        val event = awaitPointerEvent()\r\n        event.changes.forEach { it.consumeAllChanges() }\r\n    } while (event.changes.any { it.pressed })\r\n}\r\n```\r\n\r\n# これの使い方\r\n\r\n親要素でもクリックイベントがほしい！！！ときにさっき書いたやつを使います\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    @OptIn(ExperimentalMaterialApi::class)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        setContent {\r\n            // 親要素を押したときの時間\r\n            var parentClickTime by remember { mutableStateOf(0L) }\r\n            // ボタンを押したときの時間\r\n            var buttonClickTime by remember { mutableStateOf(0L) }\r\n\r\n            MaterialTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(\r\n                    modifier = Modifier.fillMaxSize(),\r\n                    color = MaterialTheme.colors.background\r\n                ) {\r\n\r\n                    Column {\r\n                        Text(text = \"親要素押したとき：${parentClickTime.toTimeFormat()}\")\r\n                        Text(text = \"子要素押したとき：${buttonClickTime.toTimeFormat()}\")\r\n\r\n                        // 適当な広さの親要素を作成\r\n                        Box(\r\n                            modifier = Modifier\r\n                                .size(200.dp)\r\n                                .background(Color.LightGray)\r\n                                .pointerInput(Unit) {\r\n                                    // 親要素だけどクリックイベントと5000兆円ほしい！！！\r\n                                    detectParentComponentTapGestures {\r\n                                        parentClickTime = System.currentTimeMillis()\r\n                                    }\r\n                                },\r\n                            contentAlignment = Alignment.Center\r\n                        ) {\r\n                            Button(onClick = { buttonClickTime = System.currentTimeMillis() }) {\r\n                                Text(text = \"おせ！\")\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** ミリ秒UnixTimeを日付フォーマットへ変換する拡張関数 */\r\n    fun Long.toTimeFormat(): String? {\r\n        val simpleDateFormat = SimpleDateFormat(\"HH:mm:ss.SSS\", Locale.getDefault())\r\n        return simpleDateFormat.format(this)\r\n    }\r\n\r\n}\r\n```\r\n\r\n# 実際に起動させるとこんな感じになるはず\r\n\r\n- 親要素(灰色の部分)だけクリックした場合\r\n    - 親要素押したときの時間だけが更新される\r\n\r\n![Imgur](https://imgur.com/3eM10f8.png)\r\n\r\n- ボタンも押した場合\r\n    - 親要素押したとき、子要素押したとき両方の時間が更新される\r\n\r\n![Imgur](https://imgur.com/2V1N7ey.png)\r\n\r\n## 仕組み的ななにか\r\n`PointerInputScope.detectTapGestures`をほぼパクって作りました\r\n\r\n```kotlin\r\nBox(\r\n    modifier = Modifier\r\n        .pointerInput(Unit) {\r\n            // ↓これの中身をほとんどパクって作った\r\n            detectTapGestures(onTap = {\r\n                \r\n            })\r\n        },\r\n    contentAlignment = Alignment.Center\r\n) { }\r\n```\r\n\r\n`PointerInputScope.detectTapGestures`から、\r\n\r\nまだ消費されていないクリックイベントが来るまで待機サスペンド関数\r\n\r\nを 消費されていてもクリックイベントが来るまで待つサスペンド関数 へ書き換えることで動かしています。\r\n\r\n- 最初の`awaitFirstDown()`を`awaitPointerEvent()`にすることで消費されていてもいいクリックイベントが来るまで待機\r\n- 上記の理由から`event.changes.fastAll { it.changedToUp() }` を `event.changes.all { it.changedToUpIgnoreConsumed() }`にしました\r\n- onTap 以外は使わないので削除\r\n\r\n# 終わりに\r\nソースコードです。\r\n\r\nhttps://github.com/takusan23/JetpackComposeParentClickEvent"},{"title":"Jetpack Composeで一番大きいコンポーネントにすべて合わせたい","link":"/posts/android_jc_parent_size/","markdown":"どうもこんばんわ。  \r\n無線LAN子機を買い替えたら`Gradle sync`でコケなくなりました。今まではライブラリ拾ってくるところでよくコケてたので...\r\n\r\n# 本題\r\n一番大きいコンポーネントにすべて合わせたい。\r\n\r\n![Imgur](https://imgur.com/cXiFrne.png)\r\n\r\n# 作り方\r\n\r\n```kotlin\r\n@Composable\r\nfun ParentDynamicWidth() {\r\n    Column(modifier = Modifier.width(IntrinsicSize.Max)) {\r\n        Button(\r\n            onClick = { },\r\n            modifier = Modifier.fillMaxWidth()\r\n        ) {\r\n            Text(text = \"Jetpack Compose\")\r\n        }\r\n        Button(\r\n            onClick = { },\r\n            modifier = Modifier.fillMaxWidth()\r\n        ) {\r\n            Text(text = \"Android\")\r\n        }\r\n        Button(\r\n            onClick = { },\r\n            modifier = Modifier.fillMaxWidth()\r\n        ) {\r\n            Text(text = \"Kotlin \")\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n親要素に`Modifier.width(IntrinsicSize.Max)`を付けて、子要素には`Modifier.fillMaxWidth()`を付けてあげます。\r\n\r\n![Imgur](https://imgur.com/GAwVnRH.png)\r\n\r\n# 終わりに\r\nそろそろ寝たいのでここらへんで失礼します。\r\n\r\n# 参考リンク\r\nhttps://stackoverflow.com/questions/66458270/modifier-wrapcontentwidth-vs-modifier-widthintrinsicsize-max-in-android-jetp"},{"title":"Jetpack Compose の例","link":"/posts/android_jc_recipe/","markdown":"追記：2021/07/15：1.0.0-rc02が出てます。\n\n\n追記：2021/07/14：1.0.0-rc01が出てます。\n正式リリースも近い。あとなんかAndroid Studioのプレビュー機能が4んでるみたいだから、`ui-tooling`だけは`Beta09`のままがいいらしい？  \n詳細：https://stackoverflow.com/questions/68224361/jetpack-compose-cant-preview-after-updating-to-1-0-0-rc01\n\n```\ncomposeOptions {\n    kotlinCompilerVersion '1.5.10'\n    kotlinCompilerExtensionVersion '1.0.0-rc01'\n}\n```\n\n追記：2021/06/26：Beta09が出てます。  \nそれと、現状？AndroidStudioのテンプレートからEmpty Compose Activityを選択してそのままの状態で実行すると起動しません。KotlinとJetpackComposeのバージョンを上げる必要があります。初見殺しだろこれ\n\n```\njava.lang.NoSuchMethodError: No static method copy-H99Ercs$default\n```\n\n`build.gradle`(appフォルダではない方)\n\n```kotlin\nbuildscript {\n    ext {\n        compose_version = '1.0.0-beta09' // beta09へ\n    }\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:7.0.0-beta04\"\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.10\" // 1.5.10へ\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n```\n\n`app/build.gradle`(appフォルダの方のbuild.gradle)\n\n```gradle\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version\n        kotlinCompilerVersion '1.5.10' // 1.5.10へ\n    }\n```\n\nこれで実行できると思います。\n\n追記：2021/06/06：知らん間にJetpack Compose Beta08がリリースされました。Kotlinのバージョンを1.5.10にする必要があります。\n\n```\ncomposeOptions {\n    kotlinCompilerVersion '1.5.10'\n    kotlinCompilerExtensionVersion '1.0.0-beta08'\n}\n```\n\nあと `Compose版マテリアルデザインライブラリ` のリファレンスが親切になっていました。Google本気やん\nhttps://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#overview\n\n\n【割と破壊的仕様変更】`beta08`から`Surface()`と`Card()`のクリックイベントは`Modifier`経由ではなく、`onClick`の引数を使うようになりました。\n\n- beta07まで    \n```kotlin\nSurface(modifier = Modifier.clickable {  }) {\n\n}\n```\n\n- beta08以降\n```kotlin\nSurface(onClick = { }) {\n\n}\n```\n\nそして`Surface()`、`Card()`で`onClick`引数を使う際は、`@ExperimentalMaterialApi`をComposeな関数に付ける必要があります。\n\n```kotlin\n@ExperimentalMaterialApi\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    setContent {\n        Surface(onClick = { }) {\n        \n        }    \n    }\n\n}\n```\n\n追記：2021/05/22：Jetpack Composeがいつの間にかbeta07まで進んでました。  \nあとGoogle I/Oで言ってたけどホーム画面のウイジェットもJetpack Composeで書けるようになるとかなんとか\n\n追記：2021/04/11：Beta04がリリースされました。多分Kotlinのバージョンを上げる必要があります。\n\n```\ncomposeOptions {\n    kotlinCompilerVersion '1.4.32'\n    kotlinCompilerExtensionVersion '1.0.0-beta04'\n}\n```\n\n追記：2021/03/25：Beta03がリリースされました。`AndroidView`の問題が修正されています。  \nついでに、Android 7以前？で起きてたスクロール時に`AndroidView`がずれる問題も直ってました。\n\n追記：2021/03/13：Beta02がリリースされました。一緒にKotlinのバージョンを`1.4.31`にする必要があります。  \n`ComposeView`の問題が修正されました（多分）。\n\n(なお今度はスクロール時に`AndroidView()`がずれるようになった模様)\n\n```gradle\ncomposeOptions {\n    kotlinCompilerVersion '1.4.31'\n    kotlinCompilerExtensionVersion '1.0.0-beta02'\n}\n```\n\nまた、`AppCompat`、`Fragment`のライブラリのバージョンをそれぞれ`1.3`以上にする必要があります。  \n\n```gradle\ndependencies {\n    implementation 'androidx.fragment:fragment-ktx:1.3.1'\n    implementation 'androidx.appcompat:appcompat:1.3.0-beta01'\n}\n```\n\n追記 2021/03/02: Jetpack Compose Beta がリリースされました！。ついに（待望の）ベータ版になります\n\n追記 2021/02/15：Jetpack Composeのバージョンが`alpha 12`になりました。  \n影響があったといえば、  \n- `vectorResource`が非推奨。`painterResource`を使うように。\n    - よって`Icon`へDrawableを渡すときの引数は`imageVector`ではなく、`painter`になります。\n\n```kotlin\nIcon(\n    painter = painterResource(R.drawable.ic_outline_open_in_browser_24px),\n    contentDescription = \"ブラウザ起動\"\n)\t\n```\n\n- Context取得時に使う、`AmbientContext.current`が`LocalContext.current`に変更になりました。\n\n- Android Studioが対応してないのか、Kotlinのバージョンを1.4.30にしても、**バージョンが古いので利用できません**ってIDEに言われます。 \n    -  **エラー出るけど実行はできる。修正待ち**\n    - `'padding(Dp): Modifier' is only available since Kotlin 1.4.30 and cannot be used in Kotlin 1.4`\n    - 解決方法は、設定を開き、`Languages & Frameworks`へ進み、`Kotlin`を選び、`Update Channel`を`Early Access Preview 1.4.x`にして`Install`を押せばいいらしい。\n        - ここらへん参照：https://github.com/android/compose-samples/pull/387#issuecomment-777515590\n\n\n追記：`Icon`の増えてるのでコピペじゃ動かなくなりました。  \n`contentDescription`という文字列を入れる引数が増えてます。ので、コピペしたら`Icon`の引数を足してください。以下のように\n```kotlin\nIcon(\n    imageVector = Icons.Outlined.Home,\n    contentDescription = \"アイコンの説明。なければnullでもいい\"\n)\n```\n\nこの続きです。そのうち追記しに来る\n\nhttps://takusan.negitoro.dev/posts/android_jc/\n\n## Snackbar表示\n\n`Scaffold { }`で囲ってあげる必要があります。  \nSnackbar表示以外でもアプリバーとかドロワーの表示でも使うので置いておいて損はないはず。\n\nまた、Compose内で利用できるコルーチン(`rememberCoroutineScope()`)を利用する必要があります。\n\n```kotlin\n@ExperimentalMaterialApi\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n        MaterialTheme {\n            val state = rememberScaffoldState()\n            val scope = rememberCoroutineScope()\n            Scaffold(\n                scaffoldState = state,\n                topBar = {\n                    TopAppBar() {\n                        Column(\n                            horizontalAlignment = Alignment.CenterHorizontally,\n                            verticalArrangement = Arrangement.Center,\n                            modifier = Modifier.fillMaxHeight().padding(10.dp),\n                        ) {\n                            Text(text = \"ブログ一覧\")\n                        }\n                    }\n                }\n            ) {\n                OutlinedButton(onClick = {\n                    scope.launch {\n                        val result = state.snackbarHostState.showSnackbar(\n                            message = \"Snackbar表示\",\n                            actionLabel = \"押せます\",\n                            duration = SnackbarDuration.Short,\n                        )\n                        // 押せたかどうか\n                        if (result == SnackbarResult.ActionPerformed) {\n                            Toast.makeText(this@MainActivity, \"押せました！\", Toast.LENGTH_SHORT).show()\n                        }\n                    }\n                }) {\n                    Text(text = \"Snackbar表示\")\n                }\n            }\n        }\n    }\n}\n```\n\n実行結果\n\n![Imgur](https://imgur.com/T2NNPnK.png)\n\n参考にしました：https://gist.github.com/gildor/82ec960cc0c5873453f024870495eab3\n\n## Context取得\nリソース取得等は用意されてるけど、それ以外でContextを使いたい場合はこうです！\n\n```kotlin\n@Composable\nfun needContext() {\n    val context = LocalContext.current\n}\n```\n\n## コルーチンは？\n\nなんかコルーチン、2種類あるっぽい。  \n\n### LaunchedEffect vs rememberCoroutineScope\nなんか警告出てたので追記（2021/04/19）\n\n### LaunchedEffect\n\nこれは`@Composable`がついた関数内でしか呼べません。  \n`Button()`や`Text()`を置く感じで使うことになります。\n\n```kotlin\n@Composable\nfun TimerText() {\n    val timerCount = remember { mutableStateOf(0) }\n    /**\n     * ここはコンポーザブルのスコープ内\n     *\n     * Button()やText()が設置可能\n     * */\n    LaunchedEffect(key1 = Unit, block = {\n        while (true) {\n            timerCount.value += 1\n            delay(1000)\n        }\n    })\n    Text(text = \"${timerCount.value} 秒経過\")\n}\n\n```\n\nまた、`key1`の中身が変わると、今のコルーチンはキャンセルされ、新しいコルーチンが起動するようになっています。\n\n```kotlin\n@Composable\nfun TimerText() {\n    val timerCount = remember { mutableStateOf(0) }\n    val isRunning = remember { mutableStateOf(false) }\n    /**\n     * Button()やText()が設置可能な場所\n     *\n     * Composable内で利用できるコルーチン\n     *\n     * key1が変更されると、既存のコルーチンはキャンセルされ、新しくコルーチンが起動する\n     * */\n    LaunchedEffect(key1 = isRunning.value, block = {\n        timerCount.value = 0\n        while (isRunning.value) {\n            timerCount.value += 1\n            delay(1000)\n        }\n    })\n    Button(onClick = {\n        isRunning.value = !isRunning.value\n    }) {\n        if (isRunning.value) {\n            Text(text = \"${timerCount.value} 秒経過\")\n        } else {\n            Text(text = \"タイマー開始\")\n        }\n    }\n}\n```\n\n### rememberCoroutineScope\nじゃあ`rememberCoroutineScope`はなんだよって話ですが、これは`Composable`な関数ではないところで使うのが正解らしいです。  \n(例えば、ボタンを押したときに呼ばれる関数は`Composableな関数`ではない)\n\n```kotlin\n@Composable\nfun RememberCoroutine() {\n    val scope = rememberCoroutineScope()\n    val context = LocalContext.current\n\n    Button(onClick = {\n        // ここはComposableな関数ではない\n        scope.launch {\n            // Toast表示が終わるまで一時停止する\n            suspendToast(context)\n            println(\"終了\")\n        }\n    }) {\n        Text(text = \"rememberCoroutineScope\")\n    }\n}\n\n/** Toast表示が終わるまで一時停止する関数 */\nsuspend fun suspendToast(context: Context) {\n    Toast.makeText(context, \"rememberCoroutineScope\", Toast.LENGTH_SHORT).show()\n    delay(2 * 1000) // 2秒ぐらい\n}\n```\n\nあってるか分からないので、詳しくは公式で  \nhttps://developer.android.com/jetpack/compose/lifecycle\n\n## テーマとか文字の色にカラーコードを使いたい！\n`Color.parseColor()`がそのままでは使えないので、`androidx.compose.ui.graphics`の方の`Color`の引数に入れてあげます。\n\n```kotlin\nText(\n    text = AnniversaryDate.makeAnniversaryMessage(anniversary),\n    color = Color(android.graphics.Color.parseColor(\"#252525\"))\n)\n```\n\n## ダークモード\n\nまずは`ThemeColor.kt`みたいな色だけを書いておくクラスを作ってはりつけ  \n~~なんか`isDarkMode`に`@Composable`を付ける理由はわかりません。サンプルコードがそうなってたので便乗~~  \n`@Composable`をつけると`LocalContext`等へアクセスできる。  \nつけない場合だと(今回の場合は)引数に`Context`が必要になる。なるほどなあ\n\n```kotlin\n// 引数にContextが必要\nfun isDarkMode(context: Context) {}\n\n// いらない\n@Composable\nfun isDarkMode() {\n    val context = LocalContext.current\n}\n```\n\nここから例です\n\n```kotlin\n/**\n * [MaterialTheme]に渡すテーマ。コードでテーマの設定ができるってマジ？\n * */\n\n/** ダークモード。OLED特化 */\nval DarkColors = darkColors(\n    primary = Color.White,\n    secondary = Color.Black,\n)\n\n/** ライトテーマ */\nval LightColors = lightColors(\n    primary = Color(android.graphics.Color.parseColor(\"#757575\")),\n    primaryVariant = Color(android.graphics.Color.parseColor(\"#494949\")),\n    secondary = Color(android.graphics.Color.parseColor(\"#a4a4a4\")),\n)\n\n/** ダークモードかどうか */\n@Composable\nfun isDarkMode(): Boolean {\n    // ComposableをつけるとLocalContext等、Composable内でしか呼べない関数を呼べる（それはそう）\n    // 今回はContextを引数に取らなくてもLocalContextを使うことが出来た\n    val context = LocalContext.current\n    val conf = context.resources.configuration\n    val nightMode = conf.uiMode and Configuration.UI_MODE_NIGHT_MASK\n    return nightMode == Configuration.UI_MODE_NIGHT_YES // ダークモードなら true\n}\n```\n\nそしたら`MaterialTheme { }`に渡してあげます。if文を一行で書く\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme(\n                // 色の設定\n                colors = if (isDarkMode(AmbientContext.current)) DarkColors else LightColors\n            ) {\n                Scaffold {\n                    Column(\n                        modifier = Modifier.fillMaxWidth().fillMaxHeight(),\n                        verticalArrangement = Arrangement.Center,\n                        horizontalAlignment = Alignment.CenterHorizontally,\n                    ) {\n                        // この２つ、ダークモードなら白色、それ以外なら黒色になるはず\n                        Text(text = \"もじのいろ\")\n                        Icon(imageVector = Icons.Outlined.Home)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nちゃんと動けばダークモードのときは真っ暗になると思います。AOD\n\n![Imgur](https://imgur.com/pMaRzgc.png)\n\nちなみに黒基調にすると`Icon()`等が勝手に検知してアイコンの色を白色に変更してくれるそうです。ダークモード対応の手間が減る\n\n\n## タブレイアウト\n見つけたので報告しますね。そんなに難しくない。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MaterialTheme(\n                // 色の設定\n                colors = if (isDarkMode(AmbientContext.current)) DarkColors else LightColors\n            ) {\n                Scaffold {\n                    Column(\n                        modifier = Modifier.fillMaxWidth().fillMaxHeight(),\n                        verticalArrangement = Arrangement.Center,\n                        horizontalAlignment = Alignment.CenterHorizontally,\n                    ) {\n\n                        // 選択中タブ\n                        var selectTabIndex by remember { mutableStateOf(0) }\n\n                        TabLayout(\n                            selectTabIndex = selectTabIndex,\n                            tabClick = { index -> selectTabIndex = index }\n                        )\n                        Text(text = \"選択中：$selectTabIndex\")\n\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n/**\n * タブレイアウト\n *\n * @param selectTabIndex 選択するタブを入れてね\n * @param tabClick タブを押した時\n * */\n@Composable\nfun TabLayout(selectTabIndex: Int, tabClick: (Int) -> Unit) {\n    TabRow(\n        modifier = Modifier.padding(10.dp),\n        selectedTabIndex = selectTabIndex,\n        backgroundColor = Color.Transparent,\n    ) {\n        Tab(selected = selectTabIndex == 0, onClick = {\n            tabClick(0)\n        }) {\n            Icon(imageVector = Icons.Outlined.Android)\n            Text(text = \"Android 9\")\n        }\n        Tab(selected = selectTabIndex == 1, onClick = {\n            tabClick(1)\n        }) {\n            Icon(imageVector = Icons.Outlined.Android)\n            Text(text = \"Android 10\")\n        }\n        Tab(selected = selectTabIndex == 2, onClick = {\n            tabClick(2)\n        }) {\n            Icon(imageVector = Icons.Outlined.Android)\n            Text(text = \"Android 11\")\n        }\n    }\n}\n```\n\n動作結果\n\n![Imgur](https://imgur.com/nXfFeG5.png)\n\n## 動的にテーマを変える\n\n`MaterialTheme`の`colors`の部分を変えることでテーマを切り替えられるようになりました。これ従来のレイアウトじゃできないからComposeの強みじゃない？\n\nまずは色の情報を置いておくクラスを作成して、以下をコピペします。\n\n`ThemeColor.kt`\n\n```kotlin\n/** ダークモード。OLED特化 */\nval DarkColors = darkColors(\n    primary = Color.White,\n    secondary = Color.Black,\n)\n\n/** ライトテーマ */\nval LightColors = lightColors(\n    primary = Color(android.graphics.Color.parseColor(\"#FF6200EE\")),\n    primaryVariant = Color(android.graphics.Color.parseColor(\"#FF3700B3\")),\n    secondary = Color(android.graphics.Color.parseColor(\"#FFFFFF\")),\n)\n\n/** 青基調 */\nval blueTheme = lightColors(\n    primary = Color(android.graphics.Color.parseColor(\"#0277bd\")),\n    primaryVariant = Color(android.graphics.Color.parseColor(\"#58a5f0\")),\n    secondary = Color(android.graphics.Color.parseColor(\"#004c8c\")),\n)\n\n/** 赤基調 */\nval redTheme = lightColors(\n    primary = Color(android.graphics.Color.parseColor(\"#c2185b\")),\n    primaryVariant = Color(android.graphics.Color.parseColor(\"#8c0032\")),\n    secondary = Color(android.graphics.Color.parseColor(\"#fa5788\")),\n)\n\n/** 緑基調 */\nval greenTheme = lightColors(\n    primary = Color(android.graphics.Color.parseColor(\"#1b5e20\")),\n    primaryVariant = Color(android.graphics.Color.parseColor(\"#003300\")),\n    secondary = Color(android.graphics.Color.parseColor(\"#4c8c4a\")),\n)\n\n/** ダークモードかどうか */\n@Composable\nfun isDarkMode(context: Context): Boolean {\n    val conf = context.resources.configuration\n    val nightMode = conf.uiMode and Configuration.UI_MODE_NIGHT_MASK\n    return nightMode == Configuration.UI_MODE_NIGHT_YES // ダークモードなら true\n}\n```\n\nその後に書いていきます。ダークモードを一緒に書いた人はこっから掛けばいいです。\n\n```java\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n\n            // デフォルト\n            val defaultTheme = if (isDarkMode(AmbientContext.current)) DarkColors else LightColors\n\n            // 色を保持する\n            val themes = remember { mutableStateOf(defaultTheme) }\n\n            MaterialTheme(\n                // 色の設定\n                colors = themes.value\n            ) {\n                Scaffold(\n                    topBar = {\n                        TopAppBar() {\n                            Column(\n                                horizontalAlignment = Alignment.CenterHorizontally,\n                                verticalArrangement = Arrangement.Center,\n                                modifier = Modifier.fillMaxHeight().padding(10.dp),\n                            ) {\n                                Text(text = \"動的テーマ\")\n                            }\n                        }\n                    }\n                ) {\n                    // テーマ切り替え\n                    DynamicThemeButtons(themeClick = { themes.value = it})\n                }\n            }\n        }\n    }\n}\n\n/**\n * 動的にテーマを切り替える。\n *\n * @param themeClick ボタンを押したときに呼ばれる。引数にはテーマ（[Colors]）が入ってる\n * */\n@Composable\nfun DynamicThemeButtons(\n    themeClick: (Colors) -> Unit,\n) {\n\n    // デフォルト\n    val defaultTheme = if (isDarkMode(context = AmbientContext.current)) DarkColors else LightColors\n\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n    ) {\n        Button(\n            modifier = Modifier.padding(5.dp),\n            onClick = { themeClick(blueTheme) }\n        ) {\n            Text(text = \"青\")\n        }\n        Button(modifier = Modifier.padding(5.dp),\n            onClick = { themeClick(redTheme) }\n        ) {\n            Text(text = \"赤\")\n        }\n        Button(modifier = Modifier.padding(5.dp),\n            onClick = { themeClick(greenTheme) }\n        ) {\n            Text(text = \"緑\")\n        }\n        Button(modifier = Modifier.padding(5.dp),\n            onClick = { themeClick(defaultTheme) }\n        ) {\n            Text(text = \"デフォルト\")\n        }\n    }\n\n}\n```\n\n実行結果\n\nボタンを押すと色が切り替わると思います。\n\n![Imgur](https://imgur.com/cijIOts.png)\n\n![Imgur](https://imgur.com/Xr8lRaT.png)\n\n## 表示、非表示をアニメーションしてほしい\n\n`AnimatedVisibility`ってのがあります。  \n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    \n    @ExperimentalAnimationApi\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n\n            // デフォルト\n            val defaultTheme = if (isDarkMode(AmbientContext.current)) DarkColors else LightColors\n\n            // 色を保持する\n            val themes = remember { mutableStateOf(defaultTheme) }\n\n            MaterialTheme(\n                // 色の設定\n                colors = themes.value\n            ) {\n                VisibilityAnimationSample()\n            }\n        }\n    }\n}\n\n@ExperimentalAnimationApi\n@Composable\nfun VisibilityAnimationSample() {\n    // 表示するか\n    val isShow = remember { mutableStateOf(false) }\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .fillMaxHeight(),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n    ) {\n        AnimatedVisibility(visible = isShow.value) {\n            // この中に書いたやつがアニメーションされながら表示される\n            Column {\n                // 10個ぐらい\n                repeat(10) {\n                    Icon(imageVector = Icons.Outlined.Android, modifier = Modifier.rotate(90f * it))\n                }\n            }\n        }\n        // 表示、非表示切り替え\n        Button(onClick = { isShow.value = !isShow.value }) {\n            Text(text = \"アニメーションさせながら表示\")\n        }\n    }\n}\n```\n\n画像じゃわからんけど、ちゃんとアニメーションされてます。\n\n![Imgur](https://imgur.com/VFFCZR9.png)\n\n\n## 右寄せ\n`android:gravity=\"right\"`をJetpack Composeでもやりたいわけですね。重要な点は`fillMaxWidth()`を使うところです\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            GravityRight()\n        }\n    }\n}\n\n@Composable\nfun GravityRight() {\n    Column {\n        Row(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalArrangement = Arrangement.End,\n            verticalAlignment = Alignment.CenterVertically,\n        ) {\n            Text(text = \"右に寄ってる Row\")\n            IconButton(onClick = { /*TODO*/ }) {\n                Icon(imageVector = Icons.Outlined.Adb)\n            }\n        }\n        Divider() // 区切り\n        Column(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalAlignment = Alignment.End,\n            verticalArrangement = Arrangement.Center\n        ) {\n            Text(text = \"右に寄ってる Column\")\n            IconButton(onClick = { /*TODO*/ }) {\n                Icon(imageVector = Icons.Outlined.Adb)\n            }\n        }\n    }\n}\n```\n\nこうなるはず\n\n![Imgur](https://imgur.com/38Uu9zz.png)\n\n\n## 均等に並べる\n`LinearLayout`と同じように`weight`を設定すればできます。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            WeightSample()\n        }\n    }\n}\n\n@Composable\nfun WeightSample() {\n    Row(\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Button(modifier = Modifier.weight(1f).padding(5.dp), onClick = { /*TODO*/ }) {\n            Text(text = \"ぼたんだよー\")\n        }\n        Button(modifier = Modifier.weight(1f).padding(5.dp), onClick = { /*TODO*/ }) {\n            Text(text = \"ぼたんだよー\")\n        }\n        Button(modifier = Modifier.weight(1f).padding(5.dp), onClick = { /*TODO*/ }) {\n            Text(text = \"ぼたんだよー\")\n        }\n    }\n}\n```\n\nこうなるはず\n\n![Imgur](https://imgur.com/6YRtu3S.png)\n\n## 余りのスペースを埋める\n埋めたい部品に対して`weight(1f)`を足してあげることで、他の部品の事を考えながら埋めたい部品で埋めてくれます。  \nこっちも親要素に`fillMaxWidth()`を指定してあげる必要があります。(画面いっぱい使うなら)\n\n```kotlin   \nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MessageSendUI()\n        }\n    }\n}\n\n@Composable\nfun MessageSendUI() {\n    Row(\n        modifier = Modifier.fillMaxWidth(),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        val message = remember { mutableStateOf(\"\") }\n        // この部品を最大まで広げたい\n        OutlinedTextField(\n            value = message.value,\n            onValueChange = { message.value = it },\n            modifier = Modifier\n                .padding(5.dp)\n                .weight(1f)\n        )\n        IconButton(\n            onClick = { /*TODO*/ },\n            modifier = Modifier.padding(5.dp)\n        ) {\n            Icon(imageVector = Icons.Outlined.Send)\n        }\n    }\n}\n```\n\nこうなるはず\n\n![Imgur](https://imgur.com/dcxKhg3.png)\n\n## もっとサンプル書け！\n\n`Jetpack Compose`を書いてる人のサンプルには勝てないというわけで`ソースコード`の探し方でも。\n\n#### 1.Android Studioで使いたいUI部品のソースコードを開く\n\n`Button`とか`OutlinedButton`とか`MaterialTheme`の部分で`Ctrl 押しながら クリック`することで飛べます。\n\nこんなのが出ると思う\n\n![Imgur](https://imgur.com/PovnHgF.png)\n\n#### 2.ブラウザで\n\nhttps://cs.android.com/\n\nを開きます。\n\n#### 3.@sample の部分を探します。\n\nさっきの画像だと、\n\n```java\n@sample androidx.compose.material.samples.OutlinedButtonSample\n```\n\nのところですね\n\n#### 4.検索欄に入れる\nで、何を検索欄に入れればいいんだって話ですが、さっき見つけた`@sample ～`の部分、  \n最後から`.`までの部分を入力します。\n\n```java\n@sample androidx.compose.material.samples.OutlinedButtonSample\n```\n\nだと、`OutlinedButtonSample`がそうです。\n\n\n早速検索欄に入れましょう\n\n![Imgur](https://imgur.com/zUlBhLR.png)\n\n#### 5.コードを読み解く\n\n検索欄に入れたらおそらく一番最初のサジェストが使い方の例になってると思います。\n\nあとは読んでいくしか無いです。\n\n![Imgur](https://imgur.com/7dM94mY.png)\n\n\n## サンプルアプリ\n\n今までやったこと(だいたい)を一つのアプリにしてみました。どうぞ。\n\nhttps://github.com/takusan23/JetpackComposeSampleApp\n\n### ダウンロード\n\nhttps://github.com/takusan23/JetpackComposeSampleApp/releases/tag/1.0"},{"title":"Jetpack ComposeのTabRowのインジケータの角を丸く","link":"/posts/android_jc_tab_rounded_indicator/","markdown":"\r\nどうもこんばんわ。\r\n\r\n# 本題\r\n最近のマテリアルデザインにあるタブの下の選択中を示す棒の端っこが丸いやつをやりたい。  \r\nちなみにこれはPlayStore。オープンソースライセンス見るとComposeの文字が...？\r\n\r\n![Imgur](https://imgur.com/DS6aAR4.png)\r\n\r\n# コード\r\n\r\n```kotlin\r\n@Composable\r\nfun RoundedIndicatorTabRow() {\r\n    val selectIndex = remember { mutableStateOf(0) }\r\n    TabRow(\r\n        selectedTabIndex = selectIndex.value,\r\n        contentColor = MaterialTheme.colors.primary,\r\n        backgroundColor = MaterialTheme.colors.background,\r\n        indicator = { tabPositions ->\r\n            // テキストの下に出るあの棒のやつ\r\n            Box(\r\n                modifier = Modifier\r\n                    .tabIndicatorOffset(tabPositions[selectIndex.value])\r\n                    .height(3.dp)\r\n                    .padding(start = 20.dp, end = 20.dp)\r\n                    .background(LocalContentColor.current, RoundedCornerShape(100, 100, 0, 0))\r\n            )\r\n        }\r\n    ) {\r\n        Tab(\r\n            selected = 0 == selectIndex.value,\r\n            modifier = Modifier.padding(5.dp),\r\n            onClick = { selectIndex.value = (0) },\r\n            content = {\r\n                Text(text = \"ホーム\")\r\n            }\r\n        )\r\n        Tab(\r\n            selected = 1 == selectIndex.value,\r\n            modifier = Modifier.padding(5.dp),\r\n            onClick = { selectIndex.value = (1) },\r\n            content = {\r\n                Text(text = \"通知\")\r\n            }\r\n        )\r\n        Tab(\r\n            selected = 2 == selectIndex.value,\r\n            modifier = Modifier.padding(5.dp),\r\n            onClick = { selectIndex.value = (1) },\r\n            content = {\r\n                Text(text = \"お気に入り\")\r\n            }\r\n        )\r\n        Tab(\r\n            selected = 3 == selectIndex.value,\r\n            modifier = Modifier.padding(5.dp),\r\n            onClick = { selectIndex.value = (1) },\r\n            content = {\r\n                Text(text = \"設定\")\r\n            }\r\n        )\r\n    }\r\n\r\n}\r\n```\r\n\r\n以上です。お疲れさまでした。\r\n\r\n![Imgur](https://imgur.com/ibFilId.png)"},{"title":"Jetpack Compose の TextField でカーソルの位置変更","link":"/posts/android_jc_textfield_cursor/","markdown":"どうもこんばんわ。  \r\n自分用メモ。あの文字入力中のカーソル？点滅してるやつってキャレットって言うらしいですよ？\r\n\r\n# 本題\r\n\r\nJetpack Compose でテキストフィールドのカーソルの位置はどこで変更できるの\r\n\r\n## こたえ\r\n\r\n`String`ではなく`TextFieldValue`を引数に取る`TextField`を利用すると、  \r\n`TextFieldValue`経由でカーソルの位置を変更できます。\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            TextFieldCursorPosTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background) {\r\n\r\n                    val textFieldValue = remember { mutableStateOf(TextFieldValue()) }\r\n\r\n                    LaunchedEffect(key1 = textFieldValue.value.text, block = {\r\n                        val textBoxValue = textFieldValue.value.text\r\n                        // ここで文字変更時のイベントが取れるよ...\r\n                    })\r\n\r\n                    Column(\r\n                        verticalArrangement = Arrangement.Center,\r\n                        horizontalAlignment = Alignment.CenterHorizontally\r\n                    ) {\r\n                        OutlinedTextField(\r\n                            value = textFieldValue.value,\r\n                            onValueChange = { textFieldValue.value = it }\r\n                        )\r\n\r\n                        // カーソルを最後に持っていく\r\n                        Button(onClick = { textFieldValue.value = textFieldValue.value.copy(selection = TextRange(textFieldValue.value.text.length)) }) {\r\n                            Text(text = \"最後へ\")\r\n                        }\r\n\r\n                        // カーソルを最初に持っていく\r\n                        Button(onClick = { textFieldValue.value = textFieldValue.value.copy(selection = TextRange(0)) }) {\r\n                            Text(text = \"最初へ\")\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nただこれを利用すると、カーソルを動かすたびに`onValueChange = { }`が呼ばれるので、\r\n今まで通りに文字変更時だけ呼ばれるようにしたい場合は`LaunchedEffect`の`key`に入れれば良いんじゃないかと思いました。\r\n\r\n## 利用例\r\n検索であるサジェスト（テキスト補充のやつ）とかで使えるんじゃないかと思いました\r\n\r\n```\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    private val ALL_LIST = listOf(\r\n        \"Android 12\",\r\n        \"Android 13 DP\",\r\n        \"Android JetpackCompose\",\r\n        \"Android Room\",\r\n        \"Android LiveData\",\r\n        \"Android ViewModel\",\r\n    )\r\n\r\n    @OptIn(ExperimentalMaterialApi::class)\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            TextFieldCursorPosTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background) {\r\n                    // サジェスト一覧\r\n                    val suggestList = remember { mutableStateListOf<String>() }\r\n                    // 入力欄の文字\r\n                    val textFieldValue = remember { mutableStateOf(TextFieldValue()) }\r\n                    // 文字だけ変更検知\r\n                    LaunchedEffect(key1 = textFieldValue.value.text, block = {\r\n                        suggestList.clear()\r\n                        suggestList.addAll(ALL_LIST.filter { it.contains(textFieldValue.value.text) })\r\n                    })\r\n                    Column(modifier = Modifier.padding(10.dp)) {\r\n                        OutlinedTextField(\r\n                            value = textFieldValue.value,\r\n                            onValueChange = { textFieldValue.value = it }\r\n                        )\r\n                        LazyColumn(content = {\r\n                            items(suggestList) { suggestText ->\r\n                                Surface(\r\n                                    onClick = {\r\n                                        textFieldValue.value = textFieldValue.value.copy(\r\n                                            text = suggestText,\r\n                                            selection = TextRange(suggestText.length) // 押したらカーソルを最後に移動\r\n                                        )\r\n                                    }\r\n                                ) { Text(modifier = Modifier.padding(10.dp), text = suggestText) }\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/XUHFn8t.png)\r\n\r\n### ソースコード\r\n\r\nおいておきます\r\n\r\nhttps://github.com/takusan23/TextFieldCursorPos\r\n\r\n## おわりに\r\n\r\n```kotlin\r\nTextFieldValue(\r\n    text = \"入力中文字\",    // 入力している文字\r\n    selection = TextRange(0),   // カーソルの位置情報、もしくは長押しで文字を範囲指定した際の位置情報\r\n    composition = null // 変換前テキストがある場合はその範囲。nullを入れると確定になる（文字入力中のボーダーラインが消える）\r\n)\r\n```\r\n\r\n花粉やばい"},{"title":"JetpackComposeのTextFieldをViewのEditTextに似せたい","link":"/posts/android_jc_traditional_text_field/","markdown":"\r\n`BasicTextField`を使えばいいです。\r\n"},{"title":"Jetpack Compose と ViewModel","link":"/posts/android_jc_viewmodel/","markdown":"\r\nどうもこんにちは。  \r\n楽天モバイルのテザリングでこの記事書いてます。\r\n\r\n# 本題\r\nJetpack ComposeでViewModelを使うときどうすればええの？\r\n\r\n# なんかいい感じにやってくれる。\r\nViewModelにKeyを内部的に付けてくれるので、同じスコープでも複数のViewModelが持てました。よく考えてある\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            ComposeViewModelTheme {\r\n                // A surface container using the 'background' color from the theme\r\n                Surface(color = MaterialTheme.colors.background) {\r\n\r\n                    val currentPageName = remember { mutableStateOf(\"home\") }\r\n\r\n                    Scaffold(\r\n                        bottomBar = {\r\n                            BottomNavigation {\r\n                                BottomNavigationItem(\r\n                                    selected = currentPageName.value == \"home\",\r\n                                    onClick = { currentPageName.value = \"home\" },\r\n                                    label = { Text(text = \"Home\") },\r\n                                    icon = { Icon(painter = painterResource(id = R.drawable.ic_baseline_home_24), contentDescription = \"home\") }\r\n                                )\r\n                                BottomNavigationItem(\r\n                                    selected = currentPageName.value == \"notification\",\r\n                                    onClick = { currentPageName.value = \"notification\" },\r\n                                    label = { Text(text = \"Notification\") },\r\n                                    icon = { Icon(painter = painterResource(id = R.drawable.ic_baseline_notifications_24), contentDescription = \"notification\") }\r\n                                )\r\n                            }\r\n                        }\r\n                    ) {\r\n                        // ページ切り替え\r\n                        when (currentPageName.value) {\r\n                            \"home\" -> HomeScreen()\r\n                            \"notification\" -> NotificationScreen()\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun HomeScreen() {\r\n    val viewModel = viewModel<HomeViewModel>()\r\n    Text(text = \"Home Screen ${viewModel.hashCode()}\")\r\n}\r\n\r\n@Composable\r\nfun NotificationScreen() {\r\n    val viewModel = viewModel<NotificationViewModel>()\r\n    Text(text = \"Notification is empty ${viewModel.hashCode()}\")\r\n}\r\n```\r\n\r\n## ViewModelProvider#Factory\r\nにも対応しています。\r\n\r\n```kotlin\r\nclass InfoViewModel(application: Application, private val gameId: Int) : AndroidViewModel(application) {\r\n\r\n}\r\n```\r\n\r\n```kotlin\r\nclass InfoViewModelFactory(val application: Application, val gameId: Int) : ViewModelProvider.Factory {\r\n\r\n    override fun <T : ViewModel?> create(modelClass: Class<T>): T {\r\n        return InfoViewModel(application, gameId) as T\r\n    }\r\n\r\n}\r\n```\r\n\r\n```kotlin\r\nGameInfoScreen(viewModel = viewModel(factory = InfoViewModelFactory(application, \"contentId\")))\r\n```\r\n\r\n```kotlin\r\n@Composable\r\nfun GameInfoScreen(viewModel: InfoViewModel) {\r\n    // 省略\r\n}\r\n```\r\n\r\n以上です。\r\n\r\n# サンプル\r\n一つのActivityにJetpack Composeで2画面実現してます\r\n\r\nhttps://github.com/takusan23/ErogameScapeDroid\r\n\r\n# 終わりに\r\nJetpack Composeで書き直したいけど時間がない。"},{"title":"Jetpack ComposeのviewModel()が赤くなる","link":"/posts/android_jc_viewmodel_fun_err/","markdown":"どうもこんばんわ。  \r\nWWDCも夜勤で見れません。あとまいてつがセール中なんだって？気になる\r\n\r\n# 本題\r\n\r\n`viewModel()`関数がなんか赤くなってる。別にバージョンもいじってないのに\r\n\r\n![Imgur](https://imgur.com/Nt8YeKE.png)\r\n\r\n# 直し方\r\n\r\n左上の`File`から`Invalidate Caches/ Restart...`を選んで、`Invalidate and Restart`を押せば勝手にAndroid Studioが再起動する。\r\n\r\n![Imgur](https://imgur.com/alXmBnd.png)\r\n\r\n# 終わりに\r\n`Jetpack Compose`では`ViewModel`を使わないみたいなのを観測したけどどういうことなの？  "},{"title":"自作Androidライブラリを Maven Central へ公開する","link":"/posts/android_library_publish_to_maven_central/","markdown":"どうもこんばんわ。\r\n\r\n保健室のセンセーとゴスロリの校医 攻略しました。前作はやってないです。  \r\nロープライスだけどシナリオがちゃんとしていていいと思いました。おすすめ\r\n\r\n![Imgur](https://imgur.com/zgom8f4.png)\r\n\r\n![Imgur](https://imgur.com/mS4S4ne.png)\r\n\r\nみんなかわいい\r\n\r\n![Imgur](https://imgur.com/roZOqlK.png)\r\n\r\n鈴ルートも近々発売みたいなので楽しみですね。くー\r\n\r\n![Imgur](https://imgur.com/8PamPDe.png)\r\n\r\n# 本題\r\nちょっと前に書いたアプリのコア部分をライブラリに切り出した。\r\n- https://github.com/takusan23/Coneco/tree/master/conecocore\r\n- https://github.com/takusan23/Coneco/tree/master/conecohls\r\n\r\nライブラリを作ったのでせっかくなら公開しようというわけで、  \r\n`Maven Central`へ公開し、他の人から使えるようにしてみます！\r\n\r\n# 環境\r\n\r\n- リポジトリ\r\n    - https://github.com/takusan23/Coneco\r\n- build.gradle.kts を使います\r\n    - 別に移行しても便利にはならないと思います...\r\n- Windows 10 Pro\r\n\r\n## 用語集\r\nなんだかよく分からん名前ばっか出るのでまとめます。  \r\nそれぞれの立ち位置を理解するのでお腹いっぱいになりそう。\r\n\r\n- Sonatype Jira\r\n    - ライブラリをアップロードするリポジトリを作成するため使う\r\n        - 多分リポジトリ管理してる中の人とやり取りするのに使う\r\n        - Jira チケットを切って担当者にお願いする\r\n        - チケットを切るには Jira アカウントも作らないといけない\r\n- Sonatype OSSRH\r\n    - Sonatype OpenSourceSoftware Repository Hosting の略らしい\r\n    - まずはここにライブラリをアップロードする\r\n- MavenCentral\r\n    - Sonatype OSSRH へアップロードしたライブラリが問題なければ MavenCentral へ公開する。\r\n    - よく分からん\r\n\r\n## 流れ\r\n- Sonatype (Atlassian) Jira のアカウントを作る\r\n- リポジトリの作成をお願いするJiraチケットを切る\r\n    - グループID（ドメイン、GitHub Pages）のどれかを利用する\r\n- 署名に使うGPG鍵を作成する\r\n- Gradleを書く\r\n- リリースする\r\n- Sonatypeの管理画面からMavenCentralに公開する\r\n- おわり\r\n\r\nなげえよ...\r\n\r\n## 公式\r\n\r\nhttps://central.sonatype.org/publish/publish-guide/\r\n\r\n## 使うライブラリ\r\nあり座椅子\r\n\r\nhttps://github.com/gradle-nexus/publish-plugin\r\n\r\nhttps://github.com/Kotlin/dokka\r\n\r\n(Dokkaでjavadoc.jar 生成 : https://kotlinlang.org/docs/dokka-gradle.html#build-javadoc-jar)\r\n\r\n## 参考にしました、ありがとうございます！\r\nhttps://getstream.io/blog/publishing-libraries-to-mavencentral-2021/\r\n\r\nhttp://yuki312.blogspot.com/2021/08/maven-central-repository.html\r\n\r\n\r\n# Sonatype Atlassian Jira アカウントの作成\r\nここから作れます。  \r\nhttps://issues.sonatype.org/secure/Signup!default.jspa\r\n\r\nFull name は適当でいいんじゃね、バカ正直にかく必要はなさそう雰囲気（知らんけどあとから変更できる）。  \r\n**Usernameは変更できない上に管理画面へログインする際も使われるのでよく考えたほうが良さそう**\r\n\r\nhttps://central.sonatype.org/publish/manage-user/#change-my-full-name-e-mail-address-or-password\r\n\r\nパスワードの条件難しくて草。最後の記号とかどうやって出すんだよ\r\n\r\n```\r\nYou must specify a password that satisfies the password policy.\r\nThe password must contain at least 1 special character, such as &, %, ™, or É.\r\n```\r\n\r\n出来たらこうなる。作ったアカウントでログインして、適当に初期設定を進めます。\r\n\r\n![Imgur](https://imgur.com/4NYMvGD.png)\r\n\r\nAtlassian Jira 自体には日本語があります。なお日本語で対応してくれるとは言っていない。\r\n\r\n![Imgur](https://imgur.com/wHObSuK.png)\r\n\r\n# リポジトリを作ってもらうJiraチケットを切る\r\n**作成**からチケットを切れます。\r\n\r\n![Imgur](https://imgur.com/UK5Aezu.png)\r\n\r\nプロジェクト、課題タイプ はそのままでおっけー\r\n\r\n![Imgur](https://imgur.com/K8YduK0.png)\r\n\r\nそして以下の項目を埋めていきます。  \r\nGroup Idってのは`io.github.takusan23`みたいなやつです。    \r\n自分で持ってるドメインとか使えるみたいですが、今回はGitHub Pagesのドメインを使います。  \r\nよくライブラリ導入時にドメインが逆になった文字列を入れると思うのですが、それです。\r\n\r\n`implementation(\"io.github.takusan23:conecocore:1.0.0\")` ← この `io.github.takusan23`がグループID\r\n\r\n| なまえ                    | 書くこと                                                 | 例                                                                                                          |\r\n|---------------------------|----------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|\r\n| 要約                      | リポジトリを作って欲しいよ～的な                         | Create repository for io.github.takusan23                                                                   |\r\n| 説明                      | ライブラリ作ったからMavenCentralで公開したいんだ！～的な | I created an Android library that connects multiple videos. I would like to publish it using Maven Central. |\r\n| Group Id                  | グループID、GitHub Pagesのドメインとか                   | io.github.takusan23                                                                                         |\r\n| Project URL               | GitHubのリポジトリへのURL                                | https://github.com/takusan23/Coneco                                                                         |\r\n| SCM url                   | Project URLで書いたURLに`.git`をつければ良さそう         | https://github.com/takusan23/Coneco.git                                                                     |\r\n| Already Synced to Central | 初めてならNoで良いと思う                                 | No                                                                                                          |\r\n\r\n以下例です。\r\n\r\n![Imgur](https://imgur.com/kanqUyx.png)\r\n\r\n作成を押すと、こんな風になるのでチケットの詳細ページへ飛びましょう。\r\n\r\n![Imgur](https://imgur.com/Bnxb0zf.png)\r\n\r\n## 数十秒待っていると...\r\nチケットへコメントが付きます。（Botなんですけどね初見さん）  \r\n\r\n![Imgur](https://imgur.com/lljwjuq.png)\r\n\r\nここでグループIDの検証を行います、が特に難しいことをするわけでもなく、  \r\n自分のGitHubのリポジトリに作ったJiraチケットのチケット番号（OSSRH- から始まるやつ）の名前でリポジトリを作成しろって内容です。\r\n\r\nというわけで作成して\r\n\r\n![Imgur](https://imgur.com/VtlXUag.png)\r\n\r\nチケットのコメントに作ったことを知らせます。  \r\n\r\n```\r\nCreated repository for https://github.com/takusan23/OSSRH-79851\r\n```\r\n\r\n![Imgur](https://imgur.com/tSevFmy.png)\r\n\r\nチケットをOpenにしろって言われてるんだけど勝手にOpenになってた\r\n\r\n![Imgur](https://imgur.com/396HM8B.png)\r\n\r\n## 数分後に...\r\n\r\nMavenCentralで`io.github.takusan23`が使えるようになったぞ！ってメールが来ました。歯磨き終わったら仕事終わってた。有能かよ\r\n\r\n![Imgur](https://imgur.com/k01PjD8.png)\r\n\r\nこれで、https://s01.oss.sonatype.org/ にログインできるようになります。  \r\nログインはここです。  \r\nUsername、パスワードはさっきのJiraアカウントと同じものを使えばOKです。\r\n\r\n![Imgur](https://imgur.com/zyI6CQw.png)\r\n\r\n![Imgur](https://imgur.com/dqOgO67.png)\r\n\r\n# 署名で使う鍵を作成する\r\n公式：https://central.sonatype.org/publish/requirements/gpg/\r\n\r\n私は Windowsユーザー なので Gpg4win を入れます。\r\n\r\nhttps://gpg4win.org/index.html\r\n\r\n![Imgur](https://imgur.com/p2ekpeb.png)\r\n\r\nインストーラーの案内に従って入れましょう。\r\n\r\n![Imgur](https://imgur.com/xdPIIfD.png)\r\n\r\nインストールしたら開きます。GUIが付属してますので使っていきましょう。\r\n\r\n![Imgur](https://imgur.com/isJTqGm.png)\r\n\r\n## 署名の中身\r\n詳細設定は、`詳細設定`を押すと開きます。\r\n\r\n| なまえ                                      | あたい                                          |\r\n|---------------------------------------------|-------------------------------------------------|\r\n| 名前                                        | 各自の名前                                      |\r\n| メールアドレス                              | 各自のメールアドレス                            |\r\n| 鍵の要素                                    | RSA +RSA (4096 ビット)                          |\r\n| 証明書の利用目的                            | 署名 （有効期限決めることも可能、今回はしない） |\r\n| Protect the generated key with a passphrase | チェックを入れる                                |\r\n\r\n![Imgur](https://imgur.com/YNdDU66.png)\r\n\r\nパスワードを入力します。\r\n\r\n![Imgur](https://imgur.com/R2kALYR.png)\r\n\r\nできました。\r\n\r\n![Imgur](https://imgur.com/N5svyQA.png)\r\n\r\n### バックアップと失効証明書の作成\r\n一応作成します。\r\n\r\nバックアップはキーを右クリックしてコンテキストメニューを出し、`Backup Secret Keys...`で出来ます。\r\n\r\n![Imgur](https://imgur.com/NprkeQg.png)\r\n\r\n失効証明書を作っておくと、万が一秘密鍵が漏れた場合に無効にできます。  \r\nコンテキストメニューを開き、`詳細`を押します。\r\n\r\n![Imgur](https://imgur.com/12Qnqs7.png)\r\n\r\nそしたら`Generate revocation certificate`を押すことで発行できます。\r\n\r\n![Imgur](https://imgur.com/HVpCBv3.png)\r\n\r\n## 公開鍵を鍵サーバーへアップロードする\r\nGUIでやる方法がわからんかったので、コマンドプロンプトでやります。  \r\nコマンドプロンプト、PowerShell等を起動して、まず鍵一覧を出します\r\n\r\n`gpg --list-keys`\r\n\r\nそしたら長い16進数があると思うので、この16進数の最後から8文字分をコピーしておきます。\r\n\r\n次に、以下のコマンドを叩いてアップロードします。\r\n\r\n```shell\r\ngpg --keyserver keyserver.ubuntu.com --send-keys <コピーした16進数>\r\n```\r\n\r\n![Imgur](https://imgur.com/PHk9DF8.png)\r\n\r\n## 署名鍵をBase64にする\r\n最後にライブラリの署名で使うので、秘密鍵をBase64で書き出しておきます。  \r\n**秘密鍵なので扱いには十分気をつけてね！！！！**\r\n\r\n`macOS`とかだとワンライナーみたいなんですが、Windowsの場合はちょっとめんどいですね...  \r\n適当なフォルダを作りその中で、PowerShellなどを起動して...\r\n\r\n```shell\r\ngpg --export-secret-keys コピーした16進数 > export_secret\r\ncertutil -f -encode export_secret export_secret_base64\r\n```\r\n\r\n`export_secret_base64`ファイルができていれば成功です。Base64なファイルは文字なのでテキストエディタで開けます。  \r\n最初の`-----BEGIN CERTIFICATE-----`と最後の`-----END CERTIFICATE-----`を消して、改行も消します\r\n\r\n# いよいよライブラリを公開するためのGradleタスクを書いていく...\r\n\r\n**2023/02/19 めっちゃ間違えてました。すいませｎ。ソースとjavadocが入るように修正しました。**\r\n\r\n## ルート (.idea がある場所) の build.gradle.kts\r\n\r\nまずルートにある build.gradle.kts へ書き足します。  \r\n`kts`で書いた場合、別ファイルにスクリプトを書いて`apply from`する方法が使えないみたいなので、直接書くしかないです。  \r\n(参考にした記事では別スクリプトに分けてた、~~あれ？ktsに移行するメリットマジでなくない...~~)\r\n\r\nhttps://github.com/gradle/kotlin-dsl-samples/issues/1287\r\n\r\n```kotlin\r\nbuildscript {\r\n    val kotlinVersion: String by extra(\"1.7.10\")\r\n    val composeVersion: String by extra(\"1.3.1\")\r\n}\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    id(\"com.android.application\").version(\"7.4.0\").apply(false)\r\n    id(\"com.android.library\").version(\"7.4.0\").apply(false)\r\n    id(\"org.jetbrains.kotlin.android\").version(\"1.7.10\").apply(false)\r\n    // ドキュメント生成と Maven Central へ公開をしてくれるやつ\r\n    id(\"org.jetbrains.dokka\").version(\"1.7.10\")\r\n    id(\"io.github.gradle-nexus.publish-plugin\").version(\"1.1.0\")\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n\r\n// ライブラリ署名情報がなくてもビルドできるようにする\r\nextra[\"signing.keyId\"] = \"\"\r\nextra[\"signing.password\"] = \"\"\r\nextra[\"signing.key\"] = \"\"\r\nextra[\"ossrhUsername\"] = \"\"\r\nextra[\"ossrhPassword\"] = \"\"\r\nextra[\"sonatypeStagingProfileId\"] = \"\"\r\n\r\n// 署名情報を読み出す。開発環境では local.properties に署名情報を置いている。\r\nval secretPropsFile = project.rootProject.file(\"local.properties\")\r\nif (secretPropsFile.exists()) {\r\n    // 読み出して、extra へ格納する\r\n    val properties = java.util.Properties().apply {\r\n        load(secretPropsFile.inputStream())\r\n    }\r\n    properties.forEach { name, value -> extra[name as String] = value }\r\n} else {\r\n    // システム環境変数から読み出す。CI/CD 用\r\n    extra[\"ossrhUsername\"] = System.getenv(\"OSSRH_USERNAME\")\r\n    extra[\"ossrhPassword\"] = System.getenv(\"OSSRH_PASSWORD\")\r\n    extra[\"sonatypeStagingProfileId\"] = System.getenv(\"SONATYPE_STAGING_PROFILE_ID\")\r\n    extra[\"signing.keyId\"] = System.getenv(\"SIGNING_KEY_ID\")\r\n    extra[\"signing.password\"] = System.getenv(\"SIGNING_PASSWORD\")\r\n    extra[\"signing.key\"] = System.getenv(\"SIGNING_KEY\")\r\n}\r\n\r\n// Sonatype OSSRH リポジトリ情報\r\nnexusPublishing.repositories.sonatype {\r\n    stagingProfileId.set(extra[\"sonatypeStagingProfileId\"] as String)\r\n    username.set(extra[\"ossrhUsername\"] as String)\r\n    password.set(extra[\"ossrhPassword\"] as String)\r\n    nexusUrl.set(uri(\"https://s01.oss.sonatype.org/service/local/\"))\r\n    snapshotRepositoryUrl.set(uri(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\"))\r\n}\r\n```\r\n\r\n## ライブラリの方の build.gradle.kts\r\nこっちも同様直接書くしかないです。  \r\n`ライブラリ名`、`ライブラリの説明`の部分や、  \r\n作者とかライセンスとかが書いてある下の部分は各自書き換えてください。\r\n\r\n| なまえ     | せつめい                                                |\r\n|------------|---------------------------------------------------------|\r\n| groupId    | Sonatype OSSRH のJiraチケットで決めたのと同じグループID |\r\n| artifactId | ライブラリ名とも言う                                    |\r\n| version    | バージョン                                              |\r\n\r\n```kotlin\r\nplugins {\r\n    id(\"com.android.library\")\r\n    id(\"org.jetbrains.kotlin.android\")\r\n    // ライブラリに同梱するドキュメント生成器\r\n    id(\"org.jetbrains.dokka\")\r\n    // ライブラリ作成に必要\r\n    `maven-publish`\r\n    signing\r\n}\r\n\r\n// ライブラリバージョン\r\nval libraryVersion = \"1.0.2\"\r\n// ライブラリ名\r\nval libraryName = \"conecocore\"\r\n// ライブラリの説明\r\nval libraryDescription = \"It is a library that connects multiple videos into one.\"\r\n\r\nandroid {\r\n    compileSdk = 33\r\n    namespace = \"io.github.takusan23.conecocore\"\r\n\r\n    defaultConfig {\r\n        minSdk = 21\r\n        targetSdk = 33\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n        consumerProguardFile(\"consumer-rules.pro\")\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            isMinifyEnabled = false\r\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility = JavaVersion.VERSION_1_8\r\n        targetCompatibility = JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.0\")\r\n\r\n    implementation(\"androidx.core:core-ktx:1.7.0\")\r\n    implementation(\"androidx.appcompat:appcompat:1.4.1\")\r\n\r\n    testImplementation(\"junit:junit:4.13.2\")\r\n    androidTestImplementation(\"androidx.test.ext:junit:1.1.3\")\r\n    androidTestImplementation(\"androidx.test.espresso:espresso-core:3.4.0\")\r\n}\r\n\r\nval androidSourcesJar = tasks.register<Jar>(\"androidSourcesJar\") {\r\n    archiveClassifier.set(\"sources\")\r\n    from(android.sourceSets[\"main\"].java.srcDirs)\r\n}\r\n\r\ntasks.dokkaJavadoc {\r\n    outputDirectory.set(File(buildDir, \"dokkaJavadoc\"))\r\n}\r\n\r\nval javadocJar = tasks.register<Jar>(\"dokkaJavadocJar\") {\r\n    dependsOn(tasks.dokkaJavadoc)\r\n    from(tasks.dokkaJavadoc.flatMap { it.outputDirectory })\r\n    archiveClassifier.set(\"javadoc\")\r\n}\r\n\r\nartifacts {\r\n    archives(androidSourcesJar)\r\n    archives(javadocJar)\r\n}\r\n\r\nsigning {\r\n    // ルート build.gradle.kts の extra を見に行く\r\n    useInMemoryPgpKeys(\r\n        rootProject.extra[\"signing.keyId\"] as String,\r\n        rootProject.extra[\"signing.key\"] as String,\r\n        rootProject.extra[\"signing.password\"] as String,\r\n    )\r\n    sign(publishing.publications)\r\n}\r\n\r\nafterEvaluate {\r\n    publishing {\r\n        publications {\r\n            create<MavenPublication>(\"maven\") {\r\n                groupId = \"io.github.takusan23\"\r\n                artifactId = libraryName\r\n                version = libraryVersion\r\n                if (project.plugins.hasPlugin(\"com.android.library\")) {\r\n                    from(components[\"release\"])\r\n                } else {\r\n                    from(components[\"java\"])\r\n                }\r\n                artifact(androidSourcesJar)\r\n                artifact(javadocJar)\r\n                pom {\r\n                    // ライブラリ情報\r\n                    name.set(artifactId)\r\n                    description.set(libraryDescription)\r\n                    url.set(\"https://github.com/takusan23/Coneco/\")\r\n                    // ライセンス\r\n                    licenses {\r\n                        license {\r\n                            name.set(\"Apache License 2.0\")\r\n                            url.set(\"https://github.com/takusan23/Coneco/blob/master/LICENSE\")\r\n                        }\r\n                    }\r\n                    // 開発者\r\n                    developers {\r\n                        developer {\r\n                            id.set(\"takusan_23\")\r\n                            name.set(\"takusan_23\")\r\n                            url.set(\"https://takusan.negitoro.dev/\")\r\n                        }\r\n                    }\r\n                    // git\r\n                    scm {\r\n                        connection.set(\"scm:git:github.com/takusan23/Coneco\")\r\n                        developerConnection.set(\"scm:git:ssh://github.com/takusan23/Coneco\")\r\n                        url.set(\"https://github.com/takusan23/Coneco\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# local.properties に認証情報を書き込む\r\nこのファイルはgitの管理下にしてはいけません。絶対人には見せちゃだめですよ。  \r\nなんか書いてあるかもだけどその下にかけばいいです。\r\n\r\n```properties\r\n# Git管理下に入れてはぜっっったいダメです\r\n# 絶対秘密です\r\n# 鍵IDの最後8桁\r\nsigning.keyId=xxxxxx\r\n# パスワード\r\nsigning.password=password\r\n# 秘密鍵のBase64\r\nsigning.key=xxxxxxxxx\r\n# Sonatype OSSRH のユーザー名\r\nossrhUsername=takusan_23\r\n# Sonatype OSSRH のパスワード\r\nossrhPassword=password\r\n# Sonatype ステージングプロファイルId\r\nsonatypeStagingProfileId=8320....\r\n```\r\n\r\n## ステージングプロファイルId どこやねん\r\n\r\nSonatype OSSRH の nexus repository manager へログインします。  \r\nhttps://s01.oss.sonatype.org\r\n\r\nそしたら、左側にある中から、`Staging Profiles`を押して、自分の名前の部分を押します。  \r\n押したら、ブラウザのアドレス欄を見ます。`stagingProfiles;`のあとの16進数が`ステージングプロファイルId`になります。\r\n\r\n![Imgur](https://imgur.com/z9PU7tD.png)\r\n\r\n# 公開するぞ！！！！\r\nといっても直接`MavenCentral`に公開されるわけではなく、一旦`Sonatype OSSRH`の`nexus repository manager`へアップロードされます。  \r\nその後問題がなければ公開という流れになります。\r\n\r\nAndroid Studioの右側にある`Gradle`を押してぞうさんのマーク🐘を押して、以下のコマンドを叩きます。  \r\n参考にした記事とコマンドが変わってますね。\r\nhttps://github.com/gradle-nexus/publish-plugin\r\n\r\n```\r\ngradle :ライブラリ名(モジュール名):publishToSonatype\r\n```\r\n\r\n![Imgur](https://imgur.com/d5Stw0C.png)\r\n\r\n数十秒後に終了しました。  \r\nプラグイン作ったやつすげえ！\r\n\r\n![Imgur](https://imgur.com/OCI1AHS.png)\r\n\r\n# Sonatype OSSRH nexus repository manager の ステージングリポジトリを見に行く\r\n\r\nまたさっきのリポジトリのURL https://s01.oss.sonatype.org/ を開いて、`Staging Repositories`を押します。\r\n押したら、`Refresh`を押して最新の状態にしましょう。\r\n\r\nどうですか？ありましたか！？\r\n\r\n![Imgur](https://imgur.com/QQk5ikQ.png)\r\n\r\n問題がなければ**Close**を、やり直したい場合は**Drop**で消せます。  \r\n\r\n## Close を押す\r\n`Close`を押すと、MavenCentralへ公開する？準備が始まります。  \r\n自動で公開されるわけではないので、まだ安心できますね。\r\n\r\n![Imgur](https://imgur.com/omkAFZU.png)\r\n\r\nしばらく待っていると**Release**が押せるようになっていました。  \r\nいくぞおおおおお、新曲！\r\n\r\n![Imgur](https://imgur.com/EdiIqLW.png)\r\n\r\n`Confirm`を押してリリースです！\r\n\r\n![Imgur](https://imgur.com/Ys8HBSc.png)\r\n\r\n数時間後に https://repo1.maven.org/maven2/ から見れるようになるみたいなので楽しみですね。\r\n\r\n# 公開されたか見る\r\nhttps://repo1.maven.org/maven2/ を開いて辿っていけばいいです。 \r\nあった！！！\r\n\r\n![Imgur](https://imgur.com/b38RD5W.png)\r\n\r\n## search.maven.org でも確認する\r\nさらに待ってると、 https://search.maven.org で検索出来るようになってます。\r\n\r\n![Imgur](https://imgur.com/v02mUI0.png)\r\n\r\n\r\nうおおおお、なんかすごい\r\n\r\n![Imgur](https://imgur.com/0IIme8l.png)\r\n\r\nライブラリの詳細画面はこんな感じ、導入方法とか書いてある。\r\n\r\n![Imgur](https://imgur.com/KTPtKXR.png)\r\n\r\n# 使う側になる\r\n\r\nプロジェクトレベル(appフォルダ内)の`build.gradle`に書き足すと追加できます。やったぜ\r\n\r\n```\r\nimplementation '<グループId>:<ライブラリ名（アーティファクトId）>:<バージョン>'\r\n```\r\n\r\n今回作ったライブラリだとこうですね。\r\n\r\n```java\r\n// build.gradle\r\nimplementation 'io.github.takusan23:conecocore:1.0.0'\r\n\r\n// build.gradle.kts の場合\r\nimplementation(\"io.github.takusan23:conecocore:1.0.0\")\r\n```\r\n\r\nこれで他の大手ライブラリのように導入できます。くっそ大変だなこれ...\r\n\r\n![Imgur](https://imgur.com/qek6dbP.png)\r\n\r\n~~(なんか別にドキュメントを生成しないとダメみたいですね...)~~\r\n\r\nライブラリを入れた際に一緒に`XXX-sources.jar`がダウンロードされるので、IDE上でもそのまま表示されるようになります。  \r\n\r\n![Imgur](https://imgur.com/AwCm0Oh.png)\r\n\r\n![Imgur](https://imgur.com/RuVmcSf.png)\r\n\r\n# 他にライブラリを公開したい場合\r\nすでにリポジトリがある(Sonatype OSSRH nexus repository manager が使える)ので、`build.gradle.kts`のところからやればいいと思います。\r\n\r\n# ソースコード\r\nどうぞ\r\n\r\nhttps://github.com/takusan23/Coneco\r\n\r\n# おわりに\r\n\r\n4月も終わりますね..."},{"title":"AndroidのMediaCodecを利用して複数の動画を繋げて一つの動画にする","link":"/posts/android_mediacodec_merge_video/","markdown":"どうもこんばんわ。  \r\nアイカギ2 攻略しました。<span style=\"font-size:10px\">声優買いだったけど</span>予想以上で面白かったです。  \r\nずーーーっとかわいかった。\r\n\r\n![Imgur](https://imgur.com/SBK2sis.png)\r\n\r\n![Imgur](https://imgur.com/PC8tXYN.png)\r\n\r\n![Imgur](https://imgur.com/wPFTJ6b.png)\r\n\r\nかわいい\r\n\r\n# 本題\r\nHLS形式の動画って`MPEG2-TS セグメント`が複数流れてくるんだけど、これ一つの`mp4`とかにできないのかって話。  \r\n複数の動画って言ってるけどコーデックとかフォーマットが同じ場合に限るけど...\r\n\r\n### 番外編 FFmpeg でよくない？\r\nGPL「やあ！」  \r\nライセンス問題もあるっちゃあるけど、それよりアプリのサイズがデカくなりそう...\r\n\r\n### 番外編 MediaCodecの使い方の例が見たかったんだけど検索妨害するの辞めない？\r\nhttps://github.com/takusan23/MediaCodecDecode  \r\nのブランチに音声、映像それぞれをMediaCodecを利用してデコードするサンプルがあります。チラシの裏的な感じでどうぞ...  \r\n(`masterブランチ`以外で作業してたせいでGitHubの草が生えてないよ...；；)\r\n\r\n- 動画をデコードしてSurfaceViewへレンダリングする\r\n    - https://github.com/takusan23/MediaCodecDecode/blob/video-decode/app/src/main/java/io/github/takusan23/mediacodecdecode/MainActivity.kt\r\n- 動画をデコードしてAudioTarckで音声を再生する\r\n    - https://github.com/takusan23/MediaCodecDecode/blob/audio-decode/app/src/main/java/io/github/takusan23/mediacodecdecode/MainActivity.kt\r\n\r\n## 多分読まなくていい 動画フォーマット の話\r\n多分基礎的な話なので見なくて良き。というかあってるか分からない；；\r\n\r\n### コンテナフォーマット\r\n`MPEG2-TS`とか`mp4`とかはコンテナフォーマットであり、音声・映像をぞれぞれしまっておくものです。（多分）  \r\n上記2つのコンテナフォーマットなら、映像（H.264が多い？）と音声（AACが多い？）を入れます。\r\n\r\nAndroidだと`MediaExtractor`、`MediaMuxer`あたりで触ります。\r\n\r\n### コーデック\r\nエンコード、デコードの種類。  \r\n映像ならH.264（AVC）とかH.265（HEVC）のこと。  \r\n音声ならAACとか？\r\n\r\nAndroidでは`MediaCodec`で触りますね\r\n\r\nこう書いてみると、FFmpegってこの辺よくわからんくても適当にやってくれてたんやなあ...\r\n\r\n### HLS\r\nApple様が作った映像をごまぎれにして送る技術。ライブ配信とか暗号化したい動画の場合に使ってるとかなんとか。  \r\n\r\n超絶どうでもいいけど、AppleのWWDCって昔はAppleデバイスじゃないと見れなかった（昔はブラウザの中でもHLSに対応してるのはAppleのSafariだけだった？）  \r\nなのでWindows/AndroidユーザーはVLCにWWDCのHLSアドレスを入れて見てたような。  \r\nその後、今は無いけどEdgeHTMLなEdgeでHLSが（Apple Safari以外のブラウザとしては初？）サポートされて、Appleデバイス or Windows 10 のEdgeブラウザで見れるようになったような。  \r\n今日はモダンブラウザで見れるほか、Apple公式がようつべにミラーしてるのでいい時代になりましたね←？？？\r\n\r\n# 環境\r\n実機がおすすめです。\r\n\r\n| なまえ           | あたい                                         |\r\n|------------------|------------------------------------------------|\r\n| 端末             | Pixel 3 XL / Xperia 5 Ⅱ / Xiaomi Mi 11 Lite 5G |\r\n| SoC (Snapdragon) | SDM 845 / SDM 865 / SDM 780G                   |\r\n| Android          | 12 / 11 / 11                                   |\r\n| 言語             | Kotlin                                         |\r\n\r\n# 本日のメイン MediaCodec \r\nhttps://developer.android.com/reference/android/media/MediaCodec\r\n\r\n扱いがとても難しい。公式リファレンスも長い説明があるけど分からんということがわかる。  \r\n各メソッドは最終的にC言語で書かれたコードにたどり着くらしい、何も分からん。\r\n\r\n## 登場人物\r\n\r\n- MediaFormat\r\n- MediaExtractor\r\n- MediaMuxer\r\n- MediaCodec\r\n\r\n### MediaFormat\r\n映像、音声のメタデータを入れる。ビットレート、フレームレートなど。  \r\nこれを`MediaCodec`や`MediaMuxer`へ渡す。  \r\nでも動画の情報なんて分からんので、`MediaExtractor`を利用してMediaFormatを取得してから作るのがいい？\r\n\r\n```kotlin\r\nval videoMediaFormat = // MediaExtractorの説明で...\r\n\r\nval height = videoMediaFormat?.getInteger(MediaFormat.KEY_HEIGHT) ?: 720\r\nval width = videoMediaFormat?.getInteger(MediaFormat.KEY_WIDTH) ?: 1280\r\nval encoderMediaFormat = MediaFormat.createVideoFormat(ENCODE_MIME_TYPE, width, height).apply {\r\n    setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, INPUT_BUFFER_SIZE)\r\n    setInteger(MediaFormat.KEY_BIT_RATE, BIT_RATE)\r\n    setInteger(MediaFormat.KEY_FRAME_RATE, 30)\r\n    setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)\r\n    setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n}\r\n```\r\n\r\n### MediaExtractor\r\n`MP4`、`MPEG2-TS`とかのコンテナフォーマットから、映像・音声のメタデータ(`MediaFormat`)を取り出したり、`MediaCodec`へ渡すデータを取り出す。  \r\n私もよく知らないんだけど、`MediaExtractor`から出てきた`MediaFormat`を直接`MediaCodec`へ渡すとコケる場合がある？  \r\nAndroidのファイルピッカー(Storage Access Framework)の結果(Uri、contentスキーム)の場合は多分受け付けないと思います（知らんけど）。  \r\nなので、ユーザーに選ばせた後、選択したUriがもらえるのでInputStreamを使い、一度アプリ内の固有ストレージにコピーする必要があると思います。\r\n\r\n```kotlin\r\n// MP4とかMPEG2-TSのファイルパスを渡す\r\nval extractor = MediaExtractor().apply { setDataSource(\"file:///\") }\r\n// 映像データのMediaFormatを取り出す\r\nval videoMediaFormat = (0 until extractor.trackCount) // [0,1] のような配列を作る\r\n    .map { extractor.getTrackFormat(it) } // [MediaFormat,MediaFormat] に変換する\r\n    .firstOrNull { it.getString(MediaFormat.KEY_MIME)?.startsWith(\"video/\") == true } // 配列の中からMIME_TYPEが video/ から始まるのを返す\r\n// 音声データのMediaFormat\r\nval audioMediaFormat = (0 until extractor.trackCount)\r\n    .map { extractor.getTrackFormat(it) }\r\n    .firstOrNull { it.getString(MediaFormat.KEY_MIME)?.startsWith(\"audio/\") == true }\r\n\r\n// MediaCodecへデータを渡す\r\nval inputBuffer = decodeMediaCodec.getInputBuffer(inputBufferId)!!\r\nval size = extractor.readSampleData(inputBuffer, 0)\r\n\r\n// 使い終わったら\r\nextractor.release()\r\n```\r\n\r\n#### Uriコピー例\r\n今回の話ではないので適当に...\r\n\r\n```kotlin\r\n// Uriだと...\r\nval uri = // ファイルピッカーの結果\r\nval inputStream = contentResolver.openInputStream(uri)!!\r\n// 固有ストレージにコピー\r\nval tempFile = File(getExternalFilesDir(null), \"copy.mp4\")\r\ntempFile.createNewFile()\r\ntempFile.writeBytes(inputStream.readBytes()) // もし2GBを超えるなら使えない\r\ninputStream.close()\r\nval filePath = tempFile.path // file スキーム\r\n```\r\n\r\n### MediaMuxer\r\n`MediaCodec`でエンコードされた映像、音声をMP4とかのコンテナフォーマットへ格納する。  \r\n`MediaMuxer`へ渡す`MediaFormat`は`MediaCodec#getOutputFormat()`とか`MediaExtractor#getTrackFormat()`で貰えるやつじゃないと失敗する？（コーデック固有データが無いとかで）  \r\n参考：https://stackoverflow.com/questions/19505845/mediamuxer-error-failed-to-stop-the-muxer\r\n\r\n```kotlin\r\n// 映像MediaFormat\r\nval videoMediaFormat = // 上で書いたので省略...\r\n// MediaMuxer作成\r\nval mediaMuxer = MediaMuxer(mergedFile.path, OUTPUT_CONATINER_FORMAT)\r\n// 映像トラック追加\r\nval videoTrackIndex = mediaMuxer.addTrack(videoMediaFormat) // ここで入れるMediaFormatはMediaCodec#getOutputFormat()で貰えるのを入れると確実？\r\nmediaMuxer.start()\r\n\r\n// MediaCodecの結果を書き込む...\r\nmediaMuxer.writeSampleData(videoTrackIndex, /* outputBuffer, outputBufferInfo */)\r\n\r\n// 後片付け\r\nmediaMuxer.stop()\r\nmediaMuxer.release()\r\n```\r\n\r\n### MediaCodec\r\nエンコードされた映像・音声をデコードする、もしくはその逆をする。  \r\n非同期モードと同期モードがあるけどどっちがいいんだろう。今回は同期モードで書きます。  \r\nAOSPのソース覗いたけど、Android 11から搭載された内部音声と画面録画を合成する部分でも同期モードなMediaCodecを使ってた  \r\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/base/packages/SystemUI/src/com/android/systemui/screenrecord/ScreenInternalAudioRecorder.java;l=234?q=internalaudio\r\n\r\n別スレッド必須です。\r\n\r\n```kotlin\r\n// デコード用（H.264 -> 生データ）MediaCodec\r\nval decodeMediaCodec = MediaCodec.createDecoderByType(\"video/avc\").apply {\r\n    configure(decoderMediaFormat, null, null, 0)\r\n    start()\r\n}\r\n// メタデータ格納用\r\nval decoderBufferInfo = MediaCodec.BufferInfo()\r\nwhile (true) {\r\n    // デコーダー部分\r\n    val inputBufferId = decodeMediaCodec.dequeueInputBuffer(TIMEOUT_US)\r\n    if (inputBufferId >= 0) {\r\n        // Extractorからデータを読みだす\r\n        val inputBuffer = decodeMediaCodec.getInputBuffer(inputBufferId)!!\r\n        val size = mediaExtractor.readSampleData(inputBuffer, 0)\r\n        if (size > 0) {\r\n            // デコーダーへ流す\r\n            decodeMediaCodec.queueInputBuffer(inputBufferId, 0, size, mediaExtractor.sampleTime, 0)\r\n            mediaExtractor.advance()\r\n        } else {\r\n            // データなくなった場合は終了\r\n            decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n            // 開放\r\n            mediaExtractor.release()\r\n            // 終了\r\n            break\r\n        }\r\n    }\r\n    // デコード結果\r\n    val outputBufferId = decodeMediaCodec.dequeueOutputBuffer(decoderBufferInfo, TIMEOUT_US)\r\n    if (outputBufferId >= 0) {\r\n        // デコード結果をもらう\r\n        // 返す\r\n        decodeMediaCodec.releaseOutputBuffer(outputBufferId, true)\r\n    }\r\n}\r\n```\r\n\r\n# これらを踏まえて複数の動画を繋げたい\r\n\r\n## 音声\r\n音声の場合は、動画ファイルを`MediaExtractor`へ入れて、データを`MediaCodec`へ突っ込みます。  \r\n生データが出てくるので、これを一旦適当なファイルを作り書き込んでおきます。  \r\nこれを結合したい動画全てで繰り返します。デコード結果が先程の適当なファイルにまとまっているように。  \r\n\r\nそのあと、エンコード用の`MediaCodec`を作り先程の適当なファイルに書き込んでおいたデータを突っ込みます。  \r\nするとエンコードされたデータが出てくるので、`MediaMuxer`へ渡します。\r\n\r\nこれでなんか動いてる。なんでだろう\r\n\r\nあと割と時間がかかりますこれ...\r\n\r\n![Imgur](https://imgur.com/qCxBbMW.png)\r\n\r\n## 映像\r\n映像の場合、音声のように一時的に生（意味深）データを外出し（意味深）しておく方法が使えないと思います。映像の生データとかデカすぎでヤバそう。  \r\nなので代わりに、エンコーダーの入力用`Surface`へデコード結果を書き込む方法を使います。  \r\n\r\nデコーダーの設定時にエンコーダーの`Surface`を指定しておきます。  \r\n結合したい動画を順次`MediaExtractor`で読み出して、デコーダーへ流します。  \r\nファイルが読み終わったら次の動画にしてまたデコーダーへ流してあげます。これを無くなるまでやります。\r\n\r\nそれで`Surface`へ映像が流れてくるので、エンコーダーで受け取り`MediaMuxer`へ渡します。  \r\n本来は`Surface`を指定する部分に`SurfaceView`の`Surface`を入れて映像を出力するんだと思う。\r\n\r\n![Imgur](https://imgur.com/BlWU5jP.png)\r\n\r\nちなみに形式が異なる場合は無理だと思います。OpenGLとかが出来れば別だと思う\r\n\r\n## 音声と映像をコンテナフォーマットへ格納\r\n`MediaExtractor`で取り出して、`MediaMuxer`に入れればOK\r\n\r\n![Imgur](https://imgur.com/QV1cYdL.png)\r\n\r\n# 実際に作ってみた！\r\n攻略のカギは、`presentationTime`にあります！(フレームの時間をセットするやつ)  \r\n(前回の動画の位置を足していく)\r\n\r\n## 予めデータを入れておく\r\n今回は、予めアプリ固有ストレージ（`getExternalFilesDir(null)`）のところに動画を入れておきます。  \r\nHLSを想定して、`FFmpeg`で`.ts`ファイルへ変換して転送します。  \r\n命名規則は ファイル名+番号+拡張子 で、あとで配列にする際に正規表現で取り出して数字の小さい順に並べ替えられるようにしてます。 \r\n\r\nファイルピッカーとかで選ばせたいけど長くなるのでカットで...\r\n\r\n`io.github.takusan23.～`の部分は各自違うと思う...\r\n\r\n![Imgur](https://imgur.com/qLPsuYH.png)\r\n\r\n### ちなみに\r\nAndroid標準のファイラーだと、`Android/data`が端末でも見れます。\r\n\r\n## 音声部分\r\n音声データを結合するクラスを書きました。  \r\n説明はコメントに書いておきました。  \r\n`setInteger`、`setLong`はちゃんと選ばないとだめです。  \r\n`getInteger`の値がない場合は代わりを指定したほうがいいと思います（でも`getInteger`のデフォルト値指定付きメソッドがAndroid 10以降だった...）  \r\n\r\nなんか`MediaExtractor`でもらえる`MediaFormat`経由でビットレートも取得できるはずですが、なんかゴミみたいな音質だったので引数に取るようにした。 \r\n\r\n```kotlin\r\n/**\r\n * 音声データを結合する\r\n *\r\n * @param videoList 結合する動画、音声ファイルの配列。入っている順番どおりに結合します。\r\n * @param mergeFilePath 結合したファイルの保存先\r\n * @param tempRawDataFile 一時的ファイル保存先\r\n * @param bitRate ビットレート。なんかゴミみたいな音質だった...\r\n * */\r\nclass AudioDataMerge(\r\n    videoList: List<File>,\r\n    private val mergeFilePath: File,\r\n    private val tempRawDataFile: File,\r\n    private val bitRate: Int = 192_000,\r\n) {\r\n\r\n    /** タイムアウト */\r\n    private val TIMEOUT_US = 10000L\r\n\r\n    /** MediaCodecでもらえるInputBufferのサイズ */\r\n    private val INPUT_BUFFER_SIZE = 655360\r\n\r\n    /** 結合する動画の配列のイテレータ */\r\n    private val videoListIterator = videoList.listIterator()\r\n\r\n    /** 一時ファイル保存で使う */\r\n    private val bufferedOutputStream by lazy { tempRawDataFile.outputStream().buffered() }\r\n\r\n    /** 一時ファイル読み出しで使う */\r\n    private val bufferedInputStream by lazy { tempRawDataFile.inputStream().buffered() }\r\n\r\n    /** ファイル合成 */\r\n    private val mediaMuxer by lazy { MediaMuxer(mergeFilePath.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) }\r\n\r\n    /** 取り出した[MediaFormat] */\r\n    private var currentMediaFormat: MediaFormat? = null\r\n\r\n    /** 現在進行中の[MediaExtractor] */\r\n    private var currentMediaExtractor: MediaExtractor? = null\r\n\r\n    /** エンコード用 [MediaCodec] */\r\n    private var encodeMediaCodec: MediaCodec? = null\r\n\r\n    /** デコード用 [MediaCodec] */\r\n    private var decodeMediaCodec: MediaCodec? = null\r\n\r\n    /**\r\n     * 結合を開始する\r\n     *\r\n     * 同期処理になるので、別スレッドで実行してください\r\n     * */\r\n    fun merge() {\r\n\r\n        /**\r\n         * MediaExtractorで動画ファイルを読み出す\r\n         *\r\n         * @param path 動画パス\r\n         * */\r\n        fun extractVideoFile(path: String) {\r\n            // 動画の情報を読み出す\r\n            val (_mediaExtractor, index, format) = extractMedia(path, \"audio/\") ?: return\r\n            currentMediaExtractor = _mediaExtractor\r\n            currentMediaFormat = format\r\n            // 音声のトラックを選択\r\n            currentMediaExtractor?.selectTrack(index)\r\n        }\r\n\r\n        // 最初の動画を解析\r\n        extractVideoFile(videoListIterator.next().path)\r\n\r\n        // 解析結果から各パラメータを取り出す\r\n        val mimeType = currentMediaFormat?.getString(MediaFormat.KEY_MIME)!! // AACなら audio/mp4a-latm\r\n        val samplingRate = currentMediaFormat?.getInteger(MediaFormat.KEY_SAMPLE_RATE)!! // 44100\r\n        val channelCount = currentMediaFormat?.getInteger(MediaFormat.KEY_CHANNEL_COUNT)!! // 2\r\n\r\n        // エンコーダーにセットするMediaFormat\r\n        val audioMediaFormat = MediaFormat.createAudioFormat(mimeType, samplingRate, channelCount).apply {\r\n            setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n            setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, INPUT_BUFFER_SIZE)\r\n            setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC)\r\n        }\r\n\r\n        // 音声を追加してトラック番号をもらう\r\n        // 多分 addTrack する際は MediaExtractor 経由で取得した MediaFormat を入れないといけない？\r\n        val audioTrackIndex = mediaMuxer.addTrack(currentMediaFormat!!)\r\n\r\n        // デコード用（aac -> 生データ）MediaCodec\r\n        decodeMediaCodec = MediaCodec.createDecoderByType(mimeType).apply {\r\n            // デコード時は MediaExtractor の MediaFormat で良さそう\r\n            configure(currentMediaFormat!!, null, null, 0)\r\n        }\r\n        // エンコード用（生データ -> aac）MediaCodec\r\n        encodeMediaCodec = MediaCodec.createEncoderByType(mimeType).apply {\r\n            configure(audioMediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n\r\n        // nonNull\r\n        val decodeMediaCodec = decodeMediaCodec!!\r\n        val encodeMediaCodec = encodeMediaCodec!!\r\n        // スタート\r\n        decodeMediaCodec.start()\r\n        encodeMediaCodec.start()\r\n        mediaMuxer.start()\r\n\r\n        // 再生位置など\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n\r\n        /**\r\n         * データを順次読み出して、[MediaCodec]で生データへ変換する。\r\n         * 変換した生データは[tempRawDataFile]へ一時的に入れる。\r\n         * */\r\n        var totalPresentationTime = 0L\r\n        var prevPresentationTime = 0L\r\n        while (true) {\r\n            // もし -1 が返ってくれば configure() が間違ってる\r\n            val inputBufferId = decodeMediaCodec.dequeueInputBuffer(TIMEOUT_US)\r\n            if (inputBufferId >= 0) {\r\n                // Extractorからデータを読みだす\r\n                val inputBuffer = decodeMediaCodec.getInputBuffer(inputBufferId)!!\r\n                val size = currentMediaExtractor!!.readSampleData(inputBuffer, 0)\r\n                if (size > 0) {\r\n                    // デコーダーへ流す\r\n                    decodeMediaCodec.queueInputBuffer(inputBufferId, 0, size, currentMediaExtractor!!.sampleTime + totalPresentationTime, 0)\r\n                    currentMediaExtractor!!.advance()\r\n                    // 一個前の動画の動画サイズを控えておく\r\n                    // else で extractor.sampleTime すると既に-1にっているので\r\n                    if (currentMediaExtractor!!.sampleTime != -1L) {\r\n                        prevPresentationTime = currentMediaExtractor!!.sampleTime\r\n                    }\r\n                } else {\r\n                    totalPresentationTime += prevPresentationTime\r\n                    // データがないので次データへ\r\n                    if (videoListIterator.hasNext()) {\r\n                        // 次データへ\r\n                        val file = videoListIterator.next()\r\n                        // 多分いる\r\n                        decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, 0)\r\n                        // 動画の情報を読み出す\r\n                        currentMediaExtractor!!.release()\r\n                        extractVideoFile(file.path)\r\n                    } else {\r\n                        // データなくなった場合は終了フラグを立てる\r\n                        decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n                        // 開放\r\n                        currentMediaExtractor!!.release()\r\n                        // 終了\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            /**\r\n             * デコード結果を受け取って、一時的に保存する\r\n             * */\r\n            val outputBufferId = decodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n            if (outputBufferId >= 0) {\r\n                // デコード結果をもらう\r\n                val outputBuffer = decodeMediaCodec.getOutputBuffer(outputBufferId)!!\r\n                // 生データを一時的に保存する\r\n                val chunk = ByteArray(bufferInfo.size)\r\n                outputBuffer[chunk]\r\n                bufferedOutputStream.write(chunk)\r\n                // 消したほうがいいらしい\r\n                outputBuffer.clear()\r\n                // 返却\r\n                decodeMediaCodec.releaseOutputBuffer(outputBufferId, false)\r\n            }\r\n        }\r\n\r\n        // Xiaomi端末で落ちたので例外処理\r\n        try {\r\n            // デコーダー終了\r\n            decodeMediaCodec.stop()\r\n            decodeMediaCodec.release()\r\n            bufferedOutputStream.close()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n\r\n        // 読み出し済みの位置と時間\r\n        var totalBytesRead = 0\r\n        var presentationTime = 0L\r\n\r\n        /**\r\n         * 一時的に保存したファイルを読み出して、エンコーダーに入れる。\r\n         * エンコード結果を[MediaMuxer]へ入れて完成。\r\n         * */\r\n        while (true) {\r\n            val inputBufferId = encodeMediaCodec.dequeueInputBuffer(TIMEOUT_US)\r\n            if (inputBufferId >= 0) {\r\n                // デコードした生データをエンコーダーへ渡す\r\n                val inputBuffer = encodeMediaCodec.getInputBuffer(inputBufferId)!!\r\n                val buffer = ByteArray(inputBuffer.capacity())\r\n                val size = bufferedInputStream.read(buffer)\r\n                // エンコーダーへ渡す\r\n                if (size > 0) {\r\n                    // 書き込む。書き込んだデータは[onOutputBufferAvailable]で受け取れる\r\n                    inputBuffer.put(buffer, 0, size)\r\n                    encodeMediaCodec.queueInputBuffer(inputBufferId, 0, size, presentationTime, 0)\r\n                    totalBytesRead += size\r\n                    // あんまり分からん\r\n                    presentationTime = 1000000L * (totalBytesRead / (channelCount * 2)) / samplingRate\r\n                } else {\r\n                    // 終了\r\n                    encodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n                }\r\n            }\r\n            // デコーダーから生データを受け取る\r\n            val outputBufferId = encodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n            if (outputBufferId >= 0) {\r\n                // デコード結果をもらう\r\n                val outputBuffer = encodeMediaCodec.getOutputBuffer(outputBufferId)!!\r\n                if (bufferInfo.size > 0) {\r\n                    // 書き込む\r\n                    mediaMuxer.writeSampleData(audioTrackIndex, outputBuffer, bufferInfo)\r\n                    // 返却\r\n                    encodeMediaCodec.releaseOutputBuffer(outputBufferId, false)\r\n                } else {\r\n                    // もう無い！\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n        // Xiaomi端末で落ちたので例外処理\r\n        try {\r\n            // エンコーダー終了\r\n            encodeMediaCodec.stop()\r\n            encodeMediaCodec.release()\r\n            bufferedInputStream.close()\r\n\r\n            // MediaMuxerも終了\r\n            // MediaMuxer#stopでコケる場合、大体MediaFormatのパラメータ不足です。\r\n            // MediaExtractorで出てきたFormatを入れると直ると思います。\r\n            mediaMuxer.stop()\r\n            mediaMuxer.release()\r\n\r\n            // 一時ファイルの削除\r\n            tempRawDataFile.delete()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    /** 強制終了時に呼ぶ */\r\n    fun stop() {\r\n        decodeMediaCodec?.stop()\r\n        decodeMediaCodec?.release()\r\n        bufferedOutputStream.close()\r\n        encodeMediaCodec?.stop()\r\n        encodeMediaCodec?.release()\r\n        bufferedInputStream.close()\r\n        currentMediaExtractor?.release()\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n        tempRawDataFile.delete()\r\n    }\r\n\r\n    /**\r\n     * 引数に渡した動画パス[videoPath]の情報を[MediaExtractor]で取り出す\r\n     *\r\n     * @param mimeType 音声なら audio/ 動画なら video/\r\n     * @param videoPath 動画の動画パス\r\n     * */\r\n    private fun extractMedia(videoPath: String, mimeType: String): Triple<MediaExtractor, Int, MediaFormat>? {\r\n        val mediaExtractor = MediaExtractor().apply { setDataSource(videoPath) }\r\n        val (index, track) = (0 until mediaExtractor.trackCount)\r\n            .map { index -> index to mediaExtractor.getTrackFormat(index) }\r\n            .firstOrNull { (_, track) -> track.getString(MediaFormat.KEY_MIME)?.startsWith(mimeType) == true } ?: return null\r\n        return Triple(mediaExtractor, index, track)\r\n    }\r\n\r\n}\r\n```\r\n\r\n### MainActivity.kt\r\n\r\n```kotlin\r\n/**\r\n * 動画保存先\r\n *\r\n * /sdcard/Android/data/{パッケージId}/files/video\r\n * */\r\nclass MainActivity : AppCompatActivity() {\r\n    /** 動画ファイルがあるフォルダ名 */\r\n    private val FOLDER_NAME = \"bakkure\"\r\n\r\n    /** ファイル名 */\r\n    private val MERGE_FILE_NAME = \"merged.aac\"\r\n\r\n    /** 一時ファイルの名前 */\r\n    private val TEMP_RAW_DATA_FILE_NAME = \"temp_raw_data\"\r\n\r\n    /** 音声くっつけるやつ */\r\n    private lateinit var audioDataMerge: AudioDataMerge\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // 結合したい動画ファイルが置いてあるフォルダ\r\n        val videoFolder = File(getExternalFilesDir(null), FOLDER_NAME).apply {\r\n            if (!exists()) {\r\n                mkdir()\r\n            }\r\n        }\r\n\r\n        // 最終的に結合するファイル\r\n        val mergedFile = File(getExternalFilesDir(null), MERGE_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 音声だけの生データをおいておくファイル\r\n        val tempRawDataFile = File(getExternalFilesDir(null), TEMP_RAW_DATA_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 数字を見つける正規表現\r\n        val numberRegex = \"(\\\\d+)\".toRegex()\r\n        // 結合する動画ファイルを配列\r\n        val videoList = videoFolder.listFiles()\r\n            // ?.filter { it.extension == \"ts\" } // これ動画ファイル以外が入ってくる場合はここで見切りをつける\r\n            ?.toList()\r\n            ?.sortedBy { numberRegex.find(it.name)?.groupValues?.get(0)?.toIntOrNull() ?: 0 } // 数字の若い順にする\r\n\r\n        // インスタンス作成\r\n        audioDataMerge = AudioDataMerge(videoList!!, mergedFile, tempRawDataFile)\r\n\r\n        // 別スレッドを起動して開始\r\n        // コルーチンとかを使うべきです...\r\n        thread {\r\n            val startMs = System.currentTimeMillis()\r\n            showMessage(\"開始：$startMs\")\r\n            audioDataMerge.merge()\r\n            showMessage(\"終了：${System.currentTimeMillis() - startMs} Ms\")\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        audioDataMerge.stop()\r\n    }\r\n\r\n    private fun showMessage(message: String) {\r\n        println(message)\r\n        runOnUiThread { Toast.makeText(this@MainActivity, message, Toast.LENGTH_SHORT).show() }\r\n    }\r\n}\r\n```\r\n\r\n## 映像部分\r\n映像データをSurfaceへ描画して結合するクラスを書きました。  \r\n説明はコメントに書いておきました。  \r\n緑で出力された場合はMediaFormatのコーデック固有のパラメーターがおかしいかも。(csd-1,csd-0 とか？)  \r\nなんか動かない場合は、解像度は16の倍数であるか確認するといいのかも？\r\n- 1280 x 720\r\n    - 余り出ない\r\n- 720 x 480\r\n    - 余り出ない\r\n- 640 x 360\r\n    - 360 / 16 で余りが出るので、割り切れる 368 にする必要がある\r\n\r\n```kotlin\r\n/**\r\n * 映像データを結合する\r\n *\r\n * @param videoList 結合する動画、音声ファイルの配列。入っている順番どおりに結合します。\r\n * @param mergeFilePath 結合したファイルの保存先\r\n * @param bitRate ビットレート。何故か取れなかった\r\n * @param frameRate フレームレート。何故か取れなかった\r\n * */\r\nclass VideoDataMerge(\r\n    videoList: List<File>,\r\n    private val mergeFilePath: File,\r\n    private val bitRate: Int = 1_000_000, // 1Mbps\r\n    private val frameRate: Int = 30, // 30fps\r\n) {\r\n\r\n    /** タイムアウト */\r\n    private val TIMEOUT_US = 10000L\r\n\r\n    /** MediaCodecでもらえるInputBufferのサイズ */\r\n    private val INPUT_BUFFER_SIZE = 655360\r\n\r\n    /** 結合する動画の配列のイテレータ */\r\n    private val videoListIterator = videoList.listIterator()\r\n\r\n    /** ファイル合成 */\r\n    private val mediaMuxer by lazy { MediaMuxer(mergeFilePath.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4) }\r\n\r\n    /** 取り出した[MediaFormat] */\r\n    private var currentMediaFormat: MediaFormat? = null\r\n\r\n    /** 現在進行中の[MediaExtractor] */\r\n    private var currentMediaExtractor: MediaExtractor? = null\r\n\r\n    /** エンコード用 [MediaCodec] */\r\n    private var encodeMediaCodec: MediaCodec? = null\r\n\r\n    /** デコード用 [MediaCodec] */\r\n    private var decodeMediaCodec: MediaCodec? = null\r\n\r\n    /** エンコーダーとデコーダーの橋渡しをするSurface */\r\n    private var encoderSurface: Surface? = null\r\n\r\n    /**\r\n     * 結合を開始する\r\n     *\r\n     * 同期処理になるので、別スレッドで実行してください\r\n     * */\r\n    fun merge() {\r\n        /**\r\n         * MediaExtractorで動画ファイルを読み出す\r\n         *\r\n         * @param path 動画パス\r\n         * */\r\n        fun extractVideoFile(path: String) {\r\n            // 動画の情報を読み出す\r\n            val (_mediaExtractor, index, format) = extractMedia(path, \"video/\") ?: return\r\n            currentMediaExtractor = _mediaExtractor\r\n            currentMediaFormat = format\r\n            // 音声のトラックを選択\r\n            currentMediaExtractor?.selectTrack(index)\r\n            currentMediaExtractor?.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC)\r\n        }\r\n\r\n        // 最初の動画を解析\r\n        extractVideoFile(videoListIterator.next().path)\r\n\r\n        // 解析結果から各パラメータを取り出す\r\n        // 動画の幅、高さは16の倍数である必要があります。（どこに書いてんねんクソが）\r\n        val mimeType = currentMediaFormat?.getString(MediaFormat.KEY_MIME)!! // video/avc\r\n        val width = currentMediaFormat?.getInteger(MediaFormat.KEY_WIDTH)!! // 1280\r\n        val height = currentMediaFormat?.getInteger(MediaFormat.KEY_HEIGHT)!! // 720\r\n\r\n        // エンコーダーにセットするMediaFormat\r\n        val videoMediaFormat = MediaFormat.createVideoFormat(mimeType, width, height).apply {\r\n            setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, INPUT_BUFFER_SIZE)\r\n            setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n            setInteger(MediaFormat.KEY_FRAME_RATE, frameRate)\r\n            setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)\r\n            setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n        }\r\n\r\n        // 後に映像トラックのトラック番号が入る\r\n        // encodeMediaCodec.outputFormat を MediaMuxer へ渡す\r\n        var videoTrackIndex = NO_INDEX_VALUE\r\n\r\n        // エンコード用（生データ -> H.264）MediaCodec\r\n        encodeMediaCodec = MediaCodec.createEncoderByType(mimeType).apply {\r\n            configure(videoMediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n\r\n        // エンコーダーのSurfaceを取得\r\n        // デコーダーの出力Surfaceの項目にこれを指定して、エンコーダーに映像データがSurface経由で行くようにする\r\n        encoderSurface = encodeMediaCodec!!.createInputSurface()\r\n\r\n        // デコード用（H.264 -> 生データ）MediaCodec\r\n        decodeMediaCodec = MediaCodec.createDecoderByType(mimeType).apply {\r\n            // デコード時は MediaExtractor の MediaFormat で良さそう\r\n            configure(currentMediaFormat!!, encoderSurface, null, 0)\r\n        }\r\n\r\n        // nonNull\r\n        val decodeMediaCodec = decodeMediaCodec!!\r\n        val encodeMediaCodec = encodeMediaCodec!!\r\n        encodeMediaCodec.start()\r\n        decodeMediaCodec.start()\r\n\r\n        // 前回の動画ファイルを足した動画時間\r\n        var totalPresentationTime = 0L\r\n        var prevPresentationTime = 0L\r\n\r\n        // メタデータ格納用\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n\r\n        // ループ制御\r\n        var outputDone = false\r\n        var inputDone = false\r\n\r\n        /**\r\n         *  --- 複数ファイルを全てデコードする ---\r\n         * */\r\n        while (!outputDone) {\r\n            if (!inputDone) {\r\n\r\n                val inputBufferId = decodeMediaCodec.dequeueInputBuffer(TIMEOUT_US)\r\n                if (inputBufferId >= 0) {\r\n                    val inputBuffer = decodeMediaCodec.getInputBuffer(inputBufferId)!!\r\n                    val size = currentMediaExtractor!!.readSampleData(inputBuffer, 0)\r\n                    if (size > 0) {\r\n                        // デコーダーへ流す\r\n                        // 今までの動画の分の再生位置を足しておく\r\n                        decodeMediaCodec.queueInputBuffer(inputBufferId, 0, size, currentMediaExtractor!!.sampleTime + totalPresentationTime, 0)\r\n                        currentMediaExtractor!!.advance()\r\n                        // 一個前の動画の動画サイズを控えておく\r\n                        // else で extractor.sampleTime すると既に-1にっているので\r\n                        if (currentMediaExtractor!!.sampleTime != -1L) {\r\n                            prevPresentationTime = currentMediaExtractor!!.sampleTime\r\n                        }\r\n                    } else {\r\n                        totalPresentationTime += prevPresentationTime\r\n                        // データがないので次データへ\r\n                        if (videoListIterator.hasNext()) {\r\n                            // 次データへ\r\n                            val file = videoListIterator.next()\r\n                            // 多分いる\r\n                            decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, 0)\r\n                            // 動画の情報を読み出す\r\n                            currentMediaExtractor!!.release()\r\n                            extractVideoFile(file.path)\r\n                        } else {\r\n                            // データなくなった場合は終了\r\n                            decodeMediaCodec.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n                            // 開放\r\n                            currentMediaExtractor!!.release()\r\n                            // 終了\r\n                            inputDone = true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var decoderOutputAvailable = true\r\n            while (decoderOutputAvailable) {\r\n                // Surface経由でデータを貰って保存する\r\n                val encoderStatus = encodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (encoderStatus >= 0) {\r\n                    val encodedData = encodeMediaCodec.getOutputBuffer(encoderStatus)!!\r\n                    if (bufferInfo.size > 1) {\r\n                        if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                            // ファイルに書き込む...\r\n                            mediaMuxer.writeSampleData(videoTrackIndex, encodedData, bufferInfo)\r\n                        } else if (videoTrackIndex == NO_INDEX_VALUE) {\r\n                            // MediaMuxerへ映像トラックを追加するのはこのタイミングで行う\r\n                            // このタイミングでやると固有のパラメーターがセットされたMediaFormatが手に入る(csd-0 とか)\r\n                            // 映像がぶっ壊れている場合（緑で塗りつぶされてるとか）は多分このあたりが怪しい\r\n                            val newFormat = encodeMediaCodec.outputFormat\r\n                            videoTrackIndex = mediaMuxer.addTrack(newFormat)\r\n                            mediaMuxer.start()\r\n                        }\r\n                    }\r\n                    outputDone = bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0\r\n                    encodeMediaCodec.releaseOutputBuffer(encoderStatus, false)\r\n                }\r\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                    continue\r\n                }\r\n                // Surfaceへレンダリングする。\r\n                val outputBufferId = decodeMediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId == MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                    decoderOutputAvailable = false\r\n                } else if (outputBufferId >= 0) {\r\n                    val doRender = bufferInfo.size != 0\r\n                    decodeMediaCodec.releaseOutputBuffer(outputBufferId, doRender)\r\n                    if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {\r\n                        decoderOutputAvailable = false\r\n                        encodeMediaCodec.signalEndOfInputStream()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Xiaomi端末で落ちたので例外処理\r\n        try {\r\n            // デコーダー終了\r\n            decodeMediaCodec.stop()\r\n            decodeMediaCodec.release()\r\n            // Surface開放\r\n            encoderSurface?.release()\r\n            // エンコーダー終了\r\n            encodeMediaCodec.stop()\r\n            encodeMediaCodec.release()\r\n            // MediaMuxerも終了\r\n            mediaMuxer.stop()\r\n            mediaMuxer.release()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    /** 強制終了時に呼ぶ */\r\n    fun stop() {\r\n        decodeMediaCodec?.stop()\r\n        decodeMediaCodec?.release()\r\n        encoderSurface?.release()\r\n        encodeMediaCodec?.stop()\r\n        encodeMediaCodec?.release()\r\n        currentMediaExtractor?.release()\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n    }\r\n\r\n    /**\r\n     * 引数に渡した動画パス[videoPath]の情報を[MediaExtractor]で取り出す\r\n     *\r\n     * @param mimeType 音声なら audio/ 動画なら video/\r\n     * @param videoPath 動画の動画パス\r\n     * */\r\n    private fun extractMedia(videoPath: String, mimeType: String): Triple<MediaExtractor, Int, MediaFormat>? {\r\n        val mediaExtractor = MediaExtractor().apply { setDataSource(videoPath) }\r\n        val (index, track) = (0 until mediaExtractor.trackCount)\r\n            .map { index -> index to mediaExtractor.getTrackFormat(index) }\r\n            .firstOrNull { (_, track) -> track.getString(MediaFormat.KEY_MIME)?.startsWith(mimeType) == true } ?: return null\r\n        return Triple(mediaExtractor, index, track)\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** トラック番号が空の場合 */\r\n        const val NO_INDEX_VALUE = -100\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### MainActivity.kt\r\n音声とあんまり変わらん。  \r\nビットレート、フレームレートを調整したい場合は引数に渡せばいいと思います。\r\n\r\n```kotlin\r\n/**\r\n * 動画保存先\r\n *\r\n * /sdcard/Android/data/io.github.takusan23.androidmediacodecvideomerge/files/video\r\n * */\r\nclass MainActivity : AppCompatActivity() {\r\n    /** 動画ファイルがあるフォルダ名 */\r\n    private val FOLDER_NAME = \"bakkure\"\r\n\r\n    /** ファイル名 */\r\n    private val MERGE_FILE_NAME = \"merged.mp4\"\r\n\r\n    /** 映像くっつけるやつ */\r\n    private lateinit var videoDataMerge: VideoDataMerge\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // 結合したい動画ファイルが置いてあるフォルダ\r\n        val videoFolder = File(getExternalFilesDir(null), FOLDER_NAME).apply {\r\n            if (!exists()) {\r\n                mkdir()\r\n            }\r\n        }\r\n\r\n        // 最終的に結合するファイル\r\n        val mergedFile = File(getExternalFilesDir(null), MERGE_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 数字を見つける正規表現\r\n        val numberRegex = \"(\\\\d+)\".toRegex()\r\n        // 結合する動画ファイルを配列\r\n        val videoList = videoFolder.listFiles()\r\n            // ?.filter { it.extension == \"ts\" } // これ動画ファイル以外が入ってくる場合はここで見切りをつける\r\n            ?.toList()\r\n            ?.sortedBy { numberRegex.find(it.name)?.groupValues?.get(0)?.toIntOrNull() ?: 0 } // 数字の若い順にする\r\n\r\n        // インスタンス作成\r\n        videoDataMerge = VideoDataMerge(videoList!!, mergedFile, /*bitRate = 1_000_000, frameRate = 30*/)\r\n\r\n        // 別スレッドを起動して開始\r\n        // コルーチンとかを使うべきです...\r\n        thread {\r\n            val startMs = System.currentTimeMillis()\r\n            showMessage(\"開始：$startMs\")\r\n            videoDataMerge.merge()\r\n            showMessage(\"終了：${System.currentTimeMillis() - startMs} Ms\")\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        videoDataMerge.stop()\r\n    }\r\n\r\n    private fun showMessage(message: String) {\r\n        println(message)\r\n        runOnUiThread { Toast.makeText(this@MainActivity, message, Toast.LENGTH_SHORT).show() }\r\n    }\r\n}\r\n```\r\n\r\n## 音声と映像をコンテナフォーマットへ格納する\r\nこっからはそんなに難しくないです。  \r\nそれぞれを`MediaExtractor`で取り出して、そのまま`MediaMuxer`へ渡すだけです！\r\n\r\n```kotlin\r\n/**\r\n * 音声と映像をコンテナフォーマットへしまって一つの動画にする関数がある\r\n * */\r\nobject MergedDataMuxer {\r\n\r\n    /**\r\n     * コンテナフォーマットへ格納する\r\n     *\r\n     * @param resultFile 最終的なファイル\r\n     * @param mergeFileList コンテナフォーマットへ入れる音声、映像データの[File]\r\n     * */\r\n    @SuppressLint(\"WrongConstant\")\r\n    fun mixed(\r\n        resultFile: File,\r\n        mergeFileList: List<File>,\r\n    ) {\r\n        // 映像と音声を追加して一つの動画にする\r\n        val mediaMuxer = MediaMuxer(resultFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)\r\n\r\n        // 音声、映像ファイルの トラック番号 と [MediaExtractor] の Pair\r\n        val trackIndexToExtractorPairList = mergeFileList\r\n            .map {\r\n                // MediaExtractorとフォーマット取得\r\n                val mediaExtractor = MediaExtractor().apply { setDataSource(it.path) }\r\n                val mediaFormat = mediaExtractor.getTrackFormat(0) // 音声には音声、映像には映像しか無いので 0\r\n                mediaExtractor.selectTrack(0)\r\n                mediaFormat to mediaExtractor\r\n            }\r\n            .map { (format, extractor) ->\r\n                // フォーマットをMediaMuxerに渡して、トラックを追加してもらう\r\n                val videoTrackIndex = mediaMuxer.addTrack(format)\r\n                videoTrackIndex to extractor\r\n            }\r\n        // MediaMuxerスタート\r\n        mediaMuxer.start()\r\n        // 映像と音声を一つの動画ファイルに書き込んでいく\r\n        trackIndexToExtractorPairList.forEach { (index, extractor) ->\r\n            val byteBuffer = ByteBuffer.allocate(1024 * 4096)\r\n            val bufferInfo = MediaCodec.BufferInfo()\r\n            // データが無くなるまで回す\r\n            while (true) {\r\n                // データを読み出す\r\n                val offset = byteBuffer.arrayOffset()\r\n                bufferInfo.size = extractor.readSampleData(byteBuffer, offset)\r\n                // もう無い場合\r\n                if (bufferInfo.size < 0) break\r\n                // 書き込む\r\n                bufferInfo.presentationTimeUs = extractor.sampleTime\r\n                bufferInfo.flags = extractor.sampleFlags // Lintがキレるけど黙らせる\r\n                mediaMuxer.writeSampleData(index, byteBuffer, bufferInfo)\r\n                // 次のデータに進める\r\n                extractor.advance()\r\n            }\r\n            // あとしまつ\r\n            extractor.release()\r\n        }\r\n        // あとしまつ\r\n        mediaMuxer.stop()\r\n        mediaMuxer.release()\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 最終的な MainActivity\r\n\r\n```kotlin\r\n/**\r\n * 動画保存先\r\n *\r\n * /sdcard/Android/data/io.github.takusan23.androidmediacodecvideomerge/files/video\r\n * */\r\nclass MainActivity : AppCompatActivity() {\r\n    /** 動画ファイルがあるフォルダ名 */\r\n    private val FOLDER_NAME = \"bakkure\"\r\n\r\n    /** 映像 ファイル名 */\r\n    private val MERGE_VIDEO_FILE_NAME = \"video_merge.mp4\"\r\n\r\n    /** 音声 ファイル名 */\r\n    private val MERGE_AUDIO_FILE_NAME = \"audio_merge.aac\"\r\n\r\n    /** 映像と音声を合わせたファイル */\r\n    private val FINAL_RESULT_FILE = \"final_merge.mp4\"\r\n\r\n    /** 一時ファイルの名前 */\r\n    private val TEMP_RAW_DATA_FILE_NAME = \"temp_raw_data\"\r\n\r\n    /** 映像くっつけるやつ */\r\n    private lateinit var videoDataMerge: VideoDataMerge\r\n\r\n    /** 音声くっつけるやつ */\r\n    private lateinit var audioDataMerge: AudioDataMerge\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // 結合したい動画ファイルが置いてあるフォルダ\r\n        val videoFolder = File(getExternalFilesDir(null), FOLDER_NAME).apply {\r\n            if (!exists()) {\r\n                mkdir()\r\n            }\r\n        }\r\n\r\n        // 最終的に結合するファイル。映像\r\n        val videoMergedFile = File(getExternalFilesDir(null), MERGE_VIDEO_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 最終的に結合するファイル。音声\r\n        val audioMergedFile = File(getExternalFilesDir(null), MERGE_AUDIO_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 音声だけの生データをおいておくファイル\r\n        val tempRawDataFile = File(getExternalFilesDir(null), TEMP_RAW_DATA_FILE_NAME).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n        // 最終的なファイル\r\n        val finalResultFile = File(getExternalFilesDir(null), FINAL_RESULT_FILE).apply {\r\n            if (!exists()) {\r\n                delete()\r\n            }\r\n            createNewFile()\r\n        }\r\n\r\n\r\n        // 数字を見つける正規表現\r\n        val numberRegex = \"(\\\\d+)\".toRegex()\r\n        // 結合する動画ファイルを配列\r\n        val videoList = videoFolder.listFiles()\r\n            // ?.filter { it.extension == \"ts\" } // これ動画ファイル以外が入ってくる場合はここで見切りをつける\r\n            ?.toList()\r\n            ?.sortedBy { numberRegex.find(it.name)?.groupValues?.get(0)?.toIntOrNull() ?: 0 } // 数字の若い順にする\r\n        // ?.dropLast(6)\r\n\r\n        // インスタンス作成\r\n        videoDataMerge = VideoDataMerge(videoList!!, videoMergedFile /*bitRate = 1_000_000, frameRate = 30*/)\r\n        audioDataMerge = AudioDataMerge(videoList!!, audioMergedFile, tempRawDataFile, bitRate = 192_000)\r\n\r\n        // 別スレッドを起動して開始\r\n        // 音声と映像をそれぞれ並列で実行したほうがいいと思います...（デコーダーの起動制限に引っかからなければ）\r\n        // 今回はコルーチン入れてないので直列で行います...\r\n        thread {\r\n            // 映像デコード\r\n            val videoStartMs = System.currentTimeMillis()\r\n            showMessage(\"映像開始：$videoStartMs\")\r\n            videoDataMerge.merge()\r\n            showMessage(\"映像終了：${System.currentTimeMillis() - videoStartMs} Ms\")\r\n\r\n            // 音声デコード\r\n            val audioStartMs = System.currentTimeMillis()\r\n            showMessage(\"音声開始：$audioStartMs\")\r\n            audioDataMerge.merge()\r\n            showMessage(\"音声終了：${System.currentTimeMillis() - audioStartMs} Ms\")\r\n\r\n            // 合成...\r\n            MergedDataMuxer.mixed(finalResultFile, listOf(audioMergedFile, videoMergedFile))\r\n            showMessage(\"合成終了：${System.currentTimeMillis() - videoStartMs} Ms\")\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        videoDataMerge.stop()\r\n        audioDataMerge.stop()\r\n    }\r\n\r\n    private fun showMessage(message: String) {\r\n        println(message)\r\n        runOnUiThread { Toast.makeText(this@MainActivity, message, Toast.LENGTH_SHORT).show() }\r\n    }\r\n}\r\n```\r\n\r\n## ベンチマーク\r\n映像 -> 音声 -> 合成 という感じに直列でやっている\r\n\r\n5:14分の動画をFFmpegで細切れにして合成テスト  \r\n各tsファイル 1MB ～ 2MB ぐらい。これが30個。\r\n\r\n- https://www.youtube.com/watch?v=F2ZAlXrldIM\r\n    - 5分14秒\r\n    - 1280 x 720\r\n        - 解像度の割に画質が悪い（ビットレートのせい？）\r\n    - 60 fps\r\n    - ビットレートはわからん\r\n    - H.264 / AAC\r\n\r\n- Pixel 3 XL\r\n    - Snapdragon 845 / RAM 4GB (ハイエンドな同世代のスマホと比べても少ない)\r\n\r\n```\r\n映像終了：1090457 Ms\r\n音声終了：231366 Ms\r\n合成終了：1332262 Ms\r\nファイルサイズ：105 MB ←！？\r\n```\r\n\r\n- Xperia 5 Ⅱ\r\n    - Snapdragon 865 / RAM 8GB\r\n\r\n```\r\n映像終了：817174 Ms\r\n音声終了：174536 Ms\r\n合成終了：995225 Ms\r\nファイルサイズ：46.80 MB\r\n```\r\n\r\n- Xiaomi Mi 11 Lite 5G\r\n    - Snapdragon 780G / RAM 6GB\r\n\r\n```\r\n映像終了：871282 Ms\r\n音声終了：187584 Ms\r\n合成終了：1063305 Ms\r\nファイルサイズ：49.81 MB\r\n```\r\n\r\n# メモ\r\n\r\n- Pixel 3 XL だとなんか映像データのファイルサイズがクソでかい\r\n    - 今回使った Xperia / Xiaomi と比べてもくっそでかい\r\n- `MediaCodec#getInputBuffer()`のサイズを変更する\r\n    - 初期状態だと`4096`ぐらいだったはず\r\n        - `MediaCodec#configure()`で`MediaFormat.KEY_MAX_INPUT_SIZE`をいい感じにすれば大きく出来ます\r\n- 1、2年前ぐらいにAOSPをパクって作った内部音声録画のサンプルがいい感じに役立った。ありがとう過去の私\r\n    - https://github.com/takusan23/InternalAudioRecorder\r\n- エミュレータが起動しない\r\n    - Cドライブ空いてる？\r\n- 出力がぶっ壊れる（緑色とか）\r\n    - MediaMuxerへ渡したMediaFormatだ正しくないかも\r\n        - `MediaCodec#getOutputFormat()`で取れるやつを入れればいいと思う\r\n- 解像度が16の倍数じゃないとだめ\r\n    - 公式に書いてないっぽい？\r\n\r\n# すぺしゃる さんくす\r\nとてもとても参考にしました\r\n\r\n- https://android.googlesource.com/platform/cts/+/jb-mr2-release/tests/tests/media/src/android/media/cts/ExtractDecodeEditEncodeMuxTest.java\r\n    - Apache License, Version 2.0\r\n- https://github.com/ypresto/android-transcoder/blob/ac94c6b059785bc7440e35422bf18d3a9913e884/lib/src/main/java/net/ypresto/androidtranscoder/engine/VideoTrackTranscoder.java\r\n    - Apache License, Version 2.0\r\n- https://github.com/zolad/VideoSlimmer\r\n    - Apache License, Version 2.0\r\n\r\n# おまけ\r\n参考にしたサンプルにOpenGLを利用する例があったので作ってみました、  \r\n何やってるのかはまじでわかりません。なんでこれで動くの...？\r\n\r\nOpenGLを利用すると分からんけど、形式が異なる（横縦の大きさが違う）ファイルでも結合できるっぽい（なんで？）\r\n\r\n- https://github.com/takusan23/AndroidMediaCodecVideoMerge/blob/master/app/src/main/java/io/github/takusan23/androidmediacodecvideomerge/VideoDataOpenGlMerge.kt\r\n    - OpenGLを利用した VideoDataMerge\r\n    - VideoDataMerge と使い方は同じ...\r\n- https://github.com/takusan23/AndroidMediaCodecVideoMerge/blob/master/app/src/main/java/io/github/takusan23/androidmediacodecvideomerge/gl/TextureRenderer.java\r\n    - 必要。何やってるのかは分からん\r\n- https://github.com/takusan23/AndroidMediaCodecVideoMerge/blob/master/app/src/main/java/io/github/takusan23/androidmediacodecvideomerge/gl/CodecInputSurface.java\r\n    - 必要。何やってるのかは分からん\r\n\r\n# ソースコード\r\n気が向いたら合成アプリを作りたいです...\r\n\r\nhttps://github.com/takusan23/AndroidMediaCodecVideoMerge\r\n\r\n# おわりに\r\n\r\nDreamin'Her -僕は、彼女の夢を見る。-  \r\n\r\nってやつ全年齢なんだけどめっちゃ気になる。~~買おうかな~~\r\n\r\nかった、パッケージ版高いよぉ\r\n\r\n![Imgur](https://imgur.com/oiBU1KT.png)"},{"title":"MediaControllerCompat#transportControlsでリピート、シャッフル操作する","link":"/posts/android_mediasession_callback/","markdown":"\r\n本当かどうかは知りませんがメモとして置いておきます。\r\n\r\n## 本題\r\n`Fragment/Activity`に紐づけした`MediaControllerCompat`で  \r\n`transportControls.setRepeatMode()`や`transportControls.setShuffleMode()`を呼んだのに、\r\n`repeatMode`や`shuffleMode`が変わらない問題\r\n\r\n## 解決方法\r\n\r\n```kotlin\r\nprivate val callback = object : MediaSessionCompat.Callback() {\r\n    /** リピートモード変更 */\r\n    override fun onSetRepeatMode(repeatMode: Int) {\r\n        super.onSetRepeatMode(repeatMode)\r\n        // もしかして：この一行必須？\r\n        mediaSessionCompat.setRepeatMode(repeatMode)\r\n        if (repeatMode == PlaybackStateCompat.REPEAT_MODE_ALL) {\r\n            // 無限ループループする\r\n            exoPlayer.repeatMode = Player.REPEAT_MODE_ALL\r\n        } else {\r\n            // 同じ曲を何回も聞く。\r\n            exoPlayer.repeatMode = Player.REPEAT_MODE_ONE\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`mediaSessionCompat.setRepeatMode(repeatMode)`を呼んだら直った"},{"title":"Androidで好きな音楽アプリの操作とか楽曲情報取得とか","link":"/posts/android_mediasession_manager/","markdown":"どうもこんばんわ。  \r\nソニーのイヤホンのアプリが楽曲情報を取得できていたので謎だなーって思って調査した。（ちなみにこれから書くこととは関係ない。多分別の仕組みで取得してる）\r\n\r\n# 本題\r\nRoot権限とかなしで再生中の音楽アプリから楽曲情報取得とか音楽操作をします。  \r\n多分いま存在している音楽アプリではMediaSessionを使っているはずなので、多分各自好きな音楽アプリで動くはずです。\r\n\r\n## MediaSession #とは\r\n音楽アプリがいま再生している曲の情報を外部に公開するのに使う。  \r\n他にも他から音楽アプリへ次の曲行け！とか操作を受け付けるのにも使う。  \r\n\r\nこれのおかげで、\r\n\r\n- Googleアシスタントで、今音楽アプリが再生している曲名を教えてくれたり\r\n    - 次の曲にしてとかも対応してる\r\n- ロック画面の背景にアルバムジャケットが表示されたり    \r\n    - Android 11ぐらいで廃止になったけどね。\r\n- Bluetoothイヤホンとの接続が切断された際に一時停止する\r\n\r\nなど。\r\n\r\n![Imgur](https://imgur.com/8oYASKU.png)\r\n\r\n↑ [そう言えばSMEEが新作出すっぽいですよ？](http://www.hook-net.jp/smee/smee13th/)。いやこれ以上手を出したらまじで詰んでるゲーム終わらなくなる。\r\n\r\nちなみに他のアプリが音を出すから、いま再生している音楽アプリは一時停止してねってやつは`AudioFocus`ってやつだと思う。MediaSessionの機能じゃなかったはず。\r\n\r\n## 正規ルートで楽曲情報取得とかするには\r\n`MediaSessionManager`を利用することで、現在アクティブ状態になっているMediaSessionのControllerを貰えます。  \r\nこれを使うと楽曲情報(`MediaMetadata`)や、操作(`TransportControls`)へアクセスできるようになります。\r\n\r\nなんだけど、これシステム権限の`MEDIA_CONTENT_CONTROL`か、通知領域の監視権限のどちらかが必要です。  \r\nRoot無いので必然的に後者しか無いです。まぁそんな難しくないので大丈夫です。\r\n\r\n## 通知領域の監視権限\r\n`NotificationListenerService`ってやつを使うときに必要になる。  \r\nDangerPermissionより上の、設定画面へ誘導してユーザーにONにしてもらう系の権限です。  \r\n\r\n# 通知監視サービスを作る\r\n適当に`NotificationListenerService`を継承したサービスを作ります。  \r\n多分サービスのクラスがあればいいので特に継承して何か書くことは無いと思います。\r\n\r\n```kotlin\r\nclass MediaSessionNotificationListenerService : NotificationListenerService() {\r\n\r\n}\r\n```\r\n\r\n# AndroidManifest.xmlに書き足す\r\n`<application>`の中に書き足します。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.getcurrentplayingmusic\">\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.GetCurrentPlayingMusic\">\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n\r\n\r\n        <service\r\n            android:name=\".MediaSessionNotificationListenerService\"\r\n            android:exported=\"true\"\r\n            android:label=\"@string/app_name\"\r\n            android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\">\r\n            <intent-filter>\r\n                <action android:name=\"android.service.notification.NotificationListenerService\" />\r\n            </intent-filter>\r\n        </service>\r\n\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n# アプリを実行する。\r\n起動したら、閉じて設定画面へ進み、  \r\n\r\n- Android 12\r\n    - 通知 > デバイスとアプリの通知 \r\n- Android 11\r\n    - アプリと通知 > 特別なアプリアクセス > 通知へのアクセス\r\n- Android 5\r\n    - 音と通知 > 通知へのアクセス\r\n- MIUI 12\r\n    - プライバシー保護 > 特別な権限 > 通知へのアクセス\r\n\r\nからこのアプリへ権限を付与してください。  \r\nこれで準備完了です！\r\n\r\n# 現在再生している楽曲情報を取得\r\n\r\n`activity_main.xml`に最初からあるTextViewに適当にIDを振っておいてください。\r\n\r\n`MediaController#getMetadata`から取得できます。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val textView = findViewById<TextView>(R.id.activity_main_text_view)\r\n\r\n        // 現在アクティブ状態になっているMediaSessionのController取得\r\n        val mediaSessionManager = getSystemService(Context.MEDIA_SESSION_SERVICE) as MediaSessionManager\r\n        val componentName = ComponentName(this, MediaSessionNotificationListenerService::class.java)\r\n        // 曲名をセット\r\n        val currentPlayingMediaController = mediaSessionManager.getActiveSessions(componentName)[0]\r\n        textView.text = currentPlayingMediaController.metadata?.getString(MediaMetadata.METADATA_KEY_TITLE) // タイトル取得\r\n        \r\n    }\r\n}\r\n```\r\n\r\n# 一時停止操作など\r\n`MediaController#getTransportControls`から一時停止操作や、再生とか出来ます。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val textView = findViewById<TextView>(R.id.activity_main_text_view)\r\n\r\n        // 現在アクティブ状態になっているMediaSessionのController取得\r\n        val mediaSessionManager = getSystemService(Context.MEDIA_SESSION_SERVICE) as MediaSessionManager\r\n        val componentName = ComponentName(this, MediaSessionNotificationListenerService::class.java)\r\n        // 曲名をセット\r\n        val currentPlayingMediaController = mediaSessionManager.getActiveSessions(componentName)[0]\r\n        textView.text = currentPlayingMediaController.metadata?.getString(MediaMetadata.METADATA_KEY_TITLE)\r\n\r\n        // 一時停止\r\n        currentPlayingMediaController.transportControls.pause()\r\n    }\r\n}\r\n```\r\n\r\n# 終わりに\r\nこれを応用した、音楽アプリのウイジェットだけを追加するアプリを作りました。  \r\n\r\nソースコード：https://github.com/takusan23/MyMusicControlWidget\r\n\r\nPlayストア：https://play.google.com/store/apps/details?id=io.github.takusan23.mymusiccontrolwidget\r\n\r\nAPKダウンロード：https://github.com/takusan23/MyMusicControlWidget/releases"},{"title":"Androidで接続中のバンドを取得する","link":"/posts/android_mobile_data_band/","markdown":"どうもこんばんわ\n\n<img src=\"https://imgur.com/31rkY0c.png\" width=\"300\">\n\n店員ちゃんのセイイキ、、、どこ？\n\n# 本題\nAndroidで接続中バンドを取得するアプリを作りたい。  \nBand 3とかそういうのがほしい\n\n# 一筋縄では行かない\n`getBand()`みたいな関数は無い。じゃあ世の中の電測[^1]アプリはどうやってバンドを取得しているのって話ですが、  \n`EARFCN`という値が取得できるので、`EARFCN`の値と`バンド一覧`を照らし合わせることでバンドを取得することが出来ます。\n\n周波数も`EARFCN`から出すことができるみたいです。\n\nちなみに3Gでは`UARFCN`、5Gでは`NRARFCN`と呼ばれているそう。\n\nEARFCNからバンドを割り出すサイト→https://www.sqimway.com/lte_band.php\n\n# とりあえずEARFCNを取得してみる\n\n## app/build.gradle\n\n`ViewBinding`、`Acitivty Result API`を利用できるようにします\n\n```\nandroid {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"io.github.takusan23.connectionband\"\n        minSdkVersion 24\n        targetSdkVersion 30\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildFeatures{\n        viewBinding true\n    }\n\n    // 省略\n\n}\n\ndependencies {\n\n    // Activity Result API\n    implementation 'androidx.activity:activity-ktx:1.3.0-alpha06'\n    implementation 'androidx.fragment:fragment-ktx:1.3.2'\n\n\n}\n```\n\n## activity_main.xml\n\n`TextView`と`Button`をおいておきましょう\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:id=\"@+id/activity_main_text_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"ボタンを押して計測\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/activity_main_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"16dp\"\n        android:text=\"計測\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/activity_main_text_view\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n## AndroidManifest.xml\n\nAndroid 10以降はこの権限が無いと最新の値が取れない。\n\n```xml\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n```\n\n## MainActivity.kt\n\n### 権限とViewBinding\n\nとりあえず権限もらうのと、`ViewBinding`の用意をします。\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\n\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n        if (isGranted) {\n            // 権限もらえた\n\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(viewBinding.root)\n\n        start()\n\n        viewBinding.activityMainButton.setOnClickListener {\n            start()\n        }\n\n    }\n\n    /** 権限があれば計測、なければ権限をもらう */\n    private fun start() {\n        if (ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n            // 権限あり\n\n        } else {\n            // 権限なし。貰いに行く\n            permissionCallBack.launch(android.Manifest.permission.ACCESS_FINE_LOCATION)\n        }\n    }\n\n\n}\n```\n\n## EARFCNの取得\n`getEarfcn`関数内に書いていきます。\n\n```kotlin\n/** TextViewにバンドを表示させる。コールバック形式になります */\nprivate fun getEarfcn(result: (CellInfo) -> Unit) {\n    val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\n    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {\n        // Android 10以降\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n            telephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\n                override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\n                    result.invoke(cellInfo[0])\n                }\n            })\n        }\n    } else {\n        // Android 9以前\n        result.invoke(telephonyManager.allCellInfo[0])\n    }\n}\n```\n\n# EARFCNからバンドを割り出す関数\n\nと、その前に`EARFCN`の値とバンドの相対表が必要ですので用意しましょう。 \n\n- https://www.arib.or.jp/english/html/overview/doc/STD-T104v2_10/5_Appendix/Rel11/36/36101-b50.pdf\n    - 33ページ目、`Table 5.7.3-1: E-UTRA channel numbers`\n- `lte band earfcn table` とかで検索\n\n多分PDF見るのが早いと思います。\n\n中を見るとこんな感じの表が出てきます。（以下はクソ簡略版）\n\n| band | Range of Ndl |\n|------|--------------|\n| 1    | 0 - 599      |\n| 2    | 600 - 1199   |\n| 3    | 1200 - 1949  |\n\n取得した`EARFCN`が`1850`の場合は、`1200 から 1949 まで`の`Band 3`が正解！となるわけです。  \n`1500`の場合でも、`1200 から 1949 まで`の`Band 3`が正解となります。\n\nこの表と照らし合わせる処理を書きます。\n\n## データクラスを用意\nデータ3つなので`Triple`でも良かったですね\n\n```kotlin\n/**\n * バンドの表データ\n * @param bandNumber バンドの番号\n * @param nDlMin Earfcnここから\n * @param nDlMax Earfcnここまで\n * */\ndata class BandData(val bandNumber: Int, val nDlMin: Int, val nDlMax: Int)\n```\n\n## 変換する関数\n\nKotlinの(0..10)みたいなやつのおかげで楽ですね。  \n(比較演算子使って範囲内かどうかを調べてもいいけど)\n\n```kotlin\n/** EARFCNからバンドを割り出す */\nprivate fun getBand(earfcn: Int): Int {\n    /**\n     * https://www.arib.or.jp/english/html/overview/doc/STD-T104v2_10/5_Appendix/Rel11/36/36101-b50.pdf\n     *\n     * 33ページ目、「Table 5.7.3-1: E-UTRA channel numbers」参照\n     * */\n    val bandList = listOf(\n            BandData(1, 0, 599),\n            BandData(2, 600, 1199),\n            BandData(3, 1200, 1949),\n            BandData(4, 1950, 2399),\n            BandData(5, 2400, 2649),\n            BandData(6, 2650, 2749),\n            BandData(7, 2750, 3449),\n            BandData(8, 3450, 3799),\n            BandData(9, 3800, 4149),\n            BandData(10, 4150, 4749),\n            BandData(11, 4750, 4949),\n            BandData(12, 5010, 5179),\n            BandData(13, 5180, 5279),\n            BandData(14, 5280, 5279),\n            BandData(17, 5730, 5849),\n            BandData(18, 5850, 5999),\n            BandData(19, 6000, 6149),\n            BandData(20, 6150, 6449),\n            BandData(21, 6450, 6599),\n            BandData(22, 6600, 7399),\n            BandData(23, 7500, 7699),\n            BandData(24, 7700, 8039),\n            BandData(25, 8040, 8689),\n            BandData(26, 8690, 9039),\n            BandData(27, 9040, 9209),\n            BandData(28, 9210, 9659),\n            BandData(29, 9660, 9769),\n            BandData(30, 9770, 9869),\n            BandData(31, 9870, 9919),\n            BandData(32, 9920, 10359),\n            BandData(65, 65536, 66435),\n            BandData(66, 66436, 67335),\n            BandData(67, 67336, 67535),\n            BandData(68, 67536, 67835),\n            BandData(69, 67836, 68335),\n            BandData(70, 68336, 68585),\n            BandData(71, 68586, 68935),\n    )\n    // 探す\n    return bandList.find { bandData -> earfcn in bandData.nDlMin..bandData.nDlMax }?.bandNumber ?: 0\n}\n```\n\n## 合体\nEARFCN取得関数と合体させます。\n\n```kotlin\n/** 接続しているバンドをTextViewに入れる */\nprivate fun setBandToTextView() {\n    getEarfcn { cellInfo ->\n        if (cellInfo is CellInfoLte) {\n           val band = getBand(cellInfo.cellIdentity.earfcn)\n            viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n        }\n    }\n}\n```\n\nそして権限コールバックのところとボタン押したところに書いて完成\n\n```kotlin\nprivate val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n    if (isGranted) {\n        // 権限もらえた\n        setBandToTextView()\n    }\n}\n```\n\n```kotlin\n/** 権限があれば計測、なければ権限をもらう */\nprivate fun start() {\n    if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n        // 権限あり\n        setBandToTextView()\n    } else {\n        // 権限なし。貰いに行く\n        permissionCallBack.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n    }\n}\n```\n\n# 全部くっつけてこう\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\n\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n        if (isGranted) {\n            // 権限もらえた\n            setBandToTextView()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(viewBinding.root)\n\n        start()\n\n        viewBinding.activityMainButton.setOnClickListener {\n            start()\n        }\n\n    }\n\n    /** 権限があれば計測、なければ権限をもらう */\n    private fun start() {\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n            // 権限あり\n            setBandToTextView()\n        } else {\n            // 権限なし。貰いに行く\n            permissionCallBack.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n        }\n    }\n\n    /** 接続しているバンドをTextViewに入れる */\n    private fun setBandToTextView() {\n        getEarfcn { cellInfo ->\n            when (cellInfo) {\n                is CellInfoLte -> {\n                    // 4G / LTE\n                    val band = getBand(cellInfo.cellIdentity.earfcn)\n                    viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n                }\n            }\n        }\n    }\n\n    /** TextViewにバンドを表示させる。コールバック形式になります */\n    private fun getEarfcn(result: (CellInfo) -> Unit) {\n        val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {\n            // Android 10以降\n            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n                telephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\n                    override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\n                        result.invoke(cellInfo[0])\n                    }\n                })\n            }\n        } else {\n            // Android 9以前\n            result.invoke(telephonyManager.allCellInfo[0])\n        }\n    }\n\n    /** EARFCNからバンドを割り出す */\n    private fun getBand(earfcn: Int): Int {\n        /**\n         * https://www.arib.or.jp/english/html/overview/doc/STD-T104v2_10/5_Appendix/Rel11/36/36101-b50.pdf\n         *\n         * 33ページ目、「Table 5.7.3-1: E-UTRA channel numbers」参照\n         * */\n        val bandList = listOf(\n                BandData(1, 0, 599),\n                BandData(2, 600, 1199),\n                BandData(3, 1200, 1949),\n                BandData(4, 1950, 2399),\n                BandData(5, 2400, 2649),\n                BandData(6, 2650, 2749),\n                BandData(7, 2750, 3449),\n                BandData(8, 3450, 3799),\n                BandData(9, 3800, 4149),\n                BandData(10, 4150, 4749),\n                BandData(11, 4750, 4949),\n                BandData(12, 5010, 5179),\n                BandData(13, 5180, 5279),\n                BandData(14, 5280, 5279),\n                BandData(17, 5730, 5849),\n                BandData(18, 5850, 5999),\n                BandData(19, 6000, 6149),\n                BandData(20, 6150, 6449),\n                BandData(21, 6450, 6599),\n                BandData(22, 6600, 7399),\n                BandData(23, 7500, 7699),\n                BandData(24, 7700, 8039),\n                BandData(25, 8040, 8689),\n                BandData(26, 8690, 9039),\n                BandData(27, 9040, 9209),\n                BandData(28, 9210, 9659),\n                BandData(29, 9660, 9769),\n                BandData(30, 9770, 9869),\n                BandData(31, 9870, 9919),\n                BandData(32, 9920, 10359),\n                BandData(65, 65536, 66435),\n                BandData(66, 66436, 67335),\n                BandData(67, 67336, 67535),\n                BandData(68, 67536, 67835),\n                BandData(69, 67836, 68335),\n                BandData(70, 68336, 68585),\n                BandData(71, 68586, 68935),\n        )\n        // 探す\n        return bandList.find { bandData -> earfcn in bandData.nDlMin..bandData.nDlMax }?.bandNumber ?: 0\n    }\n\n    /**\n     * バンドの表データ\n     * @param bandNumber バンドの番号\n     * @param nDlMin Earfcnここから\n     * @param nDlMax Earfcnここまで\n     * */\n    data class BandData(val bandNumber: Int, val nDlMin: Int, val nDlMax: Int)\n\n}\n```\n\n動かすとこんなかんじ\n\n![Imgur](https://imgur.com/FIzgY7v.png)\n\n## 番外編：5G（NR）に対応する\nNew Radioの略らしい。  \n\n- https://www.etsi.org/deliver/etsi_ts/138100_138199/13810101/15.08.02_60/ts_13810101v150802p.pdf\n    - 30ページ目、「Table 5.4.2.3-1: Applicable NR-ARFCN per operating band」参照\n\nここに4Gのときみたいな表があるので\n\n| band | Downlink Range of NREF |\n|------|------------------------|\n| n1   | 422000 – 434000        |\n| n2   | 386000  – 398000       |\n| n3   | 361000 - 376000        |\n\nこれを配列に入れてこんな感じに。\n\nあ、ミリ波の方は、\n\n- https://www.etsi.org/deliver/etsi_ts/138100_138199/13810102/15.08.00_60/ts_13810102v150800p.pdf\n    - 27ページ目、「Table 5.4.2.3-1: Applicable NR-ARFCN per operating band」\n\nだと思います。（多分）\n\n```kotlin\n/** バンドを取得する。5G対応版 */\nprivate fun getNRBand(arfcn: Int): Int {\n    /**\n     * https://www.etsi.org/deliver/etsi_ts/138100_138199/13810101/15.08.02_60/ts_13810101v150802p.pdf\n     *\n     * 30ページ目、「Table 5.4.2.3-1: Applicable NR-ARFCN per operating band」参照\n     * */\n    val bandList = listOf(\n            BandData(1, 422000, 434000),\n            BandData(2, 386000, 398000),\n            BandData(3, 361000, 376000),\n            BandData(5, 173800, 178800),\n            BandData(7, 524000, 538000),\n            BandData(8, 185000, 192000),\n            BandData(20, 158200, 164200),\n            BandData(28, 151600, 160600),\n            BandData(38, 514000, 524000),\n            BandData(41, 499200, 537999),\n            BandData(50, 286400, 303400),\n            BandData(51, 285400, 286400),\n            BandData(66, 422000, 440000),\n            BandData(70, 399000, 404000),\n            BandData(71, 123400, 130400),\n            BandData(74, 295000, 303600),\n            BandData(75, 286400, 303400),\n            BandData(76, 285400, 286400),\n            BandData(77, 620000, 680000),\n            BandData(78, 620000, 653333),\n            BandData(79, 693334, 733333),\n            // 5G ミリ波\n            BandData(257, 2054166, 2104165),\n            BandData(258, 2016667, 2070832),\n            BandData(260, 2229166, 2279165),\n            BandData(261, 2070833, 2084999),\n    )\n    // 探す\n    return bandList.find { bandData -> arfcn in bandData.nDlMin..bandData.nDlMax }?.bandNumber ?: 0\n}\n```\n\n```kotlin\n/** 接続しているバンドをTextViewに入れる */\nprivate fun setBandToTextView() {\n    getEarfcn { cellInfo ->\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {\n            when (cellInfo) {\n                is CellInfoLte -> {\n                    // 4G / LTE\n                    val band = getBand(cellInfo.cellIdentity.earfcn)\n                    viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n                }\n                is CellInfoNr -> {\n                    // 5G NR\n                    val band = getNRBand((cellInfo.cellIdentity as CellIdentityNr).nrarfcn)\n                    viewBinding.activityMainTextView.text = \"接続中バンド：n${band}\"\n                }\n            }\n        } else {\n            when (cellInfo) {\n                is CellInfoLte -> {\n                    // 4G / LTE\n                    val band = getBand(cellInfo.cellIdentity.earfcn)\n                    viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n                }\n            }\n        }\n    }\n}\n```\n\n作ったのはいいけど5Gエリアに行かないとあってるかどうかわからない。\n\n# 全部くっつけて\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\n\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\n        if (isGranted) {\n            // 権限もらえた\n            setBandToTextView()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(viewBinding.root)\n\n        start()\n\n        viewBinding.activityMainButton.setOnClickListener {\n            start()\n        }\n\n    }\n\n    /** 権限があれば計測、なければ権限をもらう */\n    private fun start() {\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n            // 権限あり\n            setBandToTextView()\n        } else {\n            // 権限なし。貰いに行く\n            permissionCallBack.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n        }\n    }\n\n    /** 接続しているバンドをTextViewに入れる */\n    private fun setBandToTextView() {\n        getEarfcn { cellInfo ->\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {\n                when (cellInfo) {\n                    is CellInfoLte -> {\n                        // 4G / LTE\n                        val band = getBand(cellInfo.cellIdentity.earfcn)\n                        viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n                    }\n                    is CellInfoNr -> {\n                        // 5G NR\n                        val band = getNRBand((cellInfo.cellIdentity as CellIdentityNr).nrarfcn)\n                        viewBinding.activityMainTextView.text = \"接続中バンド：n${band}\"\n                    }\n                }\n            } else {\n                when (cellInfo) {\n                    is CellInfoLte -> {\n                        // 4G / LTE\n                        val band = getBand(cellInfo.cellIdentity.earfcn)\n                        viewBinding.activityMainTextView.text = \"接続中バンド：${band}\"\n                    }\n                }\n            }\n        }\n    }\n\n    /** TextViewにバンドを表示させる。コールバック形式になります */\n    private fun getEarfcn(result: (CellInfo) -> Unit) {\n        val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {\n            // Android 10以降\n            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\n                telephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\n                    override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\n                        result.invoke(cellInfo[0])\n                    }\n                })\n            }\n        } else {\n            // Android 9以前\n            result.invoke(telephonyManager.allCellInfo[0])\n        }\n    }\n\n    /** EARFCNからバンドを割り出す */\n    private fun getBand(earfcn: Int): Int {\n        /**\n         * https://www.arib.or.jp/english/html/overview/doc/STD-T104v2_10/5_Appendix/Rel11/36/36101-b50.pdf\n         *\n         * 33ページ目、「Table 5.7.3-1: E-UTRA channel numbers」参照\n         * */\n        val bandList = listOf(\n                BandData(1, 0, 599),\n                BandData(2, 600, 1199),\n                BandData(3, 1200, 1949),\n                BandData(4, 1950, 2399),\n                BandData(5, 2400, 2649),\n                BandData(6, 2650, 2749),\n                BandData(7, 2750, 3449),\n                BandData(8, 3450, 3799),\n                BandData(9, 3800, 4149),\n                BandData(10, 4150, 4749),\n                BandData(11, 4750, 4949),\n                BandData(12, 5010, 5179),\n                BandData(13, 5180, 5279),\n                BandData(14, 5280, 5279),\n                BandData(17, 5730, 5849),\n                BandData(18, 5850, 5999),\n                BandData(19, 6000, 6149),\n                BandData(20, 6150, 6449),\n                BandData(21, 6450, 6599),\n                BandData(22, 6600, 7399),\n                BandData(23, 7500, 7699),\n                BandData(24, 7700, 8039),\n                BandData(25, 8040, 8689),\n                BandData(26, 8690, 9039),\n                BandData(27, 9040, 9209),\n                BandData(28, 9210, 9659),\n                BandData(29, 9660, 9769),\n                BandData(30, 9770, 9869),\n                BandData(31, 9870, 9919),\n                BandData(32, 9920, 10359),\n                BandData(65, 65536, 66435),\n                BandData(66, 66436, 67335),\n                BandData(67, 67336, 67535),\n                BandData(68, 67536, 67835),\n                BandData(69, 67836, 68335),\n                BandData(70, 68336, 68585),\n                BandData(71, 68586, 68935),\n        )\n        // 探す\n        return bandList.find { bandData -> earfcn in bandData.nDlMin..bandData.nDlMax }?.bandNumber ?: 0\n    }\n\n    /** バンドを取得する。5G対応版 */\n    private fun getNRBand(arfcn: Int): Int {\n        val bandList = listOf(\n                BandData(1, 422000, 434000),\n                BandData(2, 386000, 398000),\n                BandData(3, 361000, 376000),\n                BandData(5, 173800, 178800),\n                BandData(7, 524000, 538000),\n                BandData(8, 185000, 192000),\n                BandData(20, 158200, 164200),\n                BandData(28, 151600, 160600),\n                BandData(38, 514000, 524000),\n                BandData(41, 499200, 537999),\n                BandData(50, 286400, 303400),\n                BandData(51, 285400, 286400),\n                BandData(66, 422000, 440000),\n                BandData(70, 399000, 404000),\n                BandData(71, 123400, 130400),\n                BandData(74, 295000, 303600),\n                BandData(75, 286400, 303400),\n                BandData(76, 285400, 286400),\n                BandData(77, 620000, 680000),\n                BandData(78, 620000, 653333),\n                BandData(79, 693334, 733333),\n                // 5G ミリ波\n                BandData(257, 2054166, 2104165),\n                BandData(258, 2016667, 2070832),\n                BandData(260, 2229166, 2279165),\n                BandData(261, 2070833, 2084999),\n        )\n        // 探す\n        return bandList.find { bandData -> arfcn in bandData.nDlMin..bandData.nDlMax }?.bandNumber ?: 0\n    }\n\n    /**\n     * バンドの表データ\n     * @param bandNumber バンドの番号\n     * @param nDlMin Earfcnここから\n     * @param nDlMax Earfcnここまで\n     * */\n    data class BandData(val bandNumber: Int, val nDlMin: Int, val nDlMax: Int)\n\n}\n```\n\n# ソースコード\n\nhttps://github.com/takusan23/ConnectionBand\n\n# 終わりに\n休日終わるの早すぎ。  \nあと機内モードポチポチしてたら家でも楽天回線掴むようになってた。うれしい\n\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">機内モードぽちぽちしてたら楽天の自社回線掴んだ <a href=\"https://t.co/GPq60McH5o\">pic.twitter.com/GPq60McH5o</a></p>&mdash; たくさん (@takusan__23) <a href=\"https://twitter.com/takusan__23/status/1381290674478145537?ref_src=twsrc%5Etfw\">April 11, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n[^1]:電波測定の略らしい"},{"title":"Android10以降でもモバイルデータ利用量を取得する","link":"/posts/android_mobile_data_usage_api/","markdown":"\r\n20GBまでのプランがMNO4社とも出揃いましたね。MNOの割に安い\r\n\r\n# 本題\r\nAndroidで通信量を取得したい。\r\n\r\n## AOSPの通信量を表示する設定項目を見てみる\r\n\r\n興味なければ[#モバイルデータ利用量を取得するメソッド](#モバイルデータ利用量を取得するメソッド)まで飛ばしてもいいよ。読んでもいいけど\r\n\r\nAndroidの設定アプリのソースコードを追いかけて、通信量を表示している部分を見つけます。\r\n\r\nAOSPミラーGitHub：https://github.com/aosp-mirror/platform_packages_apps_settings\r\n\r\n## どこにあるの？\r\n日本語のローカライズで使う`string.xml`を開いて、そこからモバイルデータ利用量を表示している設定で使ってる文字列を探す。  \r\n見つけたらそのname属性の値を使って検索をかければ見つけられると思う。\r\n\r\nとりあえずそれっぽいのを見つけたのでこれで検索をかける\r\n\r\n```xml\r\n<string name=\"cell_data_warning\" msgid=\"5664921950473359634\">\"警告するデータ使用量: <xliff:g id=\"ID_1\">^1</xliff:g>\"</string>\r\n````\r\n\r\nこれで検索をかけると、`DataUsageSummaryPreferenceController.java`ってのにたどり着きます\r\n\r\nそしたら、モバイルデータ利用量に関係してそうな部分を探します。こことかどうでしょう？\r\n\r\n```java\r\nsummaryPreference.setUsageNumbers(displayUsageLevel(usageLevel),\r\n/* dataPlanSize */ -1L,\r\n/* hasMobileData */ true);\r\n```\r\n\r\n`usageLevel`ってのはどこから来てるかというと、\r\n\r\n```java\r\nmDataUsageController = new DataUsageController(context);\r\n\r\n// 省略\r\n\r\nfinal DataUsageController.DataUsageInfo info =\r\nmDataUsageController.getDataUsageInfo(mDefaultTemplate);\r\nlong usageLevel = info.usageLevel;\r\n```\r\n\r\n`DataUsageController`ってのから取得しているそうですので、`DataUsageController`を探します。\r\n\r\nところが、`DataUsageController`が見つかりません。   \r\nしゃーないのでGoogleで検索をすると`platform_frameworks_base/blob/master/packages/SettingsLib/src/com/android/settingslib/net/DataUsageController.java`だそうです。\r\n\r\n`DataUsageController.java`を開き、`getDataUsageInfo()`を探します。ありました。もうゴールは近い\r\n\r\n```java\r\npublic DataUsageInfo getDataUsageInfo(NetworkTemplate template) {\r\n    // 省略\r\n    final long totalBytes = getUsageLevel(template, start, end);\r\n    // 省略\r\n}\r\n```\r\n\r\n`DataUsageController#getUsageLevel`を見ます  \r\n\r\n```java\r\nfinal Bucket bucket = mNetworkStatsManager.querySummaryForDevice(template, start, end);\r\nif (bucket != null) {\r\n    return bucket.getRxBytes() + bucket.getTxBytes();\r\n}\r\n```\r\n\r\nここで使っている`querySummaryForDevice`は、`@hide`されているので使えませんが、`@hide`のついていない`querySummaryForDevice`もありました。\r\n\r\n# モバイルデータ利用量を取得するメソッド\r\n`クラス名#メソッド名`みたいに`#`で区切る書き方があってるのかどうかは知らない [^1]\r\n```\r\nNetworkStatsManager#querySummaryForDevice(\r\n    int networkType, \r\n    String subscriberId, \r\n    long startTime, \r\n    long endTime\r\n)\r\n```\r\nここで悲報です。`subscriberId`はAndroid 10からサードパーティアプリでは取れません。\r\n\r\nしかし、リファレンスを読んでみると\r\n\r\n|parameters|description|\r\n|---|---|\r\n|subscriberId|文字列。該当する場合は、ネットワーク・インターフェイスのサブスクライバ ID。API レベル 29 以降、subscriberId は追加の制限によって保護されます。subscriberId にアクセスするための新しい要件を満たしていないアプリを呼び出すと、すべてのモバイルネットワークの使用状況を受信するために、モバイルネットワークの種類を照会する際に NULL 値を提供することができます。詳細については、TelephonyManager#getSubscriberId() を参照してください。（Deepl翻訳：https://www.deepl.com/translator）|\r\n\r\n`null`を渡せばモバイルデータ利用量を取得できるっぽい。  \r\nでも複数SIMが刺さってたらどうなるんだろうね？\r\n\r\n# 作る\r\n\r\n|なまえ|あたい|\r\n|---|---|\r\n|Android|11|\r\n|実機|Pixel 3 XL|\r\n|minSdkVersion|23|\r\n\r\n## activity_main.xml\r\n\r\n最初から置いてあるTextViewにIDを振っておいてください。適当に`activity_main_text_view`とでも\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_text_view\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Hello World!\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintLeft_toLeftOf=\"parent\"\r\n        app:layout_constraintRight_toRightOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## AndroidManifest.xml\r\n\r\n「`PACKAGE_USAGE_STATS`」権限が必要です。しかもダイアログ形式ではない、設定画面に誘導するタイプのやつです。  \r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.mobiledatausage\">\r\n\r\n    <!-- 使用状況へのアクセス 権限 -->\r\n    <uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\"/>\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.MobileDataUsage\">\r\n        <activity android:name=\".MainActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n    </application>\r\n\r\n</manifest>\r\n```\r\n\r\n## MainActivity.kt\r\n### 権限を確認、もらうコードを書く\r\n権限の確認もいつものメソッドが使えないのでコードを書く必要があります。  \r\n参考：https://stackoverflow.com/questions/28921136/how-to-check-if-android-permission-package-usage-stats-permission-is-given\r\n\r\n```kotlin\r\n/**\r\n * PACKAGE_USAGE_STATSの権限が付与されているか確認する\r\n * @return 権限があればtrue\r\n * */\r\nfun checkUsageStatsPermission(): Boolean {\r\n    val appOpsManager = getSystemService(APP_OPS_SERVICE) as AppOpsManager\r\n    val mode = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {\r\n        // Android 10 以降\r\n        appOpsManager.unsafeCheckOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), application.packageName)\r\n    } else {\r\n        // Android 9 以前\r\n        appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), application.packageName)\r\n    }\r\n    return mode == AppOpsManager.MODE_ALLOWED\r\n}\r\n```\r\n\r\nこれを使って、権限がなければ取得する画面へ飛ばすようにします\r\n\r\n```kotlin\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    setContentView(R.layout.activity_main)\r\n    if (checkUsageStatsPermission()) {\r\n        // 権限がある\r\n    } else {\r\n        // ない\r\n        startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS))\r\n    }\r\n}\r\n```\r\n\r\n## モバイルデータ利用量を取得する\r\nとりあえず今月の利用分を取得する関数を書いてみる\r\n\r\n```kotlin\r\n/**\r\n * 今月のモバイルデータ利用量を取得する。単位はバイト\r\n * @return バイト単位で返す\r\n * */\r\nfun getMobileDataUsageFromCurrentMonth(): Long {\r\n    val networkStatsManager = getSystemService(Context.NETWORK_STATS_SERVICE) as NetworkStatsManager\r\n    // 集計開始の日付その月の最初の日\r\n    val startTime = Calendar.getInstance().apply {\r\n        set(Calendar.DAY_OF_MONTH, 1)\r\n        set(Calendar.HOUR_OF_DAY, 0)\r\n        set(Calendar.MINUTE, 0)\r\n        set(Calendar.SECOND, 0)\r\n    }.time.time\r\n    // 集計終了は現在時刻\r\n    val endTime = Calendar.getInstance().time.time\r\n    // 問い合わせる\r\n    val bucket = networkStatsManager.querySummaryForDevice(ConnectivityManager.TYPE_MOBILE, null, startTime, endTime)\r\n    // 送信 + 受信\r\n    return bucket.txBytes + bucket.rxBytes\r\n}\r\n```\r\n\r\n最後にTextViewに入れるようにして完成\r\n\r\n```kotlin\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    setContentView(R.layout.activity_main)\r\n    // findViewByIdよりViewBindingを使ったほうがいい\r\n    val textView = findViewById<TextView>(R.id.activity_main_text_view)\r\n    if (checkUsageStatsPermission()) {\r\n        // 権限がある\r\n        val byte = getMobileDataUsageFromCurrentMonth()\r\n        // MBへ変換\r\n        val usageMB = byte / 1024f / 1024f\r\n        // TextViewに入れる\r\n        textView.text = \"$usageMB MB\"\r\n    } else {\r\n        // ない\r\n        startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS))\r\n    }\r\n}\r\n```\r\n\r\n# 結果\r\n多分あってる（AOSP見て作ったんだからそりゃそうだろ）\r\n\r\n![Imgur](https://imgur.com/V6gKPaz.png)\r\n\r\n# 全部くっつけたコード\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // findViewByIdよりViewBindingを使ったほうがいい\r\n        val textView = findViewById<TextView>(R.id.activity_main_text_view)\r\n\r\n        if (checkUsageStatsPermission()) {\r\n            // 権限がある\r\n            val byte = getMobileDataUsageFromCurrentMonth()\r\n            // MBへ変換。Byte -> KB -> MB\r\n            val usageMB = byte / 1024f / 1024f\r\n            // TextViewに入れる\r\n            textView.text = \"$usageMB MB\"\r\n        } else {\r\n            // ない\r\n            startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS))\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * PACKAGE_USAGE_STATSの権限が付与されているか確認する\r\n     * @return 権限があればtrue\r\n     * */\r\n    fun checkUsageStatsPermission(): Boolean {\r\n        val appOpsManager = getSystemService(APP_OPS_SERVICE) as AppOpsManager\r\n        val mode = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {\r\n            // Android 10 以降\r\n            appOpsManager.unsafeCheckOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), application.packageName)\r\n        } else {\r\n            // Android 9 以前\r\n            appOpsManager.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), application.packageName)\r\n        }\r\n        return mode == AppOpsManager.MODE_ALLOWED\r\n    }\r\n\r\n    /**\r\n     * 今月のモバイルデータ利用量を取得する。単位はバイト\r\n     * @return バイト単位で返す\r\n     * */\r\n    fun getMobileDataUsageFromCurrentMonth(): Long {\r\n        val networkStatsManager = getSystemService(Context.NETWORK_STATS_SERVICE) as NetworkStatsManager\r\n        // 集計開始の日付その月の最初の日\r\n        val startTime = Calendar.getInstance().apply {\r\n            set(Calendar.DAY_OF_MONTH, 1)\r\n            set(Calendar.HOUR_OF_DAY, 0)\r\n            set(Calendar.MINUTE, 0)\r\n            set(Calendar.SECOND, 0)\r\n        }.time.time\r\n        // 集計終了は現在時刻\r\n        val endTime = Calendar.getInstance().time.time\r\n        // 問い合わせる\r\n        val bucket = networkStatsManager.querySummaryForDevice(ConnectivityManager.TYPE_MOBILE, null, startTime, endTime)\r\n        // 送信 + 受信\r\n        return bucket.txBytes + bucket.rxBytes\r\n    }\r\n\r\n}\r\n```\r\n\r\n# 終わりに\r\nソースコード置いておきます。  \r\nhttps://github.com/takusan23/MobileDataUsage\r\n\r\nAOSPのソースコード読むところいらんかった気がする\r\n\r\n\r\n[^1]: 「java class method hash tag symbol」とかで検索検索！"},{"title":"AndroidのNavigationViewって便利じゃねって話。下から出てくるメニューの作り方","link":"/posts/android_navigation_view/","markdown":"\r\n今まで`TextView`並べてたのがｂｋみたいだわ  \r\nそんなことより7月ですね。\r\n\r\n# 本題\r\nこういうのを作ります。  \r\n\r\n![Imgur](https://imgur.com/u1b56Rr.png)\r\n\r\n# 環境\r\n| なまえ  | あたい                            |\r\n|---------|-----------------------------------|\r\n| Android | 11 Beta 1 (5以降なら動くはずです) |\r\n| 言語    | Kotlin                            |\r\n\r\n# マテリアルデザインのライブラリを入れる\r\n\r\n`appフォルダ`の方にある`build.gradle`を開きます。  \r\n開いたら、`dependencies`に追記します。\r\n\r\n```gradle\r\ndependencies {\r\n    // Material Design\r\n    implementation 'com.google.android.material:material:1.3.0-alpha01'\r\n    // 省略\r\n}\r\n```\r\n\r\nあと多分関係ないけど、Java 8を使うようにしておくと今後幸せになれるかもしれない。\r\n\r\n```gradle\r\nandroid {\r\n    compileSdkVersion 30\r\n    buildToolsVersion \"30.0.0\"\r\n    // 省略\r\n    compileOptions {\r\n        sourceCompatibility = 1.8\r\n        targetCompatibility = 1.8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n}\r\n```\r\n\r\n# styles.xml を書き換える\r\nこれしないと **メニューを押したときの背景** がちゃんと反映されないと思います。  \r\nといっても`parent`を`Theme.MaterialComponents.Light.DarkActionBar`に変更するだけです。難しくない\r\n\r\n```xml\r\n<resources>\r\n    <!-- Base application theme. -->\r\n    <style name=\"AppTheme\" parent=\"Theme.MaterialComponents.Light.DarkActionBar\">\r\n        <!-- Customize your theme here. -->\r\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\r\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\r\n        <item name=\"colorAccent\">@color/colorAccent</item>\r\n    </style>\r\n\r\n</resources>\r\n```\r\n\r\n# メニュー作成\r\n## menuフォルダの中にファイルを置く\r\n\r\n`res`の中に`menu`フォルダを作ります。  \r\nできたら、`bottom_fragment_menu.xml`ファイルを置きます。\r\n\r\n## アイコンを取ってくる\r\nAndroid Studio 4.0 からアイコンを選ぶ際に、Outlinedなアイコンが選択可能になりました。たすかる  \r\n`Vector Asset`を開いて、好きなアイコンを取ってきてください。  \r\n起動方法は、`Shiftキーを3連続`押して`Vector Asset`って入力すれば多分出ると思います。`macOSのSpotlight的ななにか（macOS触ったこと無いけど）`\r\n\r\n![Imgur](https://imgur.com/EIxL4JP.png)\r\n\r\n## bottom_fragment_menu.xml を書く\r\n以下のように。  \r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <group android:checkableBehavior=\"single\">\r\n        <item\r\n            android:id=\"@+id/nav_menu_java\"\r\n            android:icon=\"@drawable/ic_outline_settings_24\"\r\n            android:title=\"Java\" />\r\n        <item\r\n            android:id=\"@+id/nav_menu_kotlin\"\r\n            android:icon=\"@drawable/ic_outline_settings_24\"\r\n            android:title=\"Kotlin\" />\r\n        <item\r\n            android:id=\"@+id/nav_menu_js\"\r\n            android:icon=\"@drawable/ic_outline_settings_24\"\r\n            android:title=\"JS\" />\r\n    </group>\r\n</menu>\r\n```\r\n\r\n# MainActivity\r\n## activity_main.xml\r\nレイアウトを書き換えます。ボタン一個置くだけなので`ConstraintLayout`をそのまま使おうと思います。  \r\nいつかはちゃんと`ConstraintLayout`できるようにして**MotionLayoutの初め方**みたいな記事を書きたい。  \r\nちなみに現状`MotionLayout`使うと`RecyclerView`のクリックが行かない（たまによくクリックが反応しなくなる）のでもう少し様子見したほうが良い。\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <Button\r\n        android:id=\"@+id/activity_main_bottom_menu\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"BottomMenu\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintLeft_toLeftOf=\"parent\"\r\n        app:layout_constraintRight_toRightOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## MainActivity.kt\r\nメニューを開くコードを書きます。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        // BottomFragment開く\r\n        activity_main_bottom_menu.setOnClickListener {\r\n            MenuBottomFragment().show(supportFragmentManager, \"menu\")\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`MenuBottomFragment`が赤くなるのでこれから書いていきましょう。\r\n\r\n# MenuBottomFragment.kt\r\nを作成します。  \r\nよくわからん人は`MainActivity.kt`のある場所に`MenuBottomFragment.kt`を作ればいいです。\r\n\r\n## bottom_fragment_menu.xml\r\n`res/layout`の中に`bottom_fragment_menu.xml`を作成してください。  \r\n中身はこんな感じで\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\">\r\n\r\n    <com.google.android.material.navigation.NavigationView\r\n        android:id=\"@+id/bottom_fragment_menu_navigation_view\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n        app:menu=\"@menu/bottom_fragment_menu\" />\r\n\r\n</LinearLayout>\r\n```\r\n\r\n## MenuBottomFragment.kt\r\n\r\n今回はメニューを押したらToastを出すようにしてみました。\r\n\r\n```kotlin\r\nclass MenuBottomFragment : BottomSheetDialogFragment() {\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        return inflater.inflate(R.layout.bottom_fragment_menu, container, false)\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n        // メニュー押したとき\r\n        bottom_fragment_menu_navigation_view.setNavigationItemSelectedListener {\r\n            Toast.makeText(context, it.title, Toast.LENGTH_SHORT).show()\r\n            true\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nこれで終わりです。おつ88888888888\r\n\r\nあとは起動してボタンを押すと下からメニューが出てくると思います。\r\n\r\n# ソースコード\r\nhttps://github.com/takusan23/NavigationViewSample\r\n\r\n# おわりに\r\nAndroid Studioくんに背景画像セットしてるせいでスクショが取れなかった。  \r\n次からはPreview版をブログ書く用に入れておきたいと思いましたまる"},{"title":"ndk-bundle did not have a source.properties file を直す","link":"/posts/android_ndk_setup/","markdown":"\r\nライブラリ入れたら出たので解決方法です。\r\n\r\n## 環境\r\n\r\n|なまえ|あたい|\r\n|--|--|\r\n|Android Studio|Android Studio 4.1|\r\n\r\n## でるえらー\r\n\r\n```\r\n> NDK at C:\\Users\\takusan23\\AppData\\Local\\Android\\Sdk\\ndk-bundle did not have a source.properties file\r\n```\r\n\r\n## NDKを入れる\r\n\r\nもう導入済みなら飛ばしていいです。\r\n\r\n`SDK Manager`から導入できます。\r\n\r\n`SDK Tools`へタブ移動して、`NDK`にチェックを入れて`Apply`を押してください。\r\n\r\n## `local.properties`を開く\r\n\r\n開いたら、`sdk.dir`のしたに一行足します。  \r\n\r\n```\r\nndk.dir=C\\:\\\\Users\\\\ユーザー名\\\\AppData\\\\Local\\\\Android\\\\Sdk\\\\ndk\\\\21.3.6528147\r\n```\r\n\r\nユーザー名のところは各自変えてね。\r\n\r\n`Windows`はこうですが、`macOS`は知らない\r\n\r\nこれでビルドが通るようになります。"},{"title":"Androidで新規プロジェクトを作ると何もしていないのに壊れた","link":"/posts/android_new_project_jdk_error/","markdown":"毎回 Java のバージョンが足りないって出てくるんだけどなぜ？\r\n\r\n```\r\nThe consumer was configured to find a runtime of a library compatible with Java 8\r\n```\r\n\r\n# 修正\r\n設定を開いて、`Build, Execution, Deployment`を押して`Build Tools`をおして`Gradle`を押します。\r\n\r\nそして、`Gradle JDK`の部分を`11`以上の`Java`にします。  \r\n\r\n![Imgur](https://imgur.com/3AT260T.png)\r\n\r\n## 11 以上の Java がない\r\n入れましょう。  \r\n多分 `Android Studio` 入れたときについてくるはずですが、もしない場合はダウンロードしてくる必要があります。\r\n\r\n## Java を入れる\r\n実は `Java (JDK)` は `Oracle` 以外のベンダーも作っていて（マイクロソフトやアマゾンなど）、好きな`11 以降のJDK`を入れて↑の設定を完了させれば解決します。  \r\nおすすめは`Eclipse Temurin （旧 AdoptOpenJDK）`です。別に`Oracle JDK / OpenJDK`でもいいですが\r\n\r\n![Imgur](https://imgur.com/p8I1NTw.png)\r\n\r\nhttps://adoptium.net/download/\r\n\r\nダウンロードしたらインストールして、さっきの`Android Studio`の設定画面を開いて、さっき入れたJavaを選択して閉じます。\r\n\r\n![Imgur](https://imgur.com/KtIdNeW.png)\r\n\r\nあとは `Try Again` を押して完了\r\n\r\n![Imgur](https://imgur.com/VDYTzU3.png)\r\n\r\n以上でつ、お疲れ様でした。  "},{"title":"5Gなのに通信始めると4Gになるやつ","link":"/posts/android_new_radio_api/","markdown":"どうもこんばんわ。  \r\nウチはもう、延期できない。 攻略しました。  \r\n\r\nhttp://www.cuffs.co.jp/products/enking/\r\n\r\nみんな可愛かったです。  \r\nシナリオなら未来ちゃんかなー\r\n\r\n![Imgur](https://imgur.com/gn5s67t.png)\r\n![Imgur](https://imgur.com/ofeHzOf.png)\r\n\r\nでもやっぱ千紗さんが可愛かったです。\r\n\r\n![Imgur](https://imgur.com/QfWM9eI.png)\r\n![Imgur](https://imgur.com/fmBl3jo.png)\r\n\r\nとりあえずオープニング見てほしい、テンポ良くて良き\r\n\r\n## 本題\r\nPixel 6 Pro を更新したらついにdocomoの5Gを掴むようになった。いえーい  \r\n(ちなみに12月のパッチ、モバイルデータ通信に問題があるみたいで配信止まってるみたいですね。いまから適用するのは辞めて1月のパッチまで待ったほうがいいと思います。)\r\n\r\nそーす：https://9to5google.com/2021/12/30/pixel-6-december-update-delay/\r\n\r\n<img width=\"200\" src=\"https://imgur.com/Mg1qpT3.png\">\r\n\r\nというわけで、Android 11から追加された 5G（NR / New Radio）向けのAPIを試してみる\r\n\r\nhttps://developer.android.com/about/versions/11/features/5g\r\n\r\n(正直私もよくわかってない)\r\n\r\n## 環境\r\n\r\n| なまえ   | あたい                              |\r\n|----------|-------------------------------------|\r\n| 端末     | Google Pixel 6 Pro                  |\r\n| Android  | 12                                  |\r\n| キャリア | docomo (ギガホプレミア契約してきた) |\r\n\r\n## その前に：5G来た！通信始めたろｗ→4Gに切り替わる\r\n仕様です。\r\n\r\nhttps://www.nttdocomo.co.jp/area/5g/notice.html\r\n\r\n### 5Gなのに4Gに切り替わるのはなぜ？\r\n5Gの展開では、`スタンドアローン (SA)`方式と、`ノンスタンドアローン (NSA)`方式があって、現状普及してる5Gは`NSA方式`です。   \r\n前者の`SA方式`では、**5G基地局単体**で動くことができますが、  \r\n後者の`NSA方式`では**従来の4G基地局設備(eNB)に5G基地局(gNB)を導入した物で**、制御信号(C-Plane)に4Gの電波を利用し実際のデータ転送(U-Plane)では5Gの電波を利用します。   \r\n4Gと5Gを同時に利用する`EN-DC`って言う技術を採用しているそうです。この場合では4Gを`マスターノード`、5Gを`セカンダリノード`と呼んでいるようです。\r\n\r\n流れとしては、\r\n- 4G基地局へ導入した5G基地局(NSA方式)があって、  \r\n- その4G基地局の圏内に入った場合に、5G基地局の存在が4Gの制御信号で送られて来る。\r\n    - セカンダリノードの5G基地局は自分の存在を送出しないらしい？(3GPP TS 37.340 7.1\tSystem information handling)\r\n- でも実際は5G基地局の圏内には入っていない。しかし4G（と5Gの制御信号）は届くのでアンテナピクトの隣のアイコン(RAT表示)が5Gになる。\r\n    - 5G圏内にいれば4Gの制御信号をもとに接続してくれる模様（要調査）\r\n\r\n詳しく知りたい場合は`EN-DC (E-UTRA-NR Dual Connectivity)`とか`アンカーバンド`とか`5G NR NSA Call Flow`で検索して下さい。\r\n\r\n3GPPの資料が見たい場合はこちらです  \r\nTS 37.340\r\n\r\nhttps://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3198\r\n\r\n`Versions`タブへ移動して`Version`のところのリンクを押すとDLできます。  \r\nGoogle翻訳にドキュメントファイルを投げれば翻訳してくれます。（なお理解できるとは言っていない）\r\n\r\n### そういうことなので\r\n5G対応端末をSIMロックフリーで買う際は、5Gの対応バンド以外にも4Gのバンドを確認しないといけません。  \r\n`EN-DC組み合わせ`とかで検索すれば4Gのバンドと5Gのバンドの組み合わせが出てくるのでいいと思います。  \r\n(どうでもいいんだけどdocomoの5G Sub-6で使ってる`n79`ってSIMフリー端末だと全然対応してなくない？)\r\n\r\n## 適当にアプリを作る\r\n\r\n### 使うメソッド\r\n\r\n- `ConnectivityManager#registerDefaultNetworkCallback()`\r\n    - どうやらこれで`従量制 or 定額制`ネットワークの検出ができるらしい（無理じゃね？）\r\n        - 使い放題か上限付きのプランかみたいな？\r\n- `TelephonyManager#listen()`と`onDisplayInfoChanged()`\r\n    - これで5Gが`Sub-6 or ミリ波`のどっちなのかが検出できるみたい。\r\n    - アンテナピクト📶の隣の`5G`、`4G+`と同じのが取れるっぽい\r\n- `TelephonyManager#listen()`と`onDisplayInfoChanged()`\r\n    - 接続中バンドが知りたい\r\n\r\n### app/build.gradle\r\n\r\n`Activity Result API`を使いたいのでActivityとFragmentのバージョンをあげます。  \r\nあと`ViewBinding`も使いたいので有効にします。\r\n\r\n```java\r\nplugins {\r\n    id 'com.android.application'\r\n    id 'kotlin-android'\r\n}\r\n\r\nandroid {\r\n    compileSdk 31\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.newradioapichecker\"\r\n        minSdk 30\r\n        targetSdk 31\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    implementation \"androidx.activity:activity:1.4.0\"\r\n    implementation \"androidx.fragment:fragment-ktx:1.4.0\"\r\n\r\n    implementation 'androidx.core:core-ktx:1.7.0'\r\n    implementation 'androidx.appcompat:appcompat:1.4.0'\r\n    implementation 'com.google.android.material:material:1.4.0'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.2'\r\n    testImplementation 'junit:junit:4.+'\r\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\r\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\r\n}\r\n```\r\n\r\n### AndroidManifest.xml\r\n電波状態にアクセスするために位置情報とか発信権限とか余計なもん付いてきますが仕方ない。\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\r\n```\r\n\r\n### activity_main.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <TextView\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"従量制チェック\"\r\n        android:textSize=\"20sp\" />\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_metered_textview\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:gravity=\"end\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"---\"\r\n        android:textSize=\"20sp\" />\r\n\r\n    <TextView\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"5Gコールバック\"\r\n        android:textSize=\"20sp\" />\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_new_radio_textview\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:gravity=\"end\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"---\"\r\n        android:textSize=\"20sp\" />\r\n\r\n    <TextView\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"接続中バンド\"\r\n        android:textSize=\"20sp\" />\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_band_textview\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:gravity=\"end\"\r\n        android:padding=\"10dp\"\r\n        android:text=\"---\"\r\n        android:textSize=\"20sp\" />\r\n\r\n</LinearLayout>\r\n```\r\n\r\n### MainActivity.kt\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val connectivityManager by lazy { getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager }\r\n    private val telephonyManager by lazy { getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager }\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    // コールバック解除用\r\n    private var connectivityManagerCallback: ConnectivityManager.NetworkCallback? = null\r\n    private var phoneStateListener: PhoneStateListener? = null\r\n    private var telephonyCallback: TelephonyCallback? = null\r\n\r\n    private val permissionRequest = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { result ->\r\n        if (result.all { it.value }) {\r\n            startListen()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        // 権限確認\r\n        if (isGranted()) {\r\n            // あるので監視開始\r\n            startListen()\r\n        } else {\r\n            // ない\r\n            permissionRequest.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.READ_PHONE_STATE))\r\n        }\r\n    }\r\n\r\n    private fun startListen() {\r\n        listenUnlimitedNetwork {\r\n            viewBinding.activityMainMeteredTextview.text = if (it) \"無制限のネットワーク接続\" else \"上限ありのネットワーク接続\"\r\n        }\r\n        listenNewRadio(\r\n            onCellInfoCallback = {\r\n                viewBinding.activityMainBandTextview.text = when (it) {\r\n                    is CellInfoLte -> \"\"\"LTE\r\n接続中バンド：${it.cellIdentity.bands.map { it.toString() }} (${it.cellIdentity.earfcn})\"\"\"\r\n                    is CellInfoNr -> \"\"\"5G\r\n接続中バンド：${(it.cellIdentity as CellIdentityNr).bands.map { it.toString() }} (${(it.cellIdentity as CellIdentityNr).nrarfcn})\"\"\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            },\r\n            onDisplayInfoCallback = {\r\n                viewBinding.activityMainNewRadioTextview.text = when (it.overrideNetworkType) {\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO -> \"LTE Advanced Pro（5Ge）\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_CA -> \"LTE キャリアアグリゲーション\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA -> \"5G Sub-6 ネットワーク\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE -> \"5G ミリ波 ネットワーク (非推奨)\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_ADVANCED -> \"5G ミリ波 (もしくはそれ同等の) ネットワーク\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    private fun isGranted(): Boolean {\r\n        val fineLocation = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n        val readPhoneState = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE)\r\n        return (fineLocation == PackageManager.PERMISSION_GRANTED) && (readPhoneState == PackageManager.PERMISSION_GRANTED)\r\n    }\r\n\r\n    private fun listenNewRadio(\r\n        onCellInfoCallback: (CellInfo) -> Unit,\r\n        onDisplayInfoCallback: (TelephonyDisplayInfo) -> Unit,\r\n    ) {\r\n        // Android 12より書き方が変わった\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n            telephonyCallback = object : TelephonyCallback(), TelephonyCallback.DisplayInfoListener, TelephonyCallback.CellInfoListener {\r\n                /** 実際の状態 */\r\n                override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>) {\r\n                    onCellInfoCallback(cellInfo[0])\r\n                }\r\n\r\n                /** アンテナピクトと同じやつ */\r\n                override fun onDisplayInfoChanged(telephonyDisplayInfo: TelephonyDisplayInfo) {\r\n                    onDisplayInfoCallback(telephonyDisplayInfo)\r\n                }\r\n            }\r\n            telephonyManager.registerTelephonyCallback(mainExecutor, telephonyCallback!!)\r\n        } else {\r\n            phoneStateListener = object : PhoneStateListener() {\r\n\r\n                @SuppressLint(\"MissingPermission\")\r\n                override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>?) {\r\n                    super.onCellInfoChanged(cellInfo)\r\n                    cellInfo?.get(0)?.let { onCellInfoCallback(it) }\r\n                }\r\n\r\n                @SuppressLint(\"MissingPermission\")\r\n                override fun onDisplayInfoChanged(telephonyDisplayInfo: TelephonyDisplayInfo) {\r\n                    super.onDisplayInfoChanged(telephonyDisplayInfo)\r\n                    onDisplayInfoCallback(telephonyDisplayInfo)\r\n                }\r\n            }\r\n            telephonyManager.listen(phoneStateListener!!, PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED or PhoneStateListener.LISTEN_CELL_INFO)\r\n        }\r\n    }\r\n\r\n    private fun listenUnlimitedNetwork(onResult: (Boolean) -> Unit) {\r\n        connectivityManagerCallback = object : ConnectivityManager.NetworkCallback() {\r\n            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {\r\n                super.onCapabilitiesChanged(network, networkCapabilities)\r\n                // 無制限プランを契約している場合はtrue\r\n                val isUnlimited = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED) ||\r\n                        networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED)\r\n                onResult(isUnlimited)\r\n            }\r\n        }\r\n        connectivityManager.registerDefaultNetworkCallback(connectivityManagerCallback!!)\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        connectivityManagerCallback?.let { connectivityManager.unregisterNetworkCallback(it) }\r\n        phoneStateListener?.let { telephonyManager.listen(it, PhoneStateListener.LISTEN_NONE) }\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n            telephonyCallback?.let { telephonyManager.unregisterTelephonyCallback(it) }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 結果\r\n\r\n寒い中ドコモショップの近くをフラフラして5Gの電波を感じてきました。(ドコモショップには貴重な5Gミリ波アンテナがある。すべての店舗には無いっぽい？)\r\n\r\n<img width=\"200\" src=\"https://imgur.com/Mg1qpT3.png\">\r\n<img width=\"200\" src=\"https://imgur.com/J2BomtM.png\">\r\n<img width=\"200\" src=\"https://imgur.com/TcmirVd.png\">\r\n<img width=\"200\" src=\"https://imgur.com/PhYA35b.png\">\r\n\r\n- `ConnectivityManager#registerDefaultNetworkCallback()`\r\n    - モバイルデータ接続中は常に従量制ネットワーク判定だった\r\n        - なんか設定が必要なの？\r\n- `TelephonyManager#listen()`と`onDisplayInfoChanged()`\r\n    - `ミリ波`でも変わらず、`Sub-6`判定だった。\r\n    - `アンカーバンド圏内`の場合でも`Sub-6`判定だった。\r\n- `TelephonyManager#listen()`と`onDisplayInfoChanged()`\r\n    - アンカーバンド時は`CellInfoLte`、5G(Sub-6/NR)の場合は`CellIdentityNr`が貰える\r\n        - よって`Sub-6`or`ミリ波`or`アンカーバンド`の検出にはこっちを利用する必要があるってことですね！\r\n\r\n## Sub-6 か ミリ波 か判定する方法\r\n\r\n`NRARFCN`の数字が`2054166`以上の場合は多分ミリ波です(5Gバンド`n257`以上)\r\n\r\nというわけで、`startListen 関数`を書き換えれば5G ミリ波、5G Sub-6の検知も出来るはずです。\r\n\r\n```kotlin\r\n    private fun startListen() {\r\n        listenUnlimitedNetwork {\r\n            viewBinding.activityMainMeteredTextview.text = if (it) \"無制限のネットワーク接続\" else \"上限ありのネットワーク接続\"\r\n        }\r\n        listenNewRadio(\r\n            onCellInfoCallback = {\r\n                viewBinding.activityMainBandTextview.text = when (it) {\r\n                    is CellInfoLte -> \"\"\"LTE\r\n接続中バンド：${it.cellIdentity.bands.map { it.toString() }} (${it.cellIdentity.earfcn})\"\"\"\r\n                    is CellInfoNr -> \"\"\"5G\r\n接続中バンド：${(it.cellIdentity as CellIdentityNr).bands.map { it.toString() }} (${(it.cellIdentity as CellIdentityNr).nrarfcn})\r\n${if ((it.cellIdentity as CellIdentityNr).nrarfcn > 2054166) \"ミリ波に接続中\" else \"Sub-6に接続中\"}\r\n\"\"\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            },\r\n            onDisplayInfoCallback = {\r\n                viewBinding.activityMainNewRadioTextview.text = when (it.overrideNetworkType) {\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO -> \"LTE Advanced Pro（5Ge）\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_CA -> \"LTE キャリアアグリゲーション\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA -> \"5G Sub-6 ネットワーク\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE -> \"5G ミリ波 ネットワーク (非推奨)\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_ADVANCED -> \"5G ミリ波 (もしくはそれ同等の) ネットワーク\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            }\r\n        )\r\n    }\r\n```\r\n\r\n## アンカーバンドかどうかを判断する方法\r\n\r\n`CellInfo`と`TelephonyDisplayInfo`から判断できます\r\n\r\n```kotlin\r\n    private fun listenNewRadio(\r\n        onCellInfoCallback: (CellInfo) -> Unit,\r\n        onDisplayInfoCallback: (TelephonyDisplayInfo) -> Unit,\r\n        onAnchorBandCallback: (Boolean) -> Unit,\r\n    ) {\r\n\r\n        // onCellInfoChanged onDisplayInfoChanged の結果を一時的に持っておく\r\n        var tempCellInfo: CellInfo? = null\r\n        var tempTelephonyDisplayInfo: TelephonyDisplayInfo? = null\r\n\r\n        // アンカーバンドかどうかを送る\r\n        fun checkAnchorBand() {\r\n            if (tempCellInfo == null && tempTelephonyDisplayInfo == null) return\r\n            // CellInfoがLTEのもので、実際に表示しているアイコンが5Gの場合はアンカーバンド\r\n            val isAnchorBand = tempCellInfo is CellInfoLte && tempTelephonyDisplayInfo?.overrideNetworkType == TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA\r\n            onAnchorBandCallback(isAnchorBand)\r\n        }\r\n\r\n        // Android 12より書き方が変わった\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n            telephonyCallback = object : TelephonyCallback(), TelephonyCallback.DisplayInfoListener, TelephonyCallback.CellInfoListener {\r\n                /** 実際の状態 */\r\n                override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>) {\r\n                    onCellInfoCallback(cellInfo[0])\r\n                    tempCellInfo = cellInfo[0]\r\n                    checkAnchorBand()\r\n                }\r\n\r\n                /** アンテナピクトと同じやつ */\r\n                override fun onDisplayInfoChanged(telephonyDisplayInfo: TelephonyDisplayInfo) {\r\n                    onDisplayInfoCallback(telephonyDisplayInfo)\r\n                    tempTelephonyDisplayInfo = telephonyDisplayInfo\r\n                    checkAnchorBand()\r\n                }\r\n            }\r\n            telephonyManager.registerTelephonyCallback(mainExecutor, telephonyCallback!!)\r\n        } else {\r\n            phoneStateListener = object : PhoneStateListener() {\r\n\r\n                @SuppressLint(\"MissingPermission\")\r\n                override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>?) {\r\n                    super.onCellInfoChanged(cellInfo)\r\n                    cellInfo?.get(0)?.let { onCellInfoCallback(it) }\r\n                    tempCellInfo = cellInfo?.get(0)\r\n                    checkAnchorBand()\r\n                }\r\n\r\n                @SuppressLint(\"MissingPermission\")\r\n                override fun onDisplayInfoChanged(telephonyDisplayInfo: TelephonyDisplayInfo) {\r\n                    super.onDisplayInfoChanged(telephonyDisplayInfo)\r\n                    onDisplayInfoCallback(telephonyDisplayInfo)\r\n                    tempTelephonyDisplayInfo = telephonyDisplayInfo\r\n                    checkAnchorBand()\r\n                }\r\n            }\r\n            telephonyManager.listen(phoneStateListener!!, PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED or PhoneStateListener.LISTEN_CELL_INFO)\r\n        }\r\n    }\r\n```\r\n\r\n関数を呼ぶ側はこんな風に\r\n\r\n```kotlin\r\n    private fun startListen() {\r\n        listenUnlimitedNetwork {\r\n            viewBinding.activityMainMeteredTextview.text = if (it) \"無制限のネットワーク接続\" else \"上限ありのネットワーク接続\"\r\n        }\r\n        listenNewRadio(\r\n            onCellInfoCallback = {\r\n                viewBinding.activityMainBandTextview.text = when (it) {\r\n                    is CellInfoLte -> \"\"\"LTE\r\n接続中バンド：${it.cellIdentity.bands.map { it.toString() }} (${it.cellIdentity.earfcn})\"\"\"\r\n                    is CellInfoNr -> \"\"\"5G\r\n接続中バンド：${(it.cellIdentity as CellIdentityNr).bands.map { it.toString() }} (${(it.cellIdentity as CellIdentityNr).nrarfcn})\r\n${if ((it.cellIdentity as CellIdentityNr).nrarfcn > 2054166) \"ミリ波に接続中\" else \"Sub-6に接続中\"}\"\"\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            },\r\n            onDisplayInfoCallback = {\r\n                viewBinding.activityMainNewRadioTextview.text = when (it.overrideNetworkType) {\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO -> \"LTE Advanced Pro（5Ge）\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_CA -> \"LTE キャリアアグリゲーション\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA -> \"5G Sub-6 ネットワーク\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE -> \"5G ミリ波 ネットワーク (非推奨)\"\r\n                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_ADVANCED -> \"5G ミリ波 (もしくはそれ同等の) ネットワーク\"\r\n                    else -> \"それ以外\"\r\n                }\r\n            },\r\n            onAnchorBandCallback = {\r\n                // レイアウトにTextView追加しておいて！\r\n                viewBinding.activityMainAnchorBandTextview.text = if (it) \"アンカーバンド接続中\" else \"4G接続中、もしくはアンカーバンドではありません。\"\r\n            }\r\n        )\r\n    }\r\n```\r\n\r\n## ソースコード\r\nどうぞ～\r\n\r\nhttps://github.com/takusan23/NewRadioAPIChecker\r\n\r\n# 終わりに\r\nアンカーバンドチェッカー作りました。作ったんだけどなんかdocomoなのに`バンド：n77`とか表示するしなんか強制終了するして適当だけどどうぞ。\r\n\r\n(PlayStoreって年末年始も審査してるんか・・・？お疲れ様です)\r\n\r\n- PlayStore\r\n    - https://play.google.com/store/apps/details?id=io.github.takusan23.newradiosupporter\r\n    - Android 11 以降\r\n- ソースコード\r\n    - https://github.com/takusan23/NewRadioSupporter\r\n\r\nそういえばdocomoもなんちゃって5G（4G周波数を転用）の姿勢を見せたみたいですよ。docomoはやらない雰囲気（なぜか変換できない）出してたのに・・・"},{"title":"NewRadioSupporterがデュアルSIMに対応しました","link":"/posts/android_new_radio_supporter_dual_sim_update/","markdown":"\r\nどうもこんばんわ。\r\n\r\nジュエリー・ハーツ・アカデミア -We will wing wonder world- 攻略しました。  \r\n\r\n![Imgur](https://imgur.com/vR1AfMu.png)\r\n\r\n序盤の頃が懐かしくなるぐらいにはぜんぜん違う方向に話が進むのね、、評判がよさそうだったので予約してたんですがめちゃよかったです。  \r\n次々と新事実が、、、！伏線回収すごい、、色んな方向に話が進んでいくけど最後はちゃんとしてました。\r\n\r\n![Imgur](https://imgur.com/trnJxyg.png)\r\n\r\n戦闘シーンは毎回ラスボスかよって勢いなので毎回ハラハラさせられる、、、\r\n\r\n![Imgur](https://imgur.com/4gdKxtp.png)\r\n\r\nヒロインみんなめっちゃかわいい！！！。おすすめです。\r\n\r\n![Imgur](https://imgur.com/RbcdPR7.png)\r\n\r\n![Imgur](https://imgur.com/wR807Ro.png)\r\n\r\n↑アリアンナちゃんがかわいいのでぜひ\r\n\r\n曲もめっちゃいい！。エンディング曲が気に入りました。オープニング曲のイントロもすき\r\n\r\n# 本題\r\n\r\n`NewRadioSupporter`バージョンアップをしました。  \r\nソースコードもあるので自信がある方はビルド挑戦してみてもいいかもしれません。\r\n\r\n## デュアルSIM対応\r\nデュアルSIMに対応しました。そんなに難しくなかった、、、  \r\n動作確認のためにMNOのオンライン限定プランを契約してみたのですがMNOなのにずいぶん安いですね（感覚麻痺）。  \r\n~~というかテザリング無料なのね、docomo / 楽天 以外は金払わないと使えないのにオンライン限定プランはいいのか、、、？~~ 最近のプランはテザリング無料になったの？\r\n\r\n`Xperia`で動いたのは確認した。`Pixel`でも多分動くと思います。\r\n\r\n![Imgur](https://imgur.com/VZuEFBS.png)\r\n\r\n![Imgur](https://imgur.com/liyNL0w.png)\r\n\r\n## 転用5G の検出\r\n`3.6GHz`未満の周波数の場合に転用5Gと表示するようにしました。  \r\n![Imgur](https://imgur.com/BHuAk07.png)\r\n\r\n## Snapdragon 端末で動くように\r\nあともう一つ、私もXperiaで使うまで知らなかったのですが **Snapdragon 搭載端末で動いてませんでした。**  \r\nたまたま`Google Pixel`で動いてただけでした、、、、\r\n\r\nアプリを出してから一年ぐらい経ちますが気づきませんでしたごめんなさい。\r\n\r\n![Imgur](https://imgur.com/rXrsd6A.png)\r\n\r\n今回はこれらの実装方法でもつらつらと\r\n\r\n# その前にこのアプリ何\r\n電波アイコン（アンテナピクト）の隣にある、`5G`アイコン（`RAT表示`）が何を指しているのかを判定するアプリです。  \r\n実はこれ`5G`につながって無くても`5G`って表示することがあり（！？）、本当に`5G`に接続しているのか判定するアプリになります。  \r\n以下の判定機能があります。\r\n\r\n- アンカーバンド\r\n    - 現在普及している`5G`は`4G`基地局が無いと動かない。連動している（ノンスタンドアローン方式）\r\n    - → 連動している`4G`基地局とつながった際に、`5G`基地局の存在が通知される\r\n    - → 通知されるが、`5G`基地局の電波は届かず`4G`にのみ接続される。\r\n    - → しかし、`4G`基地局から`5G`の存在が通知されているため、**RAT表示が5G**になる。（実際は`4G`に繋がっているのに！）\r\n    - 雑な絵です\r\n        - ![Imgur](https://imgur.com/eCoXDPD.png)\r\n    - なんで判定がサードパーティレベルでできるんだって話ですが、どうやら内部では`4G`扱いだが、RAT表示だけ`5G`に上書きする処理のようです。\r\n- Sub-6\r\n    - 4Gの延長線上の周波数を使う5Gです。\r\n    - 転用5Gを除けばほとんどこれ\r\n- ミリ波\r\n    - Sub-6よりもさらに早い\r\n    - めったに遭遇しない\r\n    - 対応機種もあんまりない（SIMフリーならなおさら無い）\r\n- 転用5G\r\n    - 4G基地局を5Gにしたもの。名前そのまま\r\n    - 速度は4Gのままになる\r\n    - なんちゃって5G / NR化 とか呼ばれている\r\n- ノンスタンドアローン (NSA)\r\n    - いまの5Gはこれ\r\n    - 4G基地局と連動して動く5G\r\n        - 4G基地局を プライマリーセル、マスターノード とか呼んでる？\r\n        - 5G基地局を セカンダリーセル とか呼んでる？\r\n    - Androidの`TelephonyManager`の挙動がよく分からない、、、`5G NSA`の場合は内部的に`LTE`で扱われてそうな雰囲気がある\r\n        - 設定画面にある `SIM ステータス`ダイアログ（デバイス情報から見れる） のところのソースコードを眺める\r\n            - なんか `LTE` だけど `5G NSA` なら上書きする処理がある\r\n            - https://cs.android.com/android/platform/superproject/+/master:packages/apps/Settings/src/com/android/settings/deviceinfo/simstatus/SimStatusDialogController.java;l=558\r\n- スタンドアローン (SA)\r\n    - 5G単独で動く\r\n    - 今のところ個人向けに`5G SA`を提供してるのはドコモだけ？（しかもエリアも少ない）\r\n\r\n# デュアルSIM 対応\r\n\r\n`SubscriptionManager`を使うことで、端末に入ってる`SIMカード`の情報とか取れます。  \r\nデータ用 / 通話用 のSIMカードがどれかを取得できたりします。\r\n\r\nまた、`SubscriptionInfo#getSimSlotIndex`で取得できる値を利用することで`SIMカード`を指定した`TelephonyManager`のインスタンスが作成できます。  \r\nこれで`SIMカード`別の`EARFCN`とかが取得できるようになります。\r\n\r\n```kotlin\r\n// データ用SIMカード\r\nval subscriptionManager = getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE) as SubscriptionManager\r\nval dataUseSimSubscriptionId = SubscriptionManager.getActiveDataSubscriptionId()\r\nval dataUseSim = subscriptionManager.getActiveSubscriptionInfo(dataUseSimSubscriptionId)\r\n\r\ntextView.text = \"データ通信に指定されたSIMカードのキャリア名 = ${dataUseSim.carrierName}\"\r\n\r\n// SIMカードを指定した TelephonyManager を作成する\r\nval dataUseTelephonyManager = (getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager).createForSubscriptionId(dataUseSim.subscriptionId)\r\ndataUseTelephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\r\n    override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\r\n        // EARFCN の取得など...\r\n    }\r\n})\r\n```\r\n\r\nなんか取れない時があったので、確実に取得したい場合は`SubscriptionManager#addOnSubscriptionsChangedListener`でコールバックを購読するのがいいと思います（多分？）\r\n\r\n```kotlin\r\nval subscriptionInfoCallback = object : SubscriptionManager.OnSubscriptionsChangedListener() {\r\n    override fun onSubscriptionsChanged() {\r\n        super.onSubscriptionsChanged()\r\n        // 更新されたら呼ばれる\r\n        subscriptionManager.activeSubscriptionInfoList\r\n    }\r\n}\r\nsubscriptionManager.addOnSubscriptionsChangedListener(context.mainExecutor, subscriptionInfoCallback)\r\n```\r\n\r\n# 転用5G の検出\r\n私も最初は`n20`とかが転用5Gで、`n77`以上を新周波数の5Gだろ～ｗｗとか思ってたのですが、どうやら違うみたいで転用5Gでもバンドが`n78`とかになるみたいです。  \r\n`n78`の範囲は`3.3GHz ~ 3.8GHz`までなのでバンドを見るだけでは転用5Gの判定ができない。（5G専用周波数が`3.6GHz`からなので、、、）  \r\n多分周波数が`3.6GHz`未満の`5G`を`転用5G`って言うと思う、、、ので、まず周波数を取得します。(どうでもいいけど5G専用周波数（新周波数）を`3.7GHz帯`とか言うらしいんだけど、実際は`3.6GHz`からっぽいです。)  \r\n\r\nもしかするとこれは日本だけかもしれない。  \r\n参考：https://k-tai.watch.impress.co.jp/docs/column/keyword/1223471.html\r\n\r\n話を戻して、周波数を取得する方法ですが、残念ながらこれも一筋縄では行きません（`getFrequency()`みたいなメソッドはない。）  \r\nじゃあどうするんだって話ですが、`NRARFCN`から計算をすることで、周波数（`3.6GHz`）みたいな値を出すことができます！！！\r\n\r\nその計算式がここの資料に書いてある：3GPP TS 38.104 5.4.2.1  \r\n\r\n## NRARFCN から 周波数を計算する\r\nはい。単位は MHz になります。  \r\n必要な値は`NRARFCN`のみで、あと必要な値は以下の表から持ってきます。\r\n\r\n```plaintext\r\nFREF = FREF-Offs + ΔFGlobal (NRARFCN – NREF-Offs)\r\n```\r\n\r\n| NRARFCN の範囲       | ΔFGlobal (MHz) | FREF-Offs (MHz) | NREF-Offs |\r\n|----------------------|----------------|-----------------|-----------|\r\n| 0 から 599999        | 0.005          | 0               | 0         |\r\n| 600000 から 2016666  | 0.015          | 3000            | 600000    |\r\n| 2016667 から 3279165 | 0.060          | 24250.08        | 2016667   |\r\n\r\n（ソース：3GPP TS 38.104 Table 5.4.2.1-1: NR-ARFCN parameters for the global frequency raster）\r\n\r\n### 例\r\n\r\n例えば`NRARFCN`が`643334`だった場合は、  \r\n上の表を使い、`NRARFCN の範囲`から`600000 から 2016666`に該当します。あとは横になぞって`ΔFGlobal (MHz) = 0.015 / FREF-Offs (MHz) = 3000 / NREF-Offs = 600000`がそれぞれ判明します。  \r\nあとは公式に当てはめます。  \r\n\r\n```plaintext\r\nFREF = FREF-Offs + ΔFGlobal (NRARFCN – NREF-Offs)\r\n```\r\n```plaintext\r\n3000 + 0.015 (643334 – 600000) = 3650.01\r\n```\r\n\r\nというわけで周波数は`3650.01 MHz`、多分新周波数の`5G`になります。\r\n\r\n### 例2\r\n同じ`n78`でも転用5Gの可能性がある`NRARFCN`が`635424`も計算してみましょう。\r\nこちらも同様、上の表を使い`NRARFCN の範囲`から`600000 から 2016666`に該当し、横になぞって`ΔFGlobal (MHz) = 0.015 / FREF-Offs (MHz) = 3000 / NREF-Offs = 600000`が判明して、\r\n\r\n```plaintext\r\nFREF = FREF-Offs + ΔFGlobal (NRARFCN – NREF-Offs)\r\n```\r\n```plaintext\r\n3000 + 0.015 (635424 – 600000) = 3531.36\r\n```\r\n\r\n`3531.36 MHz`になりました。これは多分転用5Gになります。`au`のものですが、`3.5GHz`は4Gと同じ旨がエリアマップのところに書いてあるので多分正解でしょう。\r\n\r\n### Kotlin 実装例\r\nKotlinの機能を使って楽をしていますが、特に難しいことはしていないので他の言語でも簡単に作れると思います。\r\n\r\n```kotlin\r\n/**\r\n * NRARFCN から 周波数を求める。\r\n * 計算式は「3GPP TS 38.104 5.4.2.1」を参照してください。\r\n *\r\n * @return 周波数。単位は MHz 。3600とか。\r\n */\r\nfun toFrequencyMHz(nrarfcn: Int): Float {\r\n    // 計算に必要な、 FREF-Offs / FGlobal / NREF-Offs を NRARFCN から出す\r\n    // 資料では FGlobal は kHz だが、 MHz に合わせるため変換している\r\n    val (FGlobal, FREFOffs, NREFOffs) = when (nrarfcn) {\r\n        // 3 GHz 以下\r\n        in 0..599999 -> Triple(0.005f, 0f, 0)\r\n        // 3 GHz から 24.25 GHz\r\n        in 600000..2016666 -> Triple(0.015f, 3000f, 600000)\r\n        // 24.25 GHz 以上\r\n        in 2016667..3279165 -> Triple(0.060f, 24250.08f, 2016667)\r\n        // ありえないので適当にreturn\r\n        else -> return -1f\r\n    }\r\n    // FREFOffs + FGlobal( NRARFCN - NREFOffs ) の計算をする\r\n    val frequencyMHz = FREFOffs + ((FGlobal * nrarfcn) - (FGlobal * NREFOffs))\r\n    // 小数点第二位までにする\r\n    return \"%.2f\".format(frequencyMHz).toFloat()\r\n}\r\n```\r\n\r\n#### 組み合わせ例\r\nこんな感じに使えます\r\n\r\n```kotlin\r\n\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n\r\n    // 省略...\r\n\r\n    val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\r\n    telephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\r\n        override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\r\n            // 5G のみ\r\n            val info = cellInfo.filterIsInstance<CellInfoNr>().firstOrNull() ?: return\r\n            val cellIdentityNr = info.cellIdentity as CellIdentityNr\r\n            val frequency = toFrequencyMHz(cellIdentityNr.nrarfcn)\r\n            println(\"\"\"\r\n                NRARFCN = ${cellIdentityNr.nrarfcn}\r\n                周波数 = ${frequency}\r\n            \"\"\".trimIndent())\r\n        }\r\n    })\r\n    // I/System.out: NRARFCN = 635424\r\n    // I/System.out: 周波数 = 3531.36\r\n}\r\n\r\n/**\r\n * NRARFCN から 周波数を求める。\r\n * 計算式は「3GPP TS 38.104 5.4.2.1」を参照してください。\r\n *\r\n * @return 周波数。単位は MHz 。3600とか。\r\n */\r\nfun toFrequencyMHz(nrarfcn: Int): Float {\r\n    // 計算に必要な、 FREF-Offs / FGlobal / NREF-Offs を NRARFCN から出す\r\n    // 資料では FGlobal は kHz だが、 MHz に合わせるため変換している\r\n    val (FGlobal, FREFOffs, NREFOffs) = when (nrarfcn) {\r\n        // 3 GHz 以下\r\n        in 0..599999 -> Triple(0.005f, 0f, 0)\r\n        // 3 GHz から 24.25 GHz\r\n        in 600000..2016666 -> Triple(0.015f, 3000f, 600000)\r\n        // 24.25 GHz 以上\r\n        in 2016667..3279165 -> Triple(0.060f, 24250.08f, 2016667)\r\n        // ありえないので適当にreturn\r\n        else -> return -1f\r\n    }\r\n    // FREFOffs + FGlobal( NRARFCN - NREFOffs ) の計算をする\r\n    val frequencyMHz = FREFOffs + ((FGlobal * nrarfcn) - (FGlobal * NREFOffs))\r\n    // 小数点第二位までにする\r\n    return \"%.2f\".format(frequencyMHz).toFloat()\r\n}\r\n```\r\n\r\n# Snapdragon端末で動くように修正\r\n簡単に言うと`Google Tensor`と`Qualcomm Snapdragon`で`TelephonyManager#getAllCellInfo`関数の返り値が違う（コールバック版もそう）のが原因でした、、、  \r\n\r\n## 何が違うのか\r\n5G の ノンスタンドアローン (NSA) 方式の場合に挙動が違うっぽい\r\n\r\n`TelephonyManager#getAllCellInfo`の返り値が\r\n\r\n- Google Tensor 端末の場合\r\n    - CellInfoNr が一つだけ入った配列\r\n    - `[CellInfoNr]`\r\n- Qualcomm Snapdragon 端末の場合\r\n    - NSA の場合は CellInfoLte と CellInfoNr が配列に入ってる\r\n    - 少なくとも CellInfoNr は最初のインデックスには無い？\r\n    - `[CellInfoLte, CellInfoNr...]`\r\n\r\nで、このアプリは`CellInfoNr`が**配列の最初**に入ってる前提で動いてたので、スナドラ端末の場合で全滅します。（`Google Pixel`で動けば他でも動くやろと思ってた）  \r\nどっちが正解なのかは分からないのですが、、、`5G ノンスタンドアローン(NSA) 方式`の場合は4Gにも接続しているはず？なので`CellInfoLte`が配列に入ってないとおかしい気がします、、、。  \r\n修正としては、最初の要素ではなく`CellInfoNr`を配列の中から探すように修正しました。\r\n\r\n```diff\r\n                     /** 実際の状態 */\r\n                     override fun onCellInfoChanged(cellInfo: MutableList<CellInfo?>) {\r\n-                        // 機内モードから復帰時などにすぐ開くとなんか落ちるので\r\n-                        tempBandData = cellInfo.getOrNull(0)?.let { convertBandData(it) }\r\n+                        // CellInfoNrを探して、もしない場合は 4G にする\r\n+                        // Qualcomm Snapdragon 端末 と Google Tensor 端末 で挙動が違う\r\n+                        // Google Tensor の場合は配列の最初に CellInfoNr があるみたい。\r\n+                        // Qualcomm Snapdragon の場合、配列のどっかに CellInfoNr があるみたい。\r\n+                        // で、 Qualcomm Snapdragon の場合で CellInfoNr が取れない場合がある（ CellSignalStrengthNr だけ取れる。バンドとかは取れないけど5Gの電波強度が取れる？）\r\n+                        // ない場合は 4G か アンカーバンド？\r\n+                        tempBandData = cellInfo.filterIsInstance<CellInfoNr>().firstOrNull()?.let { convertBandData(it) } ?: cellInfo.firstOrNull()?.let { convertBandData(it) }\r\n                         sendResult()\r\n                     }\r\n```\r\n\r\n### メモ\r\n手持ちに端末がないのでなんとも言えないのですが、`5G スタンドアローン(SA) 方式`の場合はスナドラ端末でも`CellInfoNr`しか配列に入らないはず？？？なので動いてたかもしれません。  \r\n~~5G NSAが特殊すぎるんや、、、~~\r\n\r\n# より多くの端末で5Gを検出する\r\n`Qualcomm Snapdragon`の端末の場合でかつ古めの端末？理由は分からないのですが、`5G`に接続していても`CellInfoNr`が取得できないことがあります。（しかし5Gには接続できているようでアンカーバンドではなさそう、もちろん`RAT表示`も`5G`になってる）  \r\nで、いろいろ見た結果 `CellInfoNr` は取得できないけど`5G`に接続できている場合、`CellSignalStrengthNr`が取得できるらしいです（電波強度とかが入ってる）  \r\n\r\nというわけで、`CellInfoNr`が取れず`4G`の場合でも、`CellSignalStrengthNr`が取れた場合は`もしかして5G`の表示にしています。  \r\n電波強度だけ取得なので、接続中のバンドとかは4Gのままになります。（マスターノード？プライマリーセル？の情報）\r\n\r\nhttps://github.com/takusan23/NewRadioSupporter/blob/afca30269ce8e80cc4efea944560f00904c46473/app/src/main/java/io/github/takusan23/newradiosupporter/tool/NetworkCallbackTool.kt#L88\r\n\r\nより多くの端末で5Gを検出（検出だけ！）できるようにする場合は`CellSignalStrengthNr`のインスタンスが取得できるかどうかを追加するといいと思います（後述）\r\n\r\n## 実装例\r\n\r\n`TelephonyManager#getAllCellInfo`ではなく、`TelephonyManager#getSignalStrength`を利用することで`5G`かどうかを判定できます。  \r\n`callbackFlow`便利ですね。\r\n\r\n```kotlin\r\n/** 少なくとも 5G に接続している場合は true を返す (アンカーバンド / 4G は false) */\r\n@OptIn(ExperimentalCoroutinesApi::class)\r\nfun collectNrCheck() = callbackFlow {\r\n    var tempCellSignalStrength: CellSignalStrength? = null\r\n\r\n    fun sendResult() {\r\n        // Flow で返す\r\n        trySend(tempCellSignalStrength != null)\r\n    }\r\n\r\n    val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\r\n        val telephonyCallback = object : TelephonyCallback(), TelephonyCallback.SignalStrengthsListener {\r\n            // 5G に接続しているのにもかかわらず、CellInfoNr が取得できないことがある。が、その場合でも CellSignalStrengthNr が取得できる\r\n            override fun onSignalStrengthsChanged(signalStrength: SignalStrength) {\r\n                tempCellSignalStrength = signalStrength.getCellSignalStrengths(CellSignalStrengthNr::class.java).firstOrNull()\r\n                sendResult()\r\n            }\r\n        }\r\n        telephonyManager.registerTelephonyCallback(mainExecutor, telephonyCallback)\r\n        awaitClose { telephonyManager.unregisterTelephonyCallback(telephonyCallback) }\r\n    } else {\r\n        val phoneStateListener = object : PhoneStateListener() {\r\n            override fun onSignalStrengthsChanged(signalStrength: SignalStrength?) {\r\n                super.onSignalStrengthsChanged(signalStrength)\r\n                tempCellSignalStrength = signalStrength?.getCellSignalStrengths(CellSignalStrengthNr::class.java)?.firstOrNull()\r\n                sendResult()\r\n            }\r\n        }\r\n        telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS)\r\n        awaitClose { telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_NONE) }\r\n    }\r\n}\r\n```\r\n\r\n利用側でこんな感じに（別に`JetpackCompose`である必要もないですが）\r\n\r\n```kotlin\r\n// Flow で 5G かどうかを監視する\r\nval isNewRadio by remember { collectNrCheck() }.collectAsState(initial = false)\r\n\r\nColumn(\r\n    horizontalAlignment = Alignment.CenterHorizontally,\r\n    verticalArrangement = Arrangement.Center\r\n) {\r\n    if (isNewRadio) {\r\n        Text(text = \"5Gに接続しています\")\r\n    } else {\r\n        Text(text = \"4Gに接続しています\")\r\n    }\r\n}\r\n```\r\n\r\n一応そーすこーど  \r\nhttps://github.com/takusan23/AndroidNrCheckerMoreDevice\r\n\r\n\r\n# ノンスタンドアローン (NSA) / スタンドアローン (SA) 検出\r\nすでに対応済みですが、私は試せてないので本当に検出できてるかは分かんないです、、、（`docomoの 5G SA`ってあれドコモ端末だけ？）  \r\nAOSPとか眺めてる感じ？`TelephonyManager#getDataNetworkType`で`NSA / SA`判定が行えるはずです。  \r\n\r\nどうやら`ノンスタンドアローン 5G`はAndroid内部では`4G`判定らしく、`5G`表示を上書きする処理のようです。  \r\n\r\n```kotlin\r\n/**\r\n * [TelephonyDisplayInfo]と[TelephonyManager.getDataNetworkType]を見て5Gが NSA/SA のどっちで接続されているか判別する\r\n *\r\n * @param telephonyDisplayInfo [TelephonyCallback.DisplayInfoListener]で取れるやつ\r\n * @param dataNetworkType [TelephonyManager.getDataNetworkType]の値\r\n * @return [NrStandAloneType]。5G 以外は [NrStandAloneType.ERROR]\r\n */\r\nfun convertStandAloneType(telephonyDisplayInfo: TelephonyDisplayInfo, dataNetworkType: Int) = when {\r\n    /**\r\n     * 5G スタンドアローン形式 (SA)\r\n     * [TelephonyManager.getDataNetworkType]が[TelephonyManager.NETWORK_TYPE_NR]を返す\r\n     */\r\n    dataNetworkType == TelephonyManager.NETWORK_TYPE_NR -> NrStandAloneType.STAND_ALONE\r\n    /**\r\n     * 5G ノンスタンドアローン方式 (NSA)\r\n     * [TelephonyManager.getDataNetworkType]が[TelephonyManager.NETWORK_TYPE_LTE]を返し（なんと！）、\r\n     * [TelephonyDisplayInfo.getOverrideNetworkType]が NR を返す\r\n     */\r\n    dataNetworkType == TelephonyManager.NETWORK_TYPE_LTE &&\r\n            (telephonyDisplayInfo.overrideNetworkType == TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_ADVANCED\r\n                    || telephonyDisplayInfo.overrideNetworkType == TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA) -> NrStandAloneType.NON_STAND_ALONE\r\n    // 5Gじゃない\r\n    else -> NrStandAloneType.ERROR\r\n}\r\n\r\n/**\r\n * 5Gのネットワーク方式、動作未確認\r\n * Non StandAlone / StandAlone / 5G以外\r\n */\r\nenum class NrStandAloneType {\r\n    /** 5G スタンドアローン形式 */\r\n    STAND_ALONE,\r\n\r\n    /** 5G ノンスタンドアローン形式 */\r\n    NON_STAND_ALONE,\r\n\r\n    /** 5G じゃない */\r\n    ERROR\r\n}\r\n```\r\n\r\n# TelephonyCallback.CellInfoListenerの @NonNull は嘘\r\nリリース後、`Kotlin`で書いてある部分でなぜか`ぬるぽ`で落ちてるんですよね、  \r\nそんな ぬるぽ になる場所なんてあったかな、、と思い見てみたのですが、どうやらこれ`Android`が悪いんですよね。\r\n\r\nこんな感じに`@NonNull`が書いてあるので`null`が入らないと**私もKotlin**も思ってたのですが、一部の条件で`null`になるんですよね、、  \r\n（一部の条件：再起動したあとすぐ起動すると`null`になる。Issue にちょうどあって再現もした：https://issuetracker.google.com/issues/237308373）\r\n\r\n```java\r\npublic interface CellInfoListener {\r\n    @RequiresPermission(allOf = {\r\n            Manifest.permission.READ_PHONE_STATE,\r\n            Manifest.permission.ACCESS_FINE_LOCATION\r\n    })\r\n    void onCellInfoChanged(@NonNull List<CellInfo> cellInfo);\r\n}\r\n```\r\n\r\n`Java（AndroidのNonNull）`の場合、`@NonNull`はビルド時に`null`の可能性があるときに警告が出る程度なので実際に実行中に`null`になっても、特に何もなく動きます、、、  \r\n一方、`Kotlin`の場合は`Android の @NonNull アノテーション`も`NonNull`として扱う上、`NonNull`の場合実行時も`null`チェックするコードを挿入するため、`null`を渡して呼び出した場合は落ちてしまいます。  \r\n詳しい話→ http://takusan.negitoro.dev/posts/android_nonnull_annotation_kotlin/\r\n\r\n```kotlin\r\nval callback = object : TelephonyCallback(), TelephonyCallback.CellInfoListener {\r\n   \r\n    override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>) {\r\n        // ビルド時にここに cellInfo が null ではないことを確認するコードが以下のように挿入される\r\n        // Intrinsics.checkNotNullExpressionValue(...)\r\n        // cellInfo\r\n    }\r\n\r\n}\r\n```\r\n\r\n対策としては、`Java`でインターフェースを作成し、`TelephonyCallback.onCellInfoChanged`を継承して、引数の部分の`@NonNull`を`@Nullable`に置き換えるようにすると動くはずです。  \r\n\r\n```java\r\n/** NonNull が付いているが、onCellInfoChanged を null で呼び出す事があるため、Nullable にしたもの */\r\n@RequiresApi(api = Build.VERSION_CODES.S)\r\npublic interface NullableCellInfoListener extends TelephonyCallback.CellInfoListener {\r\n\r\n    @Override\r\n    void onCellInfoChanged(@Nullable List<CellInfo> cellInfo);\r\n}\r\n```\r\n\r\n```kotlin\r\nval callback = object : TelephonyCallback(), NullableCellInfoListener {\r\n    override fun onCellInfoChanged(cellInfo: MutableList<CellInfo>?) {\r\n        // nullable になった\r\n    }\r\n}\r\n```\r\n\r\n# 電波関連のIssue\r\n- https://issuetracker.google.com/issues/145308680\r\n    - `NSA`の場合`CellInfo`が返ってくるかはメーカー次第\r\n    - `CellInfoNr`が取れなくても`SignalStrengthNr`が取れる場合がある\r\n- https://issuetracker.google.com/issues/190423022\r\n    - `Exynos`で挙動が違うらしい\r\n        - `Google Tensor`も`Exynos`と同じモデムを使ってたはずなので同じ影響を受けそう感\r\n\r\n# NewRadioSupporter ソースコード\r\nhttps://github.com/takusan23/NewRadioSupporter\r\n\r\n審査提出！  \r\n\r\n![Imgur](https://imgur.com/JY0Itt0.png)\r\n\r\n# おわりに1\r\n電測APIはAOSPがどうこう、よりもモデムのベンダー次第なところがあるので、`Issue Tracker`に書いても多分無理って言われるだけだと思います；；\r\n\r\n# おわりに2\r\n`Xperia`って`SIMピン`なくてもSIMトレーを引き出せるんですけど、これ便利ですね。\r\n\r\n# おわりに3\r\nau / Softbank が転用5Gしてるせいなのか、はたまた Snapdragon搭載端末 だからなのかは知らないのですが、5Gの掴みがいい気がしました。（Pixelより掴むのかな？）  \r\n転用5Gだと少し歩けば掴むので動作確認がずいぶん楽になりますね（ドコモショップにいかなくても済む）\r\n\r\nそしてドコモも転用5Gを始めたみたい（公式発表済み、運用も始まってるとかなんとか？）なのですが、なんかドコモ端末以外は接続できないらしい？（私は持ってない）。  \r\n**しかし噂によると転用でも`80MHz`を使うところがあるらしいので結構速そう**（新周波数帯の5Gが`100MHz ~`なので8割ぐらいは出る？ｗｋｔｋ）。\r\n\r\n血を見ると力が抜けてくのって気のせいかな"},{"title":"Androidで運転免許証のICを読み取る","link":"/posts/android_nfc_japan_driver_license_card_reader/","markdown":"どうもこんばんわ。  \r\n\r\n`feng`がなんと！サウンドトラックを発売するみたいじゃないですか！！！。もう手に入らないと思ってたのにまじ？   \r\n一瞬本当か疑ったけど`fengの上様がRTしてた`のと`ちゃんと予約開始日に予約できた`あたりマジだと思う。値段が安く見える謎  \r\n\r\n![Imgur](https://imgur.com/r1OXk0z.png)\r\n\r\nhttp://fengva.com/\r\n\r\n# 本題\r\nどうやら運転免許証にはICが埋め込んであるらしく、NFC Type-Bでやり取りできるらしい？  \r\n\r\n# 仕様\r\n\r\n## 警察公式の運転免許証IC仕様書\r\nhttps://www.npa.go.jp/laws/notification/koutuu/menkyo/menkyo20210630_150.pdf\r\n\r\nURL4んでたら「運転免許証　仕様」とかで検索すればPDFで出てくると思います。  \r\n`2021/06/30`に改定されたバージョン`009`が現在のバージョンらしい。\r\n\r\nなんか警察が公式で公開してるのってなんか意外。~~無限アラート事件とかCoinhive事件とかやってたくせに。~~\r\n\r\n## AndroidでNFCやり取りドキュメント\r\nhttps://developer.android.com/guide/topics/connectivity/nfc/advanced-nfc?hl=ja\r\n\r\n今回は`IsoDep`クラスを使っていきます（後述）\r\n\r\n# 環境\r\n\r\n| なまえ | あたい |\r\n|--------|--------|\r\n| 端末    | Xperia 5 Ⅱ |\r\n| Android | 11         |\r\n| 言語    | Kotlin     |\r\n\r\n## 必要なもの？\r\n\r\n- AndroidでNFC搭載の実機\r\n- 運転免許証\r\n    - 1つ目の暗証番号を覚えている必要があります\r\n    - 本籍の取得は2つ目の暗証番号も必要\r\n    - 暗証番号を3回間違えるとロック（仕様書では閉塞って表現）されるので注意。もっと手軽ならいいのにね。\r\n- 2進数、10進数、16進数の変換が出来る電卓みたいなアプリ\r\n    - `Windows 10`に最初から入ってる電卓の`プログラマーモード`にすればいいです。\r\n\r\n# 運転免許証のICに入っている中身\r\n運転免許証IC仕様書の6ページ目の内容です。仕様書ではなんかタコ🐙の足みたいな絵が乗ってると思います。それです。 \r\n\r\n- MF\r\n    - DF1\r\n        - EF01 記載事項（本籍以外。名前とか住所とか）\r\n        - EF02 記載事項（本籍）\r\n        - EF03 外字\r\n        - EF04 記載事項変更等\r\n        - EF05 記載事項変更\r\n        - EF06 記載事項変更\r\n        - EF07 電子署名\r\n    - EF01 PIN 1\r\n    - EF02 PIN 2\r\n    - DF2\r\n        - EF01 写真\r\n    - EF2 PIN設定\r\n    - EF01 共通データ要素\r\n    - DF3\r\n        - EF01\r\n\r\nパソコンのファイル構造みたいですね。\r\n\r\n今回は `DF1のEF01`にある記載事項（本籍以外）を取得することを目標に頑張っていきましょう。\r\n\r\n# 運転免許証と通信した際に返ってくるデータについて\r\n運転免許証IC仕様書の8ページ目の内容です。`基本符号化TLV`とか言われてるそうな。  \r\n\r\n今回は記載事項を取得するわけですが、記載事項を取得すると氏名、住所、生年月日等全てまとめたバイト配列が返ってきます。以下のように。\r\n\r\n\r\n| タグフィールド | 長さフィールド | 値フィールド | タグフィールド | 長さフィールド | ... |\r\n|----------------|----------------|--------------|----------------|----------------|-----|\r\n| 1バイト        | 1バイト        | 長さフィールドを10進数に戻した値分のバイト | 1バイト        | 1バイト        | ... |\r\n\r\n### 長さフィールド\r\n長さフィールドが`0x0A`なら10進数に戻した`10`バイト分が値フィールドの長さであるということです。  \r\n値フィールドが終わったら次のデータのタグフィールドが来て、その次の長さフィールドを見て値フィールドの長さを取得して...ってやっていきます。\r\n\r\n### タグフィールド\r\n`運転免許証のICに入っている中身`を見てもらうと、住所とか名前はすべて`DF1のEF01`にある`記載事項（本籍以外）`にまとめられています。  \r\nそれだと受け取ったバイト配列のどこからが住所の値で、どこからが名前がわからないため、16進数で出来た目印のようなものです。  \r\n\r\n住所がなんの16進数の目印になっているかは仕様書に書いてあります。  \r\n記載事項を例にすると住所は`0x17`、名前は`0x12`です。\r\n\r\n### 値フィールド\r\n値フィールドの中身がテキストなのかそれとも別のなにかなのかを知るには、仕様書に書いてある`タグフィールドの表`に`符 号`ってかいてあるのでそこを見ます。  \r\n`データの内容`もここから確認できます。\r\n\r\n例：住所 タグフィールド`0x17`、符号は`JIS X 0208`。Kotlinなら`SJIS`を文字コードに指定すればいける。  \r\n\r\n### データ例\r\n記載事項（本籍除く）のデータ例です。  \r\nタグフィールドの表は仕様書の11ページ目を見てください。\r\n\r\n```js\r\n0x11, 0x01, 0x78, 0x12, 0x0A, 0x00, 0x00 ...\r\n```\r\n\r\nまず、`0x11`ですが、これは仕様書のタグフィールドの表と照らし合わせると、`JIS X 0208 制定年番号`で有ることが分かりますね。  \r\nそして、次のバイト`0x01`が`JIS X 0208 制定年番号`の値フィールドの大きさを16進数で表しています。`0x01`を10進数に変換すると`1`ですので、この次`1`バイト分が値フィールドの長さであるということです。  \r\n値フィールドが終わった次のバイト`0x12`は、仕様書のタグフィールドの表を見ると`氏名`であることが分かります。  \r\nそして、その次の`0x0A`が`氏名の値フィールド`の長さを表しています。`0x0A`は10進数に変換すると`10`ですので、この次から`10`バイト分は氏名の値フィールドであるということです。\r\n\r\nこんな感じに読んでいきます。\r\n\r\n# 運転免許証と通信する際に送るデータについて\r\n運転免許証IC仕様書の20ページ目の内容です。  \r\n`APDU`って形式で送るらしい。  \r\n\r\n最初のバイト(CLA)は`0x00`で固定。そこから先は以下の`コマンド`で変わってくる。\r\n\r\n## SELECT FILE コマンド\r\nこのコマンドはカレントディレクトリを設定するときに使う。`cd`コマンドみたいな感じ？  \r\n2バイト目(INS)が`0xA4`になります。  \r\n3バイト目(P1)以降は使うときになったらまた説明入れます。\r\n\r\n## VERIFY コマンド\r\nこのコマンドは暗証番号を照合するとき、または残り照合可能回数を確認する際にも利用する。  \r\n2バイト目(INS)が`0x20`になる。  \r\n3バイト目(P1)は`0x00`固定です。  \r\n4バイト目(P2)以降は使うときになったらまた説明入れます。\r\n\r\n## READ BINARY コマンド\r\nこのコマンドはデータを読み出すときに使う。  \r\n2バイト目(INS)が`0xB0`になる。  \r\n3バイト目(P1)以降は使うときになったらまた説明入れます。\r\n\r\n# JIS X 0208\r\n住所、氏名等の文字は`JIS X 0208`に沿って、16進数に変換され、保存されます。  \r\n\r\n## 長いのやだから三行で\r\n- `JIS X 0208`をAndroidで読める形に変換する際に使う文字コードは`JISコード`で行ける。\r\n- `JIS X 0208`で変換されたバイト配列の先頭に`0x1B, 0x24, 0x42`を入れてから\r\n- `String`クラスに突っ込む。文字コードは`charset(\"jis\")`で\r\n\r\n## JIS X 0208 は 符号化文字集合\r\n`Shift_JIS`とか`UTF-8`とかの`文字符号化方式`のお友達ではないです。  \r\n\r\n`符号化文字集合`ってのは文字ひとつひとつに番号を割り当てたものです。  \r\n`文字符号化方式`ってのは上記の`符号化文字集合`をどうやって保存出来る形（バイト配列）にするかを決めてるものです。あとは複数の`符号化文字集合`を組み合わせたものだったりします。\r\n\r\n- `Shift-JIS`\r\n    - `JIS X 0201`と`JIS X 0208`を組み合わせている\r\n    - 組み合わせる際に文字の番号が被らないよう、`Shift_JIS`では計算をしている\r\n- `ISO-2022-JP / 別名 JISコード`\r\n    - `JIS X 0211`、`JIS X 0201のラテン文字集合`、`ISO 646`、`JIS X 0208`などの符号化文字集合を組み合わせている。\r\n    - こちらは、特定のバイト配列（エスケープシーケンス）を使うことで符号化文字集合を切り替えることが出来る。\r\n        - `JIS X 0208`に切り替えるエスケープシーケンスは`0x1B, 0x24, 0x42`\r\n    - 多分エスケープシーケンスで切り替えたら多分切り替えを戻さないと行けない気がするけど、戻さなくても動いてるのでいいか←？\r\n\r\n今回は`Android`でも使えて、そのまま`JIS X 0208`の文字集合の値を入れて使える`JISコード`(`charset(\"jis\")`)を使います。  \r\n\r\n```kotlin\r\nval encodedData = byteArrayOf(0x3c.toByte(), 0x56.toByte()) // \"車\" を JIS X 0208 にしたもの\r\nval escapeSequence = byteArrayOf(0x1b.toByte(), 0x24.toByte(), 0x42.toByte()) // JIS X 0208に切り替えるエスケープシーケンス\r\nval decodeString = String(escapeSequence + encodedData, charset(\"jis\")) // ISO-2022-JP（JISコード）で戻す\r\nprintln(decodeString)\r\n```\r\n\r\n# 流れ\r\n\r\n- Android端末とNFCで接続する。\r\n- `IsoDep#get()`でインスタンスを取得。\r\n- `IsoDep#connect()`を呼び出して接続します。\r\n- `SELECT FILE`コマンドを送信して`MF`にカレントディレクトリを設定します。\r\n- `VERIFY`コマンドを送信して第一暗証番号を認証します。\r\n- `SELECT FILE`コマンドを送信して`DF1`にカレントディレクトリを設定します。\r\n- `READ BINARY`コマンドを送信して`EF01`のデータを読み出します。\r\n- バイト配列を解析します。\r\n- `IsoDep#close()`を呼び出して終了。\r\n\r\n以上になります。  \r\n今回はついでに残り照合回数と、共通データ要素も読み出してみます。\r\n\r\n## NfcBじゃないの？\r\nADPUの送信は`IsoDep`じゃないとだめらしい。\r\n\r\n# とりあえず運転免許証と通信するまで\r\n\r\n## AndroidManifest.xml\r\n`NFC`の権限が必要です。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.jdcardreader\">\r\n\r\n    <uses-permission android:name=\"android.permission.NFC\" />\r\n```\r\n\r\n## activity_main.xml\r\n\r\n`TextView`を置いておきます。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <TextView\r\n        android:id=\"@+id/activity_main_text_view\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"0dp\"\r\n        android:text=\"J(apan) D(river) Card Reader\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## MainActivity.kt\r\n今回は`Activity`に直接書いちゃいますね。  \r\n一応Activityを離れたらNFC検出を止めるようにしてあります。  \r\n\r\n`ByteArray.toHexString()`って関数は`ByteArray`の拡張関数になってて、文字列の16進数に変換してくれる関数です。\r\n\r\nこんな風に→`println(byteArrayOf(0x63.toByte(), 0xC3.toByte()).toHexString()) // 出力 : 63, c3`\r\n\r\nこれ以降は`// ここにコマンドを送信するコードを入れる`の次からコードを書いていきます。\r\n\r\n```kotlin\r\npackage io.github.takusan23.jdcardreader\r\n\r\nimport android.nfc.NfcAdapter\r\nimport android.nfc.Tag\r\nimport android.nfc.tech.IsoDep\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport android.widget.TextView\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val textView by lazy { findViewById<TextView>(R.id.activity_main_text_view) }\r\n\r\n    /** NFCを検出するのに使う */\r\n    private val nfcAdapter by lazy { NfcAdapter.getDefaultAdapter(this) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        nfcAdapter.enableReaderMode(\r\n            this,\r\n            { tag ->\r\n\r\n                val isoDep = IsoDep.get(tag)\r\n                isoDep.connect()\r\n\r\n                // ここにコマンドを送信するコードを入れる\r\n\r\n                isoDep.close()\r\n\r\n            },\r\n            NfcAdapter.FLAG_READER_NFC_B,\r\n            null\r\n        )\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        nfcAdapter.disableReaderMode(this)\r\n    }\r\n\r\n    /** 16進数に変換するやつ */\r\n    fun ByteArray.toHexString() = this.joinToString { \"%02x\".format(it) }\r\n\r\n}\r\n```\r\n\r\n## MFへカレントディレクトリを設定\r\n運転免許証IC仕様書の20ページ目のMFの選択ってやつをそのまま使います。  \r\n\r\n送信するコマンド(バイト配列)はこれです。  \r\n\r\n| CLA | INS | P1 | P2 |\r\n|-----|-----|----|----|\r\n| 0x00 | 0xA4 | 0x00 | 0x00 |\r\n\r\n```\r\n0x00, 0xA4, 0x00, 0x00\r\n```\r\n\r\nんでもって成功したときに帰ってくるバイト配列はこんな感じです。  \r\n\r\n| SW1 | SW2 |\r\n|-----|-----|\r\n| 1バイト    | 1バイト    |\r\n| 90なら成功 | 00なら成功 |\r\n\r\n失敗時の値は仕様書の23ページに書いてあるので見てください。\r\n\r\nKotlinだとこうです。\r\n\r\n```kotlin\r\n// カレントディレクトリをMFにする\r\nval mfSelectCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xA4.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte()\r\n)\r\nval mfSelectCommandResult = isoDep.transceive(mfSelectCommand)\r\nif (mfSelectCommandResult[0] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        MF選択コマンド 成功\r\n        ${mfSelectCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n## 共通データ要素を読んで見る\r\n記載事項は暗証番号が必要で、失敗したらまずいのでとりあえず認証不要な共通データ要素を読んでみます。\r\n\r\n### カレントディレクトリを共通データ要素へ\r\n\r\n送信するコマンドは以下です。  \r\n`P1 / P2`に関しては、運転免許IC仕様書の22ページ目、`P1コーディング`、`P2コーディング`を参照してください。  \r\n今回は、`P1`は`カレントDFの直下のEF`、`P2`は`最初又は唯一のファイルを選択`を指定しました。\r\n2進数を16進数にして渡すだけです。\r\n\r\n![Imgur](https://imgur.com/vJKuTN2.png)\r\n\r\n`Le`は、この後続くデータフィールドの長さです。今回は`0x2F, 0x01`で2バイトなので、2を16進数にした`0x02`(先頭`0x`つけて1桁なら`0`で埋める)を渡します。\r\n\r\n`MF/EF01`の共通データ要素の`EF識別子`は`0x2F, 0x01`なので、`Le`の次に入れます。\r\n\r\n```\r\n0x00, 0xA4, 0x02, 0x0C, 0x02, 0x2F, 0x01\r\n```\r\n\r\n| CLA | INS | P1 | P2 | Le | データフィールド | データフィールド |\r\n|-----|-----|----|----|----|------------------|------------------|\r\n| 0x00 | 0xA4 | 0x02 | 0x0C | 0x02 | 0x2F             | 0x01             |\r\n\r\n\r\n以下例です。\r\n\r\n```kotlin\r\n// カレントディレクトリを共通データ要素に設定する\r\nval mfEf01SelectCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xA4.toByte(),\r\n    0x02.toByte(),\r\n    0x0C.toByte(),\r\n    0x02.toByte(),\r\n    0x2F.toByte(),\r\n    0x01.toByte(),\r\n)\r\nval mfEf01SelectCommandResult = isoDep.transceive(mfEf01SelectCommand)\r\nif (mfEf01SelectCommandResult[0] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        DF/EF01 共通データ要素 選択コマンド 成功\r\n        ${mfEf01SelectCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n### 共通データ要素を読み取る\r\n\r\n送信するコマンドは以下です。  \r\n`P1 / P2`に関しては、カレントディレクトリの中身を見るので`0x00, 0x00`でいいです。  \r\n最後の`Le`ですが、共通データ要素の長さは17なので、16進数に変換した`0x11`を渡せばいいです。\r\n\r\n![Imgur](https://imgur.com/dXHZinj.png)\r\n\r\n```\r\n0x00, 0xB0, 0x00, 0x00, 0x11\r\n```\r\n\r\n| CLA | INS | P1 | P2 | Le |\r\n|-----|-----|----|----|----|\r\n| 0x00 | 0xA4 | 0x00 | 0x0C | 0x11 |\r\n\r\n成功した場合は、最後から2番目の値が`0x90`になっているはずです。\r\n\r\n#### 読み取った共通データ要素を解析\r\n運転免許IC仕様書9ページ目参照。\r\n\r\n読み取ったバイト配列の最後2つはステータス（成功したかどうか）が入っています。\r\n\r\n最初の`0x45`は`カード発行者データ`で、仕様書バージョン(3バイト)、交付年月日(4バイト)、有効期限(4バイト)が連続で入っているそうです。  \r\nその次の`0x0B`は`カード発行者データ`の長さが16進数で入っています。ので、10進数に戻すと`11`、`11バイト分`がカード発狂者データみたいです。  \r\n仕様書バージョンの3バイト分は`SJIS`で変換します。交付年月日(4バイト。`YYMMDD`)、有効期限(4バイト。`YYMMDD`)は`文字列の16進数`にすればいいと思います。  \r\n\r\nKotlinだとこうです。\r\n\r\n```kotlin\r\n// カレントディレクトリを読み取る\r\nval mfEf01ReadBinaryCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xB0.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x11.toByte()\r\n)\r\nval mfEf01ReadBinaryCommandResult = isoDep.transceive(mfEf01ReadBinaryCommand)\r\n// 成功した場合、最後から2番目の16進数が0x90\r\nif (mfEf01ReadBinaryCommandResult[mfEf01ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n    // カード発行者データの長さを取得\r\n    val cardPublisherDataLength = mfEf01ReadBinaryCommandResult[1].toInt() // 多分11\r\n    // 先頭から cardPublisherDataLength 分のバイト配列取得\r\n    val cardPublisherDataBinary = mfEf01ReadBinaryCommandResult.copyOfRange(2, 2 + cardPublisherDataLength)\r\n    // 最初の3バイトが仕様書バージョン（SJIS変換後確認可能）、次の4バイトが交付年月日、次の4バイトが有効期限\r\n    val version = cardPublisherDataBinary.copyOfRange(0, 3).toString(charset(\"sjis\"))\r\n    val publishDate = cardPublisherDataBinary.copyOfRange(4, 7).joinToString(separator = \"\") { \"%02x\".format(it) }\r\n    val effectiveDate = cardPublisherDataBinary.copyOfRange(8, 11).joinToString(separator = \"\") { \"%02x\".format(it) }\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        カレントディレクトリ 読み取りコマンド 成功\r\n        ${mfEf01ReadBinaryCommandResult.toHexString()}\r\n        仕様書バージョン：$version\r\n        発行年月日：$publishDate\r\n        有効期限：$effectiveDate\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n## 残り照合可能回数(暗証番号ミスった回数)を取得してみる\r\n後何回暗証番号を間違えることが出来るのか調べてみます。  \r\nちなみに3回間違えると読み取りできなくなります（仕様書曰く）。仕様書では読み取りできない状態のことを`閉塞`って呼んでいる。  \r\n**なお運転免許ICが読み取り不可の状態でも運転はできるらしい**\r\n\r\n### 残り照合可能回数へ移動する\r\n運転免許IC仕様書24ページ目、`残りの照合許容回数の出力指定`をそのまま使います。\r\n\r\nコマンドは以下です。\r\n\r\n| CLA | INS | P1 | P2 |\r\n|-----|-----|----|----|\r\n| 0x00 | 0x20 | 0x00 | 0x81 |\r\n\r\n```\r\n0x00, 0x20, 0x00, 0x81\r\n```\r\n\r\n`P2`に関してですが、`0x81`を指定することで、`MF/IEF01`(暗証番号1)の`EF識別子`を指定しています。  \r\n多分`P2`を`0x80`(カレントディレクトリを指定)にして、このコマンド実行前に`SELECT FILE コマンド`で`MF/IEF01`へカレントディレクトリを移動しもいいと思います。\r\n\r\n### 残り照合可能回数を解析する\r\n\r\n以下の2バイトが帰ってきます。  \r\n```\r\n0x63, 0xC3\r\n```\r\n\r\n最初のバイトが`0x63`なら成功です。  \r\nそれで見てほしいのは`0xC3`の部分で、最後の`3`が残り照合可能回数です。  \r\n残り2回の場合は`0xC2`になるということです。\r\n\r\nKotlinで書くとこうです。\r\n\r\n```kotlin\r\n// 残り照合可能回数を取得する\r\nval retryCountVerifyCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0x20.toByte(),\r\n    0x00.toByte(),\r\n    0x81.toByte()\r\n)\r\nval retryCountVerifyCommandResult = isoDep.transceive(retryCountVerifyCommand)\r\nprintln(retryCountVerifyCommandResult.toHexString())\r\nif (retryCountVerifyCommandResult[0] == 0x63.toByte()) {\r\n    val retryCountHex = retryCountVerifyCommandResult.last().toInt() - 0xC0 // 0xC0を引けば最後が残る\r\n    val retryCount = \"%x\".format(retryCountHex).last() // ffffff03みたいな感じになる、ので最後だけ取得\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        残り照合可能回数 読み取りコマンド 成功\r\n        ${retryCountVerifyCommandResult.toHexString()}\r\n        残り照合可能回数：$retryCount\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n## 暗証番号を照合する\r\n運転免許証の表面に書いてある情報（顔写真以外）`DF1のEF01`を読み取るには認証を通過する必要があります。  \r\n（表面に書いてあるなら暗証番号の必要性... #とは）\r\n\r\n運転免許証IC仕様書24ページ目、`照合(Case 3)`を使って認証します。  \r\n暗証番号の照合には`VERIFY`コマンドを送信します。  \r\n\r\n### 暗証番号をJIS X 0201に変換する\r\n暗証番号を`JIS X 0201`へ変換します。  \r\n\r\n`JIS X 0201`と数値の相対表を用意しました。\r\n\r\n| JIS X 0201 | 数値 |\r\n|------------|------|\r\n|0x30|0|\r\n|0x31|1|\r\n|0x32|2|\r\n|0x33|3|\r\n|0x34|4|\r\n|0x35|5|\r\n|0x36|6|\r\n|0x37|7|\r\n|0x38|8|\r\n|0x39|9|\r\n\r\n例えば暗証番号が「2525」なら、`0x32, 0x35, 0x32, 0x35`になります。\r\n\r\n今回は変換用の関数でも用意しておきましょう。\r\n\r\n```kotlin\r\nfun toJIS(c: Char): Byte {\r\n    return when (c) {\r\n        '0' -> 0x30\r\n        '1' -> 0x31\r\n        '2' -> 0x32\r\n        '3' -> 0x33\r\n        '4' -> 0x34\r\n        '5' -> 0x35\r\n        '6' -> 0x36\r\n        '7' -> 0x37\r\n        '8' -> 0x38\r\n        '9' -> 0x39\r\n        else -> 0x00\r\n    }.toByte()\r\n}\r\n```\r\n\r\n### それを踏まえて暗証番号を照合するコマンド\r\nこれです。  \r\n`INS`は`VERIFYコマンド`なので`0x20`、  \r\n`P1`は固定`0x00`です。  \r\n`P2`は`運転免許証IC仕様書24ページ目`の`P2エンコーディング`で、`短縮EF識別子指定`を利用します。暗証番号1は`IEF01`で、`EF識別子`が`0001`なので、  \r\n`P2エンコーディング`に照らし合わせると、`10000001`になります(100は固定)。これを16進数に変換した値を入れます。  \r\n`Lc`は暗証番号の長さです。4バイトなので`0x04`です。  \r\nその後は変換した暗証番号を入れます。\r\n\r\n| CLA | INS | P1 | P2 | Lc | 変換した暗証番号1桁目 | 変換した暗証番号2桁目 | 変換した暗証番号3桁目 | 変換した暗証番号4桁目 |\r\n|-----|-----|----|----|----|-----------------------|-----------------------|-----------------------|-----------------------|\r\n| 0x00 | 0x20 | 0x00 | 0x81 | 0x04 |各自|各自|各自|各自|\r\n\r\n```\r\n0x00, 0x20, 0x00, 0x81, 0x04, <暗証番号をJIS X 0201で変換した4バイト>\r\n```\r\n\r\n暗証番号が「2525」の場合は以下のようになります。\r\n\r\n```\r\n0x00, 0x20, 0x00, 0x81, 0x04, 0x32, 0x35, 0x32, 0x35\r\n```\r\n\r\n成功した場合は最初の値が`0x90`になります。\r\n\r\nそれをKotlinでやるとこうなります。\r\n\r\n```kotlin\r\n// 暗証番号1を照合する\r\nval pinCode1CharList = listOf(0, 0, 0, 0) // 各自暗証番号を入力\r\nval pinCode1EncodedList = pinCode1CharList.map { toJIS(it.toString()[0]) }\r\nval pinCode1VerifyCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0x20.toByte(),\r\n    0x00.toByte(),\r\n    0x81.toByte(),\r\n    0x04.toByte(),\r\n) + pinCode1EncodedList\r\nval pinCode1VerifyCommandResult = isoDep.transceive(pinCode1VerifyCommand)\r\nif (pinCode1VerifyCommandResult[pinCode1VerifyCommandResult.size - 2] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        第一暗証番号の照合 成功\r\n        ${pinCode1VerifyCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n### ちなみに閉塞状態になると\r\n\r\n```\r\n0x69, 0x84\r\n```\r\n\r\nが帰ってきます。（暗証番号間違えたまま読み取って閉塞した）\r\n\r\n### 閉塞状態を解除してもらった話\r\n警察署 か 運転免許試験場 で解除してもらえます。\r\n\r\n試験場の場合は**みどりの窓口**行って、受付番号発券して呼ばれるまで待って、呼ばれたら「暗証番号間違えてICカードロックされたので解除してください。」的なことを伝えて、運転免許証を渡せば数十秒後に解除された運転免許証が帰ってきます。  \r\n私は暗証番号覚えてるって伝えたから数十秒で終わったけど、暗証番号忘れてる場合はもっと掛かるかもしれない？\r\n\r\n警察署の場合はしらん。\r\n\r\n## 記載事項（DF1/EF01）を読み出す\r\n暗証番号の照合を終えたのでやっと読み出せます。  \r\nカレントディレクトリを`DF1`にして、`READ BINARY`で`EF01`を読み出すようにします。\r\n\r\n### カレントディレクトリをDF1に設定する\r\n運転免許証IC仕様書22ページ目参照。\r\n\r\nコマンドはこうです。`SELECT FILE`コマンドです。\r\n\r\n`P1`は、`P1エンコーディングの表`から`DF名による直接選択`を利用したいので、2進数`100`であることがわかります。これを16進数にした`0x04`を渡します。  \r\n`P2`は、`P2エンコーディング`の表から、`最初または唯一のファイルを選択`を利用したいので、2進数`1100`であることがわかります。これを16進数にした`0x0C`を渡します。  \r\n`LC`は、`DF名`の長さをいれます。後述しますが、`DF1`の選択には16バイト必要なので、10進数`16`を16進数にした`0x10`を渡します。  \r\n`DF1のアプリケーション識別子(AID)`なんですが、以下です。運転免許証IC仕様書7ページ目`DF1のアプリケーション識別子(AID)`参照。  \r\n\r\n```\r\n0xA0, 0x00, 0x00, 0x02, 0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n```\r\n\r\n| CLA | INS | P1 | P2 | Lc | DF1のアプリケーション識別子(AID) |\r\n|-----|-----|----|----|----|----------------------------------|\r\n| 0x00 | 0xA4 | 0x04 | 0x0C | 0x10 |後述|\r\n\r\n```\r\n0x00, 0xA4, 0x04, 0x0C, 0x10, 0xA0, 0x00, 0x00, 0x02, 0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n```\r\n\r\n成功すると、最初の値が`0x90`になります。  \r\n\r\nこれを`Kotlin`で書くとこう\r\n\r\n```kotlin\r\n// カレントディレクトリをDF1へ\r\nval df1SelectCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xA4.toByte(),\r\n    0x04.toByte(),\r\n    0x0C.toByte(),\r\n    0x10.toByte(),\r\n    0xA0.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x02.toByte(),\r\n    0x31.toByte(),\r\n    0x01.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n)\r\nval df1SelectCommandResult = isoDep.transceive(df1SelectCommand)\r\nif (df1SelectCommandResult[0] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        DF1選択 成功\r\n        ${df1SelectCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n### DF1のEF01（記載事項）を読み出すコマンド\r\n運転免許証IC仕様書26ページ目参照。\r\n\r\n長かった。いやまだバイト配列を解析する仕事が残ってるんですが。 \r\n\r\n以下のコマンドです。`READ BINARY`の`P1/P2`で`EF01`を指定するので、`SELECT FILE`で予め移動しておく必要はないです。  \r\n`P1`、`P2`は`運転免許証IC仕様書26ページ目のP1-P2のコーディング(相対アドレス８ビット指定)`の表から、`P1`で`EF01`を`短縮EF識別子`で指定するため(EF01の短縮EF識別子は`0001`)、`10000001`、`P2`が`00000000`であることがわかります。  \r\n`Lc`ですが、`運転免許証IC仕様書7ページ目のファイル構成`から、記載事項のファイル容量が`880`バイトであることがわかるので、10進数`880`を16進数にした`0x370`をバイト配列にした`0x03, 0x80`を渡すんですが、  \r\n`運転免許証IC仕様書26ページ目のコマンドAPDU`を見ると、`Lc`は`1バイトか3バイト`のどっちかなので、先頭に`0x00`をいれて3バイトにした`0x00, 0x03, 0x80`を渡します。\r\n\r\n| CLA | INS | P1 | P2 | Lc | Lc | Lc |\r\n|-----|-----|----|----|----|----|----|\r\n| 0x00 | 0xB0 | 0x81 | 0x00 |0x00|0x03|0x70|\r\n\r\n```\r\n0x00, 0xB0, 0x81, 0x00, 0x00, 0x03, 0x70\r\n```\r\n\r\n成功した場合は、バイト配列の最後から二番目が`0x90`になります。  \r\n\r\nこれをKotlinで書くとこう。\r\n\r\n```kotlin\r\n// 記載事項(DF1/EF01)を読み出す\r\nval df1Ef01ReadBinaryCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xB0.toByte(),\r\n    0x81.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x03.toByte(),\r\n    0x70.toByte(),\r\n)\r\nval df1Ef01ReadBinaryCommandResult = isoDep.transceive(df1Ef01ReadBinaryCommand)\r\nif (df1Ef01ReadBinaryCommandResult[df1Ef01ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        DF1/EF01読み出しコマンド 成功\r\n        ${df1Ef01ReadBinaryCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n}\r\n```\r\n\r\n### DF1のEF01のバイト配列を読める形に変換する\r\n運転免許証IC仕様書11ページ目参照。  \r\n[運転免許証と通信した際に返ってくるデータについて](/posts/android_nfc_japan_driver_license_card_reader/#運転免許証と通信した際に返ってくるデータについて)の説明が役に立つわけですね（くそ分かりにくい）  \r\n  \r\n氏名、住所がどの順番で入っているかは`運転免許証IC仕様書の11ページ目`の表に書いてあります。\r\n\r\nKotlinのコードは、`さっき書いたif`の中に書いていってください。以下の`// こっから`ってところから\r\n\r\n```kotlin\r\nif (df1Ef01ReadBinaryCommandResult[df1Ef01ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n    val text = \"\"\"\r\n        \r\n        ---\r\n        DF1/EF01読み出しコマンド 成功\r\n        ${df1Ef01ReadBinaryCommandResult.toHexString()}\r\n    \"\"\".trimIndent()\r\n    textView.append(text)\r\n    println(text)\r\n\r\n    // こっから\r\n\r\n}\r\n```\r\n\r\n#### JIS X 0208 制定年番号\r\n最初のデータは`JIS X 0208 制定年番号`ってのが入っているみたいです。以下例\r\n```\r\n0x11, 0x01, 0x78\r\n```\r\n\r\n`0x11`は`JIS X 0208 制定年番号`のタグです。  \r\n`0x01`はその次に来る値フィールドの長さです。今回は`0x01`を10進数にした`1`バイト分が値フィールドの長さです。  \r\n`0x78`が値フィールドの中身ですが、`78`の場合は1978年に制定された`JIS C 6226`で符号化されたというわけらしいのですがよくわかりません。  \r\n~~面白くないので飛ばします。~~\r\n\r\n```kotlin\r\n// JIS X 0208\r\nval jisX0208Data = df1Ef01ReadBinaryCommandResult.copyOfRange(0, 3)\r\nval jisX0208 = \"%02x\".format(jisX0208Data.last())\r\n```\r\n\r\n#### 氏名\r\n次のデータは氏名です。氏名は値フィールドが可変長なので（当たり前）注意してください。以下例  \r\n```\r\n0x12, 0x0A, <JIS X 0208で変換したデータ>\r\n```\r\n\r\n`0x12`は`氏名`のタグです。  \r\n`0x0A`が、この後の値フィールドの長さを16進数で表したものです。10進数に戻した値が値フィールドの長さになります。  \r\n値フィールドは`JIS X 0208`で変換しているので、あとで戻します。\r\n\r\n#### JIS X 0208 を読める形に戻す\r\n上の方でも書きましたが、戻すには、`JIS X 0208`のデータの先頭にエスケープシーケンスとして`0x1B, 0x24, 0x42`を付けて、`JISコード`として変換してあげればいいです。\r\n\r\nKotlinで書くとこうです。(JIS X 0208 制定年番号に書き足す感じで）\r\n\r\n```kotlin\r\n// データを解析する\r\n// 現在のバイト配列の位置？\r\nvar length = 0\r\n\r\n// JIS X 0208\r\nlength = 3\r\nval jisX0208Data = df1Ef01ReadBinaryCommandResult.copyOfRange(0, length)\r\nval jisX0208 = \"%02x\".format(jisX0208Data.last())\r\n\r\n// 名前\r\nval nameLength = df1Ef01ReadBinaryCommandResult[length + 1]\r\nval nameData = df1Ef01ReadBinaryCommandResult.copyOfRange(length + 2, length + 2 + nameLength.toInt())\r\nval escapeSequence = byteArrayOf(0x1b.toByte(), 0x24.toByte(), 0x42.toByte())\r\nval name = String(escapeSequence + nameData, charset(\"jis\"))\r\nlength += 2 + nameLength.toInt()\r\n\r\nval dfEf01FormattedText = \"\"\"\r\n    \r\n    ---\r\n    JIS X 0208 制定年番号：$jisX0208\r\n    名前：$name\r\n\"\"\".trimIndent()\r\ntextView.append(dfEf01FormattedText)\r\nprintln(dfEf01FormattedText)\r\n```\r\n\r\n氏名が出力されたら成功です。おめ  \r\n氏と名の間にはスペースが入ってますが仕様です。\r\n\r\n#### 見ずらいので関数にまとめる\r\n本当はタグフィールドから値を取得する関数を作れればいいんですが、  \r\nタグフィールドで利用している16進数、これ値フィールドでも普通に使われているので多分indexOfとかで検索かけてもうまくいきません。  \r\n\r\nなんで、住所だけが欲しい場合でも順番に取得していく必要があります。それは面倒なので関数を書いて少しだけでも楽になりましょう。\r\n\r\n```kotlin\r\n/**\r\n * 次のデータを取得する\r\n * @param currentPos 今の位置。初回時は0？\r\n * @return Intは、今の位置を返します。２回目以降この関数を呼ぶ際に使ってください、ByteArrayは値フィールドです\r\n * */\r\nprivate fun ByteArray.getValueField(currentPos: Int): Pair<Int, ByteArray> {\r\n    // 長さを読み取る\r\n    val length = this[currentPos + 1]\r\n    return currentPos + 2 + length to copyOfRange(currentPos + 2, currentPos + 2 + length)\r\n}\r\n\r\n/** JIS X 0208で変換されたバイト配列を戻す */\r\nprivate fun ByteArray.toJISX0208(): String {\r\n    // 変換する。JISコードで変換できる。JISコードはエスケープシーケンスにより、文字集合を切り替えることができる\r\n    val escapeSequence = byteArrayOf(0x1B.toByte(), 0x24.toByte(), 0x42.toByte()) // JIS X 0208\r\n    return String(escapeSequence + this, charset(\"jis\"))\r\n}\r\n\r\n/** JIS X 0201で変換されたバイト配列を戻す */\r\nprivate fun ByteArray.toJISX0201(): String {\r\n    // 変換する。JISコードで変換できる。JISコードはエスケープシーケンスにより、文字集合を切り替えることができる\r\n    val escapeSequence = byteArrayOf(0x1B.toByte(), 0x28.toByte(), 0x42.toByte()) // ASCII\r\n    return String(escapeSequence + this, charset(\"jis\"))\r\n}\r\n\r\n/** JIS X 0201で変換されたバイト配列を戻して、日付形式にする */\r\nprivate fun ByteArray.toJISX0201DateString(): String {\r\n    // とりあえずJIS X 0201の変換後データを取得\r\n    val valueField = this.toJISX0201()\r\n    val gengo = when (valueField.first()) {\r\n        '1' -> \"明治\"\r\n        '2' -> \"大正\"\r\n        '3' -> \"昭和\"\r\n        '4' -> \"平成\"\r\n        else -> \"令和\"\r\n    }\r\n    val year = valueField.substring(1, 3)\r\n    val month = valueField.substring(3, 5)\r\n    val date = valueField.substring(5, 7)\r\n    return \"$gengo ${year}年 ${month}月 ${date}日\"\r\n}\r\n```\r\n\r\n上記の拡張関数を利用して、制定年番号、氏名を取得する部分を書き換えるとこんな感じ。\r\n\r\n```kotlin\r\nvar currentPos = 0\r\n// 記載事項を上から順番に取得していく\r\nval byteArrayList = mutableListOf<ByteArray>()\r\nrepeat(17) {\r\n    val (pos, data) = df1Ef01ReadBinaryCommandResult.getValueField(currentPos)\r\n    byteArrayList.add(data)\r\n    currentPos = pos\r\n}\r\n\r\n// JIS X 0208 制定年番号\r\nval jisX0208 = \"%02x\".format(byteArrayList[0].last())\r\n// 名前\r\nval name = byteArrayList[1].toJISX0208()\r\n// 読み\r\nval yomi =  byteArrayList[2].toJISX0208()\r\n// 通称名\r\nval tuusyoumei = byteArrayList[3].toJISX0208()\r\n// 統一氏名\r\nval touitusimei = byteArrayList[4].toJISX0208()\r\n// 生年月日\r\nval birthday = byteArrayList[5].toJISX0201DateString()\r\n// 住所\r\nval location = byteArrayList[6].toJISX0208()\r\n// 交付年月日\r\nval registeredAt =  byteArrayList[7].toJISX0201DateString()\r\n// 照会番号\r\nval syoukaiNum = byteArrayList[8].toJISX0201()\r\n// 免許証の色区分\r\nval color = byteArrayList[9].toJISX0208()\r\n// 有効期限\r\nval endTimeAt =byteArrayList[10].toJISX0201DateString()\r\n// 運転免許の条件。メガネなど\r\nval requirement1 = byteArrayList[11].toJISX0208()\r\nval requirement2 = byteArrayList[12].toJISX0208()\r\nval requirement3 = byteArrayList[13].toJISX0208()\r\nval requirement4 = byteArrayList[14].toJISX0208()\r\n// 公安委員会名\r\nval publicSafetyCommissionName = byteArrayList[15].toJISX0208()\r\n// 運転免許証の番号\r\nval cardNumber = byteArrayList[16].toJISX0201()\r\n\r\nval dfEf01FormattedText = \"\"\"\r\n    \r\n    ---\r\n    JIS X 0208 制定年番号：$jisX0208\r\n    名前：$name\r\n    読み：$yomi\r\n    通称名：$tuusyoumei\r\n    統一氏名：$touitusimei\r\n    住所：$location\r\n    生年月日：$birthday\r\n    交付年月日：$registeredAt\r\n    有効期限：$endTimeAt\r\n    照会番号：$syoukaiNum\r\n    色区分：$color\r\n    運転免許の条件１：$requirement1\r\n    運転免許の条件２：$requirement2\r\n    運転免許の条件３：$requirement3\r\n    運転免許の条件４：$requirement4\r\n    公安委員会名：$publicSafetyCommissionName\r\n    運転免許証の番号：$cardNumber\r\n\"\"\".trimIndent()\r\ntextView.append(dfEf01FormattedText)\r\nprintln(dfEf01FormattedText)\r\n```\r\n\r\n#### 生年月日、交付年月日等の日付のデータについて\r\n生年月日、交付年月日等の日付に関わるデータは`JIS X 0201`で保存されており、  \r\n変換後の先頭の数字は元号を表しており、`明治=1, 大正=2, 昭和=3, 平成=4, 令和=5`になります。（運転免許証IC仕様書11ページ目 注6）  \r\nその次の二文字は、和暦の年を表しています。  \r\nその次の二文字は月、その次の二文字が日になります。  \r\n\r\n例(今更だけど16進数なので`0x`をつけました)：\r\n\r\n```\r\n0x16, 0x07, 0x34, 0x31, 0x34, 0x30, 0x39, 0x31, 0x33\r\n```\r\n\r\n`0x16`が生年月日で有ることを表すタグフィールド、  \r\n`0x07`がこの後続く値フィールドの長さです。10進数にした7バイト分が値フィールドの長さになります。  \r\n`0x34`から`0x33`までが値フィールドの中身です。`JIS X 0201`で変換できます。\r\n\r\n上記のバイト配列を変換した結果です。\r\n\r\n```\r\n4140913\r\n```\r\n\r\n先頭の数字が元号を表しており、`4`の場合は`平成`になります。  \r\n\r\nよって、上記のバイト配列の値は`平成14年 09月 13日`と表すことが出来ます。  \r\n\r\n#### 終わりに\r\n全部くっつけたソースコードです。\r\n\r\n<span style=\"color:red;font-size:20px\">// 暗証番号1を照合する</span>の部分は各自自分の暗証番号を入力してください。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val textView by lazy { findViewById<TextView>(R.id.activity_main_text_view) }\r\n\r\n    /** NFCを検出するのに使う */\r\n    private val nfcAdapter by lazy { NfcAdapter.getDefaultAdapter(this) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        nfcAdapter.enableReaderMode(\r\n            this,\r\n            { tag ->\r\n\r\n                val isoDep = IsoDep.get(tag)\r\n                isoDep.connect()\r\n\r\n                // ここにコマンドを送信するコードを入れる\r\n\r\n                // カレントディレクトリをMFにする\r\n                val mfSelectCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0xA4.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte()\r\n                )\r\n                val mfSelectCommandResult = isoDep.transceive(mfSelectCommand)\r\n                if (mfSelectCommandResult[0] == 0x90.toByte()) {\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        MF選択コマンド 成功\r\n                        ${mfSelectCommandResult.toHexString()}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // カレントディレクトリを共通データ要素に設定する\r\n                val mfEf01SelectCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0xA4.toByte(),\r\n                    0x02.toByte(),\r\n                    0x0C.toByte(),\r\n                    0x02.toByte(),\r\n                    0x2F.toByte(),\r\n                    0x01.toByte(),\r\n                )\r\n                val mfEf01SelectCommandResult = isoDep.transceive(mfEf01SelectCommand)\r\n                if (mfEf01SelectCommandResult[0] == 0x90.toByte()) {\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        DF/EF01 共通データ要素 選択コマンド 成功\r\n                        ${mfEf01SelectCommandResult.toHexString()}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // カレントディレクトリを読み取る\r\n                val mfEf01ReadBinaryCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0xB0.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x11.toByte()\r\n                )\r\n                val mfEf01ReadBinaryCommandResult = isoDep.transceive(mfEf01ReadBinaryCommand)\r\n                // 成功した場合、最後から2番目の16進数が0x90\r\n                if (mfEf01ReadBinaryCommandResult[mfEf01ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n                    // カード発行者データの長さを取得\r\n                    val cardPublisherDataLength = mfEf01ReadBinaryCommandResult[1].toInt() // 多分11\r\n                    // 先頭から cardPublisherDataLength 分のバイト配列取得\r\n                    val cardPublisherDataBinary = mfEf01ReadBinaryCommandResult.copyOfRange(2, 2 + cardPublisherDataLength)\r\n                    // カード発狂者データ、最初の3バイトが仕様書バージョン（SJIS変換後確認可能）、次の4バイトが交付年月日、次の4バイトが有効期限\r\n                    val version = cardPublisherDataBinary.copyOfRange(0, 3).toString(charset(\"sjis\"))\r\n                    val publishDate = cardPublisherDataBinary.copyOfRange(4, 7).joinToString(separator = \"\") { \"%02x\".format(it) }\r\n                    val effectiveDate = cardPublisherDataBinary.copyOfRange(8, 11).joinToString(separator = \"\") { \"%02x\".format(it) }\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        カレントディレクトリ 読み取りコマンド 成功\r\n                        ${mfEf01ReadBinaryCommandResult.toHexString()}\r\n                        仕様書バージョン：$version\r\n                        発行年月日：$publishDate\r\n                        有効期限：$effectiveDate\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // 残り照合可能回数を取得する\r\n                val retryCountVerifyCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0x20.toByte(),\r\n                    0x00.toByte(),\r\n                    0x81.toByte()\r\n                )\r\n                val retryCountVerifyCommandResult = isoDep.transceive(retryCountVerifyCommand)\r\n                println(retryCountVerifyCommandResult.toHexString())\r\n                if (retryCountVerifyCommandResult[0] == 0x63.toByte()) {\r\n                    val retryCountHex = retryCountVerifyCommandResult.last().toInt() - 0xC0 // 0xC0を引けば最後が残る\r\n                    val retryCount = \"%x\".format(retryCountHex).last() // ffffff03みたいな感じになる、ので最後だけ取得\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        残り照合可能回数 読み取りコマンド 成功\r\n                        ${retryCountVerifyCommandResult.toHexString()}\r\n                        残り照合可能回数：$retryCount\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // 暗証番号1を照合する\r\n                val pinCode1CharList = listOf(0, 0, 0, 0) // 各自暗証番号を入力\r\n                val pinCode1EncodedList = pinCode1CharList.map { toJIS(it.toString()[0]) }\r\n                val pinCode1VerifyCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0x20.toByte(),\r\n                    0x00.toByte(),\r\n                    0x81.toByte(),\r\n                    0x04.toByte(),\r\n                ) + pinCode1EncodedList\r\n                val pinCode1VerifyCommandResult = isoDep.transceive(pinCode1VerifyCommand)\r\n                println(pinCode1VerifyCommandResult.toHexString())\r\n                if (pinCode1VerifyCommandResult[pinCode1VerifyCommandResult.size - 2] == 0x90.toByte()) {\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        第一暗証番号の照合 成功\r\n                        ${pinCode1VerifyCommandResult.toHexString()}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // カレントディレクトリをDF1へ\r\n                val df1SelectCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0xA4.toByte(),\r\n                    0x04.toByte(),\r\n                    0x0C.toByte(),\r\n                    0x10.toByte(),\r\n                    0xA0.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x02.toByte(),\r\n                    0x31.toByte(),\r\n                    0x01.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                )\r\n                val df1SelectCommandResult = isoDep.transceive(df1SelectCommand)\r\n                if (df1SelectCommandResult[0] == 0x90.toByte()) {\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        DF1選択 成功\r\n                        ${df1SelectCommandResult.toHexString()}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(text)\r\n                }\r\n\r\n                // 記載事項(DF1/EF01)を読み出す\r\n                val df1Ef01ReadBinaryCommand = byteArrayOf(\r\n                    0x00.toByte(),\r\n                    0xB0.toByte(),\r\n                    0x81.toByte(),\r\n                    0x00.toByte(),\r\n                    0x00.toByte(),\r\n                    0x03.toByte(),\r\n                    0x70.toByte(),\r\n                )\r\n                val df1Ef01ReadBinaryCommandResult = isoDep.transceive(df1Ef01ReadBinaryCommand)\r\n                if (df1Ef01ReadBinaryCommandResult[df1Ef01ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n                    val text = \"\"\"\r\n                        \r\n                        ---\r\n                        DF1/EF01読み出しコマンド 成功\r\n                        データの長さ：${df1Ef01ReadBinaryCommandResult.size}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(text)\r\n                    println(df1Ef01ReadBinaryCommandResult.toHexString())\r\n                    println(text)\r\n\r\n                    var currentPos = 0\r\n                    // 記載事項を上から順番に取得していく\r\n                    val byteArrayList = mutableListOf<ByteArray>()\r\n                    repeat(35) {\r\n                        val (pos, data) = df1Ef01ReadBinaryCommandResult.getValueField(currentPos)\r\n                        byteArrayList.add(data)\r\n                        currentPos = pos\r\n                    }\r\n\r\n                    // JIS X 0208 制定年番号\r\n                    val jisX0208 = \"%02x\".format(byteArrayList[0].last())\r\n                    // 名前\r\n                    val name = byteArrayList[1].toJISX0208()\r\n                    // 読み\r\n                    val yomi = byteArrayList[2].toJISX0208()\r\n                    // 通称名\r\n                    val tuusyoumei = byteArrayList[3].toJISX0208()\r\n                    // 統一氏名\r\n                    val touitusimei = byteArrayList[4].toJISX0208()\r\n                    // 生年月日\r\n                    val birthday = byteArrayList[5].toJISX0201DateString()\r\n                    // 住所\r\n                    val location = byteArrayList[6].toJISX0208()\r\n                    // 交付年月日\r\n                    val registeredAt = byteArrayList[7].toJISX0201DateString()\r\n                    // 照会番号\r\n                    val syoukaiNum = byteArrayList[8].toJISX0201()\r\n                    // 免許証の色区分\r\n                    val color = byteArrayList[9].toJISX0208()\r\n                    // 有効期限\r\n                    val endTimeAt = byteArrayList[10].toJISX0201DateString()\r\n                    // 運転免許の条件。メガネなど\r\n                    val requirement1 = byteArrayList[11].toJISX0208()\r\n                    val requirement2 = byteArrayList[12].toJISX0208()\r\n                    val requirement3 = byteArrayList[13].toJISX0208()\r\n                    val requirement4 = byteArrayList[14].toJISX0208()\r\n                    // 公安委員会名\r\n                    val publicSafetyCommissionName = byteArrayList[15].toJISX0208()\r\n                    // 運転免許証の番号\r\n                    val cardNumber = byteArrayList[16].toJISX0201()\r\n                    // 他の免許\r\n                    val nirin = byteArrayList[17].toJISX0201DateString()\r\n                    val hoka = byteArrayList[18].toJISX0201DateString()\r\n                    val nisyu = byteArrayList[19].toJISX0201DateString()\r\n                    val oogata = byteArrayList[20].toJISX0201DateString()\r\n                    val hutuu = byteArrayList[21].toJISX0201DateString()\r\n                    val oogatatokusyu = byteArrayList[22].toJISX0201DateString()\r\n                    val oogatazidounirin = byteArrayList[23].toJISX0201DateString()\r\n                    val hutuuzidounirin = byteArrayList[24].toJISX0201DateString()\r\n                    val kogatatokusyu = byteArrayList[25].toJISX0201DateString()\r\n                    val gentuki = byteArrayList[26].toJISX0201DateString()\r\n                    val kanninn = byteArrayList[27].toJISX0201DateString()\r\n                    val oogatanisyu = byteArrayList[28].toJISX0201DateString()\r\n                    val hutuunisyu = byteArrayList[29].toJISX0201DateString()\r\n                    val oogataokusyunisyu = byteArrayList[30].toJISX0201DateString()\r\n                    val kenninnnisyu = byteArrayList[31].toJISX0201DateString()\r\n                    val tyuugata = byteArrayList[32].toJISX0201DateString()\r\n                    val tyuugatanisyu = byteArrayList[33].toJISX0201DateString()\r\n                    val zyuntyuugata = byteArrayList[34].toJISX0201DateString()\r\n\r\n                    val dfEf01FormattedText = \"\"\"\r\n                        \r\n                        ---\r\n                        JIS X 0208 制定年番号：$jisX0208\r\n                        名前：$name\r\n                        読み：$yomi\r\n                        通称名：$tuusyoumei\r\n                        統一氏名：$touitusimei\r\n                        住所：$location\r\n                        生年月日：$birthday\r\n                        交付年月日：$registeredAt\r\n                        有効期限：$endTimeAt\r\n                        照会番号：$syoukaiNum\r\n                        色区分：$color\r\n                        運転免許の条件１：$requirement1\r\n                        運転免許の条件２：$requirement2\r\n                        運転免許の条件３：$requirement3\r\n                        運転免許の条件４：$requirement4\r\n                        公安委員会名：$publicSafetyCommissionName\r\n                        運転免許証の番号：$cardNumber\r\n                        免許の年月日(二・小・原)：${nirin ?: \"未取得\"}\r\n                        免許の年月日(他)：${hoka ?: \"未取得\"}\r\n                        免許の年月日(二種)：${nisyu ?: \"未取得\"}\r\n                        免許の年月日(大型)：${oogata ?: \"未取得\"}\r\n                        免許の年月日(普通)：${hutuu ?: \"未取得\"}\r\n                        免許の年月日(大特)：${oogatatokusyu ?: \"未取得\"}\r\n                        免許の年月日(大自二)：${oogatazidounirin ?: \"未取得\"}\r\n                        免許の年月日(普自二)：${hutuuzidounirin ?: \"未取得\"}\r\n                        免許の年月日(小特)：${kogatatokusyu ?: \"未取得\"}\r\n                        免許の年月日(原付)：${gentuki ?: \"未取得\"}\r\n                        免許の年月日(け引)：${kanninn ?: \"未取得\"}\r\n                        免許の年月日(大二)：${oogatanisyu ?: \"未取得\"}\r\n                        免許の年月日(普二)：${hutuunisyu ?: \"未取得\"}\r\n                        免許の年月日(大特二)：${oogataokusyunisyu ?: \"未取得\"}\r\n                        免許の年月日(け引二)：${kenninnnisyu ?: \"未取得\"}\r\n                        免許の年月日(中型)：${tyuugata ?: \"未取得\"}\r\n                        免許の年月日(中二)：${tyuugatanisyu ?: \"未取得\"}\r\n                        免許の年月日(準中型)：${zyuntyuugata ?: \"未取得\"}\r\n                    \"\"\".trimIndent()\r\n                    textView.append(dfEf01FormattedText)\r\n                    println(dfEf01FormattedText)\r\n\r\n                }\r\n\r\n\r\n                isoDep.close()\r\n\r\n            },\r\n            NfcAdapter.FLAG_READER_NFC_B,\r\n            null\r\n        )\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        nfcAdapter.disableReaderMode(this)\r\n    }\r\n\r\n    /** 16進数に変換するやつ */\r\n    private fun ByteArray.toHexString() = this.joinToString { \"%02x\".format(it) }\r\n\r\n    /**\r\n     * 次のデータを取得する\r\n     * @param currentPos 今の位置。初回時は0？\r\n     * @return Intは、今の位置を返します。２回目以降この関数を呼ぶ際に使ってください、ByteArrayは値フィールドです\r\n     * */\r\n    private fun ByteArray.getValueField(currentPos: Int): Pair<Int, ByteArray> {\r\n        // 長さを読み取る\r\n        val length = this[currentPos + 1]\r\n        return currentPos + 2 + length to copyOfRange(currentPos + 2, currentPos + 2 + length)\r\n    }\r\n\r\n    /** JIS X 0208で変換されたバイト配列を戻す */\r\n    private fun ByteArray.toJISX0208(): String {\r\n        // 変換する。JISコードで変換できる。JISコードはエスケープシーケンスにより、文字集合を切り替えることができる\r\n        val escapeSequence = byteArrayOf(0x1B.toByte(), 0x24.toByte(), 0x42.toByte()) // JIS X 0208\r\n        return String(escapeSequence + this, charset(\"jis\"))\r\n    }\r\n\r\n    /** JIS X 0201で変換されたバイト配列を戻す */\r\n    private fun ByteArray.toJISX0201(): String {\r\n        // 変換する。JISコードで変換できる。JISコードはエスケープシーケンスにより、文字集合を切り替えることができる\r\n        val escapeSequence = byteArrayOf(0x1B.toByte(), 0x28.toByte(), 0x42.toByte()) // ASCII\r\n        return String(escapeSequence + this, charset(\"jis\"))\r\n    }\r\n\r\n    /**\r\n     * JIS X 0201で変換されたバイト配列を戻して、日付形式にする\r\n     * @return nullの場合は不正な値の場合（例えば普通免許以外持っていない場合は00000なのでそのときはnullを返します。）\r\n     * */\r\n    private fun ByteArray.toJISX0201DateString(): String? {\r\n        // とりあえずJIS X 0201の変換後データを取得\r\n        val valueField = this.toJISX0201()\r\n        // 持ってない免許の場合は (元号)000000 なので\r\n        if (valueField.contains(\"000000\")) return null\r\n        val gengo = when (valueField.first()) {\r\n            '1' -> \"明治\"\r\n            '2' -> \"大正\"\r\n            '3' -> \"昭和\"\r\n            '4' -> \"平成\"\r\n            else -> \"令和\"\r\n        }\r\n        val year = valueField.substring(1, 3)\r\n        val month = valueField.substring(3, 5)\r\n        val date = valueField.substring(5, 7)\r\n        return \"$gengo ${year}年 ${month}月 ${date}日\"\r\n    }\r\n\r\n    /** 数値文字をJIS X 0201にエンコードする */\r\n    private fun toJIS(c: Char): Byte {\r\n        return when (c) {\r\n            '0' -> 0x30\r\n            '1' -> 0x31\r\n            '2' -> 0x32\r\n            '3' -> 0x33\r\n            '4' -> 0x34\r\n            '5' -> 0x35\r\n            '6' -> 0x36\r\n            '7' -> 0x37\r\n            '8' -> 0x38\r\n            '9' -> 0x39\r\n            else -> 0x00\r\n        }.toByte()\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 番外編 本籍を読み出す\r\n本籍を読み出すには、暗証番号2の照合を通過する必要があります。\r\n\r\n```kotlin\r\n// MFを選択する\r\nval pin2MfSelectCommandResult = isoDep.transceive(mfSelectCommand)\r\n\r\n// IEF02(暗証番号２)を指定したVERIFYコマンドを送る\r\nval pinCode2CharList = \"0000\".toCharArray() // 各自暗証番号を入力\r\nval pinCode2EncodedList = pinCode2CharList.map { toJIS(it.toString()[0]) }\r\nval pinCode2VerifyCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0x20.toByte(),\r\n    0x00.toByte(),\r\n    0x82.toByte(), // IEF02選択\r\n    0x04.toByte(),\r\n) + pinCode2EncodedList\r\nval pinCode2VerifyCommandResult = isoDep.transceive(pinCode2VerifyCommand)\r\n\r\n// 本籍を読み出すためにDF1へ移動\r\nval pin2Df1SelectCommandResult = isoDep.transceive(df1SelectCommand)\r\n\r\n// 本籍（DF1/EF02）を読み出す\r\nval df1Ef02ReadBinaryCommand = byteArrayOf(\r\n    0x00.toByte(),\r\n    0xB0.toByte(),\r\n    0x82.toByte(),\r\n    0x00.toByte(),\r\n    0x00.toByte(),\r\n    0x03.toByte(),\r\n    0x70.toByte(),\r\n)\r\nval df1Ef02ReadBinaryCommandResult = isoDep.transceive(df1Ef02ReadBinaryCommand)\r\nif (df1Ef02ReadBinaryCommandResult[df1Ef02ReadBinaryCommandResult.size - 2] == 0x90.toByte()) {\r\n    val honsekiLength = df1Ef02ReadBinaryCommandResult[1]\r\n    val honsekiData = df1Ef02ReadBinaryCommandResult.copyOfRange(2, 2 + honsekiLength)\r\n    honseki = honsekiData.toJISX0208()\r\n}\r\n```\r\n\r\n# 面倒なので\r\nライブラリ書きました。多分簡単に使えます。\r\n\r\nhttps://github.com/takusan23/JDCardReaderCore\r\n\r\n使い方はREADME https://github.com/takusan23/JDCardReaderCore/blob/master/README.md 読んでください。\r\n\r\n# 参考にしました\r\nありがとうございます\r\n\r\nhttps://qiita.com/treastrain/items/f95ee3f99c6b6111e999  \r\nhttps://qiita.com/ikazayim/items/2e9b8bdca96db6bf34cb  \r\nhttps://www.npa.go.jp/laws/notification/koutuu/menkyo/menkyo20210630_150.pdf\r\n\r\n# 終わりに\r\n選択不可のPDFもFirefoxなら選択出来ます。\r\n\r\n8月一瞬で終わった気がするんだけどなに？"},{"title":"AndroidのNonNullアノテーションはnullを返す場合があり、Kotlinで問題になる話","link":"/posts/android_nonnull_annotation_kotlin/","markdown":"\r\n# Android 「この値は @NonNull やで」→ Kotlin 「ほな厳密なnullチェックするで」→ Android 「実行時にやっぱ null 返すわ！」→ NullPointerException\r\nうそつくな\r\n\r\n# 本題\r\n`Android`の`@NonNull`アノテーションはたまによく`null`を渡す。これが`Java`なら問題なかったけど、`Kotlin`だと例外で落ちてしまうって話。\r\n\r\n## おことわり\r\n本記事で言う`@NonNull`は`android.annotation`、`androidx.annotation`のことです。\r\n\r\n![Imgur](https://imgur.com/jbCinCs.png)\r\n\r\n# 修正する\r\n多分2パターン存在します。\r\n\r\n## Javaファイルを作成し、@NonNullなインターフェースを継承し、@NonNullを全部@Nullableにする\r\n`.java`を作る必要があるので、なんか負けた気分になります（が、`Android`が`@NonNull`守らないのが悪いので仕方ない、、、）\r\n\r\n例えば、こんな感じにJavaで書かれたインターフェースに`@NonNull`がついている場合  \r\n（以下は`Android`の`OnGestureListener`です）  \r\n```java\r\npublic interface OnGestureListener {\r\n    boolean onDown(@NonNull MotionEvent e);\r\n\r\n    void onShowPress(@NonNull MotionEvent e);\r\n\r\n    boolean onSingleTapUp(@NonNull MotionEvent e);\r\n\r\n    boolean onScroll(@NonNull MotionEvent e1, @NonNull MotionEvent e2, float distanceX, float distanceY);\r\n\r\n    void onLongPress(@NonNull MotionEvent e);\r\n\r\n    boolean onFling(@NonNull MotionEvent e1, @NonNull MotionEvent e2, float velocityX, float velocityY);\r\n}\r\n```\r\n\r\n自前でこのインターフェースを継承するインターフェースを作成し、`@NonNull`を`@Nullable`に置き換えます。  \r\nこのとき**Java**で作成する必要があります。\r\n\r\n```java\r\nimport android.view.GestureDetector;\r\nimport android.view.MotionEvent;\r\n\r\nimport androidx.annotation.Nullable;\r\n\r\n/** OnGestureListener を Nullable にしたもの */\r\npublic interface NullableOnGestureListener extends GestureDetector.OnGestureListener {\r\n\r\n    @Override\r\n    boolean onDown(@Nullable MotionEvent e);\r\n\r\n    @Override\r\n    void onShowPress(@Nullable MotionEvent e);\r\n\r\n    @Override\r\n    boolean onSingleTapUp(@Nullable MotionEvent e);\r\n\r\n    @Override\r\n    boolean onScroll(@Nullable MotionEvent e1, @Nullable MotionEvent e2, float distanceX, float distanceY);\r\n\r\n    @Override\r\n    void onLongPress(@Nullable MotionEvent e);\r\n\r\n    @Override\r\n    boolean onFling(@Nullable MotionEvent e1, @Nullable MotionEvent e2, float velocityX, float velocityY);\r\n}\r\n```\r\n\r\nこれで、`Kotlin`でも`Nullable`として扱ってくれるので、`null`が入ってきた場合でも落ちなくなります。  \r\n`MotionEvent`が全部`Nullable`になりました。やったね\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity(), NullableOnGestureListener {\r\n\r\n    override fun onDown(e: MotionEvent?): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onShowPress(e: MotionEvent?) {\r\n        // TODO\r\n    }\r\n\r\n    override fun onSingleTapUp(e: MotionEvent?): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onLongPress(e: MotionEvent?) {\r\n        // TODO\r\n    }\r\n\r\n    override fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    // 省略...\r\n}\r\n```\r\n\r\n## もう一つ\r\nこれはやっていいのかわからないのですが、どうしても`Kotlin`で完結させたい場合は使えます。  \r\n`Suppress`で黙らせるやつですね。引数が`NonNull`から`Nullable`になるだけ（引数が増えているわけではない）なので、おそらく実行時に落ちることはないと思いますが、、、\r\n\r\n```kotlin\r\n@Suppress(\"NOTHING_TO_OVERRIDE\", \"ACCIDENTAL_OVERRIDE\", \"ABSTRACT_MEMBER_NOT_IMPLEMENTED\")\r\nclass MainActivity : ComponentActivity(), GestureDetector.OnGestureListener {\r\n\r\n    override fun onDown(e: MotionEvent?): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onShowPress(e: MotionEvent?) {\r\n        // TODO\r\n    }\r\n\r\n    override fun onSingleTapUp(e: MotionEvent?): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    override fun onLongPress(e: MotionEvent?) {\r\n        // TODO\r\n    }\r\n\r\n    override fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean {\r\n        // TODO\r\n    }\r\n\r\n    // 省略....\r\n}\r\n```\r\n\r\n# 事の発端\r\n\r\n```plaintext\r\njava.lang.NullPointerException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkNotNullParameter, parameter cellInfo\r\n\tat io.github.takusan23.newradiosupporter.tool.NetworkCallbackTool$listenNetworkStatus$1$callback$1.onCellInfoChanged(Unknown Source:2)\r\n\tat android.telephony.TelephonyCallback$IPhoneStateListenerStub.lambda$onCellInfoChanged$18(TelephonyCallback.java:1504)\r\n\tat android.telephony.TelephonyCallback$IPhoneStateListenerStub$$ExternalSyntheticLambda41.run(Unknown Source:4)\r\n\tat android.os.Handler.handleCallback(Handler.java:938)\r\n\tat android.os.Handler.dispatchMessage(Handler.java:99)\r\n\tat android.os.Looper.loopOnce(Looper.java:346)\r\n\tat android.os.Looper.loop(Looper.java:475)\r\n\tat android.app.ActivityThread.main(ActivityThread.java:7889)\r\n\tat java.lang.reflect.Method.invoke(Native Method)\r\n\tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)\r\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1009)\r\n```\r\n\r\n`onCellInfoChanged`で`NullPointerException`になってしまう。  \r\n原因は`onCellInfoChanged`を`Android`が呼び出す際に`cellInfo`を`null`で渡しているため、、、\r\n\r\n```java\r\n/**\r\n * Interface for cell info listener.\r\n */\r\npublic interface CellInfoListener {\r\n    /**\r\n     * Callback invoked when a observed cell info has changed or new cells have been added\r\n     * or removed on the registered subscription.\r\n     * Note, the registration subscription ID s from {@link TelephonyManager} object\r\n     * which registers TelephonyCallback by\r\n     * {@link TelephonyManager#registerTelephonyCallback(Executor, TelephonyCallback)}.\r\n     * If this TelephonyManager object was created with\r\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\r\n     * subscription ID. Otherwise, this callback applies to\r\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\r\n     *\r\n     * @param cellInfo is the list of currently visible cells.\r\n     */\r\n    @RequiresPermission(allOf = {\r\n            Manifest.permission.READ_PHONE_STATE,\r\n            Manifest.permission.ACCESS_FINE_LOCATION\r\n    })\r\n    void onCellInfoChanged(@NonNull List<CellInfo> cellInfo);\r\n}\r\n```\r\n\r\n## Androidの@NonNullアノテーション\r\nこれ単純に**ビルド時**に`null`の可能性があるときに警告を出すものなので、ライブラリ開発者とかは意識するといいかもしれないですが、それ以外ならぶっちゃけ無くてもまあ、、、\r\n\r\n```java\r\npublic class NonNullCheck {\r\n\r\n    NonNullCheck() {\r\n        methodA(\"はい\");\r\n        // 警告が出るだけでビルドは通ってしまう\r\n        methodA(null);\r\n    }\r\n\r\n    private void methodA(@NonNull String argA) {\r\n        // NonNull でも null 入るときは入るので\r\n        if (argA == null) {\r\n            return;\r\n        }\r\n        System.out.println(argA);\r\n    }\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/wPkCSwj.png)\r\n\r\n## 一方 Kotlin の NonNull\r\n`Kotlin`は`Null`を厳格にチェックするため、`?`がついていない引数はビルドも通らないし、実行時も落ちるようになっています。  \r\n\r\n```kotlin\r\nclass NonNullCheckKt {\r\n\r\n    init {\r\n        methodA(\"はい\")\r\n        // ビルドは通らない\r\n        methodA(null)\r\n    }\r\n\r\n    fun methodA(argA: String) {\r\n        // argA は null にはならない\r\n    }\r\n\r\n}\r\n```\r\n\r\nまた実行時にも`NonNull`は機能し、関数内に引数が`null`ではないことを確認する処理が自動で挿入されています。  \r\n（全然Androidとは関係ない`Kotlin`プロジェクトだけど変わらないはず）\r\n\r\n```kotlin\r\n/**\r\n * ドロップ数を返す。失敗したら1\r\n *\r\n * @param itemStack アイテム\r\n * */\r\nprivate fun getDropSize(itemStack: ItemStack): Int {\r\n    return itemStack.name.string.toIntOrNull() ?: 1\r\n}\r\n```\r\n\r\n逆コンパイルすると`nullチェック`する関数が挿入されている\r\n```java\r\nprivate final int getDropSize(class_1799 itemStack) {\r\n  Intrinsics.checkNotNullExpressionValue(itemStack.method_7964().getString(), \"itemStack.name.string\");\r\n  StringsKt.toIntOrNull(itemStack.method_7964().getString());\r\n  return (StringsKt.toIntOrNull(itemStack.method_7964().getString()) != null) ? StringsKt.toIntOrNull(itemStack.method_7964().getString()).intValue() : 1;\r\n}\r\n```\r\n\r\n## Javaで書いた@NonNullはKotlinだと？\r\nさて、`@NonNull`でも実行時は`null`を渡す可能性がある話をしましたが、、、いかが。  \r\n\r\nまぁ予想通り`Kotlin`でもアノテーションを尊重して`NonNull`として扱われます。  \r\nhttps://kotlinlang.org/docs/java-interop.html#nullability-annotations\r\n\r\n今回、`@NonNull`が`Java`の場合に落ちないけど、`Kotlin`の場合にいきなり落ちるようになったのはこの影響です。\r\n\r\n\r\n```java\r\npublic interface NonNullInterface {\r\n    void onCallback(@NonNull String string);\r\n}\r\n```\r\n\r\n```kotlin\r\nclass NonNullCheckKt : NonNullInterface {\r\n    override fun onCallback(string: String) {\r\n\r\n    }\r\n}\r\n```\r\n\r\n以上です。  \r\n\r\n# おわりに\r\n`targetSdk = 33`から、`MotionEvent`が`NonNull`になった影響でわりと`Issue`がちらほら（全然良くない；；）\r\n\r\n- https://issuetracker.google.com/issues/243267018\r\n    - NonNull 無視して null 入れてる\r\n- https://youtrack.jetbrains.com/issue/KT-53963\r\n    - 強制的にNullableする機能についてKotlin側は拒否した模様（だってAndroidが100悪いもんね）\r\n\r\nちなみに私が引っかかった`onCellInfoChanged`に関しても`null`を返さないよう修正されたそうですが、古いバージョンには残り続けるでしょうね、、、  \r\nhttps://issuetracker.google.com/issues/237308373"},{"title":"Androidで楽天回線を判断するアプリを書く","link":"/posts/android_rakuten_kaisen/","markdown":"どうもこんにちは。\r\n\r\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">楽天の自社回線拾えず <a href=\"https://t.co/74fWoB3ENK\">pic.twitter.com/74fWoB3ENK</a></p>&mdash; たくさん (@takusan__23) <a href=\"https://twitter.com/takusan__23/status/1378719149954752514?ref_src=twsrc%5Etfw\">April 4, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\r\n\r\n家ではBand 26しか掴みません。  \r\nエリアマップでは対応してるっぽいので、恐らくau回線のほうが安定してるからauの方に繋がっちゃうとかそういう事なのかな。\r\n\r\n# 本題\r\n楽天回線か判断するアプリを書きます。\r\n\r\n# 環境\r\n\r\n| なまえ                    | あたい                                                               |\r\n|---------------------------|----------------------------------------------------------------------|\r\n| Android                   | 11                                                                   |\r\n| 端末                      | Sony Xperia 5 mk 2 （念願の高リフレッシュレート + SDカード対応端末） |\r\n| 言語                      | Kotlin                                                               |\r\n| 最低Android SDKバージョン | 28 (Android 9 以降)                                                |\r\n\r\n# 作り方\r\n\r\n## app/build.gradle\r\n\r\nViewBindingを有効にしてください。\r\n\r\n```\r\nandroid {\r\n    compileSdkVersion 30\r\n    buildToolsVersion \"30.0.3\"\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.whereisrakutenarea\"\r\n        minSdkVersion 28\r\n        targetSdkVersion 30\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    // これ\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n}\r\n```\r\n\r\nあと、`Activity Result API`を使いたいので以下のように\r\n\r\n```\r\ndependencies {\r\n\r\n    // Activity Result API\r\n    implementation 'androidx.activity:activity-ktx:1.3.0-alpha06'\r\n    implementation 'androidx.fragment:fragment-ktx:1.3.2'\r\n\r\n    // 以下省略\r\n}\r\n```\r\n\r\n## activity_main.xml\r\nまあTextViewと取得用Buttonを置いておきましょう\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <TextView\r\n        android:id=\"@+id/textView\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"ボタンを押して回線確認\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintLeft_toLeftOf=\"parent\"\r\n        app:layout_constraintRight_toRightOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginTop=\"16dp\"\r\n        android:text=\"回線確認\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/textView\" />\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## MainActivity.kt\r\n### 権限の確認\r\n\r\n`Activity Result API`が便利すぎる。権限を使いたいので付与をお願いします的なメッセージを出したほうが親切だと思う。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 権限コールバック */\r\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\r\n        if (isGranted) {\r\n            // 権限確保\r\n            checkRakutenNetwork()\r\n        }\r\n    }\r\n\r\n    /** ViewBinding */\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        start()\r\n\r\n        // ボタンを押したとき\r\n        viewBinding.button.setOnClickListener {\r\n            start()\r\n        }\r\n\r\n    }\r\n\r\n    /** 権限があれば回線チェックを行う */\r\n    private fun start() {\r\n        // 権限の確認\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            // 権限がある\r\n            checkRakutenNetwork()\r\n        } else {\r\n            // 無い\r\n            Toast.makeText(this, \"接続状態へのアクセスに権限が必要ですので付与をお願いします。\", Toast.LENGTH_SHORT).show()\r\n            permissionCallBack.launch(Manifest.permission.ACCESS_FINE_LOCATION)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 楽天回線か確認する関数\r\n\r\n関数内に関数があるけど気にしないで\r\n\r\n```kotlin\r\n/** 楽天の自社回線に繋がっているか確認する関数 */\r\nprivate fun checkRakutenNetwork() {\r\n    /** 関数内に関数を書く。TextViewに回線名を入れる */\r\n    fun setTextViewOperatorName(cellInfo: CellInfo) {\r\n        viewBinding.textView.text = when (cellInfo) {\r\n            // 3G\r\n            is CellInfoWcdma -> {\r\n                cellInfo.cellIdentity.operatorAlphaLong\r\n            }\r\n            // LTE\r\n            is CellInfoLte -> {\r\n                cellInfo.cellIdentity.earfcn\r\n                cellInfo.cellIdentity.operatorAlphaShort\r\n            }\r\n            // 5G (NR)\r\n            is CellInfoNr -> {\r\n                cellInfo.cellIdentity.operatorAlphaShort\r\n            }\r\n            else -> \"不明\"\r\n        }\r\n    }\r\n    val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            // Android 10以降は前取得したデータを使い回す仕様のため、新しく取ってきてもらうために分岐\r\n            telephonyManager.requestCellInfoUpdate(mainExecutor, object : TelephonyManager.CellInfoCallback() {\r\n                override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\r\n                    setTextViewOperatorName(cellInfo[0])\r\n                }\r\n            })\r\n        }\r\n    } else {\r\n        val cellInfoList = telephonyManager.allCellInfo\r\n        setTextViewOperatorName(cellInfoList[0])\r\n    }\r\n}\r\n```\r\n\r\n## 全体\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 権限コールバック */\r\n    private val permissionCallBack = registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted ->\r\n        if (isGranted) {\r\n            // 権限確保\r\n            checkRakutenNetwork()\r\n        }\r\n    }\r\n\r\n    /** ViewBinding */\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        start()\r\n\r\n        // ボタンを押したとき\r\n        viewBinding.button.setOnClickListener {\r\n            start()\r\n        }\r\n\r\n    }\r\n\r\n    /** 権限があれば回線チェックを行う */\r\n    private fun start() {\r\n        // 権限の確認\r\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            // 権限がある\r\n            checkRakutenNetwork()\r\n        } else {\r\n            // 無い\r\n            Toast.makeText(this, \"接続状態へのアクセスに権限が必要ですので付与をお願いします。\", Toast.LENGTH_SHORT).show()\r\n            permissionCallBack.launch(Manifest.permission.ACCESS_FINE_LOCATION)\r\n        }\r\n    }\r\n\r\n    /** 楽天の自社回線に繋がっているか確認する関数 */\r\n    private fun checkRakutenNetwork() {\r\n\r\n        /** 関数内に関数を書く。TextViewに回線名を入れる */\r\n        fun setTextViewOperatorName(cellInfo: CellInfo) {\r\n            viewBinding.textView.text = when (cellInfo) {\r\n                // 3G\r\n                is CellInfoWcdma -> {\r\n                    cellInfo.cellIdentity.operatorAlphaLong\r\n                }\r\n                // LTE\r\n                is CellInfoLte -> {\r\n                    cellInfo.cellIdentity.operatorAlphaShort\r\n                }\r\n                // 5G (NR)\r\n                is CellInfoNr -> {\r\n                    cellInfo.cellIdentity.operatorAlphaShort\r\n                }\r\n                else -> \"不明\"\r\n            }\r\n        }\r\n\r\n        val telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n            if (ActivityCompat.checkSelfPermission(\r\n                    this,\r\n                    Manifest.permission.ACCESS_FINE_LOCATION\r\n                ) == PackageManager.PERMISSION_GRANTED\r\n            ) {\r\n                // Android 10以降は前取得したデータを使い回す仕様のため、新しく取ってきてもらうために分岐\r\n                telephonyManager.requestCellInfoUpdate(\r\n                    mainExecutor,\r\n                    object : TelephonyManager.CellInfoCallback() {\r\n                        override fun onCellInfo(cellInfo: MutableList<CellInfo>) {\r\n                            setTextViewOperatorName(cellInfo[0])\r\n                        }\r\n                    })\r\n            }\r\n        } else {\r\n            val cellInfoList = telephonyManager.allCellInfo\r\n            setTextViewOperatorName(cellInfoList[0])\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n実行するとこんな感じ\r\n\r\n![Imgur](https://imgur.com/cE33GZT.png)\r\n\r\n# ソースコードです\r\n\r\nhttps://github.com/takusan23/WhereIsRakutenArea\r\n\r\n# おわりに\r\n新しめのAndroidでしかこの方法が使えない。  \r\nAndroid 7以降は`EARFCN`を取得するAPIが使えるので、  \r\n**EARFCN取得→バンド/EARFCNの表と照合→接続中バンドを取得→バンド3なら楽天回線！**  \r\nみたいな方法もあります（そのうち書きたい）。\r\n\r\n以上です。今日は夜勤"},{"title":"Roomのバックアップを取りたい","link":"/posts/android_room_backup/","markdown":"家の回線調子わるい\r\n\r\n# 本題\r\nAndroidのデータベース、Roomのバックアップを取りたい  \r\n他のスマホにデータベースを移したい\r\n\r\n## データベースのファイル　どこ？\r\n`data/data/${packageName}/databases`にある。  \r\nなおこんな面倒なことしなくても、`Context#databaseList()`を使うとこのフォルダに入ってるファイルの名前を配列で返してくれるし、  \r\nこれを使って`Context#getDatabasePath()`を使えばパスが取れる。\r\n\r\nなお、`data/data`は`root`権限がないと見れないが、開発中のアプリはAndroid Studioの`Device File Explorer`から見ることができる。\r\n\r\n## どれがデータベースのファイル？\r\n`.db`と`.db-shm`と`.db-wal`をコピーすれば多分見れる。  \r\n`.db`ファイル一個だけにしたい場合は、`Room.databaseBuilder`のときに`setJournalMode(RoomDatabase.JournalMode.TRUNCATE)`を呼べばもしかすると`.db`一個だけになるかもしれない。\r\n\r\n```kotlin\r\nnicoHistoryDB = Room.databaseBuilder(context, NicoHistoryDB::class.java, \"NicoHistory.db\")\r\n    .setJournalMode(RoomDatabase.JournalMode.TRUNCATE) // これ\r\n    .build()\r\n```\r\n\r\n# バックアップ\r\n今回は`Context#getExternalFileDir()`の場所に保存したいと思います。  \r\nなお`Android 10`まではファイルマネージャーで見ることができますが、`Android 11`ではサードパーティファイルマネージャーでは見れません。  \r\nAndroid標準のファイルマネージャー（`com.google.android.documentui`）を開ければ見れると思います（Pixel以外はしらん）\r\n\r\n```kotlin\r\n// アプリ固有ストレージに逃がす\r\ncontext.databaseList()\r\n    .map { name -> context.getDatabasePath(name) }\r\n    .forEach { dbFile ->\r\n        // アプリ固有ストレージ（外部）に保存する\r\n        File(context.getExternalFilesDir(null), dbFile.name).let { file ->\r\n            // ファイル作成\r\n            file.createNewFile()\r\n            // データ書き込み\r\n            file.writeBytes(dbFile.readBytes())\r\n        }\r\n    }\r\n```\r\n\r\n`sdcard/Android/data/パッケージ名/files`にあると思います。  \r\nなんか思ったよりきれいに書きことができた\r\n\r\n# リストア\r\nコピーのときと同じように、`Context#getExternalFilesDir()`にデータベースのデータが有るとして、  \r\nそいつらを`data/data/パッケージ名/databases`に移せばおｋ\r\n\r\n```kotlin\r\n// データベースのパス。Context#getDataDir()はAndroid 7以降のみなのでCompatを使う\r\nval dbFolder = File(ContextCompat.getDataDir(context), \"databases\")\r\n// アプリ固有ストレージ（外部）のファイルを取り出す\r\ncontext.getExternalFilesDir(null)?.listFiles()?.forEach { dbFile ->\r\n    File(dbFolder, dbFile.name).let { file ->\r\n        // ファイル作成\r\n        file.createNewFile()\r\n        // データ書き込み\r\n        file.writeBytes(dbFile.readBytes())\r\n    }\r\n}\r\n```\r\n\r\n# ファイルピッカーで選ばせたほうがいいよね\r\n`Storage Access Framework`でユーザーにファイルを選ばせる（作成、復元）ほうがいいと思います。    \r\nただ複数のファイルを選ぶ機能は`SAF`には(多分)無いので、データベースのファイルを`zip`ファイルにまとめて扱うことになりそう（他にもあるかも）  \r\n\r\nというわけで例です：\r\n\r\n`Activity Result API`を使うので、`app/build.gradle`に数行足してください。\r\n\r\n```gradle\r\ndependencies {\r\n    // Activity Result APIでonActivityResultを駆逐する。\r\n    implementation 'androidx.activity:activity-ktx:1.3.0-alpha02'\r\n    implementation 'androidx.fragment:fragment-ktx:1.3.0'\r\n\r\n}\r\n```\r\n\r\n## バックアップする\r\n\r\n```kotlin\r\n/** データベースをバックアップする */\r\nclass BackupActivity : AppCompatActivity() {\r\n\r\n    /** Activity Result API を使う。[AppCompatActivity.onActivityResult]の後継 */\r\n    private val callback = registerForActivityResult(ActivityResultContracts.CreateDocument()) { uri ->\r\n        if (uri != null) {\r\n            // ZIP作成。\r\n            val outputStream = contentResolver.openOutputStream(uri)\r\n            ZipOutputStream(outputStream).let { zip ->\r\n                /**\r\n                 * データベースフォルダをすべてZipに入れる\r\n                 * */\r\n                databaseList()\r\n                    .map { name -> getDatabasePath(name) }\r\n                    // よくわからんファイルは持ってこない。\r\n                    .filter { file -> !file.name.contains(\"com.google.android.datatransport\") }\r\n                    .forEach { file ->\r\n                        val inputStream = file.inputStream() // ファイル読み出し\r\n                        val entry = ZipEntry(file.name) // ファイル名\r\n                        zip.putNextEntry(entry)\r\n                        zip.write(inputStream.readBytes()) // 書き込む。Kotlinかんたんすぎい\r\n                        inputStream.close()\r\n                        zip.closeEntry()\r\n                    }\r\n                // おしまい\r\n                zip.close()\r\n                // 終了\r\n                Toast.makeText(this, \"バックアップできた\", Toast.LENGTH_SHORT).show()\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_backup)\r\n\r\n        // Storage Access Framework開始\r\n        callback.launch(\"backup.zip\")\r\n\r\n    }\r\n}\r\n```\r\n\r\n## リストアする\r\n\r\n```kotlin\r\n/** リストアするActivity */\r\nclass RestoreActivity : AppCompatActivity() {\r\n\r\n    /** Activity Result API を使う。[AppCompatActivity.onActivityResult]の後継 */\r\n    private val callback = registerForActivityResult(ActivityResultContracts.OpenDocument()) { uri ->\r\n        if (uri != null) {\r\n            // データベースが保存されているフォルダのパス。ContextCompatで後方互換性もはいばっちり！\r\n            val databaseFolder = File(ContextCompat.getDataDir(this), \"databases\")\r\n            // 一応前のデータを消す\r\n            databaseFolder.listFiles()?.forEach { file -> file.delete() }\r\n            // Zip展開\r\n            val inputStream = contentResolver.openInputStream(uri)\r\n            ZipInputStream(inputStream).let { zip ->\r\n                var zipEntry: ZipEntry?\r\n                // Zip内のファイルをなくなるまで繰り返す\r\n                while (zip.nextEntry.also { zipEntry = it } != null) {\r\n                    if (zipEntry != null) {\r\n                        // コピー先ファイル作成\r\n                        val dbFile = File(databaseFolder, zipEntry!!.name)\r\n                        dbFile.createNewFile()\r\n                        // データを書き込む\r\n                        dbFile.writeBytes(zip.readBytes())\r\n                    }\r\n                }\r\n            }\r\n            // おわった\r\n            Toast.makeText(this, \"リストアおわった\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_restore)\r\n\r\n        // Storage Access Framework\r\n        callback.launch(arrayOf(\"*/*\")) // application/zip 動かないのかな\r\n\r\n    }\r\n}\r\n```\r\n\r\n以上です。\r\n\r\n# おわりに\r\n```\r\nCaused by: java.lang.IllegalArgumentException: Can only use lower 16 bits for requestCode\r\n```\r\n\r\nこれは、`app/build.gradle`に`implementation 'androidx.fragment:fragment-ktx:1.3.0'`を付け足すと直ります？  \r\n`Activity`しか使わんしって思ったんですけどだめっぽいです。"},{"title":"SQLiteの思い出をRoomへお引越しする","link":"/posts/android_sqlite_to_room/","markdown":"\r\n進路どーすっかな\r\n\r\n# 本題\r\n既存のAndroidアプリにデータベースを追加したいわけですが、これから作るならRoomをやっぱ使いたいわけですよ。  \r\nでもRoomとSQLite（旧式）が共存してるのなんか気持ち悪いので**めっちゃ面倒くさそうだけど**Roomへ移行しようというわけです。\r\n\r\n# 環境\r\n| なまえ  | あたい    |\r\n|---------|-----------|\r\n| Android | 11 Beta 2 |\r\n| 言語    | Kotlin    |\r\n\r\n# やること\r\nSQLite -> Room\r\n\r\n# ライブラリを入れる\r\n## build.gradleを開いて\r\n以下のコードを足します。  \r\nファイルの一番上に`apply plugin: 'kotlin-kapt'`を書かないとエラー出ます。  \r\nあとついでにコルーチンも入れましょう。無くても`thread {}`使って別スレッドで扱えば使えますがコールバック地獄になるのでやめとこう\r\n\r\n```gradle\r\napply plugin: 'kotlin-kapt' // 一番上に\r\n\r\ndependencies {\r\n\r\n    // Room\r\n    def room_version = \"2.2.5\"\r\n    implementation \"androidx.room:room-runtime:$room_version\"\r\n    implementation \"androidx.room:room-ktx:$room_version\"\r\n    kapt \"androidx.room:room-compiler:$room_version\"\r\n    \r\n    // Coroutines\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4\"\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4\"\r\n   \r\n    // 省略...\r\n\r\n}\r\n```\r\n\r\n# なんでコルーチン\r\n\r\n**RoomはUIスレッドでは使えません。**  \r\nだからコルーチンが必要だったのですね。\r\n\r\n# Roomの構成\r\nRoomさんは3つのコンポーネントで成り立ってます。\r\n\r\n- RoomDatabase\r\n    - データベースの中心的な役割\r\n    - 説明がめんどいし何するのかよくわかっていない。\r\n    - DAOにはこいつが必要\r\n- Entity\r\n    - テーブル。Excelだと一番上の行。\r\n    - データベースの中身を定義する（主キーとか）\r\n- DAO\r\n    - データベースへアクセスする際に使う関数を定義する\r\n    - クエリも入力補助が付いたので間違いが減った（＋実行前に間違いが分かるようになってる）\r\n\r\n# 移行する\r\n流石にちょっと怖くね？\r\n\r\n## Entityを作成する\r\n今回はファイル名を`CommentCollectionEntity.kt`とします。  \r\n\r\n### 例\r\n\r\nSQLiteHelperがこうなっているとして\r\n\r\n```kotlin\r\n// データーベース名\r\nprivate val DATABASE_NAME = \"CommentCollection.db\"\r\nprivate val TABLE_NAME = \"comment_collection_db\"\r\nprivate val DESCRIPTION = \"description\"\r\nprivate val YOMI = \"yomi\"\r\nprivate val COMMENT = \"comment\"\r\nprivate val _ID = \"_id\"\r\n// , を付け忘れるとエラー\r\nprivate val SQL_CREATE_ENTRIES = \"CREATE TABLE \" + TABLE_NAME + \" (\" +\r\n        _ID + \" INTEGER PRIMARY KEY,\" +\r\n        COMMENT + \" TEXT ,\" +\r\n        YOMI + \" TEXT ,\" +\r\n        DESCRIPTION + \" TEXT\" +\r\n        \")\"\r\n```\r\n\r\nEntityはこうなります（例がクソわかりにくい。**まるで教科書の例題の解き方が参考にならない問題みたい**）\r\n\r\n```kotlin\r\n@Entity(tableName = \"comment_collection_db\")\r\ndata class CommentCollectionEntity(\r\n    @ColumnInfo(name = \"_id\") @PrimaryKey(autoGenerate = true) val id: Int = 0,\r\n    @ColumnInfo(name = \"comment\") val comment: String,\r\n    @ColumnInfo(name = \"yomi\") val yomi: String,\r\n    @ColumnInfo(name = \"description\") val description: String\r\n)\r\n```\r\n\r\n#### Entity書くときに注意しないといけないこと\r\n- `@Entity(tableName = \"\")`を書かないとだめ。\r\n    - `CREATE TABLE {ここ} `の値ですね。忘れそう\r\n- カラムと変数名が同じじゃない場合は`@ColumnInfo`を使う\r\n- **実はnullを許容するように書くと移行のときだけ楽になる**\r\n    - `Migrationを書く`の工程がほぼなくなり楽になりますが、使うときに毎回nullの可能性がある値を使う羽目になるので今回は**null絶対許さん**方針で行きます。\r\n    - nullを許容する場合は`String?`や`Int?`のように最後に`?`をつければいいですが**今回はつけません**。\r\n\r\n### DAOを書く\r\nデータベースへアクセスするする際に使う関数を定義します。  \r\nクエリもここに書きます。  \r\nここでは一般的に使いそうな動作を例として置いとくので、各自Entityクラス名等を書き換えてください。\r\n\r\nファイル名は`CommentCollectionDAO.kt`で\r\n\r\n```kotlin\r\n/**\r\n * データベースへアクセスするときに使う関数を定義する\r\n * */\r\n@Dao\r\ninterface CommentCollectionDAO {\r\n    /** 全データ取得 */\r\n    @Query(\"SELECT * FROM comment_collection_db\")\r\n    fun getAll(): List<CommentCollectionEntity>\r\n\r\n    /** データ更新 */\r\n    @Update\r\n    fun update(commentCollectionEntity: CommentCollectionEntity)\r\n\r\n    /** データ追加 */\r\n    @Insert\r\n    fun insert(commentCollectionEntity: CommentCollectionEntity)\r\n\r\n    /** データ削除 */\r\n    @Delete\r\n    fun delete(commentCollectionEntity: CommentCollectionEntity)\r\n\r\n    /** データをIDを使って検索 */\r\n    @Query(\"SELECT * FROM comment_collection_db WHERE _id = :id\")\r\n    fun findById(id: Int): CommentCollectionEntity\r\n}\r\n```\r\n\r\nこれを書く際も入力補助が聞くので間違いが減ります（この記事二回目の発言）\r\n\r\n#### 注意点\r\nなくない？\r\n\r\n### Database\r\n中心的な役割を持ちます。  \r\nファイル名は`CommentCollectionDB.kt`で\r\n\r\n```kotlin\r\n/**\r\n * コメントコレクションのデータベース。\r\n * SQLiteから移行する場合はバージョンを上げる必要がある\r\n * */\r\n@Database(entities = [CommentCollectionEntity::class], version = 2)\r\nabstract class CommentCollectionDB : RoomDatabase() {\r\n    abstract fun commentCollectionDAO(): CommentCollectionDAO\r\n}\r\n```\r\n\r\n#### 注意点\r\n- バージョンを上げないといけないそうです。\r\n\r\n## データベースへアクセス\r\nデータベースを使うときにバージョンを上げる処理を書きます。  \r\n\r\n```kotlin\r\n// データベース初期化\r\nval commentCollectionDB = Room.databaseBuilder(this, CommentCollectionDB::class.java, \"CommentCollection.db\")\r\n    .addMigrations(object : Migration(1, 2) {\r\n        override fun migrate(database: SupportSQLiteDatabase) {\r\n        }\r\n    })\r\n    .build()\r\nGlobalScope.launch(Dispatchers.Main) {\r\n    // コルーチン\r\n    withContext(Dispatchers.IO) {\r\n        // データベースから値を取る\r\n        commentCollectionDB.commentCollectionDAO().getAll().forEach { data ->\r\n            println(data.comment)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nまあこれじゃ動かないんですけどね。  \r\nそのための **addMigrations** があるので使っていきます。\r\n\r\n### なんで？動かないの？\r\n実はEntityでnullを許容すればこの問題は消えます。  \r\n```kotlin\r\n@ColumnInfo(name = \"comment\") val comment: String? // null ok!\r\n```\r\nしかしnullを許容すると使うときに面倒くさくなります（この例だと`comment?.length`みたいに?付けないといけなくなる）\r\n\r\nこの問題はSQLiteとRoomとでnullを許すかどうかで問題が発生しています。\r\n- **SQLiteくん**\r\n    - null？良いんじゃね？\r\n- **Roomくん**\r\n    - `Entity`がnullを許してくれない；；\r\n    - よし落とすか←いまここ\r\n\r\nちなみに出力されたエラーはこちら。\r\n```js\r\nExpected:\r\n    TableInfo{name='comment_collection_db', columns={description=Column{name='description', type='TEXT', affinity='2', notNull=true, primaryKeyPosition=0, defaultValue='null'}, comment=Column{name='comment', type='TEXT', affinity='2', notNull=true, primaryKeyPosition=0, defaultValue='null'}, yomi=Column{name='yomi', type='TEXT', affinity='2', notNull=true, primaryKeyPosition=0, defaultValue='null'}, _id=Column{name='_id', type='INTEGER', affinity='3', notNull=true, primaryKeyPosition=1, defaultValue='null'}}, foreignKeys=[], indices=[]}\r\nFound:\r\n    TableInfo{name='comment_collection_db', columns={description=Column{name='description', type='TEXT', affinity='2', notNull=false, primaryKeyPosition=0, defaultValue='null'}, comment=Column{name='comment', type='TEXT', affinity='2', notNull=false, primaryKeyPosition=0, defaultValue='null'}, yomi=Column{name='yomi', type='TEXT', affinity='2', notNull=false, primaryKeyPosition=0, defaultValue='null'}, _id=Column{name='_id', type='INTEGER', affinity='3', notNull=false, primaryKeyPosition=1, defaultValue='null'}}, foreignKeys=[], indices=[]}\r\n```\r\n\r\nよく見ると上の`Expected`の方の`notNull`は`true(null良いよ)`ですが、  \r\n`Found(今回作ったEntity)`は`notNull`が`false(nullだめだよ)`ってことで中身が噛み合わず例外が発生しています。\r\n\r\n## Migration\r\nnullを許容 から nullを許さん に変更したいのですが、残念ながら変更するにはデータベースを作り直す必要があるそうです。  \r\n\r\nまあまあ面倒くさい。やることは以下の4つ\r\n- 新しくデータベースを作成する\r\n    - 今までのデータベースにあったカラムを全部書く\r\n- 新しく作ったデータベースへデータを移す\r\n- 古いデータベースを消す\r\n- 新しく作ったデータベースの名前を古いデータベースの名前に変更する\r\n\r\nこれをKotlinで書くとこうなります。\r\n\r\n```kotlin\r\noverride fun migrate(database: SupportSQLiteDatabase) {\r\n    // SQLite移行。移行後のデータベースを作成する。カラムは移行前と同じ\r\n    database.execSQL(\r\n        \"\"\"\r\n        CREATE TABLE comment_collection_db_tmp (\r\n          _id INTEGER NOT NULL PRIMARY KEY, \r\n          comment TEXT NOT NULL,\r\n          yomi TEXT NOT NULL,\r\n          description TEXT NOT NULL\r\n        )\r\n        \"\"\"\r\n    )\r\n    // 移行後のデータベースへデータを移す\r\n    database.execSQL(\r\n        \"\"\"\r\n        INSERT INTO comment_collection_db_tmp (_id, comment, yomi, description)\r\n        SELECT _id, comment, yomi, description FROM comment_collection_db\r\n        \"\"\"\r\n    )\r\n    // 前あったデータベースを消す\r\n    database.execSQL(\"DROP TABLE comment_collection_db\")\r\n    // 移行後のデータベースの名前を移行前と同じにして移行完了\r\n    database.execSQL(\"ALTER TABLE comment_collection_db_tmp RENAME TO comment_collection_db\")\r\n}\r\n```\r\n\r\n全部くっつけるとこう\r\n\r\n```kotlin\r\n// データベース初期化\r\nval commentCollectionDB = Room.databaseBuilder(this, CommentCollectionDB::class.java, \"CommentCollection.db\")\r\n    .addMigrations(object : Migration(1, 2) {\r\n        override fun migrate(database: SupportSQLiteDatabase) {\r\n            // SQLite移行。移行後のデータベースを作成する。カラムは移行前と同じ\r\n            database.execSQL(\r\n                \"\"\"\r\n                CREATE TABLE comment_collection_db_tmp (\r\n                  _id INTEGER NOT NULL PRIMARY KEY, \r\n                  comment TEXT NOT NULL,\r\n                  yomi TEXT NOT NULL,\r\n                  description TEXT NOT NULL\r\n                )\r\n                \"\"\"\r\n            )\r\n            // 移行後のデータベースへデータを移す\r\n            database.execSQL(\r\n                \"\"\"\r\n                INSERT INTO comment_collection_db_tmp (_id, comment, yomi, description)\r\n                SELECT _id, comment, yomi, description FROM comment_collection_db\r\n                \"\"\"\r\n            )\r\n            // 前あったデータベースを消す\r\n            database.execSQL(\"DROP TABLE comment_collection_db\")\r\n            // 移行後のデータベースの名前を移行前と同じにして移行完了\r\n            database.execSQL(\"ALTER TABLE comment_collection_db_tmp RENAME TO comment_collection_db\")\r\n        }\r\n    })\r\n    .build()\r\nGlobalScope.launch(Dispatchers.Main) {\r\n    // コルーチン\r\n    withContext(Dispatchers.IO) {\r\n        // データベースから値を取る\r\n        commentCollectionDB.commentCollectionDAO().getAll().forEach { data ->\r\n            println(data.comment)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n以上です。  \r\n\r\n# 追加する方法\r\nSQLite時代の`ContentValues`よりずっとわかりやすい。\r\n```kotlin\r\nGlobalScope.launch(Dispatchers.Main) { \r\n    withContext(Dispatchers.IO){\r\n        val commentCollectionEntity = CommentCollectionEntity(comment = \"comment\", yomi = \"yomi\", description = \"\")\r\n        commentCollectionDB.commentCollectionDAO().insert(commentCollectionEntity)\r\n    }\r\n}\r\n```\r\n\r\n# これ今まで通りSQLiteOpenHelper経由でアクセスするとどうなるの？\r\n\r\n```terminal\r\nandroid.database.sqlite.SQLiteException: Can't downgrade database from version 2 to 1\r\n```\r\n\r\nバージョン下げんなって怒られた。\r\n\r\n# おわりに\r\nカラムが縦か横かわからん時がよくあるのでその時は**TweetDeckがマルチカラム**だってことを思い出してあ～横並びのことか～って思い出すようにしています。\r\n\r\n作らないと行けないファイルが多くて初見さんは大変そうだと思った（こなみ）\r\n\r\n# 参考にしました\r\nhttps://developer.android.com/training/data-storage/room/migrating-db-versions  \r\nhttps://medium.com/@manuelvicnt/android-room-upgrading-alpha-versions-needs-a-migration-with-kotlin-or-nonnull-7a2d140f05b9  \r\nhttps://stackoverflow.com/questions/47562157/android-room-migration-null-error  \r\nhttps://qiita.com/arara_tepi/items/7267418ca4b6bd65d744#notnull%E3%82%92%E5%90%88%E3%82%8F%E3%81%9B%E3%82%8B"},{"title":"Android単体でWebMとMPEG-DASHを使ったライブストリーミング","link":"/posts/android_standalone_webm_livestreaming/","markdown":"\r\nどうもこんにちは。  \r\n保健室のセンセーと小悪魔な会長 攻略しました。\r\n\r\n魅力的な生徒かいちょーさんを攻略できる神ゲーです。前作と違い学園生活にフォーカスしてます。  \r\n声がヒロインにめっちゃ合ってていい！\r\n\r\n![Imgur](https://imgur.com/TDO2IL4.png)\r\n\r\n；；\r\n\r\n![Imgur](https://imgur.com/ru8COek.png)\r\n\r\n↓の展開前作と変わってるのかわいい\r\n\r\n![Imgur](https://imgur.com/kKdmoCP.png)\r\n\r\n![Imgur](https://imgur.com/WZPAADx.png)\r\n\r\n~~一緒にお風呂に入るシーンがめっちゃいい！！！かわいい！~~\r\n\r\n# 本題\r\n[前回の記事](/posts/android_zero_mirror/) で`Android`の画面をブラウザへミラーリングするアプリを作りました。  \r\nが、これ問題があって、録画した映像を細切れにして`WebSocket`で送信して再生する仕組みなので、どうしても動画を入れ替える際に一瞬黒くなってしまうんですよね。これを直せないか調査しました。\r\n\r\n## ライブストリーミングするには\r\n世の中のライブ配信の仕組みを調査。\r\n\r\n`HLS`の場合は、コンテナフォーマットに`MPEG2-TS`、`Fragmented mp4`を要求します。  \r\n`MPEG-DASH`の場合は同様に、`MPEG2-TS`、`Fragmented mp4`を要求します、、、が！！  \r\n`WebM`でも初期化セグメント、メディアセグメントをそれぞれ用意できる場合は`MPEG-DASH`で配信できるみたいです！第三の選択肢！？\r\n\r\n# MPEG-DASH とは\r\nHLSみたいに動画を細切れにして配信するやつ。  \r\n`HLS`の`m3u8`に当たるマニフェスト？は、`MPEG-DASH`では`xml`で記述されており（マニフェストとか言われてる？）、若干難しい。(HLSよりは複雑になってる)  \r\nちなみに`iPhone`の`Safari`では使えないので(後述)、iPhoneを対象にしたい場合は`HLS`一択になる。；；  \r\nもっと知りたい場合は `ISO/IEC 23009-1:2022` とかでも調べてください。(それっぽいPDFが手に入る)\r\n\r\n## MPEG-DASHのマニフェスト\r\nこいうやつを、`MPEG-DASH`のプレイヤーに渡すと映像を取得して再生してくれます。  \r\n`HLS`と違って複数解像度を一度に記述出来たり、  \r\nライブ配信の際もマニフェストを更新すること無く！（後述）  \r\nセグメント（映像データ）を連番で取得出来たり、  \r\n（ライブ配信のみ？）映像が利用可能になる時間までも定義出来るのでよく分からん！！！\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" availabilityStartTime=\"2022-09-09T01:45:50+09:00\" maxSegmentDuration=\"PT3S\" minBufferTime=\"PT3S\" type=\"dynamic\" profiles=\"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple\">\r\n  <BaseURL>/</BaseURL>\r\n  <Period start=\"PT0S\">\r\n    <AdaptationSet mimeType=\"video/webm\">\r\n      <Role schemeIdUri=\"urn:mpeg:dash:role:2011\" value=\"main\" />\r\n      <!-- duration が更新頻度っぽい -->\r\n      <SegmentTemplate duration=\"3\" initialization=\"/init.webm\" media=\"/segment$Number$.webm\" startNumber=\"0\"/>\r\n      <!-- 音声入れる場合は codecs=\"vp9,opus\" -->\r\n      <Representation id=\"default\" codecs=\"vp9,opus\"/>\r\n    </AdaptationSet>\r\n  </Period>\r\n</MPD>\r\n```\r\n\r\nよく分からん...、無駄な事してるかもしれない。  \r\n誰か解説よろ...\r\n\r\n- type=\"dynamic\"\r\n    - MPEG-DASHがライブ配信モードになるはず\r\n- availabilityStartTime\r\n    - 映像が利用可能になる時間です\r\n    - ISO 8601 で記述する\r\n    - ライブ配信モードのみ利用出来る\r\n- maxSegmentDuration / minBufferTime\r\n    - わからん...\r\n- mimeType\r\n    - `Fragmented MP4`だったら`video/mp4`とかだと思います\r\n- duration\r\n    - 多分映像データの長さです\r\n- initialization\r\n    - 初期化セグメントです（WebMの部分で話す）\r\n    - デコーダーを起動するための値が入ってます\r\n- media\r\n    - メディアセグメントです（WebMの部分で話す）\r\n    - 映像データが入ってます\r\n- startNumber\r\n    - 後述\r\n- codecs\r\n    - 映像と音声のコーデックを指定します\r\n    - 音声がない場合は映像コーデックだけ指定すればいいと思います\r\n\r\n## media=\"/segment$Number$.webm\" ← $Number$ って何？\r\nテンプレート構文みたいなやつ。リクエストの際は`/segment1.webm`、`/segment2.webm`みたいな感じに展開される。  \r\n`Number`がリクエストの度にインクリメントされるので、マニフェストを更新すること無くライブ配信を提供できます！（HLSの場合は定期的にプレイリストを更新しに行ってると思う...？）\r\n\r\n他にも`$RepresentationID$`とか`$Bandwidth$`とかの変数もあります。\r\n\r\n# WebM とは\r\n映像コーデックの`VP8`/`VP9`、音声コーデックの`Opus`などを保存するコンテナフォーマット。  \r\nWebMは`Matroska`のサブセットなので`Matroska`を調べよう  \r\n\r\nエラー耐性があるとかなんとかって書いてあったけどエンコードされたデータを`Cluster`単位で保存してるからなんでしょうかね？\r\n\r\n### 番外編 コンテナフォーマット / コーデック\r\n`mp4`は実はコンテナフォーマットの一つなのです。  \r\nコンテナフォーマットはエンコード(圧縮)された映像と音声を一つのファイルにするためのフォーマットで、エンコーダーの種類ではないのですね。  \r\n(コンテナに保存することをマルチプレクサとか言ったりするっぽい)  \r\n`mp4`、`MPEG2-TS`、`WebM`、`mkv`などが仲間です。\r\n\r\nじゃあコーデックは何だと言う話ですが、エンコード（圧縮）の種類です。映像なら`H.264 (AVC)`、音声なら`AAC`が主に使われていると思います。  \r\n`H.265 (HEVC)`、`VP8`、`VP9`、`ProRes`（？）、`Opus`、`Vorbis`などが仲間です。\r\n\r\n複雑ですね、、、でもなぜか`ffmpeg`では利用者の需要を完全に理解して変換してくれます。不思議\r\n\r\nわかりやすい記事がありました：\r\nhttps://aviutl.info/ko-dekku-konntena/\r\n\r\n## WebM を MPEG-DASH で配信するためには\r\n\r\n参考になりました、ありがとうございます！！！\r\n- https://www.slideshare.net/mganeko/media-recorder-and-webm\r\n- https://qiita.com/tomoyukilabs/items/57ba8a982ab372611669\r\n\r\n一つになった`WebM`ファイルから、`初期化セグメント`と`メディアセグメント`を分離する必要があります。  \r\n\r\nWebMの最初の方に入っているデータが**初期化セグメント**になります。  \r\n多分これはデコーダーが起動するためのパラメータ（動画の幅とか）で、一度だけ必要です。  \r\n\r\n**メディアセグメント**はそのまま、エンコードされたデータが格納されています。  \r\n（実際にはエンコードされたデータが音声なのか映像なのかを判別するための値なんかも入ってます）\r\n\r\nちなみに`WebM`的に言うと、初期化セグメントは`Header`から`Tracks`まで？。メディアセグメントは`Cluster`とか言われてる部分です？  \r\n\r\n実際に`WebM`をバイナリエディタで開いてどこまでを指しているのかというと、最初の`Cluster`が始まる前までが初期化セグメントになるはずです。（雑）  \r\n\r\n![Imgur](https://imgur.com/ICMxT2U.png)\r\n\r\n`Cluster`の開始タグが`0x1F 0x43 0xB6 0x75`なので、多分こんな感じに分離できると思う。多分もっといい実装方法があるだろうけど...\r\n\r\n```kotlin\r\nval readRecordFile = recordFile.readBytes()\r\n// 初期化セグメントの範囲を探す\r\n// きれいな実装じゃない...\r\nvar initSegmentLength = -1\r\nfor (i in readRecordFile.indices) {\r\n    if (\r\n        readRecordFile[i] == 0x1F.toByte()\r\n        && readRecordFile[i + 1] == 0x43.toByte()\r\n        && readRecordFile[i + 2] == 0xB6.toByte()\r\n        && readRecordFile[i + 3] == 0x75.toByte()\r\n    ) {\r\n        initSegmentLength = i\r\n        break\r\n    }\r\n}\r\nif (initSegmentLength == -1) {\r\n    return\r\n}\r\n// 初期化セグメント\r\nval initSegmentBytes = readRecordFile.copyOfRange(0, initSegmentLength)\r\n```\r\n\r\n# Androidで実現可能なのか\r\n- WebM\r\n    - `MediaMuxer`は対応してる！\r\n        - ただ定期的にファイルを切り替える機能は流石にないので、書き込み中のファイルからコピーして細切れにしていくしかなさそう？ \r\n        - `JavaScript`にある`MediaRecorder#start`みたいな間隔で生成する機能はない（そのうちJavaScriptで画面録画してみた記事を書くと思う）\r\n    - コーデックも対応してる！\r\n        - Opus ← エンコーダーある\r\n        - VP8 / VP9 ← エンコーダーある\r\n\r\nいけそう！\r\n\r\n# 実際に作ってみる\r\nここから本題です。 \r\n端折りながら作っていきます。  \r\n\r\n## 環境\r\n\r\n| なまえ  | あたい                              |\r\n|---------|-------------------------------------|\r\n| Android | 12                                  |\r\n| 実機    | Pixel 3 XL                          |\r\n| 言語    | Kotlin (コルーチンも使っていきます) |\r\n\r\n### ライブラリ\r\n使うライブラリ集\r\n\r\n| なまえ             | なぜ                                                                                                                    |\r\n|--------------------|-------------------------------------------------------------------------------------------------------------------------|\r\n| Ktor               | ライブ配信画面（index.html）と、ライブストリーミングに必要なファイルをホスティングするために使います。Androidでも動く！ |\r\n| androidx.lifecycle | コルーチン使いたいので                                                                                                  |\r\n\r\n## AndroidManifest.xml\r\n今回はカメラ映像とマイクをライブ配信に使うので権限を書きます。  \r\n忘れがちなインターネット権限も\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n<uses-permission android:name=\"android.permission.CAMERA\" />\r\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\r\n```\r\n\r\n## build.gradle\r\n`Ktor (Webサーバー)`と`lifecycle-runtime-ktx`を追加します。  \r\nあと`Ktor`を入れたせいでエラーが出るので治すのと、`ViewBinding`を有効にします。  \r\n\r\n後述しますが、`CameraX` は使いません；；（正直プレビューView使いたかった）  \r\nよく分からんけど今回のようなことをする場合 `Camera 2` より多分難しくなる。\r\n\r\n```gradle\r\nplugins {\r\n    id 'com.android.application'\r\n    id 'org.jetbrains.kotlin.android'\r\n}\r\n\r\nandroid {\r\n    compileSdk 33\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.testwebmlivepublish\"\r\n        minSdk 21\r\n        targetSdk 33\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n    }\r\n    packagingOptions {\r\n        resources {\r\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\r\n            // Ktorのせいでエラー出るので\r\n            excludes += \"META-INF/INDEX.LIST\"\r\n            excludes += \"META-INF/io.netty.versions.properties\"\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    // Ktor Webサーバー\r\n    implementation(\"io.ktor:ktor-server-core:2.0.0\")\r\n    implementation(\"io.ktor:ktor-server-netty:2.0.0\")\r\n\r\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.4.0\"\r\n\r\n    implementation 'androidx.core:core-ktx:1.7.0'\r\n    implementation 'androidx.appcompat:appcompat:1.5.0'\r\n    implementation 'com.google.android.material:material:1.6.1'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\r\n    testImplementation 'junit:junit:4.13.2'\r\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\r\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\r\n}\r\n```\r\n\r\n# activity_main.xml\r\n映像をプレビューする`SurfaceView`と配信開始、停止ボタンを置きました。  \r\n`SurfaceView`の代わりに`TextureView`でもいいとは思いますが、電力消費とかの面から`SurfaceView`を推奨してるそうな。  \r\n(ExoPlayerですが)：https://exoplayer.dev/battery-consumption.html#video-playback\r\n\r\n（Viewを変形させたい場合は`TextureView`一択になると思います、OpenGLとかできれば話は別かも）\r\n\r\n![Imgur](https://imgur.com/0d1xt3w.png)\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <SurfaceView\r\n        android:id=\"@+id/preview_surface_view\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"0dp\"\r\n        app:layout_constraintBottom_toTopOf=\"@+id/start_button\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/start_button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"配信開始\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/stop_button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"配信停止\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\" />\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n# MainActivity.kt\r\n\r\n## 権限を貰う処理\r\n`Activity Result API`でスッキリかけるようになりましたね。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 権限リクエストする */\r\n    private val permissionRequester = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { result ->\r\n        if (result.all { it.value }) {\r\n            setupAll()\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // カメラとマイク権限がある場合は準備する\r\n        if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED\r\n            && ActivityCompat.checkSelfPermission(this, android.Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            setupAll()\r\n        } else {\r\n            // 権限を求める\r\n            permissionRequester.launch(arrayOf(android.Manifest.permission.CAMERA, android.Manifest.permission.RECORD_AUDIO))\r\n        }\r\n    }\r\n\r\n    /** セットアップを行う */\r\n    private fun setupAll() {\r\n        // カメラの用意など\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 定数\r\nはい\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    // 省略\r\n\r\n    companion object {\r\n\r\n        /** 生成間隔 */\r\n        private const val SEGMENT_INTERVAL_MS = 3_000L\r\n\r\n        /** 初期化セグメントの名前 */\r\n        private const val INIT_SEGMENT_FILENAME = \"init.webm\"\r\n\r\n        /** セグメントファイルのプレフィックス */\r\n        private const val SEGMENT_FILENAME_PREFIX = \"segment\"\r\n\r\n        /** サンプリングレート */\r\n        private const val SAMPLE_RATE = 48_000\r\n    }\r\n\r\n}\r\n```\r\n\r\n## カメラのプレビューを作る\r\nここは`Camera 2 API`のサンプルコードをそのまま使えばいいと思います。  \r\nよくわからん、、、`Surface`二回も指定しないとだめなの？\r\n\r\n### ViewBinding と カメラ\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** ViewBinding */\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    /** カメラ */\r\n    private val cameraManager by lazy { getSystemService(Context.CAMERA_SERVICE) as CameraManager }\r\n    private var cameraDevice: CameraDevice? = null\r\n    private val cameraExecutor by lazy { Executors.newSingleThreadExecutor() }\r\n\r\n    // 省略\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root) // ここ変えるの忘れずに\r\n\r\n    // 省略\r\n```\r\n\r\n### カメラの用意。プレビュー出来るまで\r\nコールバック地獄になるんですが、コルーチンのおかげでちょっと楽になります。  \r\nこれでプレビューされるはず、**アスペクト比がおかしいのですが**多分これを直すためにはかなりの努力が必要なのでやりません。（！？）  \r\n`Surface`を二回も指定しないといけないんですね。`Camera 2 API`大変。\r\n\r\nエンコーダーもついでに用意したいのですが、大変なので後回しにします。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** セットアップを行う */\r\n    private fun setupAll() {\r\n        // カメラの用意など\r\n        setupCameraAndEncoder()\r\n    }\r\n\r\n    /** プレビューとエンコーダーを用意する */\r\n    private fun setupCameraAndEncoder() {\r\n        // コールバック関数を回避するためにコルーチンを活用していく\r\n        lifecycleScope.launch {\r\n            val holder = viewBinding.previewSurfaceView.holder\r\n            val cameraDevice = suspendOpenCamera()\r\n            this@MainActivity.cameraDevice = cameraDevice\r\n\r\n            // TODO エンコーダーを起動する\r\n\r\n            // 出力先Surface\r\n            val outputSurfaceList = listOf(holder.surface)\r\n            // カメラの設定をする\r\n            val captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD).apply {\r\n                outputSurfaceList.forEach {\r\n                    addTarget(it)\r\n                }\r\n            }.build()\r\n\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\r\n                val outputList = buildList {\r\n                    outputSurfaceList.forEach {\r\n                        add(OutputConfiguration(it))\r\n                    }\r\n                }\r\n                SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n                    override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                        captureSession.setRepeatingRequest(captureRequest, null, null)\r\n                    }\r\n                    override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n\r\n                    }\r\n                }).apply { cameraDevice.createCaptureSession(this) }\r\n            } else {\r\n                cameraDevice.createCaptureSession(outputSurfaceList, object : CameraCaptureSession.StateCallback() {\r\n                    override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                        captureSession.setRepeatingRequest(captureRequest, null, null)\r\n                    }\r\n                    override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n\r\n                    }\r\n                }, null)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** カメラを取得する、コールバックが呼ばれるまで一時停止する */\r\n    @SuppressLint(\"MissingPermission\")\r\n    private suspend fun suspendOpenCamera() = suspendCoroutine<CameraDevice> {\r\n        // 多分外カメラ\r\n        val cameraId = cameraManager.cameraIdList[0]\r\n        cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {\r\n            override fun onOpened(camera: CameraDevice) {\r\n                it.resume(camera)\r\n            }\r\n            override fun onDisconnected(camera: CameraDevice) {\r\n\r\n            }\r\n            override fun onError(camera: CameraDevice, p1: Int) {\r\n\r\n            }\r\n        }, null)\r\n    }\r\n```\r\n\r\n### マイクの用意\r\nこれもエンコーダー面倒なのでそれ以外を先に書きます。  \r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** マイク */\r\n    private lateinit var audioRecord: AudioRecord\r\n\r\n    // 省略\r\n\r\n    /** セットアップを行う */\r\n    private fun setupAll() {\r\n        // カメラの用意など\r\n        setupCameraAndEncoder()\r\n        setupMicAndEncoder()\r\n    }\r\n\r\n    /** マイクとエンコーダーを用意 */\r\n    @SuppressLint(\"MissingPermission\")\r\n    private fun setupMicAndEncoder() {\r\n        // コールバック関数を回避するためにコルーチンを活用していく\r\n        lifecycleScope.launch {\r\n\r\n            // TODO エンコーダーを用意\r\n\r\n            // 音声レコーダー起動\r\n            val bufferSizeInBytes = AudioRecord.getMinBufferSize(SAMPLE_RATE, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT)\r\n            val audioFormat = AudioFormat.Builder().apply {\r\n                setEncoding(AudioFormat.ENCODING_PCM_16BIT)\r\n                setSampleRate(SAMPLE_RATE)\r\n                setChannelMask(AudioFormat.CHANNEL_IN_STEREO)\r\n            }.build()\r\n            audioRecord = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n                AudioRecord.Builder().apply {\r\n                    setAudioFormat(audioFormat)\r\n                    setAudioSource(MediaRecorder.AudioSource.MIC)\r\n                    setBufferSizeInBytes(bufferSizeInBytes)\r\n                }.build()\r\n            } else {\r\n                AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes)\r\n            }.apply { startRecording() }\r\n\r\n            // TODO エンコーダーを起動\r\n        }\r\n    }\r\n```\r\n\r\n# エンコーダーの処理を書く ( MediaCodec )\r\n音声と映像をエンコードする（MediaCodecを使いやすくしただけ）コードですが、**コピペしてください！！！**  \r\nちなみに`ぜろみらー`からコピーしてきたものです。  \r\nhttps://github.com/takusan23/ZeroMirror/tree/master/app/src/main/java/io/github/takusan23/zeromirror/media\r\n\r\n## 音声エンコーダー\r\n音声が高くなるのはサンプリングレートが`AudioRecord`と`MediaCodec`で一致してないからでした？  \r\n音声の場合はバッファーをそのままエンコーダーへ渡すことで、エンコードされたバッファーを返してくれます。\r\n\r\n詳しい動作はコメントを見てください。\r\n\r\n```kotlin\r\n/**\r\n * 音声エンコーダー\r\n * MediaCodecを使いやすくしただけ\r\n */\r\nclass AudioEncoder {\r\n\r\n    /** MediaCodec エンコーダー */\r\n    private var mediaCodec: MediaCodec? = null\r\n\r\n    /**\r\n     * エンコーダーを初期化する\r\n     *\r\n     * @param sampleRate サンプリングレート\r\n     * @param channelCount チャンネル数\r\n     * @param bitRate ビットレート\r\n     */\r\n    fun prepareEncoder(\r\n        sampleRate: Int = 48_000,\r\n        channelCount: Int = 2,\r\n        bitRate: Int = 192_000,\r\n    ) {\r\n        val audioEncodeFormat = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_OPUS, sampleRate, channelCount).apply {\r\n            setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC)\r\n            setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n        }\r\n        // エンコーダー用意\r\n        mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_AUDIO_OPUS).apply {\r\n            configure(audioEncodeFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * エンコーダーを開始する。同期モードを使うのでコルーチンを使います（スレッドでも良いけど）\r\n     *\r\n     * @param onRecordInput ByteArrayを渡すので、音声データを入れて、サイズを返してください\r\n     * @param onOutputBufferAvailable エンコードされたデータが流れてきます\r\n     * @param onOutputFormatAvailable エンコード後のMediaFormatが入手できる\r\n     */\r\n    suspend fun startAudioEncode(\r\n        onRecordInput: (ByteArray) -> Int,\r\n        onOutputBufferAvailable: (ByteBuffer, MediaCodec.BufferInfo) -> Unit,\r\n        onOutputFormatAvailable: (MediaFormat) -> Unit,\r\n    ) = withContext(Dispatchers.Default) {\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n        mediaCodec!!.start()\r\n\r\n        try {\r\n            while (isActive) {\r\n                // もし -1 が返ってくれば configure() が間違ってる\r\n                val inputBufferId = mediaCodec!!.dequeueInputBuffer(TIMEOUT_US)\r\n                if (inputBufferId >= 0) {\r\n                    // AudioRecodeのデータをこの中に入れる\r\n                    val inputBuffer = mediaCodec!!.getInputBuffer(inputBufferId)!!\r\n                    val capacity = inputBuffer.capacity()\r\n                    // サイズに合わせて作成\r\n                    val byteArray = ByteArray(capacity)\r\n                    // byteArrayへデータを入れてもらう\r\n                    val readByteSize = onRecordInput(byteArray)\r\n                    if (readByteSize > 0) {\r\n                        // 書き込む。書き込んだデータは[onOutputBufferAvailable]で受け取れる\r\n                        inputBuffer.put(byteArray, 0, readByteSize)\r\n                        // 多分 Surfaceで映像を入力した場合、presentationTimeUs は nanoTime を 1000 で割った値っぽい\r\n                        mediaCodec!!.queueInputBuffer(inputBufferId, 0, readByteSize, System.nanoTime() / 1000, 0)\r\n                    }\r\n                }\r\n                // 出力\r\n                val outputBufferId = mediaCodec!!.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId >= 0) {\r\n                    val outputBuffer = mediaCodec!!.getOutputBuffer(outputBufferId)!!\r\n                    if (bufferInfo.size > 1) {\r\n                        if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                            // ファイルに書き込む...\r\n                            onOutputBufferAvailable(outputBuffer, bufferInfo)\r\n                        }\r\n                    }\r\n                    // 返却\r\n                    mediaCodec!!.releaseOutputBuffer(outputBufferId, false)\r\n                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                    // MediaFormat、MediaMuxerに入れるときに使うやつ\r\n                    // たぶんこっちのほうが先に呼ばれる\r\n                    onOutputFormatAvailable(mediaCodec!!.outputFormat)\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    /** リソースを開放する */\r\n    fun release() {\r\n        try {\r\n            mediaCodec?.stop()\r\n            mediaCodec?.release()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** MediaCodec タイムアウト */\r\n        private const val TIMEOUT_US = 10_000L\r\n\r\n    }\r\n}\r\n```\r\n## 映像エンコーダー\r\n映像の場合は、`Surface`を経由して映像を渡します。  \r\n`Camera X`を使わない理由がここにあります。`MediaCodec`へ`Surface`経由で映像を渡したかったからです。  \r\nなんか`Camera X`だと`Surface`で映像データを取得できないっぽい。`Camera X`には代わりに画像を取得する機能があるみたい。  \r\n画像の場合だと`Bitmap`を`MediaCodec`のバッファーへ入れるか（やったこと無いけど出来なくもないらしい？）、  \r\n`MediaCodec`の`Surface`へ`Bitmap`を描画する？  \r\n（ただし`MediaCodec#createInputSurface()`は`SurfaceView`と違って多分`Surface#lockCanvas()`が使えないため、`OpenGL ES`を使う必要がありこれもくっっそ面倒）\r\n\r\nなので映像データを`Surface`経由で貰える、`Camera 2 API`を使う必要があったのですね。  \r\nこちらも詳しい動作はコメントを見てください。\r\n\r\n```kotlin\r\n/**\r\n * 動画エンコーダー\r\n * MediaCodecを使いやすくしただけ\r\n *\r\n * VP9の場合は画面解像度が厳しい？\r\n * 1920x1080 1280x720 とかなら問題ないけど、ディスプレイの画面解像度を入れると例外を吐く？\r\n */\r\nclass VideoEncoder {\r\n\r\n    /** MediaCodec エンコーダー */\r\n    private var mediaCodec: MediaCodec? = null\r\n\r\n    /** MediaCodecの入力Surface */\r\n    private var inputSurface: Surface? = null\r\n\r\n    /**\r\n     * エンコーダーを初期化する\r\n     *\r\n     * @param videoWidth 動画の幅\r\n     * @param videoHeight 動画の高さ\r\n     * @param bitRate ビットレート\r\n     * @param frameRate フレームレート\r\n     * @param iFrameInterval Iフレーム\r\n     */\r\n    fun prepareEncoder(\r\n        videoWidth: Int,\r\n        videoHeight: Int,\r\n        bitRate: Int,\r\n        frameRate: Int,\r\n        iFrameInterval: Int = 1,\r\n    ) {\r\n        // コーデックの選択\r\n        // もし重くなるようなら、コーデックを VP8 にダウングレードしてもいいかもしれない\r\n        // その場合、MPEG-DASHのマニフェストでもコーデックを vp8 にする必要あり\r\n        val videoEncodeFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_VP9, videoWidth, videoHeight).apply {\r\n            setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n            setInteger(MediaFormat.KEY_FRAME_RATE, frameRate)\r\n            setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval)\r\n            setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n        }\r\n        // エンコーダー用意\r\n        mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_VP9).apply {\r\n            configure(videoEncodeFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 入力で使うSurfaceを用意する。\r\n     * [prepareEncoder]の後に呼ばないとだめ。\r\n     *\r\n     * @return 入力で使うSurface\r\n     */\r\n    fun createInputSurface() = mediaCodec!!.createInputSurface().apply {\r\n        inputSurface = this\r\n    }\r\n\r\n    /**\r\n     * エンコーダーを開始する。同期モードを使うのでコルーチンを使います（スレッドでも良いけど）\r\n     *\r\n     * @param onOutputBufferAvailable エンコードされたデータが流れてきます\r\n     * @param onOutputFormatAvailable エンコード後のMediaFormatが入手できる\r\n     */\r\n    suspend fun startVideoEncode(\r\n        onOutputBufferAvailable: (ByteBuffer, MediaCodec.BufferInfo) -> Unit,\r\n        onOutputFormatAvailable: (MediaFormat) -> Unit,\r\n    ) = withContext(Dispatchers.Default) {\r\n        // 多分使い回す\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n        mediaCodec?.start()\r\n\r\n        try {\r\n            while (isActive) {\r\n                // もし -1 が返ってくれば configure() が間違ってる\r\n                val outputBufferId = mediaCodec!!.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId >= 0) {\r\n                    val outputBuffer = mediaCodec!!.getOutputBuffer(outputBufferId)!!\r\n                    if (bufferInfo.size > 1) {\r\n                        if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                            // ファイルに書き込む...\r\n                            onOutputBufferAvailable(outputBuffer, bufferInfo)\r\n                        }\r\n                    }\r\n                    // 返却\r\n                    mediaCodec!!.releaseOutputBuffer(outputBufferId, false)\r\n                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                    // 多分映像データより先に呼ばれる\r\n                    // MediaMuxerへ映像トラックを追加するのはこのタイミングで行う\r\n                    // このタイミングでやると固有のパラメーターがセットされたMediaFormatが手に入る(csd-0 とか)\r\n                    // 映像がぶっ壊れている場合（緑で塗りつぶされてるとか）は多分このあたりが怪しい\r\n                    onOutputFormatAvailable(mediaCodec!!.outputFormat)\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            // なぜか例外を吐くので\r\n            // java.lang.IllegalStateException\r\n            // at android.media.MediaCodec.native_dequeueOutputBuffer(Native Method)\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    /** リソースを開放する */\r\n    fun release() {\r\n        try {\r\n            inputSurface?.release()\r\n            mediaCodec?.stop()\r\n            mediaCodec?.release()\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** MediaCodec タイムアウト */\r\n        private const val TIMEOUT_US = 10_000L\r\n\r\n    }\r\n}\r\n```\r\n\r\n## エンコーダーを組み込む\r\n`MainActivity.kt`に書いたカメラとマイクのエンコーダーの部分を埋めます\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 動画エンコーダー */\r\n    private val videoEncoder = VideoEncoder()\r\n\r\n    /** 音声エンコーダー */\r\n    private val audioEncoder = AudioEncoder()\r\n\r\n    // 省略\r\n\r\n    /** プレビューとエンコーダーを用意する */\r\n    private fun setupCameraAndEncoder() {\r\n        // コールバック関数を回避するためにコルーチンを活用していく\r\n        lifecycleScope.launch {\r\n            val holder = viewBinding.previewSurfaceView.holder\r\n            val cameraDevice = suspendOpenCamera()\r\n            this@MainActivity.cameraDevice = cameraDevice\r\n\r\n            // エンコーダーを初期化する\r\n            videoEncoder.prepareEncoder(\r\n                videoWidth = 1280,\r\n                videoHeight = 720,\r\n                bitRate = 1_000_000,\r\n                frameRate = 30,\r\n            )\r\n            // Camera2 API から MediaCodec へ映像を渡すための Surface\r\n            val inputSurface = videoEncoder.createInputSurface()\r\n            \r\n            // エンコーダーを起動する、動作中は一時停止するので別コルーチンを起動\r\n            launch {\r\n                videoEncoder.startVideoEncode(\r\n                    onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                        // TODO WebM保存処理\r\n                    },\r\n                    onOutputFormatAvailable = { mediaFormat ->\r\n                        // TODO WebM保存処理\r\n                    }\r\n                )\r\n            }\r\n\r\n            // 出力先Surface、プレビューとエンコーダー\r\n            val outputSurfaceList = listOf(holder.surface, inputSurface)\r\n            // カメラの設定をする\r\n            val captureRequest = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD).apply {\r\n                outputSurfaceList.forEach {\r\n                    addTarget(it)\r\n                }\r\n            }.build()\r\n\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\r\n                val outputList = buildList {\r\n                    outputSurfaceList.forEach {\r\n                        add(OutputConfiguration(it))\r\n                    }\r\n                }\r\n                SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputList, cameraExecutor, object : CameraCaptureSession.StateCallback() {\r\n                    override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                        captureSession.setRepeatingRequest(captureRequest, null, null)\r\n                    }\r\n\r\n                    override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n\r\n                    }\r\n                }).apply { cameraDevice.createCaptureSession(this) }\r\n            } else {\r\n                cameraDevice.createCaptureSession(outputSurfaceList, object : CameraCaptureSession.StateCallback() {\r\n                    override fun onConfigured(captureSession: CameraCaptureSession) {\r\n                        captureSession.setRepeatingRequest(captureRequest, null, null)\r\n                    }\r\n\r\n                    override fun onConfigureFailed(p0: CameraCaptureSession) {\r\n\r\n                    }\r\n                }, null)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** マイクとエンコーダーを用意 */\r\n    @SuppressLint(\"MissingPermission\")\r\n    private fun setupMicAndEncoder() {\r\n        // コールバック関数を回避するためにコルーチンを活用していく\r\n        lifecycleScope.launch {\r\n\r\n            // エンコーダーを初期化する\r\n            audioEncoder.prepareEncoder(\r\n                sampleRate = SAMPLE_RATE,\r\n                channelCount = 2,\r\n                bitRate = 192_000,\r\n            )\r\n\r\n            // 音声レコーダー起動\r\n            val bufferSizeInBytes = AudioRecord.getMinBufferSize(SAMPLE_RATE, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT)\r\n            val audioFormat = AudioFormat.Builder().apply {\r\n                setEncoding(AudioFormat.ENCODING_PCM_16BIT)\r\n                setSampleRate(SAMPLE_RATE)\r\n                setChannelMask(AudioFormat.CHANNEL_IN_STEREO)\r\n            }.build()\r\n            audioRecord = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n                AudioRecord.Builder().apply {\r\n                    setAudioFormat(audioFormat)\r\n                    setAudioSource(MediaRecorder.AudioSource.MIC)\r\n                    setBufferSizeInBytes(bufferSizeInBytes)\r\n                }.build()\r\n            } else {\r\n                AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes)\r\n            }.apply { startRecording() }\r\n\r\n            // エンコーダーを起動する、動作中は一時停止するので別コルーチンを起動\r\n            launch {\r\n                // エンコードする\r\n                audioEncoder.startAudioEncode(\r\n                    onRecordInput = { bytes ->\r\n                        // PCM音声を取り出しエンコする\r\n                        audioRecord.read(bytes, 0, bytes.size)\r\n                    },\r\n                    onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                        // TODO WebM保存処理\r\n                    },\r\n                    onOutputFormatAvailable = { mediaFormat ->\r\n                        // TODO WebM保存処理\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# WebMに保存しつつ、MPEG-DASHで配信可能なファイルを生成する\r\n`MediaMuxer`に保存しつつ、`MPEG-DASH`で配信できる`webm`も作っていくコードを書きます。\r\n\r\n## MediaMuxerにはファイルを分割する機能はないので...\r\n`MediaMuxer`で書き込み中のファイルからコピーします！（多分よくない）  \r\n`WebM`を作る処理（マルチプレクサ）とか絶対大変だと思う....\r\n\r\n```kotlin\r\n// たとえば...\r\nval tempFile = File(\"ファイルパス\")\r\nval mediaMuxer = MediaMuxer(tempFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM)\r\nval inputStream = tempFile.inputStream()\r\n\r\n// よしなにコピーする\r\nval segmentFile = File(\"segment.webm\")\r\n// 前回までの範囲をスキップして切り出す\r\ninputStream.also { stream ->\r\n    val byteArray = ByteArray(stream.available())\r\n    stream.read(byteArray)\r\n    segmentFile.writeBytes(byteArray)\r\n}\r\n```\r\n\r\n書き込み中のファイルから更に定期的にファイルをコピーして保存するため、二倍ストレージを使います。  \r\nどうにかしたい\r\n\r\n\r\n## 連番なファイルを作ってくれるクラス\r\n`segment1.webm`、`segment2.webm`.... みたいに連番でファイルを作ってくれるクラスを作ります。  \r\nファイル操作、なんとなく`suspend関数`にしている。  \r\n`++`演算子、`swift`だと無いらしいですね？\r\n\r\n```kotlin\r\n/**\r\n * MPEG-DASH 用ファイル管理クラス\r\n *\r\n * - [parentFolder]\r\n *  - public\r\n *      - 生成した動画を入れるフォルダ、クライアントに返してる動画です\r\n *  - temp\r\n *      - 一時的に保存する必要のあるファイル\r\n *\r\n * @param parentFolder 保存先\r\n * @param prefixName ファイルの先頭につける文字列\r\n */\r\nclass DashContentManager(\r\n    private val parentFolder: File,\r\n    private val prefixName: String,\r\n) {\r\n    /** 作るたびにインクリメントする */\r\n    private var count = 0\r\n\r\n    /** 一時作業用フォルダ */\r\n    private val tempFolder = File(parentFolder, TEMP_FOLDER_NAME).apply { mkdir() }\r\n\r\n    /** 完成品を公開するフォルダ */\r\n    val outputFolder = File(parentFolder, OUTPUT_VIDEO_FOLDER_NAME).apply { mkdir() }\r\n\r\n    /**\r\n     * 連番なファイル名になった[File]を作成する\r\n     *\r\n     * @return [File]\r\n     */\r\n    suspend fun createIncrementFile() = withContext(Dispatchers.IO) {\r\n        File(outputFolder, \"$prefixName${count++}.$WEBM_EXTENSION\").apply {\r\n            createNewFile()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ファイルを生成する関数。\r\n     * ファイル名変更が出来る以外は [createIncrementFile] と同じ。\r\n     *\r\n     * @param fileName ファイル名\r\n     * @return [File]\r\n     */\r\n    suspend fun createFile(fileName: String) = withContext(Dispatchers.IO) {\r\n        File(outputFolder, fileName).apply {\r\n            createNewFile()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 一時ファイルを生成する関数\r\n     *\r\n     * @param fileName ファイル名\r\n     * @return [File]\r\n     */\r\n    suspend fun createTempFile(fileName: String) = withContext(Dispatchers.IO) {\r\n        File(tempFolder, fileName).apply {\r\n            createNewFile()\r\n        }\r\n    }\r\n\r\n    /** 生成したファイルを削除する */\r\n    suspend fun deleteGenerateFile() = withContext(Dispatchers.IO) {\r\n        tempFolder.listFiles()?.forEach { it.delete() }\r\n        outputFolder.listFiles()?.forEach { it.delete() }\r\n    }\r\n\r\n    companion object {\r\n        /** 拡張子 */\r\n        private const val WEBM_EXTENSION = \"webm\"\r\n\r\n        /** 完成品の動画が入るフォルダの名前 */\r\n        private const val OUTPUT_VIDEO_FOLDER_NAME = \"dist\"\r\n\r\n        /** 一時作業用フォルダ */\r\n        private const val TEMP_FOLDER_NAME = \"temp\"\r\n    }\r\n\r\n}\r\n```\r\n\r\n## セグメントファイル生成クラス\r\n`WebM`にエンコードした`VP9`、`Opus`を書き込みつつ、セグメントファイルを作成できるクラスを書きます。  \r\n`MediaMuxer`に書き込んでいるファイルから部分的にコピーすることで、`MPEG-DASH`で再生するためのセグメントファイルを生成します。  \r\n\r\n```kotlin\r\n/**\r\n * MPEG-DASHで配信する WebM を作成する。\r\n * エンコードされたデータをファイル（コンテナ）に書き込む。\r\n *\r\n * @param tempFile 一時ファイル。\r\n */\r\nclass DashContainerWriter(private val tempFile: File) {\r\n\r\n    /** コンテナへ書き込むやつ */\r\n    private var mediaMuxer: MediaMuxer? = null\r\n\r\n    /** オーディオトラックの番号 */\r\n    private var audioTrackIndex = INVALID_INDEX_NUMBER\r\n\r\n    /** 映像トラックの番号 */\r\n    private var videoTrackIndex = INVALID_INDEX_NUMBER\r\n\r\n    /** オーディオのフォーマット */\r\n    private var audioFormat: MediaFormat? = null\r\n\r\n    /** 映像のフォーマット */\r\n    private var videoFormat: MediaFormat? = null\r\n\r\n    /** 書き込み可能かどうか */\r\n    private var isWritable = true\r\n\r\n    /** MediaMuxerで書き込んでいる動画ファイルの [InputStream]、その都度開くより良さそう */\r\n    private var inputStream: InputStream? = null\r\n\r\n    /** MediaMuxer 起動中の場合はtrue */\r\n    var isRunning = false\r\n        private set\r\n\r\n    /** 初期化セグメントを作成したか */\r\n    var isGeneratedInitSegment = false\r\n        private set\r\n\r\n    /** コンテナフォーマット / MediaMuxer を生成する */\r\n    suspend fun createContainerFile() = withContext(Dispatchers.IO) {\r\n        tempFile.delete()\r\n        isGeneratedInitSegment = false\r\n        mediaMuxer = MediaMuxer(tempFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM)\r\n        inputStream = tempFile.inputStream()\r\n        // 再生成する場合はパラメーター持っているので入れておく\r\n        videoFormat?.also { setVideoTrack(it) }\r\n        audioFormat?.also { setAudioTrack(it) }\r\n    }\r\n\r\n    /**\r\n     * MediaMuxerで書き込み中のファイルから、WebMの初期化セグメントの部分を切り出す。\r\n     * 初期化セグメントの位置は Clusterタグ が始まる前まで\r\n     *\r\n     * @param filePath 書き込み先ファイルのファイルパス\r\n     * @return ファイル\r\n     */\r\n    suspend fun sliceInitSegmentFile(filePath: String) = withContext(Dispatchers.IO) {\r\n        File(filePath).also { file ->\r\n            // 書き込まれないようにしておく\r\n            isWritable = false\r\n            val readRecordFile = tempFile.readBytes()\r\n            // 初期化セグメントの範囲を探す\r\n            // きれいな実装じゃない...\r\n            var initSegmentLength = -1\r\n            for (i in readRecordFile.indices) {\r\n                if (\r\n                    readRecordFile[i] == 0x1F.toByte()\r\n                    && readRecordFile[i + 1] == 0x43.toByte()\r\n                    && readRecordFile[i + 2] == 0xB6.toByte()\r\n                    && readRecordFile[i + 3] == 0x75.toByte()\r\n                ) {\r\n                    initSegmentLength = i\r\n                    break\r\n                }\r\n            }\r\n            if (initSegmentLength == -1) {\r\n                return@withContext\r\n            }\r\n            // 初期化セグメントを書き込む\r\n            file.writeBytes(readRecordFile.copyOfRange(0, initSegmentLength))\r\n            // 読み出した位置分スキップ\r\n            inputStream?.skip(initSegmentLength.toLong())\r\n            // 書き込み可にする\r\n            isWritable = true\r\n            isGeneratedInitSegment = true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * MediaMuxerで書き込み中のファイルから、前回切り出した範囲から今書き込み中の範囲までを切り出す。\r\n     * 前回切り出した範囲は[sliceInitSegmentFile]も対象。\r\n     *\r\n     * @param filePath 書き込み先ファイルのファイルパス\r\n     * @return ファイル\r\n     */\r\n    suspend fun sliceSegmentFile(filePath: String) = withContext(Dispatchers.IO) {\r\n        File(filePath).also { file ->\r\n            // 書き込まれないようにしておく\r\n            isWritable = false\r\n            // 前回までの範囲をスキップして切り出す\r\n            inputStream?.also { stream ->\r\n                val byteArray = ByteArray(stream.available())\r\n                stream.read(byteArray)\r\n                file.writeBytes(byteArray)\r\n            }\r\n            // 書き込み可にする\r\n            isWritable = true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 映像トラックを追加する\r\n     *\r\n     * @param mediaFormat 映像トラックの情報\r\n     */\r\n    fun setVideoTrack(mediaFormat: MediaFormat) {\r\n        // MediaMuxer 開始前のみ追加できるので\r\n        if (!isRunning) {\r\n            videoTrackIndex = mediaMuxer!!.addTrack(mediaFormat)\r\n        }\r\n        videoFormat = mediaFormat\r\n    }\r\n\r\n    /**\r\n     * 音声トラックを追加する\r\n     *\r\n     * @param mediaFormat 音声トラックの情報\r\n     */\r\n    fun setAudioTrack(mediaFormat: MediaFormat) {\r\n        // MediaMuxer 開始前のみ追加できるので\r\n        if (!isRunning) {\r\n            audioTrackIndex = mediaMuxer!!.addTrack(mediaFormat)\r\n        }\r\n        audioFormat = mediaFormat\r\n    }\r\n\r\n    /**\r\n     * 書き込みを開始させる。\r\n     * これ以降のフォーマット登録を受け付けないので、ファイル再生成まで登録されません [createContainerFile]\r\n     */\r\n    fun start() {\r\n        if (!isRunning) {\r\n            mediaMuxer?.start()\r\n            isRunning = true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 映像データを書き込む\r\n     *\r\n     * @param byteBuf MediaCodec からもらえるやつ\r\n     * @param bufferInfo MediaCodec からもらえるやつ\r\n     */\r\n    fun writeVideo(byteBuffer: ByteBuffer, bufferInfo: MediaCodec.BufferInfo) {\r\n        if (isRunning && videoTrackIndex != INVALID_INDEX_NUMBER && isWritable) {\r\n            mediaMuxer?.writeSampleData(videoTrackIndex, byteBuffer, bufferInfo)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 音声データを書き込む\r\n     *\r\n     * @param byteBuf MediaCodec からもらえるやつ\r\n     * @param bufferInfo MediaCodec からもらえるやつ\r\n     */\r\n    fun writeAudio(byteBuffer: ByteBuffer, bufferInfo: MediaCodec.BufferInfo) {\r\n        if (isRunning && audioTrackIndex != INVALID_INDEX_NUMBER && isWritable) {\r\n            mediaMuxer?.writeSampleData(audioTrackIndex, byteBuffer, bufferInfo)\r\n        }\r\n    }\r\n\r\n    /** リソース開放 */\r\n    fun release() {\r\n        // 起動していなければ終了もさせない\r\n        if (isRunning) {\r\n            mediaMuxer?.stop()\r\n            mediaMuxer?.release()\r\n        }\r\n        isRunning = false\r\n        inputStream?.close()\r\n    }\r\n\r\n    companion object {\r\n        /** インデックス番号初期値、無効な値 */\r\n        private const val INVALID_INDEX_NUMBER = -1\r\n    }\r\n\r\n}\r\n```\r\n\r\n## MainActivity.kt で使う\r\n連番ファイル生成クラスと、セグメント生成クラスを`MainActivity`に書いてるカメラ、マイクの部分へ組み込みます。  \r\n書き込みを始めるのは開始ボタンを押してからです。  \r\n(Activityがデカくなっていく...まあいっか！)  \r\n\r\nこれで定期的にセグメントファイルが生成されるはず...\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 動画コンテナ管理クラス */\r\n    private lateinit var dashContainer: DashContainerWriter\r\n\r\n    /** 生成した動画をまとめるクラス */\r\n    private lateinit var contentManager: DashContentManager\r\n\r\n    /** セットアップを行う */\r\n    private fun setupAll() {\r\n        lifecycleScope.launch {\r\n            // カメラの用意など\r\n            setupCommon()\r\n            setupCameraAndEncoder()\r\n            setupMicAndEncoder()\r\n        }\r\n    }\r\n\r\n    /** 共通部分の初期化 */\r\n    private suspend fun setupCommon() {\r\n        // 開始ボタン、セグメント生成とサーバーを起動する\r\n        viewBinding.startButton.setOnClickListener {\r\n            // TODO Webサーバー開始\r\n            dashContainer.start()\r\n        }\r\n        // 終了ボタン\r\n        viewBinding.stopButton.setOnClickListener {\r\n            // TODO リソース開放\r\n        }\r\n\r\n        // ファイル管理クラス\r\n        contentManager = DashContentManager(getExternalFilesDir(null)!!, SEGMENT_FILENAME_PREFIX).apply {\r\n            deleteCreateFile()\r\n        }\r\n        // コンテナフォーマットに書き込むクラス\r\n        dashContainer = DashContainerWriter(contentManager.createTempFile(\"temp\")).apply {\r\n            createContainerFile()\r\n        }\r\n        \r\n        // TODO Webサーバー\r\n        \r\n        // WebM セグメントファイルを作る。MediaMuxerが書き込んでるファイルに対して切り出して保存する\r\n        lifecycleScope.launch(Dispatchers.Default) {\r\n            while (isActive) {\r\n                if (dashContainer.isRunning) {\r\n                    try {\r\n                        // SEGMENT_INTERVAL_MS 待機したら新しいファイルにする\r\n                        delay(SEGMENT_INTERVAL_MS)\r\n                        // 初回時だけ初期化セグメントを作る\r\n                        if (!dashContainer.isGeneratedInitSegment) {\r\n                            contentManager.createFile(INIT_SEGMENT_FILENAME).also { initSegment ->\r\n                                dashContainer.sliceInitSegmentFile(initSegment.path)\r\n                            }\r\n                        }\r\n                        // MediaMuxerで書き込み中のファイルから定期的にデータをコピーして（セグメントファイルが出来る）クライアントで再生する\r\n                        // この方法だと、MediaMuxerとMediaMuxerからコピーしたデータで二重に容量を使うけど後で考える\r\n                        contentManager.createIncrementFile().also { segment ->\r\n                            dashContainer.sliceSegmentFile(segment.path)\r\n                        }\r\n                    } catch (e: Exception) {\r\n                        e.printStackTrace()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** プレビューとエンコーダーを用意する */\r\n    private fun setupCameraAndEncoder() {\r\n\r\n            // 省略\r\n\r\n            // エンコーダーを起動する、動作中は一時停止するので別コルーチンを起動\r\n            launch {\r\n                videoEncoder.startVideoEncode(\r\n                    onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                        dashContainer.writeVideo(byteBuffer, bufferInfo)\r\n                    },\r\n                    onOutputFormatAvailable = { mediaFormat ->\r\n                        dashContainer.setVideoTrack(mediaFormat)\r\n                    }\r\n                )\r\n            }\r\n\r\n            // 省略\r\n    }\r\n\r\n    /** マイクとエンコーダーを用意 */\r\n    @SuppressLint(\"MissingPermission\")\r\n    private fun setupMicAndEncoder() {\r\n\r\n            // 省略\r\n\r\n            // エンコーダーを起動する、動作中は一時停止するので別コルーチンを起動\r\n            launch {\r\n                // エンコードする\r\n                audioEncoder.startAudioEncode(\r\n                    onRecordInput = { bytes ->\r\n                        // PCM音声を取り出しエンコする\r\n                        audioRecord.read(bytes, 0, bytes.size)\r\n                    },\r\n                    onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                        dashContainer.writeAudio(byteBuffer, bufferInfo)\r\n                    },\r\n                    onOutputFormatAvailable = { mediaFormat ->\r\n                        dashContainer.setAudioTrack(mediaFormat)\r\n                    }\r\n                )\r\n            }\r\n    }\r\n```\r\n\r\n# Webサーバーを立てる\r\n`Ktor`っているライブラリで建てられます。なんと`Android`でも動きます（Android 5以上）  \r\n**`Kotlin DSL`をゴリゴリ使うスタイルなので異世界に飛ばされた感がすごい**\r\n\r\n## Webサーバー\r\n`ISO 8601`の部分、古いAndroidバージョンだと使えないみたいなのでなんかしないとだめです（`XXX`が`+09:00`とかになるんだけど対応してないっぽい）  \r\n見ての通り、`index.html`、`manifest.mpd`、セグメントファイルを静的配信するためのコードがあります。（雑）  \r\nフロントエンドでは`MPEG-DASH`を再生するためのライブラリ、`dash.js`を使います。  \r\n後述しますが、コーデックの`VP9`が重い場合は`VP8`を使うことも出来るのですが変えた場合はマニフェストの`codecs`も変える必要があります。\r\n\r\n```kotlin\r\n/**\r\n * index.htmlとマニフェストとセグメントファイルをホスティングする\r\n *\r\n * @param portNumber ポート番号\r\n * @param segmentIntervalSec セグメント生成間隔\r\n * @param segmentFileNamePrefix セグメントファイルのプレフィックス\r\n * @param staticHostingFolder セグメントファイルを保存しているフォルダ\r\n */\r\nclass DashServer(\r\n    private val portNumber: Int,\r\n    private val segmentIntervalSec: Int,\r\n    private val segmentFileNamePrefix: String,\r\n    private val staticHostingFolder: File,\r\n) {\r\n\r\n    /**\r\n     * ISO 8601 で映像データの利用可能時間を指定する必要があるため\r\n     * MPEG-DASHの場合は指定時間になるまで再生を開始しない機能があるらしい。\r\n     */\r\n    @SuppressLint(\"NewApi\")\r\n    private val isoDateFormat = SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssXXX\", Locale.JAPAN)\r\n\r\n    /** マニフェスト */\r\n    private var manifest: String? = null\r\n\r\n    /** サーバー */\r\n    private val server = embeddedServer(Netty, port = portNumber) {\r\n        routing {\r\n            // WebSocketと動画プレイヤーを持った簡単なHTMLを返す\r\n            get(\"/\") {\r\n                call.respondText(INDEX_HTML, ContentType.parse(\"text/html\"))\r\n            }\r\n            // MPEG-DASHのマニフェストを返す\r\n            get(\"manifest.mpd\") {\r\n                call.respondText(manifest!!, ContentType.parse(\"text/html\"))\r\n            }\r\n            // 静的フォルダ公開するように。\r\n            // 動画を配信する\r\n            static {\r\n                staticRootFolder = staticHostingFolder\r\n                files(staticHostingFolder)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** サーバーを開始する */\r\n    fun startServer() {\r\n        manifest = createManifest()\r\n        server.start()\r\n    }\r\n\r\n    /** サーバーを終了する */\r\n    fun stopServer() {\r\n        server.stop()\r\n    }\r\n\r\n    /** マニフェストを作って返す */\r\n    private fun createManifest(): String {\r\n        val availableTime = isoDateFormat.format(System.currentTimeMillis())\r\n        return \"\"\"\r\n            <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n            <MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" availabilityStartTime=\"$availableTime\" maxSegmentDuration=\"PT${segmentIntervalSec}S\" minBufferTime=\"PT${segmentIntervalSec}S\" type=\"dynamic\" profiles=\"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple\">\r\n              <BaseURL>/</BaseURL>\r\n              <Period start=\"PT0S\">\r\n                <AdaptationSet mimeType=\"video/webm\">\r\n                  <Role schemeIdUri=\"urn:mpeg:dash:role:2011\" value=\"main\" />\r\n                  <!-- duration が更新頻度っぽい -->\r\n                  <SegmentTemplate duration=\"$segmentIntervalSec\" initialization=\"/init.webm\" media=\"/${segmentFileNamePrefix}${\"$\"}Number${'$'}.webm\" startNumber=\"0\"/>\r\n                    <!-- 音声入れる場合は codecs=\"vp9,opus\" -->\r\n                  <Representation id=\"default\" codecs=\"vp9,opus\"/>\r\n                </AdaptationSet>\r\n              </Period>\r\n            </MPD>\r\n        \"\"\".trimIndent()\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** index.html */\r\n        private const val INDEX_HTML = \"\"\"\r\n<!doctype html>\r\n<html>\r\n<head>\r\n    <title>AndroidからMPEG-DASH配信</title>\r\n    <style>\r\n        video {\r\n            width: 640px;\r\n            height: 360px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div>\r\n        <video id=\"videoPlayer\" controls muted autoplay></video>\r\n    </div>\r\n    <script src=\"https://cdn.dashjs.org/latest/dash.all.debug.js\"></script>\r\n    <script>\r\n        (function () {\r\n            var url = \"manifest.mpd\";\r\n            var player = dashjs.MediaPlayer().create();\r\n            player.initialize(document.querySelector(\"#videoPlayer\"), url, true);\r\n        })();\r\n    </script>\r\n</body>\r\n</html>\r\n\"\"\"\r\n    }\r\n}\r\n```\r\n\r\n## MainActivity.kt へ組み込む\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** Webサーバー */\r\n    private lateinit var dashServer: DashServer\r\n\r\n\r\n    /** 共通部分の初期化 */\r\n    private suspend fun setupCommon() {\r\n        // 開始ボタン、セグメント生成とサーバーを起動する\r\n        viewBinding.startButton.setOnClickListener {\r\n            dashServer.startServer()\r\n            dashContainer.start()\r\n        }\r\n\r\n        // 終了ボタン\r\n        viewBinding.stopButton.setOnClickListener {\r\n            // TODO リソース開放\r\n        }\r\n\r\n        // ファイル管理クラス\r\n        contentManager = DashContentManager(getExternalFilesDir(null)!!, SEGMENT_FILENAME_PREFIX).apply {\r\n            deleteCreateFile()\r\n        }\r\n        // コンテナフォーマットに書き込むクラス\r\n        dashContainer = DashContainerWriter(contentManager.createTempFile(\"temp\")).apply {\r\n            createContainerFile()\r\n        }\r\n\r\n        // Webサーバー\r\n        dashServer = DashServer(\r\n            portNumber = 8080,\r\n            segmentIntervalSec = (SEGMENT_INTERVAL_MS / 1000).toInt(),\r\n            segmentFileNamePrefix = SEGMENT_FILENAME_PREFIX,\r\n            staticHostingFolder = contentManager.outputFolder\r\n        )\r\n\r\n        // 省略\r\n```\r\n\r\n# リソース開放\r\n終了時にそれぞれのクラスに書いた終了処理を呼び出します。  \r\n**これで一通り完成したはず！**\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    /** 共通部分の初期化 */\r\n    private suspend fun setupCommon() {\r\n        // 開始ボタン、セグメント生成とサーバーを起動する\r\n        viewBinding.startButton.setOnClickListener {\r\n            dashServer.startServer()\r\n            dashContainer.start()\r\n        }\r\n        // 終了ボタン\r\n        viewBinding.stopButton.setOnClickListener {\r\n            release()\r\n        }\r\n\r\n        // 省略\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        release()\r\n    }\r\n\r\n    /** 終了処理 */\r\n    private fun release() {\r\n        dashServer.stopServer()\r\n        dashContainer.release()\r\n        cameraDevice?.close()\r\n        videoEncoder.release()\r\n        audioEncoder.release()\r\n        lifecycleScope.cancel()\r\n    }\r\n```\r\n\r\n# 動かした\r\n`SEGMENT_INTERVAL_MS`を1000にしました。(1000ms = 1sec)  \r\nやっぱり遅延が出ちゃうけど、`WebSocket`で動画ファイルを受け取って切り替えるよりは快適だった。  \r\n**Android単体でライブ配信が出来て満足です。**\r\n\r\n![Imgur](https://imgur.com/4Fn5tRq.gif)\r\n\r\n4MBぐらいのGIFです、モバイルデータの方はすいません；；\r\n\r\nちなみに iOS だとHLSで、しかも今回のような無理やりな方法でセグメントファイルを作ること無く配信できるみたいです。  \r\nマルチメディア関係はやっぱりAppleが強そう（？）\r\n\r\n- https://qiita.com/rb-de0/items/779235007752452b2bdc\r\n- https://qiita.com/fuziki/items/675f88058bdf11d7a48b\r\n\r\n# そーすこーど\r\n\r\nhttps://github.com/takusan23/AndroidWebMDashLive\r\n\r\n# Q & A\r\n\r\n## プレビュー含めてなんか重い！\r\n`VP9`のエンコードだと負荷が高すぎの可能性があります（`Pixel 3 XL (SDM 845 / RAM 4GB)`だとやっぱ重い）。  \r\n`MediaCodec`の`MediaFormat.MIMETYPE_VIDEO_VP9`を`MediaFormat.MIMETYPE_VIDEO_VP8`にすれば軽くなりそう。  \r\n変えた場合は`MPEG-DASH`のマニフェストのコーデックも変えてください\r\n\r\n```kotlin\r\n// VideoEncoder.kt\r\n\r\nfun prepareEncoder(\r\n    videoWidth: Int,\r\n    videoHeight: Int,\r\n    bitRate: Int,\r\n    frameRate: Int,\r\n    iFrameInterval: Int = 1,\r\n) {\r\n    // コーデックの選択\r\n    // もし重くなるようなら、コーデックを VP8 にダウングレードしてもいいかもしれない\r\n    // その場合、MPEG-DASHのマニフェストでもコーデックを vp8 にする必要あり\r\n    val videoEncodeFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_VP8, videoWidth, videoHeight).apply {\r\n        setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n        setInteger(MediaFormat.KEY_FRAME_RATE, frameRate)\r\n        setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval)\r\n        setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\r\n    }\r\n    // エンコーダー用意\r\n    mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_VP8).apply {\r\n        configure(videoEncodeFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n    }\r\n}\r\n```\r\n\r\n```kotlin\r\n// DashServer.kt\r\n\r\n/** マニフェストを作って返す */\r\nprivate fun createManifest(): String {\r\n    val availableTime = isoDateFormat.format(System.currentTimeMillis())\r\n    return \"\"\"\r\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n        <MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" availabilityStartTime=\"$availableTime\" maxSegmentDuration=\"PT${segmentIntervalSec}S\" minBufferTime=\"PT${segmentIntervalSec}S\" type=\"dynamic\" profiles=\"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple\">\r\n          <BaseURL>/</BaseURL>\r\n          <Period start=\"PT0S\">\r\n            <AdaptationSet mimeType=\"video/webm\">\r\n              <Role schemeIdUri=\"urn:mpeg:dash:role:2011\" value=\"main\" />\r\n              <!-- duration が更新頻度っぽい -->\r\n              <SegmentTemplate duration=\"$segmentIntervalSec\" initialization=\"/init.webm\" media=\"/${segmentFileNamePrefix}${\"$\"}Number${'$'}.webm\" startNumber=\"0\"/>\r\n              <!-- vp8 にしたら↓ここも vp8 にする -->\r\n              <Representation id=\"default\" codecs=\"vp8,opus\"/>\r\n            </AdaptationSet>\r\n          </Period>\r\n        </MPD>\r\n    \"\"\".trimIndent()\r\n}\r\n```\r\n\r\n## iOS と iPad OS で再生できますか？\r\n`iPad OS`だと動くと思います。  \r\n\r\n- dash.js (フロントエンドでMPEG-DASHを再生するライブラリ) が動かない\r\n    - もっと詳しく言うと、`Media Source Extensions`というAPIが存在するのですが`iOS`では使えません\r\n        - しかし何故か`iPad OS`ではサポートされている模様、ふにゃ？\r\n        - https://caniuse.com/mediasource\r\n\r\n`Safari`しか許してない`Apple`が悪いのも分かるんですが、`WebKit`が無くなると本当に`Google`の好きなようにWebを支配出来てしまうのでやっぱこのままで！（フロント何も分からんマン）  \r\n`HLS`の例が多いのもやっぱ`iOS`でサポートされているからなのでしょうか\r\n\r\n## スマホのローカルIPアドレスがわからん\r\nWi-Fi設定の接続中アクセスポイントを選べば表示できたはず。  \r\nもちろんアプリで取得する方法があります。\r\n\r\n[AndroidでIPアドレスを取得する](/posts/android_12_wifi_local_ip_address)\r\n\r\n## Surfaceから流れてくる映像のプレゼンテーションタイムがわからないため、音声とずれる\r\n`Surface`経由で`MediaCodec`へ渡す場合、`queueInputBuffer`を呼び出すことがないので時間(`presentationTimeUs`)が勝手に指定されるんですよね。  \r\n多分`System.nanoTime() / 1000`が指定されていると思います....（`dequeueOutputBuffer`で貰える`BufferInfo`の時間を見ると多分そう）  \r\n\r\n```kotlin\r\n// 多分 Surfaceで映像を入力した場合、presentationTimeUs は nanoTime を 1000 で割った値っぽい\r\nmediaCodec.queueInputBuffer(inputBufferId, 0, readByteSize, System.nanoTime() / 1000, 0)\r\n```\r\n\r\n以上です、お疲れ様でした 888888888888888888\r\n\r\n# おわりに\r\n需要があればストアに出したいけど、プレビューのアスペクト比だったりで色々直すところがあって大変そう。\r\n\r\nあとこれ使ってるとそこそこ発熱します、はよ冬来い"},{"title":"Android Studio Bumblebee にアップデートしたら ADB が起動しない（ずっと Loading Devices... ）","link":"/posts/android_studio_bumblebee_not_start_adb/","markdown":"\r\nどうもこんばんわ。  \r\n\r\n高かったけどさくらんぼキッスが収録されてるアルバム買っちゃった\r\n\r\n![Imgur](https://imgur.com/VFf1oEs.png)\r\n\r\n\r\n# 本題\r\n`Android Studio Bumblebee`に更新したら`ADB`が起動しない。  \r\n**本来デバイス名が表示されているドロップダウンメニューのところ**が`Loading Devices...`のまま一向に動かない。  \r\n\r\nターミナルにコマンド打ち込んでもなんか受け付けない\r\n\r\n![Imgur](https://imgur.com/lcOrjgc.png)\r\n\r\n# 環境\r\n\r\n| なまえ                     | あたい                    |\r\n|----------------------------|---------------------------|\r\n| Android Studio             | Android Studio Bumblebee  |\r\n| Windows                    | 10 Pro                    |\r\n| Android SDK Platform-Tools | 32.0.0 (記述時時点最新版) |\r\n\r\n# 解決策\r\n\r\n## Enable adb mDNS for wireless debugging を OFF にする\r\n\r\nIssueTrackerの人Thx!!!  \r\nhttps://issuetracker.google.com/issues/159562232\r\n\r\nAndroidStudioの左上の`File`から`Settings...`へ進み、`Build, Execution, Deployment > Debugger`へ進み、  \r\n`Android Debug Bridge (adb)`の項目の`Enable adb mDNS for wireless debugging`のチェックを外して、  \r\n`Apply`を押して`OK`を押します。  \r\n\r\n![Imgur](https://imgur.com/ajgSTI2.png)\r\n\r\n最後にプロジェクトを開き直すか、AndroidStudioを再起動すると直りました！！！\r\n\r\n**OFFでもQRコードを読み込んでワイヤレスデバッグすることができるみたい**\r\n\r\n(電源未接続時の挙動とか、AC充電器で高速に充電しながら実機で確認したい際に便利そうだよねこれ)\r\n\r\n![Imgur](https://imgur.com/kQ3WcoW.png)\r\n\r\n## もう一度ADBコマンドを叩く\r\n\r\nもう一回適当なADBコマンドを叩くと起動しました。私の環境だけかもしれない。\r\n\r\n`adb devices`とか入力して叩けばいいと思います。\r\n\r\n![Imgur](https://imgur.com/nIlXTWO.png)\r\n\r\n**ちなみに別プロジェクトを開くとまたADBが起動しなくなります (？？？)**\r\n\r\n# おわりに\r\n\r\nAndroid Studio の `Device Manager`くん、これ既に開いてるとドロップダウンメニューから押しても起動しないので\r\nDockに留めて置けるのはいいね。  \r\n(既に開いてるせいでドロップダウンメニューから項目選んでも無反応で困惑することがたまにある)"},{"title":"Check your module classpath for missing or conflicting dependencies を直す","link":"/posts/android_studio_cannnot_access_class/","markdown":"どうもこんばんわ\r\n\r\n# 本題\r\n\r\n```\r\nCannot access class 'okhttp3.ResponseBody'. Check your module classpath for missing or conflicting dependencies\r\n```\r\n\r\n# 直し方\r\n\r\n左上の`File`から、`Invalidate Caches / Restart...`を押せば直った\r\n\r\n![Imgur](https://imgur.com/jYKBHg3.png)\r\n\r\n（関係ない話）あとどうでもいいんですけど、このサイト200を返してるし中身もあるのに `ソフト404` 判定を食らってます。はぁ～"},{"title":"Android Studio で小文字大文字かかわらず補充の予測を表示してもらう","link":"/posts/android_studio_completion/","markdown":"\r\n`Shift`を押す指の負担を減らそう\r\n\r\n## 設定を開いて\r\nEditor > General > Code Completion へ進みます。  \r\n\r\n開いたら、一番上にある`Match case:`のチェックを外します。\r\n\r\n<input type=\"checkbox\" checked>Match case:</input>\r\n\r\n↓\r\n\r\n<input type=\"checkbox\">Match case:</input>\r\n\r\nこれで小文字から入力を始めても、大文字から始まる単語を予測に出してくれます。\r\n"},{"title":"Jetpack Compose のプレビュー画面で動作確認する","link":"/posts/android_studio_interactive_preview_enable/","markdown":"\r\n昔あったのにいつの間にか消滅してたので復活させました。\r\n\r\n👆指のマークのボタン、これ押すとAndroid Studioで見た目だけじゃなくてちゃんと`Modifier#clickable { }`の動作確認ができる。\r\n\r\n![Imgur](https://imgur.com/8zMF08P.png)\r\n\r\nちなみに「インタラクティブ プレビュー」って言うそうですよ？\r\n\r\n# 環境\r\n\r\n| なまえ         | あたい                    |\r\n|----------------|---------------------------|\r\n| Android Studio | Android Studio Arctic Fox |\r\n\r\n# 有効化\r\n左上の`File`から`Settings...`を選んで、`Experimental`を押します。  \r\n押したら`Enable interactive and animation preview tools`を有効化します。以上です。\r\n\r\n![Imgur](https://imgur.com/a6q0PPY.png)\r\n\r\n# 参考\r\nhttps://stackoverflow.com/questions/68002376/how-to-enable-interactive-preview-button-for-jetpack-compose-ui-in-android-studi\r\n\r\n# 終わりに\r\nどうでもいいんだけど`Setting`と`Preference`と`Config`って何が違うん？ ~~全部設定では。~~"},{"title":"Android Studio (IDEA) で行をコピーして貼り付けると上の行に貼り付けられる","link":"/posts/android_studio_paste_setting/","markdown":"\r\nメモ\r\n\r\n# なにこれ\r\n\r\n行をコピーして（何も選択していない状態で`Ctrl + C`すると行のコピーができる）\r\n\r\n![Imgur](https://imgur.com/qn3CNlV.png)\r\n\r\n今の位置に貼り付けるために`Ctrl + V`するけど...\r\n\r\n![Imgur](https://imgur.com/BgbC7HF.png)\r\n\r\n何故かカーソル（キャレット）の位置より上の行で貼り付けされてしまう...\r\n\r\n![Imgur](https://imgur.com/DmuNeP3.png)  \r\n\r\n↑カッコの中で貼り付けてほしくてカーソル（キャレット）移動させたのに...\r\n\r\n# 直し方\r\n`File`→`Settings...`で設定画面を開き、  \r\n`Advanced Settings`の中にある、`When pasting a line copied with no selection`のドロップダウンメニューを`Paste at the caret position`にすることで、上の行ではなく、現在の行に貼り付けをしてくれるようになります。\r\n\r\n![Imgur](https://imgur.com/mqCPfJa.png)\r\n\r\nなおった！！\r\n\r\n![Imgur](https://imgur.com/QcIkkrB.png)\r\n\r\n# おわりに\r\n`Ctrl + C` ← `Copy` の `C` やろなぁ  \r\n`Ctrl + F` ← `Find` の `F` やろなぁ  \r\n`Ctrl + V` ← `V`...ってなに？  \r\n\r\nって思い調べてみましたが、`P`は印刷用で予約済みだから説、`C`キーの隣だから説なんかがあるらしい。はえ～"},{"title":"AndroidのMediaStoreでは 新しいファイル(31) 以上は自動で作れないらしい","link":"/posts/android_unique_file/","markdown":"どうもこんばんわ。  \r\n**同じ名前のファイルを作らなければいいだけの話です。**\r\n\r\n## 本題\r\n\r\n```\r\njava.lang.IllegalStateException: Failed to build unique file:\r\n```\r\n\r\n`MediaStore`へ登録しようとしたら、ファイル名が被って作れなかったエラー\r\n\r\n### 本来なら\r\n\r\n同じ名前のファイルを登録しようとすると、自動的にファイル名がかぶらないように`(1)`とかをいい感じに付けてくれる\r\n\r\n**ただ、`(31)`を超えると作れずに例外を吐く**\r\n\r\n### なぜ\r\n\r\n`FileUtils.java`の`buildUniqueNameIterator`が多分そう。  \r\nここの`hasNext()`が32までしか用意されてないから？\r\n\r\nhttps://cs.android.com/android/platform/superproject/+/master:packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java;drc=master;l=636\r\n\r\n```java\r\n// Generate names like \"foo (2)\"\r\nreturn new Iterator<String>() {\r\n    int i = 0;\r\n    @Override\r\n    public String next() {\r\n        final String res = (i == 0) ? name : name + \" (\" + i + \")\";\r\n        i++;\r\n        return res;\r\n    }\r\n    @Override\r\n    public boolean hasNext() {\r\n        return i < 32;\r\n    }\r\n};\r\n```"},{"title":"Wear OS のコンプリケーションを作りたい","link":"/posts/android_wear_os_complication/","markdown":"\r\nどうもこんばんわ。まだゲームが終わってないので今回は感想無しです。  \r\nPixel Watch、予想より**かなり、めっちゃいいですね**。USB Type-C の充電器持って無いのでPCのType-Cに挿してます。  \r\n\r\n意外に小さめ。他のWearOSなデバイスは着けられてる感がすごかったので...  \r\nセルラー通信、試してみたかったな；；（docomoなので\r\n\r\n30億のデバイスで動くJavaすごい  \r\n\r\n# 本題\r\nコンプリケーションを作りたい！！！  \r\nというか デジタルクラウン？りゅうず？ あの横の回せるやつを押さずに、タッチだけでアプリ一覧画面を開きたい！！！  \r\n（物理ボタンあんまり押したくない...押したくない？）\r\n\r\n![Imgur](https://imgur.com/tk1nwae.png)\r\n\r\n押したらアプリ一覧画面に行くようなアプリを作りたい\r\n\r\n## コンプリケーションってなに\r\n\r\n天気とか、曜日とか電池マークが書いてある部分。  \r\n\r\n![Imgur](https://imgur.com/4MemA9U.png)\r\n\r\n\r\n公式でも作り方書いてあるけど、なんか非推奨になってた...  \r\nここが参考になる→ https://github.com/android/wear-os-samples\r\n\r\n# 環境\r\n\r\n| なまえ         | あたい                        |\r\n|----------------|-------------------------------|\r\n| Android Studio | Android Studio Dolphin        |\r\n| 実機           | Pixel Watch ( Wear OS 3.5 )   |\r\n| 言語           | Kotlin ( やっぱコルーチンよ ) |\r\n\r\n## 公式の例を出せ\r\n公式のはなんか非推奨なので、コードとにらめっこしたほうがいいのかな\r\n\r\nhttps://github.com/android/wear-os-samples/blob/main/WearComplicationDataSourcesTestSuite\r\n\r\n# その前に Wear OS とどうやって ADB 接続するん？\r\nAndroid 11 から追加された、`ワイヤレス デバッグ`が使えます。  \r\nPixel WatchをWi-Fiに接続して、開発者向けオプション（有効化方法はAndroidスマホと同じ）内の`ワイヤレス デバッグ`を押します。  \r\n有効にして、ペア設定を押します。なんかコードとIPアドレスが表示されると思うので、ターミナル（コマンドプロンプト など）を開いて、\r\n\r\n```\r\nadb pair {表示されているIPアドレスとポート}\r\n```\r\n\r\n```\r\n# 例\r\n# adb pair 192.168.0.0:00000\r\n```\r\n\r\nを叩きます。なんか入力しろと言われるので、\r\n\r\n```\r\n{Wi-Fi ペア設定コード}\r\n```\r\n\r\nを入れます。完了したら、画面が戻る？ので`IP アドレスとポート`のところに書いてあるIPアドレスとポート番号を、ターミナルに入れます\r\n\r\n```\r\nadb connect IPアドレスとポート番号\r\n```\r\n\r\n```\r\n# 例\r\n# adb connect 192.168.0.0:00000\r\n```\r\n\r\n`connected to 192.168.0.0:0000`がターミナルに表示されれば完了です！\r\n\r\n![Imgur](https://imgur.com/87nqO8x.png)\r\n\r\n# 適当にプロジェクトを作って下さい\r\n`Wear OS`の`No Activity`で良いんじゃない。アプリの画面いらないし。\r\n\r\n![Imgur](https://imgur.com/rL3xV01.png)\r\n\r\n名前は適当に、SDKバージョンは後で`build.gradle`書き換えるのでなんでもいいです\r\n\r\n![Imgur](https://imgur.com/Qwg7oXC.png)\r\n\r\n## app/build.gradle\r\n`app`フォルダに有る`build.gradle`を開いて、直します  \r\n`compileSdk`、`minSdk`、`targetSdk`を直します。  \r\nあとは`dependencies`にコンプリケーションを作るライブラリを追加します。\r\n\r\n```gradle\r\nplugins {\r\n    id 'com.android.application'\r\n    id 'org.jetbrains.kotlin.android'\r\n}\r\n\r\nandroid {\r\n    namespace 'io.github.takusan23.batteryapplaunchercomplication'\r\n    compileSdk 33\r\n\r\n    defaultConfig {\r\n        applicationId \"io.github.takusan23.batteryapplaunchercomplication\"\r\n        // Wear OS 3.x が SDK 30 みたい\r\n        // Wear OS 2.x をサポートしたい場合は SDK 26 にする？\r\n        minSdk 30\r\n        targetSdk 33\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    // コンプリケーションを作るライブラリ\r\n    implementation \"androidx.wear.watchface:watchface-complications-data-source:1.2.0-alpha03\"\r\n    implementation \"androidx.wear.watchface:watchface-complications-data-source-ktx:1.2.0-alpha03\"\r\n\r\n    implementation 'androidx.core:core-ktx:1.7.0'\r\n    implementation 'com.google.android.gms:play-services-wearable:18.0.0'\r\n    implementation 'androidx.percentlayout:percentlayout:1.0.0'\r\n    implementation 'androidx.legacy:legacy-support-v4:1.0.0'\r\n    implementation 'androidx.recyclerview:recyclerview:1.2.1'\r\n}\r\n```\r\n\r\n## SuspendingComplicationDataSourceService を継承したクラスを作る\r\n適当にクラスを作り、`SuspendingComplicationDataSourceService`を継承します。  \r\n`ComplicationDataSourceService`の`kotlinx.coroutines`対応版です！！！便利！！！\r\n\r\n```kotlin\r\n/** 電池残量を表示して、押したらアプリ一覧を開く コンプリケーション */\r\nclass BatteryAppLauncherComplication : SuspendingComplicationDataSourceService() {\r\n    override fun getPreviewData(type: ComplicationType): ComplicationData? {\r\n        \r\n    }\r\n\r\n    override suspend fun onComplicationRequest(request: ComplicationRequest): ComplicationData? {\r\n\r\n    }\r\n}\r\n```\r\n\r\n### getPreviewData\r\nこれはプレビュー表示の際に呼び出されます。  \r\n今回は電池残量を表示するコンプリケーションと同じ`RangedValueComplicationData`にしました。他にも`ShortTextComplicationData`とかあります。  \r\nプレビューなので値は決め打ちでいいでしょう。\r\n\r\n```\r\nclass BatteryAppLauncherComplication : SuspendingComplicationDataSourceService() {\r\n\r\n    /** プレビューの際に呼び出される */\r\n    override fun getPreviewData(type: ComplicationType): ComplicationData {\r\n        // RangedValueComplicationData は 丸いプログレスバーみたいなやつ\r\n        return RangedValueComplicationData.Builder(\r\n            value = 75f,\r\n            min = 0f,\r\n            max = 100f,\r\n            contentDescription = createPlainTextComplication(\"電池残量とアプリランチャー\")\r\n        ).also { build ->\r\n            build.setText(createPlainTextComplication(\"75%\"))\r\n            build.setMonochromaticImage(createMonochromeIcon(R.drawable.icon_battery_4_bar))\r\n        }.build()\r\n    }\r\n\r\n    /** 実際のウォッチフェイスから呼び出される */\r\n    override suspend fun onComplicationRequest(request: ComplicationRequest): ComplicationData {\r\n        // TODO この後すぐ！\r\n    }\r\n\r\n    /** [String]から[PlainComplicationText]を作る */\r\n    private fun createPlainTextComplication(string: String) = PlainComplicationText.Builder(string).build()\r\n\r\n    /** アイコンのリソースIDから[MonochromaticImage]を作る */\r\n    private fun createMonochromeIcon(iconRes: Int) = MonochromaticImage.Builder(\r\n        image = Icon.createWithResource(this, iconRes)\r\n    ).build()\r\n\r\n}\r\n```\r\n\r\nアイコンはこの辺から拝借しました。アウトラインのアイコンすき\r\n\r\n![Imgur](https://imgur.com/zesuYSM.png)\r\n\r\n## onComplicationRequest\r\nこれは実際の値を返す必要があります。\r\n\r\n```kotlin\r\n/** 電池残量を表示して、押したらアプリ一覧を開く コンプリケーション */\r\nclass BatteryAppLauncherComplication : SuspendingComplicationDataSourceService() {\r\n\r\n    /** プレビューの際に呼び出される */\r\n    override fun getPreviewData(type: ComplicationType): ComplicationData {\r\n        // RangedValueComplicationData は 丸いプログレスバーみたいなやつ\r\n        return RangedValueComplicationData.Builder(\r\n            value = 75f,\r\n            min = 0f,\r\n            max = 100f,\r\n            contentDescription = createPlainTextComplication(\"電池残量とアプリランチャー\")\r\n        ).also { build ->\r\n            build.setText(createPlainTextComplication(\"75%\"))\r\n            build.setMonochromaticImage(createMonochromeIcon(R.drawable.icon_battery_4_bar))\r\n        }.build()\r\n    }\r\n\r\n    /** 実際のウォッチフェイスから呼び出される */\r\n    override suspend fun onComplicationRequest(request: ComplicationRequest): ComplicationData {\r\n        request.complicationType\r\n        // 実際の電池残量を取得する\r\n        val batteryLevel = getBatteryLevel().toFloat()\r\n        return RangedValueComplicationData.Builder(\r\n            value = batteryLevel, // 現在の値\r\n            min = 0f, // 最低値\r\n            max = 100f, // 最大値\r\n            contentDescription = createPlainTextComplication(\"電池残量とアプリランチャー\")\r\n        ).also { build ->\r\n            build.setText(createPlainTextComplication(\"${batteryLevel.toInt()}%\"))\r\n            build.setMonochromaticImage(createMonochromeIcon(R.drawable.icon_battery_4_bar))\r\n        }.build()\r\n    }\r\n\r\n    /** [String]から[PlainComplicationText]を作る */\r\n    private fun createPlainTextComplication(string: String) = PlainComplicationText.Builder(string).build()\r\n\r\n    /** アイコンのリソースIDから[MonochromaticImage]を作る */\r\n    private fun createMonochromeIcon(iconRes: Int) = MonochromaticImage.Builder(\r\n        image = Icon.createWithResource(this, iconRes)\r\n    ).build()\r\n\r\n    /** 電池残量を取得 */\r\n    private fun getBatteryLevel(): Int {\r\n        val powerManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager\r\n        return powerManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\r\n    }\r\n\r\n}\r\n```\r\n\r\n## AndroidManifest.xml\r\n最後にサービスを`Manifest`に追加します。  \r\n`intent-filter`は絶対必要です。  \r\n\r\n```xml\r\n<service\r\n    android:name=\".BatteryAppLauncherComplication\"\r\n    android:exported=\"true\"\r\n    android:icon=\"@drawable/icon_battery_4_bar\"\r\n    android:label=\"電池残量とアプリランチャー\"\r\n    android:permission=\"com.google.android.wearable.permission.BIND_COMPLICATION_PROVIDER\">\r\n    <intent-filter>\r\n        <action android:name=\"android.support.wearable.complications.ACTION_COMPLICATION_UPDATE_REQUEST\" />\r\n    </intent-filter>\r\n\r\n    <meta-data\r\n        android:name=\"android.support.wearable.complications.SUPPORTED_TYPES\"\r\n        android:value=\"RANGED_VALUE\" />\r\n    <meta-data\r\n        android:name=\"android.support.wearable.complications.UPDATE_PERIOD_SECONDS\"\r\n        android:value=\"300\" />\r\n</service>\r\n```\r\n\r\n`android.support.wearable.complications.SUPPORTED_TYPES`は、今回は`RangedValueComplicationData`を返すので`RANGED_VALUE`です。  \r\nクラスと値の対応表などはちょっと見つけられなかったのですが、  \r\n以下の列挙型から名前が同じ(`RangedValueComplicationData`だから`TYPE_RANGED_VALUE`？)、`TYPE_`を除いたのを設定すればいいそうです。  \r\n\r\n```kotlin\r\n    NO_DATA(WireComplicationData.TYPE_NO_DATA),\r\n    EMPTY(WireComplicationData.TYPE_EMPTY),\r\n    NOT_CONFIGURED(WireComplicationData.TYPE_NOT_CONFIGURED),\r\n    SHORT_TEXT(WireComplicationData.TYPE_SHORT_TEXT),\r\n    LONG_TEXT(WireComplicationData.TYPE_LONG_TEXT),\r\n    RANGED_VALUE(WireComplicationData.TYPE_RANGED_VALUE),\r\n    MONOCHROMATIC_IMAGE(WireComplicationData.TYPE_ICON),\r\n    SMALL_IMAGE(WireComplicationData.TYPE_SMALL_IMAGE),\r\n    PHOTO_IMAGE(WireComplicationData.TYPE_LARGE_IMAGE),\r\n    NO_PERMISSION(WireComplicationData.TYPE_NO_PERMISSION),\r\n```\r\n\r\n`ShortTextComplicationData`なら`SHORT_TEXT`になると思います。  \r\nちなみに、コンマ区切りで複数指定できます。複数指定した場合は`onComplicationRequest`の第一引数の`ComplicationRequest#complicationType`で判断できると思います。\r\n\r\n```xml\r\n<meta-data android:name=\"android.support.wearable.complications.SUPPORTED_TYPES\"\r\nandroid:value=\"RANGED_VALUE,SHORT_TEXT,ICON\"/>\r\n```\r\n\r\n\r\n複数選択時はこんな感じで分岐できるはず？\r\n\r\n```kotlin\r\nwhen(request.complicationType){\r\n    ComplicationType.SHORT_TEXT -> TODO()\r\n    ComplicationType.LONG_TEXT -> TODO()\r\n    ComplicationType.RANGED_VALUE -> TODO()\r\n    ComplicationType.MONOCHROMATIC_IMAGE -> TODO()\r\n    ComplicationType.SMALL_IMAGE -> TODO()\r\n    ComplicationType.PHOTO_IMAGE -> TODO()\r\n}\r\n```\r\n\r\n`android.support.wearable.complications.UPDATE_PERIOD_SECONDS`は最低更新間隔です。多分書いたどおりに実行されないと思いますが。  \r\n最低間隔は300秒らしいです：https://developer.android.com/training/wearables/watch-faces/exposing-data-complications?hl=ja#meta-data\r\n\r\n```xml\r\n<meta-data\r\n    android:name=\"android.support.wearable.complications.UPDATE_PERIOD_SECONDS\"\r\n    android:value=\"300\" />\r\n```\r\n\r\n# 動かす\r\n\r\n`Activity`が無いと実行ボタンすら表示されないのね、  \r\n`Add Configuration...`を押して、`+`をおして`Android App`を選びます。\r\n\r\n![Imgur](https://imgur.com/vajZiez.png)\r\n\r\n`Activity`ないので、`Launch`は`Nothing`になると思います。  \r\n`Module`は多分一個しか表示されないと思うのでそれを選べばおｋです。\r\n\r\n![Imgur](https://imgur.com/2oq3Vkw.png)\r\n\r\n実行すると、なんか赤い文字で怖いメッセージが出ますが、アプリがインストールできてるのでOKです。  \r\n\r\n```\r\n10/17 02:22:22: Launching 'Unnamed' on Google Google Pixel Watch.\r\nInstall successfully finished in 2 s 700 ms.\r\nCould not identify launch activity: Default Activity not found\r\nError while Launching activity\r\nFailed to launch an application on all devices\r\n```\r\n\r\n# コンプリケーションを追加する\r\n文字盤の変更とかはこの辺見て下さい。  \r\nhttps://support.google.com/wearos/answer/6140435?hl=ja\r\n\r\nおお？\r\n\r\n![Imgur](https://imgur.com/0iH51lM.png)\r\n\r\n\r\n動いてま！す！（最初から入ってるやつとほぼ一緒だから出来てるのか分からんね）\r\n\r\n![Imgur](https://imgur.com/RbXEIkI.png)\r\n\r\n# 押したときにアプリランチャーを開いてほしい！！\r\n多分ランチャーの`Activity`を直接`Intent`で指定して`startActivity`しても無理だと思うので、別の方法を取る必要があります。  \r\nで、色々やってたら**文字盤を表示しているときにホームボタンを押すとアプリランチャーが開く**ことがわかりました。  \r\n(ごめん Pixel Watch だけかもしれない)\r\n\r\n```\r\nC:\\Users\\takusan23>adb shell input keyevent KEYCODE_HOME\r\n```\r\n\r\nというわけで、アプリ側からホームボタンを押せば、アプリランチャーを開くことができそうです！\r\n\r\n## ホームボタンを押すには？\r\n\r\n上記の`adb shell input`が使えればいいのですが、アプリでこれを実行しても動かないと思います。  \r\n\r\n```\r\nRuntime.getRuntime().exec(\"adb shell input keyevent KEYCODE_HOME\")\r\n```\r\n\r\n詰んだか...と思いきや、ユーザー補助サービスを作ることで、ユーザーに代わってホームボタンを押すことが出来ます。ｋｔｋｒ\r\n\r\n## ユーザー補助サービスをサクサクっと作る\r\n\r\n`performGlobalAction`を使いたいだけなので、それ以外は作りません。  \r\nブロードキャストをセットして、コンプリケーションを押した際にここのブロードキャストに飛ばすようにします。\r\n\r\n```kotlin\r\n/** ホームボタンを押すだけのユーザー補助サービス */\r\nclass HomeButtonAccessibilityService : AccessibilityService() {\r\n\r\n    /** ホームボタンを押してほしいことを受け取るブロードキャスト */\r\n    private val broadcastReceiver = object : BroadcastReceiver() {\r\n        override fun onReceive(context: Context?, intent: Intent?) {\r\n            when (intent?.action) {\r\n                // ホームボタンを押す\r\n                DOWN_HOME_BUTTON -> performGlobalAction(GLOBAL_ACTION_HOME)\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onServiceConnected() {\r\n        super.onServiceConnected()\r\n        registerReceiver(broadcastReceiver, IntentFilter().apply {\r\n            addAction(DOWN_HOME_BUTTON)\r\n        })\r\n    }\r\n\r\n    override fun onAccessibilityEvent(event: AccessibilityEvent?) {\r\n        // do nothing\r\n    }\r\n\r\n    override fun onInterrupt() {\r\n        // do nothing\r\n    }\r\n\r\n    override fun onUnbind(intent: Intent?): Boolean {\r\n        unregisterReceiver(broadcastReceiver)\r\n        return super.onUnbind(intent)\r\n    }\r\n\r\n    companion object {\r\n        /** ブロードキャストのIntentのAction */\r\n        const val DOWN_HOME_BUTTON = \"io.github.takusan23.batteryapplaunchercomplication.DOWN_HOME_BUTTON\"\r\n    }\r\n}\r\n```\r\n\r\n### accessibility_service_config.xml を書く\r\n`res/xml`内に`accessibility_service_config.xml`を追加して以下コピペ  \r\nちなみに Codelab そのままです：https://codelabs.developers.google.com/codelabs/developing-android-a11y-service/?hl=ja#2\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:accessibilityFeedbackType=\"feedbackGeneric\" android:accessibilityFlags=\"flagDefault\"\r\n    android:canPerformGestures=\"true\" android:canRetrieveWindowContent=\"true\" />\r\n```\r\n\r\n### AndroidManifest.xml を書く\r\nはい。\r\n\r\n```xml\r\n<service\r\n    android:name=\".HomeButtonAccessibilityService\"\r\n    android:exported=\"true\"\r\n    android:label=\"ホームボタンを押すユーザー補助サービス\"\r\n    android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\r\n\r\n    <intent-filter>\r\n        <action android:name=\"android.accessibilityservice.AccessibilityService\" />\r\n    </intent-filter>\r\n\r\n    <meta-data\r\n        android:name=\"android.accessibilityservice\"\r\n        android:resource=\"@xml/accessibility_service_config\" />\r\n</service>\r\n```\r\n\r\n### コンプリケーションを押したときに、ホームボタンを押すだけのユーザー補助サービスへブロードキャストを送る\r\n`setTapAction`へ`PendingIntent`をセットすると押したときに`Intent`が発行されるようになります。\r\n\r\n```kotlin\r\n/** 実際のウォッチフェイスから呼び出される */\r\noverride suspend fun onComplicationRequest(request: ComplicationRequest): ComplicationData {\r\n    request.complicationType\r\n    // 実際の電池残量を取得する\r\n    val batteryLevel = getBatteryLevel().toFloat()\r\n    return RangedValueComplicationData.Builder(\r\n        value = batteryLevel,\r\n        min = 0f,\r\n        max = 100f,\r\n        contentDescription = createPlainTextComplication(\"電池残量とアプリランチャー\")\r\n    ).also { build ->\r\n        build.setText(createPlainTextComplication(\"${batteryLevel.toInt()}%\"))\r\n        build.setMonochromaticImage(createMonochromeIcon(R.drawable.icon_battery_4_bar))\r\n        // コンプリケーションを押したときの PendingIntent 。ホームボタンを押すだけのユーザー補助サービスへブロードキャストを送信している\r\n        build.setTapAction(PendingIntent.getBroadcast(this, 4545, Intent(HomeButtonAccessibilityService.DOWN_HOME_BUTTON), PendingIntent.FLAG_IMMUTABLE))\r\n    }.build()\r\n}\r\n```\r\n\r\n# 実行して、ユーザー補助を有効にする\r\n\r\n設定を開いて、ユーザー補助の項目へ行き、さっき作ったやつを有効にします。\r\n\r\n![Imgur](https://imgur.com/K8fEKlQ.png)\r\n\r\n![Imgur](https://imgur.com/DegI7dB.png)\r\n\r\nあと最後に、コンプリケーションを再度置き直す必要があるかもしれないです。  \r\nこれで、コンプリケーションを押したらアプリランチャーが開くようになりました。やったぜ！！！\r\n\r\nなんか`Android Studio`で録画したせいか重い...\r\n\r\n![Imgur](https://imgur.com/16BAh1s.gif)\r\n\r\n# ソースコード\r\nhttps://github.com/takusan23/BatteryAppLauncherComplication\r\n\r\n# おわりに\r\nガジェット買うよりよりメイン機のSSD増設するのが先かもしれない...  \r\nいやでもガチのまじで円安で時期が悪いやろ...  \r\n\r\n![Imgur](https://imgur.com/KgFDjOf.png)\r\n\r\n![Imgur](https://imgur.com/fD3nP9Z.png)\r\n\r\nそんな円安の中お財布に優しいレートで売ってくれるあたりGoogleガチなのかもしれない。  \r\n349ドルを39,800円で販売したら大赤字なのでは\r\n\r\n![Imgur](https://imgur.com/47Ydxq6.png)\r\n\r\n# おまけ Wear OS でスクリーンショットの取り方\r\n`Android Studio`が起動中の場合は、`Wear OS デバイス`とADBで接続した後、`Logcat`を開いて、カメラマークを押すことで撮ることが出来ます。\r\n\r\n![Imgur](https://imgur.com/9QCpkia.png)\r\n\r\nもし手元にPCがなければ、`Pixel Watch`アプリから撮ることができます。  \r\n（もしかしたら WearOS で開発者向けオプションを有効にしないと出来ないかも）\r\n\r\n![Imgur](https://imgur.com/cr6Ddg7.png)\r\n\r\n# 追記 2022/10/23\r\nもしかしたら、これ有効にすると `りゅうず` 回したときの感触フィードバックが無効になるかもしれないです。  \r\n原因は`accessibility_service_config.xml`で`canPerformGestures`を`true`にしたせいだと思います。  \r\n\r\n対策としては、`canPerformGestures`をブロードキャストを受信した際に動的に有効にすることで利用できると思います。\r\n\r\n`accessibility_service_config.xml`の`canPerformGestures`を`false`にして\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:accessibilityFeedbackType=\"feedbackGeneric\" android:accessibilityFlags=\"flagDefault\"\r\n    android:canPerformGestures=\"false\" />\r\n```\r\n\r\nブロードキャストを受信した際に`canPerformGestures`を有効にします。ホームボタンを押したら再度`canPerformGestures`を向こうにします。  \r\nで、動的に有効にするための関数が`@UnsupportedAppUsage`アノテーションで隠されているため、普通には呼び出せません。  \r\nリフレクションで呼び出すしか無いと思います。(ほんとか？)\r\n\r\n(AccessibilityService_canRetrieveWindowContent が 動的に変更はできない(xmlで指定しろ)って書いてあるので、逆に動的に変更するメソッドがあるのかと期待してたのですがアノテーションで隠されてました。)\r\n\r\n```kotlin\r\n/** ホームボタンを押してほしいことを受け取るブロードキャスト */\r\nprivate val broadcastReceiver = object : BroadcastReceiver() {\r\n    override fun onReceive(context: Context?, intent: Intent?) {\r\n        when (intent?.action) {\r\n            // ホームボタンを押す\r\n            DOWN_HOME_BUTTON -> {\r\n                // xml で android:canPerformGestures を指定すると、\r\n                // りゅうず を回したときの感触フィードバック が貰えなくなるため、\r\n                // 実行時に canPerformGestures を指定する\r\n                // ただ、↑のメソッドが隠されているためリフレクションで呼び出す\r\n                val setCapabilities = AccessibilityServiceInfo::class.java\r\n                    .methods\r\n                    .first { it.name == \"setCapabilities\" }\r\n                setCapabilities.invoke(serviceInfo, AccessibilityServiceInfo.CAPABILITY_CAN_PERFORM_GESTURES)\r\n                // 再セットする\r\n                serviceInfo = serviceInfo\r\n                // ホームボタンを押す\r\n                performGlobalAction(GLOBAL_ACTION_HOME)\r\n                // そして最後に戻す\r\n                setCapabilities.invoke(serviceInfo, 0)\r\n                serviceInfo = serviceInfo\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n対応コミットです  \r\n\r\nhttps://github.com/takusan23/BatteryAppLauncherComplication/commit/75d83f584322d268bbcbae2d14aa0fcdbc61b5e1"},{"title":"Wear OS からスマホのブラウザを開く","link":"/posts/android_wear_os_open_smartphone_browser/","markdown":"\r\nこの場合はスマホ側のアプリを作る必要はないです。\r\n\r\n# 本題\r\nWear OS からスマホのブラウザを開きたい場合は、スマホ側のアプリを作る必要はないよって話\r\n\r\n# つくる\r\n\r\n## build.gradle\r\nライブラリを入れます\r\n\r\n```gradle\r\nimplementation(\"androidx.wear:wear-remote-interactions:1.0.0\")\r\n```\r\n\r\n## てきとうに\r\n\r\n`RemoteActivityHelper(context).startRemoteActivity`でブラウザに向けた`Intent`を飛ばすことで開くことが出来ます。  \r\n別に`Jetpack Compose`である必要もないです。\r\n\r\n```kotlin\r\nBox(\r\n    modifier = Modifier.fillMaxSize(),\r\n    contentAlignment = Alignment.Center\r\n) {\r\n    val context = LocalContext.current\r\n    Chip(\r\n        label = { Text(text = \"スマホで開く\") },\r\n        secondaryLabel = { Text(text = \"ブラウザが開きます\") },\r\n        onClick = {\r\n            // スマートフォンのブラウザを開く\r\n            RemoteActivityHelper(context).startRemoteActivity(\r\n                Intent(Intent.ACTION_VIEW, \"https://takusan.negitoro.dev/\".toUri()).apply {\r\n                    // 多分いる\r\n                    addCategory(Intent.CATEGORY_BROWSABLE)\r\n                },\r\n            )\r\n        },\r\n    )\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/5xMHMlr.png)\r\n\r\n## 利用例\r\n\r\nソースコードに飛ばすなど\r\n\r\n![Imgur](https://imgur.com/pOVWDbG.png)\r\n\r\n以上です、お疲れ様でした 8888"},{"title":"ブラウザへAndroidの画面をミラーリングできるアプリ、ぜろみらーを作った","link":"/posts/android_zero_mirror/","markdown":"\r\nどうもこんばんわ、（お久しぶりです）  \r\nD.C.4 Sweet Harmony ～ダ・カーポ4～ スイートハーモニー 攻略しました。  \r\nめっちゃいいですね、ヒロインみんなかわいい！\r\n\r\nここの話ほんとかわいい  \r\n\r\n![Imgur](https://imgur.com/iBWxbJI.png)\r\n\r\nここほんとすき  \r\n\r\n![Imgur](https://imgur.com/7IlRZEE.png)\r\n\r\nあぁぁぁ  \r\n\r\n![Imgur](https://imgur.com/B36lbxb.png)\r\n\r\n本編では焦点があまり当てられなかったヒロインたちのストーリーが本作でちゃんとしてていい！  \r\n\r\n![Imgur](https://imgur.com/RKCEJn9.png)\r\n\r\n~~実用性もあるとおもう~~\r\n\r\n# 本題\r\nぜろみらーを作りました。ミラーリングアプリです。  \r\nとりあえずリリースしましたが、多分動く端末のほうが少ないと思う←！？\r\n\r\n![Imgur](https://imgur.com/FwtzpvV.png)\r\n\r\nニコ生のコミュの名前にありそうですが関係ないです。  \r\n\r\n# ダウンロード\r\n- PlayStore\r\n    - https://play.google.com/store/apps/details?id=io.github.takusan23.zeromirror\r\n- GitHub\r\n    - https://github.com/takusan23/ZeroMirror\r\n- プライバシーポリシー\r\n    - https://github.com/takusan23/ZeroMirror/blob/master/PRIVACY_POLICY.md\r\n\r\n# 機能\r\n- ブラウザがあれば見れる、同じWi-Fi (同じLAN) に接続している端末のブラウザから見れます\r\n- 設定はほぼない\r\n- 画面だけじゃなくて、端末内音声も共有される（Android 10 以上、がんばった）\r\n- 一応おまけ機能として、`VP9`でエンコードする機能もあります。`H.264`と比べて同じビットレートだと多分きれいな気がする...\r\n- ブラウザ側は簡単なHTMLとJavaScriptが書いてあるだけ\r\n    - WebSocketクライアント、HTTPクライアント、動画再生機能、インターネット接続 があればブラウザ以外でも視聴側は移植できるかも\r\n\r\nブラウザがあれば使える → ほぼ設定がない → Zero ( Config ) Mirroring → ぜろみらー  \r\n結構無理やりなので負荷がやばいかも  \r\nあと動画を細切れにしている以上、切り替えで一瞬ロードされちゃいます...\r\n\r\n# ざっくり仕組み\r\n端末の画面録画と(あれば)端末内音声を集めて、動画を細切れにして、ブラウザへWebSocketで送信してます。  \r\nもっといい方法があったかもしれない...\r\n\r\n![Imgur](https://imgur.com/czpAHGx.png)\r\n\r\n## 真面目に仕組み\r\nAndroidの画面録画、端末内音声の内容を`MediaProjection`で受け取ります。  \r\n（画面録画は`Surface`、端末内音声は`PCM`）  \r\n\r\n受け取ったら`MediaCodec`で`H.264`か（設定したら）`VP9`にエンコードします。  \r\nエンコードしたら`MediaMuxer`を使い`mp4`か`webm`の動画ファイルにします、一定期間経ったらファイルを切り替えてまた保存します。  \r\nできた動画ファイルを`WebSocket`を使ってブラウザへ通知して（動画ファイルのパス）、ブラウザの`<video> タグ`で再生します。\r\n\r\n動画ファイルを細切れで作って、ブラウザで再生しているだけです。はい\r\n\r\n## もっといい方法ないの\r\n\r\n### HLS / MPEG-DASH\r\nリアルタイム配信といえばこれ？  \r\n\r\n`HLS`は`MediaMuxer`が`MPEG2-TS`のコンテナフォーマットに対応していないので無理です！(これは後述)  \r\n`MPEG-DASH`も`MediaMuxer`が`Fragmented MP4`を作れないので多分無理です。  \r\n\r\nブラウザで見たかったので（追加のアプリが必要とかは敷居が高い！）今回は動画ファイルを細切れにして送ることにした。  \r\n`iOS`だと出来るみたいなのですが残念ですね...\r\n\r\n（ffmpeg？ バイナリが大きくなる上にライセンスがね...）\r\n\r\n# 大変だったこと\r\n\r\n## MediaMuxer\r\n`MediaMuxer#addTrack`がスタート前じゃないと呼べないため、使いにくい！  \r\nそれとは別なのですが、高レベルAPIの`MediaRecorder`には`MPEG2-TS`のコンテナフォーマットに対応しているのですよね。  \r\n一方今回使った低レベルAPIの`MediaMuxer`には`MPEG2-TS`のサポートはありません！え逆では\r\n\r\nなら`MediaMuxer / MediaCodec`とかを使わずに、`MediaRecorder`を使えば`HLS`で配信出来たの！？って話になるんですが、  \r\nならないです。内部音声を収録して一緒の動画ファイルにしたかったので。残念。  \r\nそれに加えて、もし内部音声がなかった場合でも動画を短い間隔で作り直すのは`MediaRecorder`では多分難しいような気がします。遅延が大きくなりそう。\r\n\r\n## MediaCodec\r\n`MediaMuxer`のインスタンスを作り直した場合は、`MediaCodec.BufferInfo`の`presentationTimeUs`を`0`からスタートするようにする必要があるみたいです。  \r\nhttps://github.com/takusan23/ZeroMirror/commit/3718678180bea6037c0e23d2686b2265b2d4e58f\r\n\r\nあと`VP9`の場合は解像度が厳しいです（1920x1080、1280x720 なら動く）、ディスプレイの画面解像度をそのまま入れたら落ちてしまう。\r\n\r\n## MP4ファイルがストリーミング出来ない\r\nmp4ファイルをストリーミングできるように（ダウンロードしながら再生）するには、`mp4`ファイルの先頭に`moovブロック`を置く必要があるらしい（？）のですが、  \r\n`MediaMuxer`の場合は最後に`moovブロック`を置くため、ストリーミング出来ません（全部ダウンロードしてから再生してしまう）\r\n`ffmpeg`が入ってる場合は以下のコマンドを叩くことで、`moovブロック`の位置が分かります。\r\n\r\n```\r\nffmpeg -v trace -i ファイル.mp4 2>&1 | grep -e type:\\'mdat\\' -e type:\\'moov\\'\r\n```\r\n\r\n多分こうなっていれば正解なのですが\r\n\r\n```sh\r\n$ ffmpeg -v trace -i  publish74.mp4  2>&1 | grep -e type:\\'mdat\\' -e type:\\'moov\\'\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 00000133f22a9a40] type:'moov' parent:'root' sz: 3844 32 1896645\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 00000133f22a9a40] type:'mdat' parent:'root' sz: 1889577 7076 1896645\r\n```\r\n\r\n`MediaMuxer`で出来たファイルは`moovブロック`が一番下なのですよね...\r\n\r\n```sh\r\n$ ffmpeg -v trace -i  publish29.mp4  2>&1 | grep -e type:\\'mdat\\' -e type:\\'moov\\'\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 000002461b249a40] type:'mdat' parent:'root' sz: 1420893 3232 1427957\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 000002461b249a40] type:'moov' parent:'root' sz: 3840 1424125 1427957\r\n```\r\n\r\nこの問題はすでに先駆け者さんが対応してくれています！  \r\nすごい！\r\n\r\n- https://qiita.com/yuya_presto/items/d48e29c89109b746d000\r\n- https://github.com/ypresto/qtfaststart-java\r\n\r\n上記のプログラムをお借りすることで、`moovブロック`を先頭に移動できました、ありがとうございます！\r\n\r\n```sh\r\n$ ffmpeg -v trace -i  publish74.mp4  2>&1 | grep -e type:\\'mdat\\' -e type:\\'moov\\'\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 00000133f22a9a40] type:'moov' parent:'root' sz: 3844 32 1896645\r\n[mov,mp4,m4a,3gp,3g2,mj2 @ 00000133f22a9a40] type:'mdat' parent:'root' sz: 1889577 7076 1896645\r\n```\r\n\r\nちなみにブラウザでもストリーミング再生なのでバッファリングの表示がされるようになります。\r\n\r\n![Imgur](https://imgur.com/JnQyJg9.png)\r\n\r\nなお`WebM`の場合は特に何もせずともストリーミング可能なファイルにしてくれるみたい\r\n\r\n![Imgur](https://imgur.com/9sI9oHv.png)\r\n\r\n# よくわからない\r\n\r\n## 端末の差がある\r\n新しめの端末じゃないと動かないっぽい？  \r\n動かない理由もよくわからん（`MediaCodec`のクラッシュログが不親切）\r\n\r\n## Opusだと音が高い？\r\nこれはまじで謎です。  \r\nなんかエンコーダーの設定間違えたのかな。\r\n\r\n追記：すいませんサンプリングレート間違ってただけでした。\r\n\r\n## VP9でエンコードした動画がなんかFirefoxだけ再生できる\r\nわかりません、Chromeだと再生されませんでした。\r\n\r\n# 終わりに\r\nPixel 6 Pro のディスプレイちょっとだけ画面傷入っちゃって悲しい。\r\n\r\nD.C.5 ！？\r\n\r\n![Imgur](https://imgur.com/7d4KIrc.png)"},{"title":"CloudFront が使えないので AWS サポートセンターにお願いしてきた","link":"/posts/aws_support_center/","markdown":"\r\nどうもこんにちは  \r\n\r\n`AWS`の`CloudFront`（と `CloudShell`）が使えないため、サポートセンターに問い合わせてみたメモです。\r\n\r\n![Imgur](https://imgur.com/nEYlRmL.png)\r\n\r\n```plaintext\r\nYour account must be verified before you can add new CloudFront resources. To verify your account, please contact AWS Support (https://console.aws.amazon.com/support/home#/ ) and include this error message.\r\n```\r\n\r\n\r\n![Imgur](https://imgur.com/t6oJtaq.png)\r\n\r\n# サポートケースをオープンする\r\nここから。無料だとアカウントと支払いくらいしか問い合わせできない・・・\r\n\r\n![Imgur](https://imgur.com/NifY8ya.png)\r\n\r\n内容を書きます\r\n\r\n![Imgur](https://imgur.com/Sh82E1t.png)\r\n\r\nおまじない程度にスクショも貼ってみる\r\n\r\n![Imgur](https://imgur.com/B4AbKTw.png)\r\n\r\nあとは送信して待つ\r\n\r\n![Imgur](https://imgur.com/UmaJoDS.png)\r\n\r\n# 返信が来る\r\nアカウントの利用状況から利用上限を定めているとのこと。  \r\nまた、`CloudShell`の利用予定のリージョンも聞かれた。\r\n\r\n# 使えるようになった\r\nFreeプランだったので数日かかりましたが、無事利用制限が解除されました。良かった良かった\r\n\r\n![Imgur](https://imgur.com/NSgTiV7.png)\r\n\r\n`CloudFront`が使えるようになりました！！！  \r\n\r\n![Imgur](https://imgur.com/APyhK5U.png)\r\n\r\n`CloudShell`も使えるようになりました。  \r\n`cal`コマンドでカレンダーを開いてみました。  \r\n\r\nもし手元に`cal コマンド`叩ける環境があれば、`cal 9 1752`をターミナルに入力して見てみてください。  \r\n多分一週間以上欠けたカレンダーが出てくるはず。\r\n\r\n![Imgur](https://imgur.com/vNgsSQA.png)\r\n\r\n詳しくは： https://ja.wikipedia.org/wiki/Cal_(UNIX)#仕様\r\n\r\n以上です。"},{"title":"記事一覧にちょっとだけ本文を乗せるようにした","link":"/posts/blog_tiramise/","markdown":"\nできる限りMarkdownに変更を加えずにやりたい。\n\n# 本題\nタイトル通り。他のブログにも有るよね。あれつけたい。\n\n### 公式ブログはどうやって実現してるか調べてみた\n- https://ja.nuxtjs.org/blog\n    - マークダウンのメタデータに`description`を追加して、文章の最初らへんを入れてる。\n        - 新規ならいいけどすでにあるMarkdownを書き換えるのはなあ\n\n# 試したこと\n## 記事を表示する要領で作ればええやん？\n`<nuxt-content>`にCSSで高さを決めればいいのではって思ってやったけど、なんか崩れちゃった。\n\n# Markdownそのままのがほしいんだが？\n`body`や`createAt`変数はあるけど、Markdownがそのまま入ってるプロパティは無い。  \n\n以下一例。\n\n```js\n{\n  slug: 'blog_tiramise',\n  title: '記事一覧にちょっとだけ本文を乗せるようにした',\n  created_at: '2020-11-16T00:00:00.000Z',\n  tags: [ '自作ブログ', 'JavaScript' ],\n  toc: [\n    {\n      id: '公式ブログはどうやって実現してるか調べてみた',\n      depth: 3,\n      text: '公式ブログはどうやって実現してるか調べてみた'\n    },\n    { id: '記事を表示する要領で作ればええやん？', depth: 2, text: '記事を表示する要領で作ればええやん？' }\n  ],\n  body: {\n    type: 'root',\n    children: [\n      [Object], [Object], [Object],\n      [Object], [Object], [Object],\n      [Object], [Object], [Object],\n      [Object], [Object], [Object],\n      [Object], [Object], [Object],\n      [Object], [Object], [Object],\n      [Object], [Object], [Object]\n    ]\n  },\n  dir: '/posts',\n  path: '/posts/blog_tiramise',\n  extension: '.md',\n  createdAt: '2020-11-15T15:55:08.945Z',\n  updatedAt: '2020-11-15T16:12:29.217Z'\n}\n```\n\nちなみに`body.children`に本文が入ってる。ただし複雑すぎて扱えたようなものではない模様。\n\n# 発展的な機能\nに`content:file:beforeInsert`ってのがあるですけど、ここでMarkdownがそのまま取得できるそうですよ！？  \nさらにdocumentへプロパティを追加できたりできますよ\n\n`nuxt.config.js`\n```js\nhooks: {\n  /**\n   * 本文を書いた際に呼ばれる。今回はここで文字数を数えている\n   */\n  'content:file:beforeInsert': (document) => {\n    if (document.extension === '.md') {\n        const text = document.text // Markdownとれる！\n    }\n  }\n}\n```\n\n## 本文をチラ見せするプロパティ(メタデータ)を追加する\nついでに文字数のメタデータを足しましょう。チラ見せは100文字まで見せるってことで。\n\n```js\nexport default {\n  // 省略\n  hooks: {\n    /**\n     * 本文を書いた際に呼ばれる。今回はここで文字数を数えている\n     */\n    'content:file:beforeInsert': (document) => {\n      if (document.extension === '.md') {\n        // 文字数を登録する\n        const textCount = document.text.length\n        document.text_count = textCount\n        // 一覧で少しだけ記事を表示したいのでそのための\n        const description = document.text.substring(0, 100)\n        document.description = description\n      }\n    }\n  }\n}\n```\n\nこれなにしてるかって言うと、Markdownにメタデータを動的に足してる(実際には足してないけど、JavaScriptで扱うときには追加されてる)\n\n\nあとはVueで表示するだけです。\n\n```vue\n<template>\n  <div>\n    <v-card\n      class=\"ma-2 pa-5\"\n      v-for=\"item in blogItems\"\n      outlined\n      :key=\"item.title\"\n    >\n      <nuxt-link :to=\"`/posts/${item.slug}`\">\n        <div class=\"headline mb-1 titleHover\">{{ item.title }}</div>\n      </nuxt-link>\n      <!-- 本文チラ見せ -->\n      <div>{{ item.description }} ...</div>\n      <v-divider></v-divider>\n      <div class=\"post-meta pa-2\">\n        <v-icon>mdi-file-upload-outline</v-icon>\n        <time>{{ new Date(item.created_at).toLocaleDateString() }} 投稿</time>\n        <!-- タグ -->\n        <TagGroup :tags=\"item.tags\"></TagGroup>\n      </div>\n    </v-card>\n  </div>\n</template>\n```\n\n以上です。8888\n\n# おまけ\n`nuxt/content`のコンテンツ取得で`where()`メソッドで大文字小文字を無視したい場合はこうです\n\n詳しくは：https://docs.mongodb.com/manual/reference/operator/query/regex\n\n```js\n// データ取得\nasync asyncData({ $content, params }) {\n  const findItem = await $content(\"posts\")\n    // 正規表現で大文字小文字を無視する。$optionsってのでiを入れると\n    // https://docs.mongodb.com/manual/reference/operator/query/regex\n    .where({ tags: { $regex: params.id, $options: \"i\" } }) // タグが含まれているかどうか。\n    .sortBy(\"created_at\", \"desc\") // 投稿日時順に並び替える\n    .fetch();\n  return { findItem };\n},\n```\n\n今回はタグが含まれているかですが、`title`でも動くと思います。  \n`$options:'i'`で大文字小文字を無視してくれる模様。"},{"title":"Cloudflare Pages と Next.js（静的書き出し）","link":"/posts/cloudflare_pages_next_js/","markdown":"どうもこんばんわ。  \r\n目次のところの見た目を若干変えてみました（色変えただけ）\r\n\r\n# 本題\r\nどうやら`Netlify`と違って、日本に`CDN`があるらしく、（日本からも）読み込みが早いらしい。  \r\nこのブログは`Netlify`にあるわけですが（記述時時点）、もし良さそうなら移行しても良いかも？\r\n\r\n# 適当に Next.js でサイトを作る\r\n作りました。  \r\nカラーコードのRGBをぞれぞれ取り出して、明るさを掛け算(0.0~1.0)することで簡易的にちょっと暗い色と明るい色を出すことができるサイトです。  \r\nカラーコード 明るさ とかで調べたらこれが一番早そうだったので...  \r\n\r\nhttps://github.com/takusan23/color-code-brightness\r\n\r\n![Imgur](https://imgur.com/ye0JoqI.png)\r\n\r\n# アカウントを作る\r\n\r\nはい。言語設定から日本語が選べます。\r\n\r\n![Imgur](https://imgur.com/byJ4gRk.png)\r\n\r\nアカウントを作るとすぐにダッシュボードみたいな画面が開きます。\r\n\r\n![Imgur](https://imgur.com/oRe7you.png)\r\n\r\n# Pages を押す\r\n\r\n新しいプロジェクトを押すとこんなのが出る\r\n\r\n![Imgur](https://imgur.com/dzKHIwM.png)\r\n\r\n今回は`GitHub`にある`Next.js`プロジェクトをホスティングしようと思います。  \r\n他にもローカルで開発した`index.html / index.css / index.js`をアップロードして公開する方法もあります。お手軽ですね  \r\n\r\n![Imgur](https://imgur.com/NcfzvRF.png)\r\n\r\n`Next.js`を選んだらいい感じにビルドコマンドとかが埋まりました。楽だね\r\n\r\n![Imgur](https://imgur.com/KsTCiKf.png)\r\n\r\nビルドが始まりました！こんな感じ  \r\n\r\n![Imgur](https://imgur.com/SUvq8G1.png)\r\n\r\nそしたらなんかコケた\r\n\r\n## SyntaxError: Unexpected token '?'\r\n`Node.js`のバージョンが足りない？合ってないらしいので、合わせます。  \r\n\r\nhttps://developers.cloudflare.com/pages/platform/language-support-and-tools/\r\n\r\n環境変数に入れる方法と、`.nvmrc`をリポジトリに置く方法（`package.json`と同じフォルダに入れる）がありますが、とりあえず後者でいきます。  \r\n\r\n手元の開発環境で`node -v`したら`v18.13.0`だったのでそうしました。\r\n\r\n![Imgur](https://imgur.com/AZriRlV.png)\r\n\r\nこれでコミットしてプッシュすると自動でビルドが試行されるはずです。無事ホスティングに成功しました。\r\n\r\n![Imgur](https://imgur.com/EOn6lS1.png)\r\n\r\n# 確かに早い気がする\r\n`Netlify`でも同じサイトをホスティングしてみたけど、ちょっとだけ`Cloudflare Pages`のほうが読み込み早い気がする。  \r\n良さそう！！！\r\n\r\n![Imgur](https://imgur.com/233hxD5.png)\r\n\r\n`PageSpeed Insights`（何使えばいいか知らないのでとりあえず）で測ってみましたが、やっぱ`Cloudflare`のほうが`Speed Index`の数値が良いですね。  \r\n\r\n![Imgur](https://imgur.com/N1q0Cnz.png)\r\n\r\n# GitHub Actions からホスティングできるか確認\r\n別に`Cloudflare Pages`のビルド機能で十分なのですが、`GitHub Actions`を使ってたのを辞めるのは寂しいので（？？？）（なんか動いてたほうがおもろい←？？？）  \r\n\r\nhttps://developers.cloudflare.com/pages/how-to/use-direct-upload-with-continuous-integration/#use-github-actions\r\n\r\n## ちょうどいい action があった\r\n\r\nこちらを使わせてもらいましょう。thx!\r\n\r\nhttps://github.com/cloudflare/pages-action\r\n\r\n## 必要な環境変数を用意する\r\nGitHub Actions で使う機密情報を作りに行きます。  \r\n多分2ついる\r\n\r\n### CLOUDFLARE_API_TOKEN\r\nアカウントページ？を開いた後、APIトークンから作成できます。\r\n\r\n![Imgur](https://imgur.com/WLLj5k1.png)\r\n\r\n多分これで良いはず。トークンは一度しか表示されないのでメモ帳とかにすぐにメモしておきましょう。\r\n\r\n![Imgur](https://imgur.com/Ysdgaec.png)\r\n\r\n### CLOUDFLARE_ACCOUNT_ID\r\nダッシュボードにログインしたときの、ドメインから後のURLについている(`dash.cloudflare.com/` から)値のことらしい。ドキュメントみるとなんか複雑なこと書いてあるけど  \r\n（↓ちょうど塗りつぶしたところ）\r\n\r\n![Imgur](https://imgur.com/RPXxh9i.png)\r\n\r\n### GitHub に登録\r\nここからできます。  \r\n`New repositroy secret`で追加することが出来ます。\r\n\r\n![Imgur](https://imgur.com/B6bR67y.png)\r\n\r\n## GitHub Actions を作る\r\n\r\nそのまえに、自動デプロイを止めておきます\r\n\r\n![Imgur](https://imgur.com/2VjGfKF.png)\r\n\r\nそしたら以下のような`yaml`を書きます。  \r\n`projectName`（Cloudflare Pages 上での名前）と`directory`（出力先のパス）は皆さんのプロジェクトごとに合わせて直してください。\r\n\r\n```yaml\r\n# GitHub Actions から Cloudflare Pages へ公開\r\n\r\n# 名前\r\nname: Publish Cloudflare Pages\r\n\r\n# 起動条件。pushと手動起動\r\non:\r\n  push:\r\n  workflow_dispatch:\r\n\r\n# やらせること\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      \r\n      # Node.js インストール\r\n      - name: Install Node.js\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: 18.13.0\r\n\r\n      # 依存関係\r\n      - name: Package install\r\n        run: npm i\r\n      \r\n      # 書き出し\r\n      - name: Build page\r\n        run: npx next build && npx next export \r\n\r\n      # 公開\r\n      - name: Publish to Cloudflare Pages\r\n        uses: cloudflare/pages-action@v1\r\n        with:\r\n          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}\r\n          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}\r\n          projectName: color-code-brightness\r\n          directory: out\r\n```\r\n\r\nあとは push すれば動くはずです。以下のように\r\n\r\n![Imgur](https://imgur.com/gwuOamY.png)\r\n\r\n# ドメイン\r\n`Apexドメイン（サブドメイン以外）`を使う場合は`Cloudflare DNS ???`とか言うやつに登録しないといけないらしい。  \r\nレジストラではなく、ネームサーバーが変わるだけなのでそこまで大変じゃなさそうな気はする。（何もわからない）  \r\n\r\n今回はサブドメインを使ってみます。サブドメインの場合はネームサーバーの変更は必要ないらしいです。\r\n\r\n![Imgur](https://imgur.com/t1ERNHe.png)\r\n\r\nこんな感じにドメインを入力して\r\n\r\n![Imgur](https://imgur.com/2pmxydu.png)\r\n\r\n自分の DNS プロバイダー を選べば良さそうです。\r\n\r\n![Imgur](https://imgur.com/UMYADH0.png)\r\n\r\n私は `Google Domains` を使っているので、 DNS の設定を開き、`Cloudflare Pages`の指示通りに入力します。\r\n\r\n![Imgur](https://imgur.com/Tcur1YT.png)\r\n\r\nボタンを押した、多分これで待ってれば完了するはず。楽ですね\r\n\r\n![Imgur](https://imgur.com/ClLG1Fx.png)\r\n\r\n歯磨きから戻ってきたら開けるようになってました！ちゃんと https です！\r\n\r\n![Imgur](https://imgur.com/cqhSn0D.png)\r\n\r\n# 終わりに\r\nよさそう！！！  \r\n全然関係ないけど `GitHub Actions` 失敗したらメールで教えてくれるのね。"},{"title":"CSSで<code>の一行目だけ空白がある","link":"/posts/css_code_tag_padding_margin/","markdown":"どうもこんばんわ。\r\n\r\n重い腰を上げて調査した。\r\n\r\n# 本題\r\nなんか一行目だけ空白がある\r\n\r\n![Imgur](https://imgur.com/4aTmscW.png)\r\n\r\n# なおす\r\n`padding`、`margin`を`0px`にしたら直ったのでメモ  \r\n`Vuetify`導入下のCSSが以下の例なので、`.v-application`はいらないかもしれない\r\n\r\n```css\r\n.v-application code {\r\n    /* codeタグにはpaddingとmarginをかけないほうがいい？ */\r\n    padding: 0px !important;\r\n    margin: 0px !important;\r\n    font-weight: initial !important;\r\n    border-radius: 5px !important;\r\n    font-family: 'Koruri Regular';\r\n    font-size: initial !important;\r\n}\r\n```"},{"title":"curl で 200 返ってくるのに、Node.js でリクエストすると 403 が返ってくる件の調査","link":"/posts/curl_successful_httpclient_error/","markdown":"\r\nタイトル通りで、`curl`だと`200`で成功するリクエストが、適当な言語（今回は`Node.js`）の`HTTP クライアント`を使ってリクエストしようとすると、なぜか`403`でエラーになる件の調査をしました。\r\n\r\n# 結果は...\r\n`Node.js`のバージョンが古かった...  \r\n`Node.js 16`だとリクエストに失敗しますが、`18`にしたら治りました。なぜ...\r\n\r\n# この件の経緯\r\n\r\n- お一人様`Misskey`を建てた\r\n- お一人様`Misskey`から一部のサーバーのユーザーを検索できない事がわかった\r\n    - ログを見ると`403`エラーになっている\r\n    - `VPS`の`curl`でも失敗している\r\n- 手元の`Windows`マシンではリクエストが成功する\r\n    - 手元でも失敗か～と思いきや`ユーザーエージェント`付けたら動いた\r\n        - `curl -H 'User-Agent: @takusan_23' https://example.com`\r\n- `VPS`の`IPアドレス`がブラックリスト入りしてると考える\r\n- 大体`Misskey`サーバーは`Cloudflare`でプロキシしているはず...\r\n    - `Cloudflare`を疑う\r\n- しかし`misskey.io`など、`Cloudflare`を使っている（であろう）サーバーのユーザーをフォローできている\r\n    - 今度は繋がらないサーバーを疑う\r\n        - 意図的に弾いているとかは考えにくいが\r\n- と思ったが、他にもお一人様サーバーから繋がらないサーバーが出てくる\r\n    - 知ってる限り二件ぐらいある\r\n    - 流石に複数のサーバーからIPアドレスを狙い撃ちでブロックされているとは考えにくい\r\n        - じゃあ`Cloudflare`か？\r\n            - でも繋がるサーバーあるんだよな\r\n- `グローバルIPアドレス`を変更してみる\r\n    - `AWS Lightsail`なら`静的IP`のデタッチしてアタッチすると新しいのが降ってくる\r\n        - しかしダメ\r\n        - ここで`AWS`が狙い撃ちされているのではと考える\r\n\r\n--- 挫折 ---\r\n\r\n- ふと、`AWS CloudShell`というサービスがあることに気付く\r\n    - すぐに使える`Linux`マシンみたいなやつ\r\n        - `Linux`しか用意されてないアプリとかを入れておくと良さそう\r\n            - `Windows`だと使えないから～`EC2 / Lightsail`建てて使いたい`Linux`アプリを入れる！みたいなことが回避できる\r\n    - `curl`とか検証用のツールを入れておくと良いのかな\r\n- `AWS CloudShell`で`curl`してみる\r\n    - リクエストが通る！！！\r\n    - やっぱ`AWS Lightsail`が狙い撃ちされているのではと考える\r\n\r\n他に案がないため一旦あきらめる\r\n\r\n- `Cloudflare` が `.dev` のトップレベルドメインをサポートする\r\n- 私のお一人様も`Cloudflare`でプロキシ（`Cloudflare DNS`を使う）すれば`IPアドレス`がブラックリスト入りされてるのも治るのではと予測\r\n    - 失敗\r\n    - まぁそれはそう。関係ないよな\r\n\r\n挫折。ぐぬぬ\r\n\r\n- ふと、`EC2`で建てたらどうなるのか試したくなる\r\n    - 他にも`AWS`で動かしているサーバーがあってもおかしくないはず\r\n- ちょうど無料枠がある\r\n    - `VPC`とか`サブネットマスク`とか`CIDR`とか意味わかんないから避けてた\r\n        - が、`デフォルト VPC`があるのでそれに`EC2`を追加すれば良いことが判明\r\n        - デフォルトを使うのはあんまり良くないらしい\r\n            - `セキュリティグループ`で必要最低限のポートだけ開けるようにする など\r\n- `Ubuntu 20.04`で借りてみる\r\n    - `Amazon Linux`は`CentOS`系列？らしくパッケージマネージャーが`apt`じゃないらしい。ので選ばなかった\r\n- 結果としては失敗だった。\r\n    - 同じエラーが帰ってきた\r\n        - やっぱり`AWS`が狙い撃ちされているのではとまた考える\r\n- ここで、別の`Linux ディストリビューション`を選ぶとどうなるか見てみる\r\n    - `Linux ディストリビューション`が`Ubuntu`だとアクセスできない`IPアドレス`が払い出されるのではと考えた\r\n    - というわけで`Amazon Linux`にしてみました。最新版で\r\n- `Amazon Linux 最新版`だと`curl`のリクエストが通ることが判明\r\n    - ！！！\r\n    - ？？？？？？\r\n    - 流石に`OS`の違いでリクエストの成功に影響するのか...？と考える\r\n- `Ubuntu 22.04 （記述時時点最新版）`で試す\r\n    - `curl`のリクエストが通る\r\n    - この環境に`Node.js 16`を入れて、リクエストするコードを試してみる\r\n        - 通らない...！！\r\n- **ここで curl だと 200 なのに HTTPクライアント だと 403 になる話が始まる**\r\n    - つまり、リクエストの成功に`IP アドレス`は関係ない。事が判明\r\n        - `AWS`だからダメではない\r\n- `curl`リクエストと同じように`HTTP クライアント`のリクエストヘッダーを書いた\r\n    - `curl`に`-v`をつけるとリクエストの詳細が見えます\r\n        - `IP アドレス`がブロックされていないことがわかったため、今度はリクエストヘッダーが悪いのではと\r\n            - リクエストヘッダーを`curl`が付けているものと同じにしてみる\r\n- が、、だめ\r\n    - 今度は`Node.js`の`HTTPクライアント`ライブラリが悪いのではと疑い始める\r\n        - `axios`、`node-fetch`、`got`、`Node.js に最初からあるやつ`を試すも`403`になる\r\n            - `request`ってもう非推奨だったんですね... ；；\r\n        - `curl`では通ってるのに...！\r\n\r\n--- 挫折 ---  \r\nいや、流石にこんな事あるか？でも`Mastodon / Misskey`の`Issue`も見たけどないんだよな。（`webfinger`とかいうユーザーを探すプロトコルがあるらしい）  \r\n`Cloudflare`がどうやら弾いてるらしい？ので`Mastodon / Misskey`は関係ないやろと思ったけどなんか1件くらいヒットしてもおかしくないと思うんだけどな...\r\n\r\n- ふと、`Node.js`のバージョンを疑い始める\r\n    - きっかけは`Misskey`バージョンアップの記事（忘れた...）\r\n    - `Ubuntu 20 -> 22`にしたら`curl`のリクエストが通るようになったのはネットワークスタック周りで更新があったのではと考える\r\n    - `Node.js`も更新すれば内部のネットワークスタックが更新され通るようになるのではという予測\r\n        - というかこれしかない\r\n            - 似たような`Issue`がないの、私のお一人様は`Ubuntu 20 / Node.js 16`で古いバージョンを使ってる説がある\r\n- **Node.js を 18 にしたら通るようになった！**\r\n    - ![Imgur](https://imgur.com/tuetWqI.png)\r\n    - `IP アドレス`が狙い撃ちされてるとか`AWS`だからダメとか`Cloudflare`に嫌われているとかではなく、**単に私のサーバーのバージョンが古いから**（`Ubuntu 20 / Node.js 16`）一部のサーバーのリクエストが`403`になるみたいでした。\r\n        - ごめんなさい\r\n\r\n# おわりに\r\nなおってよかった"},{"title":"Google Domainsでドメイン買ったからNetlifyで使う","link":"/posts/domain_katta/","markdown":"\r\nどうもこんばんわ。  \r\nニコ生で桜Trick一挙見ました。にやにや止まらんかった。一話から勢いすごかった。\r\n\r\n# 本題\r\nドメインを買いました。  \r\n三日前ぐらいからドメイン名どうするか考えてたのですが、特に思いつかなかったので好きなお寿司の名前(ねぎとろ)にしました。\r\n\r\n# ドメイン取得\r\n[Google Domains](https://domains.google/intl/ja_jp/)です。  \r\n`.dev`ドメイン（かっこいいって理由）を取りました。維持に一年1400円かかるそうです。  \r\n一瞬高く見えましたが、ニコ動のプレ垢は一ヶ月550円なのでそんなことなかった。  \r\n\r\n**Kyashで払えました。** 三井住友銀行アプリUSBデバッグ有効だと起動しないから履歴見るのめんどいんだわ。[^1]\r\n\r\n## 買い方（いる？）\r\n1:ほしいの選ぶ。  \r\n![Imgur](https://imgur.com/SkLuylR.png)\r\n\r\nスイッチとかはそのままにして次へ\r\n\r\n2:自分の情報入れる。  \r\n![Imgur](https://imgur.com/TLrH5Gb.png)\r\n\r\nWhoisって言うドメイン所有者を検索できる機能があるそうですが、ここに入力した情報は表示されないそうです。てかそうじゃないと困る\r\n\r\n3:支払い  \r\n![Imgur](https://imgur.com/r18xLqi.png)\r\n\r\n~~消費税怖い~~\r\n\r\n## Whoisどうなってんの？\r\n果たして私の情報はどの様に保護されたのか。  \r\n\r\nGoogle Domainsのナビゲーションドロワーにある、**登録の設定**押して、**公開連絡先情報**にある、**連絡先情報**に情報が書いてあるそうです。  \r\n\r\n開くと、こんな感じに（どこまで写して良いのかわからんから適当に抜粋）なってました。\r\n\r\n```console\r\nRegistrar: Google LLC\r\nRegistry Registrant ID: REDACTED FOR PRIVACY\r\nRegistrant Name: Contact Privacy Inc. なんとか～\r\nRegistry Admin ID: REDACTED FOR PRIVACY\r\nRegistry Tech ID: REDACTED FOR PRIVACY\r\n```\r\n\r\n多分大丈夫だと思います\r\n\r\n# Netlifyで使う\r\n\r\nまずNetlifyで管理画面？を開いて、カスタムドメインを設定する画面を開きます（スクショしそこねた）\r\n\r\nそしたらこんな感じに買ったドメインを入れて（今回はサブドメインにした）  \r\n\r\n![Imgur](https://imgur.com/xqMeXJO.png)\r\n\r\nDNSがなんとかって出るので押すと、この画面が出ると思います。  \r\nこの値は使うのでChrome二窓しましょう。  \r\n![Imgur](https://imgur.com/Whn3UvK.png)\r\n\r\nそしたら、**Google Domains**のナビゲーションドロワーにある**DNS**を押して、一番下に有る（編集時現在）**カスタム リソースレコード**にスクショのように情報を入れます（入力する内容は人それぞれ違いますからね！）。\r\n\r\n![Imgur](https://imgur.com/mg8hT6S.png)\r\n\r\n以上です。後は待つだけです。私は一時間しない間位に買ったドメインでNetlifyのページを開くことができました。わーい\r\n\r\nちなみにドメインでひらけるようになった頃にはSSLの設定（Let's Encrypt？）も自動でやってくれました。あざす\r\n\r\n# Google Analytics 直す\r\nを開いて、**管理**を押して、**プロパティ設定**選んで、**デフォルトのURL**を直してあげます。`https://`はドロップダウンメニューにすでにあるので、`https://`抜いたURLを書きましょう。\r\n\r\n![Imgur](https://imgur.com/ILmGn11.png)\r\n\r\n~~まあAnalytics置いたところで検索エンジンに乗らない(なんで？)ので意味ない~~\r\n\r\n# おわりに\r\nGoogle Domainsで購入する際に`営利目的もしくは商用利用で利用する場合のみ利用できる`みたいなことが書いてあったんだけど大丈夫かな（？）  \r\n![Imgur](https://imgur.com/RtQKKEj.png)\r\n\r\n# 参考にしました\r\nありがとうございます\r\n\r\nhttps://hardworkers.dev/blog/google-domains-setting-netlify/\r\n\r\nhttps://blog.a-1.dev/post/2019-04-05-migrate-domain/\r\n\r\n[^1]:Logcatに見られたら困る内容流してるんか？"},{"title":".NET Frameworkを.Net Coreへ移行する","link":"/posts/dotnet_framework_to_dotnet_core/","markdown":"\r\nハナヤマタ一挙放送ニコ生でみました（おそい）。EDの入りすき  \r\n\r\n# 本題\r\n.NET FrameworkなWPFアプリを.NET Coreへお引越しする\r\n\r\n# なんで？\r\n[.NET CoreでWPFアプリ作るぞ](dotnet_wpf)で書いたけど、\r\n\r\n- 自己完結ファイルを生成できる\r\n    - 利用者がDotNET FrameworkやDotNET Coreを入れなくても、必要なファイル全部詰めた`exe`を生成してくれる機能。\r\n        - サイズが大きくなりがち\r\n\r\nというわけです。\r\n\r\n# 移行方法\r\nhttps://docs.microsoft.com/ja-jp/dotnet/core/porting/#overview-of-the-porting-process\r\n\r\n.NET Portability Analyzer 等はめんどいので使わない方向で（よくない）\r\n\r\nあと dotnet try-convert なんて言う移行ツールがありますがそれも使わない方針で\r\n\r\n# 環境\r\n\r\n|なまえ|あたい|\r\n|--|---|\r\n|今回使うソースコード|https://github.com/takusan23/RunCat_for_windows_nicomoba_ver|\r\n|Visual Studio|2019 Community|\r\n\r\n\r\n# 移行方法を確認する\r\n## プロジェクトファイル(csproj)を開き、簡単に移行できるか判断する\r\n[公式ドキュメント](https://docs.microsoft.com/ja-jp/nuget/resources/check-project-format)　←ここも見てね\r\n\r\n.NET Coreではプロジェクトファイル(.csproj)の中身が簡素化されていて、全然別のことが書いてある模様。私も何に使ってるのかわからん。    \r\n\r\nまず`ソリューションエクスプローラー`のプロジェクト名のところを右クリックして、`プロジェクトのアンロード`を押します。  \r\n![Imgur](https://imgur.com/m90BD8l.png)\r\n\r\nそしたらもう一回プロジェクト名のところを右クリックして、`編集 なんとか.csproj`を押します\r\n\r\n![Imgur](https://imgur.com/nrumkVX.png)\r\n\r\n押すと謎のXMLファイルみたいなのが開くので、`project`要素（`<Project ToolsVersion なんとか～`のところ）に、`Sdk`属性（`Sdk=\"なんとか\"`）があれば簡単に移行できます。\r\n\r\n以下は`Sdk属性`が無い例です。よって以降はめんどいです\r\n\r\n![Imgur](https://imgur.com/F1fR6hP.png)\r\n\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n```\r\n\r\nまあ明らかに行数が多ければ疑ったほうがいいです。\r\n\r\n### もし Sdk属性 が存在した場合は？\r\nその場合は **新しいプロジェクトファイル(.csproj)** ってことで以下の方法が使えます。\r\n\r\nさっき開いたファイルの中から`<TargetFramework>`で囲まれている部分を探して、その中を`netcoreapp3.1`にすればもう`.NET Core`として扱ってくれるそうです。  \r\n\r\n`Sdk属性`がない場合は`<TargetFramework>`も無いと思います。\r\n\r\n## .NET Coreへ\r\nプロジェクトファイルが古いことが判明したので、おそらく\r\n\r\n- 新しく`.NET Core`のプロジェクトを作成してプログラム、リソースを移動させる\r\n    - 今回はこちらを取ります\r\n- [dotnet try-convert](https://github.com/dotnet/try-convert)を使う（小規模なら有力候補）\r\n\r\n## 空の`.NET Core`プロジェクトを作成\r\n今回は`WinForm`ってことで`Windows Forms App (.NET Core)`を選びました。  \r\n\r\n判別方法は、まあ`Program.cs`の`using`に`Forms`って文字があったからです。他に正規ルートがありそう。  \r\n`WPF`と`Form`の判別ってソースコードのどこ見ればわかるんですかね（え？）。\r\n\r\nWPFの場合は **WPF App(.NET Core)** を選べばいいと思います。\r\n\r\n### やらなくてもいいけど\r\n.NET Coreで作ったプロジェクト名を右クリックして、`プロジェクトファイルの編集`をおすと、すごい簡素化された`csproj`が見れると思います。こんなの\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.WindowsDesktop\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>WinExe</OutputType>\r\n    <TargetFramework>netcoreapp3.1</TargetFramework>\r\n    <UseWindowsForms>true</UseWindowsForms>\r\n  </PropertyGroup>\r\n\r\n</Project>\r\n```\r\n\r\n## プログラム、リソースの移動\r\nといっても`Program.cs`を切り貼りして移行前(`.NET Framework`)と同じようにするだけですね。\r\n\r\n## Resource\r\nリソース（画像とか）を入れるフォルダは、何もしない状態だと生成されないので、\r\n\r\nソリューションエクスプローラーのプロジェクト名(`.NET Core`で作成した方)の部分を右クリックして、`プロパティ`を選びます。\r\n\r\n![Imgur](https://imgur.com/uADCQCe.png)\r\n\r\nプロパティが開けたら、`リソース`を押します。\r\n\r\n![Imgur](https://imgur.com/6ZUL6Cd.png)\r\n\r\nするとこんな画面になるので、`このプロジェクトには既定のリソース～`って書いてある部分を押します。\r\n\r\nあとはこの画面に使う画像をドラッグアンドドロップすると画像が登録されます。  \r\nResourcesフォルダも生成されてることがわかりますね。\r\n\r\n![Imgur](https://imgur.com/9qy2cK3.png)\r\n\r\nあとはC#の方でusingを追加したら触れるようになります。\r\n\r\n![Imgur](https://imgur.com/BLkZMVJ.png)\r\n\r\n## ブラウザ起動できない\r\nこうすればいいです。`.NET Core`の問題っぽい？\r\n\r\n```cs\r\nProcessStartInfo psi = new ProcessStartInfo\r\n{\r\n    FileName = \"https://github.com/takusan23/RunCat_for_windows_nicomoba_chan_ver\",\r\n    UseShellExecute = true\r\n};\r\nProcess.Start(psi);\r\n```\r\n\r\n# おわりに\r\n[自己完結exeの作り方はここ](dotnet_wpf)。これを読めばexeを生成してばらまく事ができます。\r\n\r\nニコモバちゃんかわいい[^1]  \r\n![Imgur](https://imgur.com/ghhYzL3.png)\r\n\r\nダウンロード置いときますね。  \r\nhttps://github.com/takusan23/RunCat_for_windows_nicomoba_chan_ver/releases/tag/NicomobaChanVar_1.0\r\n\r\nこのアプリはこのアプリをフォークして作った。RunCatかわいい。  \r\nhttps://qiita.com/Kyome/items/47aac4979933dac12263\r\n\r\n# 参考にしました\r\nありがとうございます\r\n\r\nhttps://codezine.jp/article/detail/11955?p=4\r\n\r\nhttps://qiita.com/tfukumori/items/37fe740ca0b81293c03f#5-%E7%A7%BB%E6%A4%8Dporting\r\n\r\nhttps://docs.microsoft.com/ja-jp/dotnet/core/porting/#overview-of-the-porting-process\r\n\r\nhttps://docs.microsoft.com/ja-jp/nuget/resources/check-project-format\r\n\r\n\r\n[^1] 昔（配信アプリが別だった頃。nicocasとか無かった頃）スマホ配信で音のみになったときに「ニコモバ」ってコメントするとニコモバちゃんが走ってくれた。"},{"title":".NET CoreでWPFアプリ作るぞ","link":"/posts/dotnet_wpf/","markdown":"\r\n.NET Coreってなに\r\n\r\n# ほんだい\r\nWPFなんてめったに触らんから未来の私がWPFやる時に見に来る記事。  \r\n[WPFアプリ作ったので](../../posts/mousecursor_wpf/)その時に躓いたこ\r\n\r\n# 環境\r\n|なまえ|あたい|\r\n|---|---|\r\n|OS|Windows 10 Pro 2004|\r\n|Visual Studio|Community 2019|\r\n\r\n# .NET Coreってなに\r\nしらない。なんかよくわからんけど使う。  \r\n.NET Coreはクロスプラットフォームって言われてるけど、WPFに関してはWindowsに依存してるから関係ないよ\r\n\r\n[ソース](https://docs.microsoft.com/ja-jp/windows/apps/desktop/modernize/modernize-wpf-tutorial)\r\n\r\n# Visual Studio 2019 入れる\r\n最新版入れましょう。最新版じゃないと`WPF App (.NET Core)`が選べないと思います。  \r\nちなみに私は最新版にアップデートする際、ダウンロードするファイルが3GBを超えてました。クソ長かったわ。\r\n\r\n# プロジェクト作成\r\n検索ボックスに`wpf`って入れれば出ます。  \r\n`.NET Framework`じゃないほうを選びましょうね。\r\n![Imgur](https://imgur.com/BHxIloY.png)\r\n\r\n\r\nその後の`プロジェクト名`とかは各自決めてね。\r\n\r\n# ぷよぐらみんぐ\r\n久々のC#くんです。  \r\n（多分）Androidと同じ感じで、xamlでレイアウト決めて、C#でプログラムを書いていく感じですが、ちょっと違うのね。\r\n\r\n- Androidの`findViewById`\r\n    - C#ではレイアウトに`Name`付けとけばC#から扱える。\r\n    - KotlinでfindViewByIdが省略できるみたいな感じで書ける。\r\n\r\n## レイアウト\r\n**MainWindow.xaml**\r\n\r\n```xml\r\n<Window x:Class=\"DotNetCoreWPF.MainWindow\"\r\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n        xmlns:local=\"clr-namespace:DotNetCoreWPF\"\r\n        mc:Ignorable=\"d\"\r\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\r\n    <Grid>\r\n        <TextBox FontSize=\"20\" HorizontalAlignment=\"Center\" Name=\"TimeTextBox\" Text=\"\" TextWrapping=\"Wrap\" TextAlignment=\"Center\" VerticalAlignment=\"Center\" Height=\"30\" Width=\"228\"/>\r\n\r\n    </Grid>\r\n</Window>\r\n```\r\n\r\n真ん中にテキストを表示する`TextBox`を置いただけです。  \r\n\r\n## C#\r\n**MainWindow.cs**\r\n上の`using`は省略してるので気をつけて\r\n```cs\r\nnamespace DotNetCoreWPF\r\n{\r\n    /// <summary>\r\n    /// Interaction logic for MainWindow.xaml\r\n    /// </summary>\r\n    public partial class MainWindow : Window\r\n    {\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n\r\n            // タイマー初期化\r\n            var dispatcherTimer = new DispatcherTimer();\r\n            dispatcherTimer.Tick += new EventHandler(dispatcherTimer_Tick);\r\n            dispatcherTimer.Interval = new TimeSpan(0, 0, 1);\r\n            dispatcherTimer.Start();\r\n\r\n        }\r\n\r\n        // タイマーで毎秒ここ呼ばれる。\r\n        private void dispatcherTimer_Tick(object sender, EventArgs e)\r\n        {\r\n            // 時間を表示\r\n            TimeTextBox.Text = DateTime.Now.ToString();\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\nこれでデジタル時計の完成です。はっっや\r\n\r\n![Imgur](https://imgur.com/ZmZzxBb.png)\r\n\r\n# exeにする\r\n`.NET Framework`時代ではどうやってexeを配布してたのかよくわかりませんが、  \r\n`.NET Core`では**自己完結型**が使えるそうです。（.NET Frameworkじゃできない？）  \r\n## 自己完結型 #とは\r\n必要なもの全部を一つの`exeファイル`にできる機能。  \r\nちょっと前だとWindowsのフリーソフトを入れる際に、**.NET Framework のバージョンなんとか以上が必要**みたいなやつがよくありましたが、  \r\n`.NET Core（正確には3.0から）`では.NET Core（.NET Frameworkの後継）が入っていないPCでも実行できるように、.NET Coreのランタイムやらなんやらを一つのexeにいれて環境に関係なく動くようになるらしい。  \r\n変わりにファイルサイズが大きくなるけど。  \r\n\r\n今回は`.NET Core ランタイム入り（.NET Core入ってないPCでも動くやつ）`と`.NET Coreのランタイム無し`の両方をやろうと思います。\r\n\r\n## ソリューションエクスプローラー開いて\r\n名前のところを押して**発行**を押します。\r\n\r\n![Imgur](https://imgur.com/xjXxEdu.png)\r\n\r\n**フォルダー**を選んで次へ\r\n\r\n![Imgur](https://imgur.com/WBZdhUB.png)\r\n\r\nそのまま**完了**押して良いと思います。\r\n\r\n![Imgur](https://imgur.com/gZPdL5D.png)\r\n\r\nそしたら後ろのVS 2019の内容が画像のように変わるので、**構成**のところの鉛筆マークを押します。\r\n\r\n![Imgur](https://imgur.com/dGv9U3Z.png)\r\n\r\nそしてこの先は作りたいexeファイルによって操作が変わります。\r\n\r\n# .NET Core ランタイム入りのexeファイルを作成する\r\n\r\nプロファイル設定で、**配置モード**を**自己完結**にします。  \r\nそれから、下の**ファイルの公開オプション**を押して、**単一ファイルの作成**にチェックを入れます。\r\n\r\n![Imgur](https://imgur.com/ARUKDNH.png)\r\n\r\nそしたら保存して、**発行**ボタンを押せば作成されます。\r\n作成された`exeファイル`は`bin/Release/netcoreapp3.1/publish`の中にあると思います。\r\n\r\n実際に起動してみたの図。これだけなのにファイルサイズでけえ。\r\n![Imgur](https://imgur.com/hN2DDg4.png)\r\n\r\n# .NET Core ランタイム無しのexeファイルを作成する\r\n\r\nプロファイル設定で、**配置モード**を**フレームワーク依存**にします。  \r\nそれから、下の**ファイルの公開オプション**を押して、**単一ファイルの作成**にチェックを入れます。\r\n\r\n![Imgur](https://imgur.com/sRKKtZN.png)\r\n\r\nそしたら保存して、**発行**ボタンを押せば作成されます。\r\n作成された`exeファイル`は`bin/Release/netcoreapp3.1/publish`の中にあると思います。\r\n\r\n\r\n実際に起動してみたの図。ファイルサイズは小さい。\r\n\r\n![Imgur](https://imgur.com/byF4X4v.png)\r\n\r\n\r\n# おわりに\r\nこれで正解なのかはよく分かっていない。 \r\n\r\nというかなんで`TextBox`使ったの？`TextBlock`で良かったじゃん。\r\n\r\n一応ソースコード置いときますね→ https://github.com/takusan23/DotNetCoreWPF\r\n\r\nあと少しずれるんだけど、画像を入れても何故かコケる問題。画像を右クリックしてプロパティ選んで、ビルドアクションをリソースにすればいいのね。時間奪われた。\r\n\r\n# 参考にしました\r\nありがとうございます\r\n\r\n\r\nhttps://www.telerik.com/blogs/creating-a-single-exe-application-with-net-core\r\n\r\nhttps://techinfoofmicrosofttech.osscons.jp/index.php?.NET%20Core%E3%81%AE%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\r\n\r\nhttps://rksoftware.hatenablog.com/entry/2019/02/17/194701"},{"title":"運転免許証を更新してきた","link":"/posts/driver_license_kousin_syokai/","markdown":"\r\nちょっと前の話\r\n\r\n# やること\r\n\r\n## 試験場に行く\r\n休日は混んでるらしい  \r\n\r\n## 受付\r\n受付で住所とか書く紙をもらい書きます。\r\n\r\n## 支払い\r\nハガキに書いてある料金を払います。  \r\nカードも使えそうな雰囲気あったけど言い出しづらいから現金にしました。\r\n\r\n## 視力検査\r\nそのまんま\r\n\r\n## IC カードの暗証番号を決める\r\n四桁の数字を2つ用意する必要があります。（PIN 1 / PIN 2）  \r\n運転免許証 IC 仕様書によると、`PIN 1 / PIN 2`は同じ数字でも問題ないらしいです。  \r\n\r\n`運転免許証及び運転免許証作成システム等仕様書（仕様書バージョン番号：009)`より  \r\n`2-5` 参照\r\nhttps://www.npa.go.jp/laws/notification/koutuu/menkyo/menkyo20220830_187.pdf\r\n\r\n## 何やったか忘れた\r\nなんだっけ、今持ってる免許証に穴開けてた。  \r\n穴空いたので多分もう NFC は反応しない。\r\n\r\n## 顔写真の撮影\r\nその前になんかやった気がするけど...  \r\n座ってすぐ撮影だった  \r\n終わったらすぐ次の場所へ\r\n\r\n## 講習を聞く\r\n平日に行ったんですけど、半分くらい部屋が埋まってましたね、、、  \r\n休日来たらどうなってたんだろうこれ（普通に入れないと思うんだけど、、、部屋が増えるんでしょうか）\r\n\r\n初回は二時間コース  \r\nなんか自己診断やったから筆記用具が必要そう  \r\n\r\nなんか違反の話とか事故の話とか保険の話とかをする。最後にDVD見て終了。  \r\n\r\nモバイルノートパソコンくらいの大きさの紙袋を持ち帰るのでカバンとか持ってたほうが良さそう\r\n\r\n## 新しい免許証をもらう\r\nあとは新しい免許証をもらって、  \r\nICカードの記載合ってるか見て終わり。\r\n\r\n# 以上です\r\nはい"},{"title":"Fanzaでエロゲを買う","link":"/posts/eroge/","markdown":"<img src=\"https://imgur.com/aAhcJek.png\" width=\"400\">  \r\n\r\nかわいい\r\n\r\n## 本題\r\nセイイキシリーズ三作目がセール中だったので買ってみる\r\n\r\n### ログインをする\r\n無い場合はアカウントを作成しましょう。\r\n\r\n### ゲームを選ぶ\r\n今回は今すぐ購入をします\r\n\r\n![Imgur](https://imgur.com/2W67sS5.png)\r\n\r\n### 決済画面\r\nこんな感じ  \r\n![Imgur](https://imgur.com/xqp8v92.png)\r\n\r\n### ゲームをダウンロードする\r\n決済が終わると購入済み商品一覧画面になるので、買ったゲームを選んでダウンロードしましょう。  \r\n![Imgur](https://imgur.com/nncOhcN.png)\r\n\r\nあとソフト電池が必要って言われてますが、初回起動時にもダウンロードできるのでまあ飛ばします。\r\n\r\nダウンロードできたら解凍をします。そういえば皆さんは**解凍**派？それとも**展開**派？\r\n\r\n![Imgur](https://imgur.com/w6wu3TO.png)\r\n\r\n#### 複数のファイルに分かれている場合は\r\n（気になるから買ってみた）  \r\n結合ファイルと、分割ファイルをそれぞれダウンロードします。ファイルは全部同じフォルダに保存しないと駄目だと思う。  \r\nあと`WinRAR`が必要な雰囲気（なぜか変換できない（できてる））を出してますが、  \r\n別に必要ないです。（この場合は多分展開ソフトすらいらない）\r\n\r\n![Imgur](https://imgur.com/aahdbxW.png)\r\n\r\nダウンロードが終わったら、結合ファイル（`exe`のほう）を起動します。  \r\n少し待つと`Windows Defender`が警告を出しますがそのまま実行\r\n\r\n![Imgur](https://imgur.com/h8FHq48.png)\r\n\r\nそしたらなんか英語になっていますが、`Extract`をおして解凍を始めましょう。解凍先を変えたい場合は`Browse`を押せばいいです。\r\n\r\n![Imgur](https://imgur.com/pxjE53W.png)\r\n\r\n### インストーラーを起動\r\n今回買ったゲームは`setup.exe`を実行することでインストールができます（他のゲームは知らない）  \r\n保存先等はお好みで\r\n\r\n### 認証\r\n最後に、認証を済ませる必要があります。保存先のフォルダへ移動して、一度ゲームを開きます。  \r\n私の場合は二回目なのですでにソフト電池がインストールされているのですが、インストールされていない場合はインストールする必要があります。\r\n\r\n![Imgur](https://imgur.com/lK6nfN0.png)\r\n\r\nというわけでソフト電池ランタイムを入れます。  \r\nリンク：http://www.soft-denchi.jp/comdocs/dlguide/index.htm\r\n\r\n![Imgur](https://imgur.com/1QTXaf1.png)\r\n\r\nインストールできたらもう一度ゲームを起動させてみます。すると認証画面が出るので、  \r\n購入時に使ったDMMアカウントのメアド、パスワードを入力して`送信する`を押します。\r\n\r\n![Imgur](https://imgur.com/FDQ6r6x.png)\r\n\r\n成功すればゲームが起動します。やったね\r\n"},{"title":"Nuxt.jsとprocessmdでブログ作りたい。","link":"/posts/first/","markdown":"**Nuxt.js+processmd**でブログ作るよ\r\n\r\n# 環境\r\n| なまえ | あたい         |\r\n|--------|----------------|\r\n| OS     | Windows 10 Pro |\r\n| Node   | 12.14.1        |\r\n\r\n# Nuxt.jsプロジェクト作成\r\n\r\n```console\r\nnpx create-nuxt-app nuxtblog\r\n```\r\n\r\nあとは好きな方を選んでいきます\r\n- programming language\r\n    - TypeScriptにしといた（けどTS書き方分かんなくて途中からJSになってる。クソ参考にならねえじゃん）\r\n- UI framework\r\n    - Vuetifyがマテリアルデザイン（今回はElement使ってみる）\r\n- あとは適当に（PWA入れといた）\r\n\r\n```console\r\n✨  Generating Nuxt.js project in nuxtblog\r\n? Project name nuxtblog\r\n? Project description My cool Nuxt.js project\r\n? Author name takusan23\r\n? Choose programming language TypeScript     \r\n? Choose the package manager Npm      \r\n? Choose UI framework Element\r\n? Choose custom server framework None (Recommended) \r\n? Choose the runtime for TypeScript Default\r\n? Choose Nuxt.js modules Progressive Web App (PWA) Support\r\n? Choose linting tools (Press <space> to select, <a> to toggle all, <i> to invert selection)\r\n? Choose test framework None\r\n? Choose rendering mode Single Page App\r\n? Choose development tools (Press <space> to select, <a> to toggle all, <i> to invert selection)\r\n```\r\n\r\nそしたら移動して、サーバー起動させます\r\n\r\n```console\r\ncd nuxt blog\r\nnpm run dev\r\n```\r\n\r\n![Imgur](https://i.imgur.com/fsdnyw3.png)\r\n\r\n# Markdownファイルの保存場所を作る\r\n\r\nnuxtblogフォルダ(componentsとかassetsとかnode_moduleがあるフォルダ)に  \r\n**contentsフォルダ**を作り、その中に  \r\n**postsフォルダ**を作り、その中に  \r\n**markdownフォルダ**を作成します。\r\n\r\nこんな感じに\r\n\r\n![Imgur](https://i.imgur.com/9MkedEP.png)\r\n\r\n後は**Markdownフォルダ**にMarkdownファイルを置いていきます。  \r\n\r\n今回は適当にこんなMarkdownファイル（名前：first.md）を入れます。\r\n\r\n```markdown\r\n---\r\ntitle: Nuxt.jsの練習\r\ncreated_at: 2020-05-31\r\ntags:\r\n- JavaScript\r\n---\r\n# Hello World\r\n\r\n```\r\n\r\n# Markdownファイルの情報をJSONに変換するprocessmd\r\n\r\n## processmd入れます\r\n\r\n\r\n```console\r\nnpm install --save-dev processmd\r\n```\r\n\r\n## コマンド長いのでpackage.jsonに書き足します\r\n\r\n```json\r\n{\r\n  \"name\": \"nuxtblog\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"My cool Nuxt.js project\",\r\n  \"author\": \"takusan23\",\r\n  \"private\": true,\r\n  \"scripts\": {\r\n    \"dev\": \"nuxt\",\r\n    \"build\": \"nuxt build\",\r\n    \"start\": \"nuxt start\",\r\n    \"generate\": \"nuxt generate\",\r\n    \"md\": \"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json\"\r\n  },\r\n  \"dependencies\": {\r\n    \"nuxt\": \"^2.0.0\",\r\n    \"element-ui\": \"^2.4.11\",\r\n    \"@nuxtjs/pwa\": \"^3.0.0-0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@nuxt/typescript-build\": \"^0.6.0\",\r\n    \"processmd\": \"^4.5.0\"\r\n  }\r\n}\r\n```\r\n\r\nscriptsの中にmdの一行書き足せばおｋ\r\n```json\r\n\"md\": \"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json\"\r\n```\r\n\r\nあとはターミナルで以下叩きます。  \r\nこの作業は記事を追加したら毎回叩く必要があります。\r\n```console\r\nnpm run md\r\n```\r\n\r\n叩くとcontents/postsにjsonってフォルダが出来てると思います。あとsummary.jsonも\r\n\r\n# Nuxt.jsで記事一覧用意する\r\n\r\nこっからはコピペです。いくぞおおおおお  \r\n**pages/index.vue**を開いて以下のJSをどーん\r\n```vue\r\n<template>\r\n  <div class=\"container\">\r\n    <div>\r\n      <el-card class=\"box-card\" v-for=\"item in blogItems\" :key=\"item\">\r\n        <nuxt-link class=\"text item\" :to=\"`posts/${item.fileName}`\">{{ item.title }}</nuxt-link>\r\n      </el-card>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script lang=\"js\">\r\nimport Vue from 'vue'\r\nimport { fileMap } from \"../contents/posts/summary.json\";\r\n\r\nexport default {\r\n  data: () => {\r\n    return {\r\n      blogItems: []\r\n    };\r\n  },\r\n  created() {\r\n    // キーを取り出す\r\n    Object.keys(fileMap).forEach(title => {\r\n      // 記事一個ずつ取る\r\n      const blog = fileMap[title];\r\n      // 名前\r\n      const name = blog.sourceBase.replace(\".md\", \"\");\r\n      blog.fileName = name;\r\n      this.blogItems.push(blog);\r\n    });\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\nここではタイトルしか出てませんが、日付とかタグとかも出せると思います。\r\n\r\n![Imgur](https://i.imgur.com/LJF3l5H.png)\r\n\r\n> localhost:4545は別に気にしないでいいです。だた調子が悪かったのでポート番号を変えただけです。（nuxt --port 4545で変えられる）\r\n\r\n# 記事一覧ページを作る\r\n\r\n## 動的ルーティング # とは\r\nよくわからんけど静的サイトジェネレートに必要。  \r\nというわけで**nuxt.config.js**開いてね\r\n\r\n参考：https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2/\r\n参考：https://isoppp.com/note/2018-05-16/3-nuxt-firebase-blog-markdown/\r\n\r\n開いたらJS書き足していきます。\r\n\r\n```js\r\nconst { sourceFileArray } = require('./contents/posts/summary.json');\r\n\r\n/** パス生成 */\r\nconst sourceFileNameToUrl = filepath => {\r\n  const name = filepath.replace('contents/posts/markdown/', '').replace('.md', '')\r\n  return `/posts/${name}`\r\n}\r\n\r\nconst generateDynamicRoutes = callback => {\r\n  const routes = sourceFileArray.map(sourceFileName => {\r\n    return sourceFileNameToUrl(sourceFileName);\r\n  });\r\n  callback(null, routes);\r\n};\r\n\r\nexport default {\r\n// 省略\r\n  generate: {\r\n    routes: generateDynamicRoutes\r\n  },\r\n}\r\n```\r\n\r\nsourceFileNameToUrl()関数は`posts/${ファイル名}`の文字列を返す関数です。\r\n\r\nこうすることでURLが`posts/{タイトル}`になるはずです。  \r\nですがこれだけではまだ生成できません。\r\n\r\n生成するには、  \r\n**pagesフォルダ**に**posts**フォルダを作成して、  \r\nその中に **_slug.vue** ファイルを作成します。\r\n\r\n![Imgur](https://imgur.com/DSJ9WSc.png)\r\n\r\n## _slug.vueの中身\r\n**_slug.vue**は記事の表示に使います。  \r\n\r\n```vue\r\n<template>\r\n  <div class=\"container\">\r\n    <div>\r\n      <el-card class=\"box-card\">\r\n        <div>{{(new Date(created_at).toLocaleDateString())}} 投稿</div>\r\n        <div v-html=\"bodyHtml\"></div>\r\n      </el-card>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { sourceFileArray } from \"../../contents/posts/summary.json\";\r\n\r\nexport default {\r\n  // 記事があるかどうか。JSONのsourceFileArrayの配列に含まれているか確認している。\r\n  validate({ params }) {\r\n    return sourceFileArray.includes(\r\n      `contents/posts/markdown/${params.slug}.md`\r\n    );\r\n  },\r\n  // 各記事のJSONファイルを読み込んでる。\r\n  asyncData({ params }) {\r\n    return Object.assign(\r\n      {},\r\n      require(`~/contents/posts/json/${params.slug}.json`),\r\n      { params }\r\n    );\r\n  },\r\n  mounted() {\r\n    // DOM生成後\r\n  },\r\n  // さあ？\r\n  head() {\r\n    const title = `${this.title}`;\r\n    const url = `posts/${this.params.slug}/`;\r\n    return {\r\n      title: title,\r\n      meta: [\r\n        { hid: \"og:url\", property: \"og:url\", content: url },\r\n        { hid: \"og:title\", property: \"og:title\", content: title }\r\n      ],\r\n      link: [{ rel: \"canonical\", href: url }]\r\n    };\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\n記事一覧から選んだ時にちゃんとMarkdownの中身が表示されていれば動いてます。\r\n\r\n![Imgur](https://i.imgur.com/qbUf0P4.png)\r\n\r\n# おまけ 静的サイトジェネレートしてみる\r\n\r\n以下の一行をターミナルに入れます\r\n\r\n```console\r\nnpm run generate\r\n```\r\n\r\nこれで静的サイトが生成されました。後はこれをGitHubPagesに上げるなりすればいいと思います。  \r\n今回は**Web Server for Chrome**が入ってたのでそれ使って見てみます。  \r\n\r\n`npm run generate`の出力先は**dist**になってるのでそれを指定してWeb鯖立てます。\r\n\r\n![Imgur](https://i.imgur.com/O6uBFod.png)\r\n\r\n以上です。  \r\n一応/posts/first/にアクセスした後にF5（再読み込み）をかけても404にならないことを確認できたところで終わろうと思います。\r\n\r\n![Imgur](https://i.imgur.com/74quEU3.png)\r\n\r\nPWAも入れてあるので試せる。\r\n\r\n# おまけ\r\nGitHub Pages使う場合は、nuxt.config.jsをこんな感じにすればいいと思います。\r\n\r\n```js\r\nexport default {\r\n// 省略\r\n  router: {\r\n    base: '/リポジトリ名/'\r\n  },\r\n  generate: {\r\n    routes: generateDynamicRoutes,\r\n    dir: 'docs',\r\n  },\r\n}\r\n```\r\n\r\n# おわりに\r\n**nuxt.config.js**の`mode: 'spa'`ってSPAであってるの？\r\n静的サイトジェネレートの時は書いてなかったんだけど？\r\n\r\nソースコード：https://github.com/takusan23/NuxtBlog"},{"title":"初めての GitHub Actions 定期実行編","link":"/posts/github_actions/","markdown":"\n(多分最後の)夏休みが終わりますね  \n\n\n# 本題\nコロナカレンダーできました。  \n\n<a href=\"https://tokyo-covid19-calendar.netlify.app/\">![Imgur](https://imgur.com/hm8jXlf.png)\n</a>\n\n\nURLです：https://tokyo-covid19-calendar.netlify.app/  \n\nソースコードです：https://github.com/takusan23/tokyo_covid19_calendar\n\nでもこれ、データ（東京都 新型コロナウイルス陽性患者発表詳細）の更新があった際にいちいち\n\n- GitHubへプッシュする or 手動でNetlifyのデプロイボタンを押す\n    - Netlifyに設定したビルドコマンドが走る。以下\n        - 1: CSVファイルをダウンロード\n            - 東京都 新型コロナウイルス陽性患者発表詳細\n            - https://stopcovid19.metro.tokyo.lg.jp/data/130001_tokyo_covid19_patients.csv\n        - 2: CSVファイルをJSON形式へ変換するプログラムを動かす\n            - https://github.com/takusan23/tokyo_covid19_calendar/blob/master/download/main.js\n        - 3: データが揃ったところでNuxtの静的サイト書き出しを開始\n\nサイトの中身を更新するには、一日一回プッシュするか、手動でデプロイボタンを押さないと行けないんですよね。（そもそも手動でデプロイボタンを押すなんてあったっけ）  \n定期的に動かすにしてもずっとパソコン付けとくわけにも行かないし。  \nというわけで今回は**GitHub Actions**を使ってみようと思います。\n\n# GitHub Actions #とは\nCI/CDサービス は？  \nGitHubから直接コードをビルド、テスト、デプロイできるらしい\n\n## CI/CDサービス #とは\n自動でビルドしたりするサービスらしい。  \nデプロイも自分でやらずに任せることができるってことかな。  \n今回は定期実行させるけど、pushがあった時にデプロイ作業(`npm run generate`とか)をさせるみたいなことがやりたい場合はこれを使うらしい？\n\nまあすごい雑に言うと **GitHubの持ってるすごいパソコンを使って自動で作業をやらせることができる** ってことだと思います。\n\n~~というわけで、定期実行で何か成果をだしてコミット＆プッシュすれば自動草生やし機にもなれます。チートだね。~~\n\n# はじめる\n\nNetlifyにどうやって**ビルドしてくれ**って頼むかって言うと**WebHook**ってのを通じて行います。  \n\n**あとGitHub Actionsがコケると毎回メールで通知してくるので気をつけてね。**\n\n## GitHubのリポジトリのページを開いて\n\n**Actions**を見つけてください。\n\n![Imgur](https://imgur.com/jif7sE3.png)\n\n開いたら、`Set up this workflow`を押してみましょう。  \n\n![Imgur](https://imgur.com/8JrO3j1.png)\n\nもしない場合は `set up a workflow yourself` を押せばいいと思います\n\n![Imgur](https://imgur.com/jMFb5o8.png)\n\nするとこんな感じのエディタが開きます。  \nここにコマンドを書いたりするわけですね。  \n\n![Imgur](https://imgur.com/LXLmyZi.png)\n\n# 実行ボタンを付ける\n今現在（2020/08/24）、初期状態ではGitHub Actionsを実行するボタンは有りません。  \n初期状態のままだと、プッシュするまで動くかどうかわからんのです。\n\nというわけで実行ボタンを利用できるようにしましょう。  \n\nテキストの中から、`on:`ってところを探します。\n\n```yml\non:\n    push:\n      branches: [ master ]\n    pull_request:\n      branches: [ master ]\n```\n\nここらへんですね。\n\nそしたら一行`on:`の下に`workflow_dispatch:`を書き足します。こんな感じに\n```yml\non:\n    workflow_dispatch:\n    push:\n      branches: [ master ]\n    pull_request:\n      branches: [ master ]\n```\n\nこれで手動実行が利用できるようになりました。**というか初めから付けとけ**\n\n# 名前変更\n今のままだと`blank.yml`ってなってるので、何をするのワークフローなのか名前を変えてあげましょう。  \n今回は`interval_netlify_webhook.yml`とかにしておきますか\n\n![Imgur](https://imgur.com/kiWSwTB.png)\n\nそれとは別に、ワークフローの名前ってのがあります。  \nこれはGitHub Actionsの方で使われる名前になります（ファイル名とは別になってる）。  \n\n初期状態では`CI`ってなってますね。この名前はGitHub Actionsの一覧等で使われてます。  \nこちらも変えておきましょう\n```yml\n# This is a basic workflow to help you get started with Actions\n\nname: IntervalNetlifyWebHook\n```\n\nこういうところで使われている。まあ触ってみるのが一番早い  \n![Imgur](https://imgur.com/xqivVgN.png)\n\n# 書いていく\n## `on` (トリガー)\nこれからワークフローを起動する条件（トリガー）を書いていきましょう。  \nそれで定期実行（と手動実行）は以下のように書けばいいです。\n\n```yml\non:\n    workflow_dispatch:\n    schedule:\n      - cron: '0 0 * * *' # 日本時間朝の9時に毎日実行\n```\n\n0 0 って書いてるのになんで9時が出てくんだよって話ですが、これタイムゾーンがUTCになってるからですね。UTCで0時は日本(JST)では9時になります。  \n\nもし午前九時じゃやだ！って場合はこんなツールがあります：https://crontab.guru/\n\nこんかいはこのまま行きます。\n\n## `build`\n`build:`の下にある`runs-on`は環境ですので多分そのままでいいと思います(Windowsじゃなきゃダメみたいなら調べて)\n\nなので`steps:`から書いていきましょう。\n\n## `steps` (中身)\nここには仕事内容を書きます。Node.jsなら`npm install`とかですかね。  \n今回やりたいことはNetlifyにビルドしてくれって頼むことですね。WebHookを使います。  \nなので`on:`と`steps:`以外はあんま触らないのかな。\n\n### WebHookのURLを生成する\nNetlifyのサイトの設定画面へ入って、  \n`Build & Deploy`を押し、`Build hooks`まで進みます。\n![Imgur](https://imgur.com/eSQp9Bu.png)\n\nそしたら`Add build hook`をおして、適当な名前をつけて、URLを生成してもらいましょう。\n\nできたらこうです！\n\n```yml\n# NetlifyのWebHook\n  - name: Netlify WebHook\n    uses: wei/curl@v1.1.1\n    with:\n      args: -X POST -d {} ${{ secrets.WEBHOOK_URL }}\n```\n\n## WebHook URLの保存場所\nprivateなリポジトリじゃない場合はGitHub Actionsの中身も見れてしまうので(WebHook URL見られるとやばい)、WebHookのURLを別の場所に隠しておきましょう。  \nリポジトリの設定画面へ進んで、`Secrets`を選び、`New Secrets`を押しましょう。  \n![Imgur](https://imgur.com/WZeVJAN.png)\n\nnameに`WEBHOOK_URL`、valueにNetlifyから生成されたWebHook URLを入れます。\n\n# すべてくっつけたコード\n\n```yml\n# GitHub Actions 上での名前\n\nname: IntervalNetlifyWebHook\n\n# 起動条件\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * *' # 日本時間午前九時に毎日実行\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # こっから書いていく\n    steps:\n      \n    # NetlifyのWebHook\n      - name: Netlify WebHook\n        uses: wei/curl@v1.1.1\n        with:\n          args: -X POST -d {} ${{ secrets.WEBHOOK_URL }}\n```\n\n# 早速動かしてみる\n`Start Commit`を押して保存しましょう。  \n\n![Imgur](https://imgur.com/OrYpuL3.png)\n\nできたらまた`Actions`を開いてください。名前が増えていると思います。\n\n名前を押して`Run workflow`をおして<span style=\"border: solid 2px green;background-color:green;color:#fff;padding:2px;border-radius:5px\"> Run workflow </span>を押しましょう\n\n![Imgur](https://imgur.com/oY70nww.png)\n\n# 動いたか\n再読み込み？すると新しくなんかできるので押します。  \n![Imgur](https://imgur.com/4HK9rXd.png)\n\nそしたら横の`build`を選びます。  \n![Imgur](https://imgur.com/Q254eH2.png)\n\nちゃんとできてるみたいですね！\n\nそしてNetlifyの方でもビルドが走ってることが確認できました。\n\n![Imgur](https://imgur.com/433LX6W.png)\n\nこれで自動で指定した時間にNetlifyのビルドをさせることができました。やったぜ  \nコードはここです：[すべてくっつけたコード](#すべてくっつけたコード)\n\n# 番外編 自動草生やし機\nGitHub Actionsからコミット+プッシュしたい場合は参考にしてください。\n\n```yml\n# GitHub Actions 上での名前\n\nname: AutoGrass\n\n# 起動条件\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * *' # 日本時間午前九時に毎日実行\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # こっから書いていく\n    steps:\n      # リポジトリに触れるように\n      - uses: actions/checkout@v2\n      \n      # 適当なファイルを作る\n      - name: Update File\n        run: node main.js\n   \n      # Gitの設定する\n      - name: Git Setting\n        run: |\n          git config --global user.email \"${{ secrets.MAIL }}\"\n          git config --global user.name \"${{ secrets.USER_NAME }}\"\n                  \n      # CommitとPushする\n      - name: Commit and Push\n        run: |\n           git commit -m \"[GitHub Actions] File Update\" -a\n           git pull\n           git push origin master\n```\n\nGitHub Actionsで動かす`main.js`は以下\n```js\n/** 適当なファイルを生成するだけのNode.jsプログラム */\n\nconst fs = require('fs')\n// 書き込むテキスト\nconst text = new Date().toLocaleString()\n// 保存\nfs.writeFile(\"text.txt\", text, (err) => {\n    if (err) {\n        console.log(\"えらー\")\n    }\n})\n```\n\nGitHubのリポジトリの設定 > Secrets > New secret で2つ追加してください。\n\n- MAIL\n    - GitHubのメアド\n- USER_NAME\n    - GitHubのユーザー名\n\nソースコード（schedule:とその下がコメントアウトされてますので気をつけて）：https://github.com/takusan23/AutoGrassAction\n\n# おわりに\nGitHub Actionsのymlファイルはブラウザからしか変更できない？VSCodeで変更してPushすると怒られるし\n\nあと定期実行できてるかどうかは朝九時になるまでわからん。それまでのお楽しみ\n\n二学期かぁ。早起きするのつらい"},{"title":"GitHub Actions で AndroidのリリースAPK作成","link":"/posts/github_actions_android_release_apk/","markdown":"\r\nどうもこんばんわ。  \r\n創作彼女の恋愛公式 攻略しました。\r\n\r\nゆめみちゃんが可愛かったです。アペンド配信まだですか！！！！\r\n\r\n![Imgur](https://imgur.com/cDsSfhl.png)\r\n\r\n表情いっぱいあるのかわいい。\r\n\r\n![Imgur](https://imgur.com/1uoWiaU.png)\r\n\r\n![Imgur](https://imgur.com/VaS7aQw.png)\r\n\r\n共通が長いのが好きな方はどうぞ、わたし的には個別長いほうが良いかな\r\n\r\n![Imgur](https://imgur.com/PBlokGv.png)\r\n\r\n\r\n(え？グランドエンディング？...アペンド配信に期待)\r\n\r\n# 本題\r\nGitHub ActionsでAndroidのリリースAPKを作成したい！  \r\nreleaseブランチへpushしたら勝手にAPK作ってくれるようにしたい！\r\n\r\n## GitHub Actions\r\nこのブログでも何回か登場してるやつ。  \r\nビルド作業とかを自分のPCじゃなくてGitHubのマシンでやらせることができる。  \r\nしかもパブリックリポジトリなら無料！。  \r\n\r\n今回はこれを使ってそこそこ時間のかかるAPK作成をGitHub Actions（**他の人のPC**）にやらせます！\r\n\r\n## build.gradle.kts\r\n今回は`kts`へ移行した`build.gradle.kts`を利用します。  \r\n`build.gradle`の場合はコピペで動かないと思います；；\r\n\r\n# 流れ\r\n- (APK生成時のコードを管理しておく)releaseブランチを作成\r\n- `build.gradle.kts`を編集してコマンドラインからAPKを作成して署名できるようにする\r\n- 署名ファイルをBase64にする\r\n- `GitHub Actions`を組む\r\n- releaseブランチをpushする\r\n\r\n# つくる\r\n\r\n## releaseブランチを作成\r\n今回は`release`ブランチを作成して、このブランチに対してpushがあった際に自動でAPKを作成するようにします。  \r\nAPKを作成したい場合はこのブランチへmasterの中身をマージしてpushすれば良いわけなんですね。\r\n\r\n![Imgur](https://imgur.com/fcuuYib.png)\r\n\r\n(もし最初からあるmasterブランチをpushするたびにapkを作りたい場合はこれの作業はいらない)\r\n\r\n## build.gradle.ktsへ署名関係のプロパティを設定\r\nappフォルダにある`build.gradle.kts`を開きます。  \r\n`build.gradle`をお使いの方はすいませんわからないです(Kotlinしか分からんしKotlinも分からん)\r\n\r\nそしてコピペしてください。\r\n\r\n```kotlin\r\nimport java.util.*\r\n\r\n\r\nandroid {\r\n\r\n    // 省略\r\n    \r\n    // APK作成と署名の設定\r\n    signingConfigs {\r\n        // 環境変数から取りに行く\r\n        create(\"release_signing_config\") {\r\n            // 存在しない場合はとりあえずスルーする\r\n            if (System.getenv(\"ENV_SIGN_KEYSTORE_BASE64\") != null) {\r\n                // GitHubActionsの環境変数に入れておいた署名ファイルがBase64でエンコードされているので戻す\r\n                System.getenv(\"ENV_SIGN_KEYSTORE_BASE64\").let { base64 ->\r\n                    val decoder = Base64.getDecoder()\r\n                    // ルートフォルダに作成する\r\n                    File(\"keystore.jks\").also { file ->\r\n                        file.createNewFile()\r\n                        file.writeBytes(decoder.decode(base64))\r\n                    }\r\n                }\r\n                // どうやら appフォルダ の中を見に行ってるみたいなのでプロジェクトのルートフォルダを指定する\r\n                storeFile = File(rootProject.projectDir, \"keystore.jks\")\r\n                keyAlias = System.getenv(\"ENV_SIGN_KEY_ALIAS\")\r\n                keyPassword = System.getenv(\"ENV_SIGN_KEY_PASSWORD\")\r\n                storePassword = System.getenv(\"ENV_SIGN_STORE_PASSWORD\")\r\n            }\r\n        }\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            // 署名の設定を適用する\r\n            signingConfig = signingConfigs.getByName(\"release_signing_config\")\r\n            isMinifyEnabled = false\r\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n一番上の`import java.util.*`はBase64のデコードを行うために必要です。  \r\n\r\n### 雑な解説的な\r\n\r\n署名に使うパスワードとかは環境変数から取得するようにしました。  \r\n`build.gradle.kts`へ直接書くとパスワードが誰でも見れてしまうので大問題です。  \r\nじゃあどこにパスワードを保存しておくかという話ですが、GitHubのSecret機能にパスワードなんかの機密情報を登録しておきます。  \r\nそしてGitHub Actionsの環境変数をセットする際にSecretの値を使うことで、安全にパスワードを渡すことが出来ます。\r\n\r\nでも署名ファイルをどうやって渡すのかというのが問題になります。パスワードは文字列でしたが今回はファイルです。  \r\nこの問題を解決するのが`Base64`です。これを利用することでファイルをよく分からん文字列に変換してくれます（その逆も可）。文字列になったらこっちのものです。   \r\nなのでSecretへ文字列になった署名ファイルを登録しておいて、  \r\nビルド時に文字列から署名ファイルを作成することで安全に署名ファイルも管理できました。\r\n\r\n他の例だと、Base64へのエンコード/デコードをコマンドラインにやらせてる例がありますが、なんか`build.gradle.kts`の中でいい感じに変換できたのでこれで行きます。\r\n\r\n## 署名ファイルをBase64にする\r\nAndroidアプリの署名で使ってる`keystore.jks`みたいなファイルをBase64に変換します。  \r\nWindowsの標準機能でBase64に変換できるみたいなのでやってみましょう。\r\n\r\n適当なフォルダでPowerShellとかを開いてコマンドを叩きます\r\n\r\n![Imgur](https://imgur.com/EOXhnXm.png)\r\n\r\n```\r\ncertutil -encode {署名ファイルのパス} encode.txt\r\n```\r\n\r\nコマンドを叩くと`encode.txt`が出来てると思うので開いて、  \r\n`-----BEGIN CERTIFICATE-----`、`-----END CERTIFICATE-----`を消して  \r\n改行も消します。\r\n\r\n消せたらコピーします。\r\n\r\n## GitHub の Secret へ登録\r\nリポジトリの Secrets > Actions へ進みます。\r\n\r\n![Imgur](https://imgur.com/Z9Ok9ar.png)\r\n\r\nそしてこの中に署名で使うパスワード等を保存していくわけですが、  \r\nさっきの`build.gradle.kts`をパクった場合の名前と値の対応表です↓  \r\n名前変えた場合はそれぞれ変えて...\r\n\r\n**New repository secret**から追加できます。\r\n\r\n| 名前                     | 入れる中身               |\r\n|--------------------------|--------------------------|\r\n| ENV_SIGN_KEYSTORE_BASE64 | Base64にした署名ファイル |\r\n| ENV_SIGN_KEY_ALIAS       | Key alias                |\r\n| ENV_SIGN_KEY_PASSWORD    | Key password             |\r\n| ENV_SIGN_STORE_PASSWORD  | Key store password       |\r\n\r\nもしパクった場合はSecretはこうなります\r\n\r\n![Imgur](https://imgur.com/guaG8dc.png)\r\n\r\n## GitHub Actions を作成する\r\n\r\nGitHubのリポジトリにある`Actions`から新しいワークフローを作成します。  \r\nテンプレ置いておくので皆さんは Simple workflow を選んでいいですよ。\r\n\r\n![Imgur](https://imgur.com/DmOATvW.png)\r\n\r\nそしてAPKを作成するワークフローはこちらです！！！\r\n\r\n```yml\r\nname: Generate Release APK\r\n\r\non:\r\n  # releaseブランチ更新時に起動する\r\n  push:\r\n    branches: [ release ]\r\n  # 手動実行ボタン\r\n  workflow_dispatch:\r\n    \r\njobs:\r\n  build:\r\n\r\n    runs-on: ubuntu-latest\r\n\r\n    steps:\r\n    \r\n    # releaseブランチをチェックアウト\r\n    - uses: actions/checkout@v2\r\n      with:\r\n        ref: 'release'\r\n\r\n    # JDK導入\r\n    - name: set up JDK 11\r\n      uses: actions/setup-java@v2\r\n      with:\r\n        java-version: '11'\r\n        distribution: 'temurin'\r\n        cache: gradle\r\n    \r\n    # 権限を与える\r\n    - name: Grant permission gradlew\r\n      run: chmod +x gradlew\r\n      \r\n    # コマンドラインからAPKの作成。実行前に環境変数をGitHubActionsのSecretから取得\r\n    - name: Building APK\r\n      env:\r\n        ENV_SIGN_KEYSTORE_BASE64: ${{secrets.ENV_SIGN_KEYSTORE_BASE64}}\r\n        ENV_SIGN_KEY_ALIAS: ${{secrets.ENV_SIGN_KEY_ALIAS}}\r\n        ENV_SIGN_KEY_PASSWORD: ${{secrets.ENV_SIGN_KEY_PASSWORD}}\r\n        ENV_SIGN_STORE_PASSWORD: ${{secrets.ENV_SIGN_STORE_PASSWORD}}\r\n      run: ./gradlew assembleRelease\r\n\r\n    # アーティファクトとして保存\r\n    - name: Upload artifact\r\n      uses: actions/upload-artifact@v2\r\n      with:\r\n        name: app-release.apk\r\n        path: app/build/outputs/apk/release/app-release.apk\r\n```\r\n\r\nもしブランチ名が違う場合は `branches: [ release ]` と `ref: 'release'` の`release`の部分を各自書き換えてください。(`master`とか？)  \r\nGitHubのSecretは勝手に環境変数にはならないので、`env`で定義する必要があります。\r\n\r\n出来たらコミット+プッシュしましょう。\r\n\r\n![Imgur](https://imgur.com/DTux7Rj.png)\r\n\r\n## release ブランチを push してみる\r\n(releaseブランチをGitHub Actionsのトリガーにしていた場合)\r\n\r\nreleaseブランチに切り替えて、pushしてみます。  \r\nこれで動き始めるはず。Actionsタブへ移動します。\r\n\r\n![Imgur](https://imgur.com/YBBHkun.png)\r\n\r\n## 手動実行ボタンを使う\r\npushせずに動かすことが出来ます。ここをポチッと\r\n\r\n![Imgur](https://imgur.com/7Wy1SaZ.png)\r\n\r\nAPKもちゃんとアーティファクトの欄にありますね。  \r\nこれで自分のPCへ負荷をかけずにAPKを作ることが出来ました。やったー\r\n\r\n![Imgur](https://imgur.com/IwyCZpc.png)\r\n\r\n### おまけ 自分のPCで確認する編\r\n**Windows以外は知りません**\r\n\r\nAndroid Studioのターミナルを開きます。\r\n\r\n![Imgur](https://imgur.com/4knLAkM.png)\r\n\r\n環境変数の設定をします。`{}`の部分は各自違うと思うのでそれぞれ入れてください\r\n\r\n```bash\r\nset ENV_SIGN_KEYSTORE_BASE64 = {Base64にした署名ファイル}\r\nset ENV_SIGN_KEY_ALIAS = {Key alias}\r\nset ENV_SIGN_KEY_PASSWORD = {Key password}\r\nset ENV_SIGN_STORE_PASSWORD = {Key store password}\r\n```\r\n\r\n確認のために`set`を叩くと環境変数一覧を見ることが出来ます\r\n\r\n```\r\nset\r\n```\r\n\r\nパスワードとかに間違いがなければ以下のコマンドを入力します\r\n\r\n```\r\ngradlew assembleRelease\r\n```\r\n\r\n終わると `app/build/outputs/apk/release` の中にAPKが出来ていると思います。\r\n\r\n# 終わりに\r\n\r\n最低限の build.gradle.kts 置いておきます。\r\n\r\n```kotlin\r\n// トップレベル (appフォルダじゃない) build.gradle.kts\r\n\r\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    id(\"com.android.application\").version(\"7.1.0\").apply(false)\r\n    id(\"com.android.library\").version(\"7.1.0\").apply(false)\r\n    id(\"org.jetbrains.kotlin.android\").version(\"1.6.10\").apply(false)\r\n}\r\n\r\ntasks.register(\"clean\") {\r\n    doFirst {\r\n        delete(rootProject.buildDir)\r\n    }\r\n}\r\n```\r\n\r\n```kotlin\r\n// appフォルダ内 build.gradle.kts\r\n\r\nimport java.util.*\r\n\r\nplugins {\r\n    id(\"com.android.application\")\r\n    id(\"kotlin-android\")\r\n    id(\"kotlin-kapt\")\r\n}\r\n\r\nandroid {\r\n    compileSdk = 31\r\n\r\n    defaultConfig {\r\n        applicationId = \"io.github.takusan23.chocodroid\"\r\n        minSdk = 21\r\n        targetSdk = 31\r\n        versionCode = 1\r\n        versionName = \"1.0.0\"\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    compileOptions {\r\n        sourceCompatibility = JavaVersion.VERSION_1_8\r\n        targetCompatibility = JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n    buildFeatures {\r\n        viewBinding = true\r\n    }\r\n\r\n    // APK作成と署名の設定\r\n    signingConfigs {\r\n        /**\r\n         * 予め GitHubActions の環境変数に入れておく\r\n         *\r\n         * ローカル環境で行う場合 (Windows cmd.exe)\r\n         *\r\n         * set ENV_SIGN_KEYSTORE_BASE64 = Base64エンコードした署名ファイル\r\n         * set ENV_SIGN_KEY_ALIAS = KeyAlias\r\n         * set ENV_SIGN_KEY_PASSWORD = KeyPassword\r\n         * set ENV_SIGN_STORE_PASSWORD = StorePassword\r\n         * */\r\n        create(\"release_signing_config\") {\r\n            // 存在しない場合はとりあえずスルーする\r\n            if (System.getenv(\"ENV_SIGN_KEYSTORE_BASE64\") != null) {\r\n                // GitHubActionsの環境変数に入れておいた署名ファイルがBase64でエンコードされているので戻す\r\n                System.getenv(\"ENV_SIGN_KEYSTORE_BASE64\").let { base64 ->\r\n                    val decoder = Base64.getDecoder()\r\n                    // ルートフォルダに作成する\r\n                    File(\"keystore.jks\").also { file ->\r\n                        file.createNewFile()\r\n                        file.writeBytes(decoder.decode(base64))\r\n                    }\r\n                }\r\n                // どうやら appフォルダ の中を見に行ってるみたいなのでプロジェクトのルートフォルダを指定する\r\n                storeFile = File(rootProject.projectDir, \"keystore.jks\")\r\n                keyAlias = System.getenv(\"ENV_SIGN_KEY_ALIAS\")\r\n                keyPassword = System.getenv(\"ENV_SIGN_KEY_PASSWORD\")\r\n                storePassword = System.getenv(\"ENV_SIGN_STORE_PASSWORD\")\r\n            }\r\n        }\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            // 署名の設定を適用する\r\n            signingConfig = signingConfigs.getByName(\"release_signing_config\")\r\n            isMinifyEnabled = false\r\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\r\n        }\r\n    }\r\n\r\n}\r\n\r\ndependencies {\r\n  implementation(\"androidx.core:core-ktx:1.7.0\")\r\n  implementation(\"androidx.appcompat:appcompat:1.4.0\")\r\n  implementation(\"com.google.android.material:material:1.4.0\")\r\n  implementation(\"androidx.constraintlayout:constraintlayout:2.1.1\")\r\n  testImplementation(\"junit:junit:4.13.2\")\r\n  androidTestImplementation(\"androidx.test.ext:junit:1.1.3\")\r\n  androidTestImplementation(\"androidx.test.espresso:espresso-core:3.4.0\")\r\n}\r\n```"},{"title":"GitHub Actions でビルドして Netlify で公開する","link":"/posts/github_actions_netlify/","markdown":"どうもこんばんわ。成人おめでとうございます。  \r\n成人式は中学校楽しくなかったので行きませんでした。\r\n\r\n# 本題\r\n`Netlify`でどうやってもビルドが通らなくなってしまった、、\r\n\r\n# 環境\r\n| なまえ  | あたい                       |\r\n|---------|------------------------------|\r\n| Next.js | 13.1.1                       |\r\n| React   | 18.2.0                       |\r\n| Node.js | v18.13.0  (14系から更新した) |\r\n\r\n# どうやっても Netlify でビルドできなくなってしまった、、、\r\n目次機能を追加したら`Netlify`の環境でビルドできなくなりました。  \r\n手元ではビルドできるのに、、  \r\n\r\n目次を取得するために`jsdom`でHTMLをパースしてるのが悪いんか？若干メモリ多く使う＋処理時間も長くなるけど...不足するほどではないはず、なぜ？\r\n\r\n```plaintext\r\n1:47:29 AM: info  - Compiled successfully\r\n1:47:29 AM: info  - Collecting page data...\r\n1:47:43 AM: info  - Generating static pages (0/236)\r\n1:47:59 AM: info  - Generating static pages (59/236)\r\n1:48:04 AM: info  - Generating static pages (118/236)\r\n1:48:44 AM: Killed\r\n1:48:46 AM: ​\r\n1:48:46 AM:   \"build.command\" failed                                        \r\n1:48:46 AM: ────────────────────────────────────────────────────────────────\r\n1:48:46 AM: ​\r\n1:48:46 AM:   Error message\r\n1:48:46 AM:   Command failed with exit code 137: npm run deploy (https://ntl.fyi/exit-code-137)\r\n1:48:46 AM: ​\r\n1:48:46 AM:   Error location\r\n1:48:46 AM:   In Build command from Netlify app:\r\n1:48:46 AM:   npm run deploy\r\n```\r\n\r\n調べても出てこない、、ので良い機会だと思い`GitHub Actions`に移行しようかと思います。  \r\n`GitHub Actions -> Netlify`なんて何番煎じかよって話ですが一応残しておきます。\r\n\r\n## （ちなみに）やったこと\r\n手元ではビルドできるので。`Netlify`ってエラーログ見せてくれるのかな\r\n\r\n- `package-lock.json`の削除\r\n- `Node.js`を`14.x`から`18.x`へアップデート\r\n\r\n以上試しましたがダメでした。\r\n\r\n# GitHub Actions #とは\r\nほかみて\r\n\r\n[タグ名 GitHub Actions](/posts/tag/GitHub%20Actions/)\r\n\r\n# Netlify側のビルドを止める\r\nこれはサイトの詳細ページへ進み、`Site settings`を押して、`Build & deploy`を押し、`Stopped builds`を押します。\r\n\r\n![Imgur](https://imgur.com/H67TVrn.png)\r\n\r\n# 必要な値を集める\r\nGitHub Actions で利用する環境変数（アクセストークンみたいなやつ）を用意します。\r\n\r\n## NETLIFY_AUTH_TOKEN\r\nアカウントページの`Applications`へ進み、`New access token`を押します\r\n\r\n![Imgur](https://imgur.com/fFKKdKT.png)\r\n\r\nコピペして適当な場所に控えておきます。（メモ帳とか）\r\n\r\n## NETLIFY_SITE_ID\r\nこれはサイトの詳細ページへ進み、`Site settings`を押して、`Site ID:`の値をコピーします。ちょうどコピーボタンが出てますね。\r\n\r\n![Imgur](https://imgur.com/QrOEe6z.png)\r\n\r\n## GitHub Actions から参照できるように 環境変数 に追加する\r\n**Secrets**の中にある**Actions**を押します。\r\n\r\n![Imgur](https://imgur.com/FLHXe3c.png)\r\n\r\nそしたら、以下の名前で環境変数を作成します。  \r\n<span style=\"border: solid 2px green;background-color:green;color:#fff;padding:2px;border-radius:5px\"> New repository secret </span>を押すことで環境変数の追加ができます。\r\n\r\n![Imgur](https://imgur.com/oDkdXDx.png)\r\n\r\n| なまえ             | あたい                  |\r\n|--------------------|-------------------------|\r\n| NETLIFY_AUTH_TOKEN | `New access token` の値 |\r\n| NETLIFY_SITE_ID    | `Site ID:` の値         |\r\n\r\n# GitHub Actions を組む\r\nここから空の`yaml`ファイルが作成できるので\r\n\r\n![Imgur](https://imgur.com/nb1dvD4.png)\r\n\r\nあとは以下を参考に作ってください。  \r\n以下の値は環境によっては違うので、`yaml`調整してください！\r\n\r\n| なまえ         | あたい         |\r\n|----------------|----------------|\r\n| ビルドコマンド | npm run deploy |\r\n| 成果物保存先   | ./out          |\r\n\r\nビルドコマンド、成果物保存先フォルダ名とかは各自違うと思うので\r\n\r\n```yml\r\n# Netlify でビルドできなくなってしまったので GitHub Actions にやらせます\r\n\r\n# 名前\r\nname: Netlify Deploy\r\n\r\n# 起動条件。pushと手動起動\r\non:\r\n  push:\r\n  workflow_dispatch:\r\n\r\n# やらせること\r\njobs:\r\n  build:\r\n    # OS\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      \r\n      # Node.js インストール\r\n      - name: Install Node.js\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: 18.13.0\r\n      \r\n      # 依存関係\r\n      - name: Package install\r\n        run: npm i\r\n      \r\n      # 書き出し\r\n      - name: Build page\r\n        run: npm run deploy\r\n        \r\n      # Netlify アップロード\r\n      - name: Upload page\r\n        uses: netlify/actions/cli@master\r\n        with:\r\n          args: deploy --dir=./out --prod\r\n        env:\r\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\r\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\r\n```\r\n\r\n# コミットして実行する\r\nコミットします。`push`がトリガー？されるので`GitHub Actions`も動くと思います。\r\n\r\n![Imgur](https://imgur.com/kWVSwcB.png)\r\n\r\n成功しました。やったぜ～～～  \r\nそれにしても長いな、、、どうしようこれ\r\n\r\n![Imgur](https://imgur.com/vCeXSpb.png)\r\n\r\n# おまけ\r\n\r\n## 手動実行ボタン\r\nここ\r\n\r\n![Imgur](https://imgur.com/S52InIw.png)\r\n\r\n## Markdownに貼り付けるステータスバッジ？バッヂ？\r\n`Create status badge`から`Markdown`をコピーできます\r\n\r\n![Imgur](https://imgur.com/3oL1BLX.png)\r\n\r\n# おわりに1\r\nもしかしたら記事が多すぎたせいかもしれないです。少ない場合は以前通り`Netlify`でビルドできるかもしれないです。\r\n\r\n# おわりに2\r\n\r\n```ts\r\nimport { JSDOM } from \"jsdom\"\r\n\r\nstatic parseToc(html: string): TocData[] {\r\n    // HTML パーサー ライブラリを利用して h1 , h2 ... を取得する\r\n    // この関数は ブラウザ ではなく Node.js から呼び出されるため、document は使えない。\r\n    const window = (new JSDOM(html)).window\r\n    const document = window.document\r\n    const tocElementList = document.querySelectorAll('h1, h2, h3, h4, h5, h6')\r\n    // 目次データに変換して返す\r\n    const tocDataList: TocData[] = Array.from(tocElementList).map((element) => ({\r\n        label: element.textContent,\r\n        level: Number(element.tagName.charAt(1)), // h1 の 1 だけ取り出し数値型へ\r\n        hashTag: `#${element.getAttribute('id')}` // id属性 を取り出し、先頭に#をつける\r\n    }))\r\n    window.close()\r\n    return tocDataList\r\n}\r\n```\r\n\r\n目次機能のために生成したHTMLからh1,h2...を取得するために、HTMLパーサーにかけてるんですけど、これのせいで多分ビルド時間が伸びてしまった、、、  \r\n（10分以上かかる。`GitHub Actions`、パブリックリポジトリの場合は無料だけど長いのはちょっと、、）  \r\n`jsdom`じゃなくて`Unified`でいい感じに処理するべきなのかな。  \r\n（最初は`Unified`が吐き出す構文木をパースしてたけど、あとあとメンテすることを考えると`JS の Document`みたいな感じのAPIが使いやすいかなと思い切り替えたんですよね、、、）\r\n\r\n以上です。数値型への変換は`parseInt`より`Number`が良いって言ってました。"},{"title":"GitHubのリモートブランチを削除する","link":"/posts/github_remote_branch_delete/","markdown":"\r\nブラウザからできます。\r\n\r\n## リポジトリを開く\r\nはい\r\n\r\n![Imgur](https://imgur.com/1dZQe8v.png)\r\n\r\n## branches を押す\r\nここ\r\n\r\n![Imgur](https://imgur.com/KuOq8yr.png)\r\n\r\n## ゴミ箱ボタンを押す\r\n`Your branches`と`Active branches`の2つに表示されてても、どちらか片方を押せば両方消えます。\r\n\r\n![Imgur](https://imgur.com/gKlbMoa.png)\r\n\r\nおしまい"},{"title":"Gitでコミットとプッシュし終わったあとに間違いに気付いてコミットをやり直したい場合は","link":"/posts/git_commit_and_push_kaizan/","markdown":"\n歴史改ざんです。\n\n# 本題\n\n- 1.コミットをする\n- 2.プッシュをする\n- 3.草を生やす\n- 4.消し忘れてた関数があることに気付く\n    - いまここ\n    - 1からやり直したい！！！\n\n# コマンドを叩きます\n今回は`Git Bash`を使います。  \n~~目に優しくない~~`PowerShell`だと日本語が化けちゃった。\n\nというわけで`.git`フォルダーがあるフォルダーで右クリックして、`Git Bash Here`を選び起動しましょう。\n\n## (ちなみに)コミットメッセージだけを変更するだけなら\nプログラムの変更なしでコミットメッセージだけを変える場合は以下を叩きます。`--amend`ってのが重要？\n\n```\ngit commit --amend -m コミットメッセージ\n```\n\nリモートリポジトリへプッシュをする際は以下を叩きます。\n\n```\ngit push -f origin HEAD\n```\n\n動くかどうかは怪しい\n\n# 現状のコミット\nまずコミット履歴を見ましょう。\n```\ngit log\n```\n叩くと以下のように表示されるはずです。\n\n```terminal\ncommit b1469aa3cf2cdddb9cfd4877a52018ff17756849 (HEAD -> master)\nAuthor: メアドは隠させてもらったよ\nDate:   Sun Sep 27 02:57:26 2020 +0900\n\n    取り消し予定\n\ncommit 30eac0d8e356bc9e28d92f34edd8727bc45ff749\nAuthor: メアドは隠させてもらったよ\nDate:   Sun Sep 27 02:47:00 2020 +0900\n\n    コミット練習\n\ncommit ae1c9930cfb302dc7680cd6ce94c7aaa6dbe5e84\nAuthor: メアドは隠させてもらったよ\nDate:   Sun Sep 27 02:46:30 2020 +0900\n\n    メモ追加\n\n```\n\n(メアドは隠させてもらいました)。\n\nこのコミットの中から、今回は一番上の`取り消し予定`ってコミットを消そうと思います。\n\n**それと、履歴表示を終了させてターミナルに戻る場合はキーボードの`q`を押します**\n\n# 直前のコミットを取り消す\nコミットを取り消すんですが、注意したいことが\n\n## `git reset --hard` vs `git reset --soft`\n変更点をそのままにするかどうかです。\n- hard\n    - 変更もすべて戻す\n    - せっかく書いたプログラムが水の泡になる\n- soft\n    - コミットだけ取り消して、変更はそのままにする\n    - **コミットをやり直す場合はこっちを選ぶ**\n\nこれを踏まえて、今回は変更点はそのままコミットのみなかったことにします。\n\n```terminal\ngit reset --soft HEAD^\n```\n\n変更点はそのまま、コミットだけが取り消されてるはずです。\n\n# コミット履歴を確認してみる\n以下のコマンドを叩きます\n\n```terminal\ngit log\n```\n\nすると、`メモだよ`のコミットが無いことになっていますね！歴史改ざんｋｔｋｒ\n\n```terminal\ncommit 30eac0d8e356bc9e28d92f34edd8727bc45ff749 (HEAD -> master)\nAuthor: メアド隠し\nDate:   Sun Sep 27 02:47:00 2020 +0900\n\n    コミット練習\n\ncommit ae1c9930cfb302dc7680cd6ce94c7aaa6dbe5e84\nAuthor: メアド隠し\nDate:   Sun Sep 27 02:46:30 2020 +0900\n\n    メモ追加\n\n```\n\n(メアドは隠させてもらったよ)\n\n\n# プッシュする\n以下のコマンドを叩きます\n\n```terminal\ngit push -f origin HEAD\n```\n\n`-f`をつけることで**歴史改ざんを押し通す**事ができます。\n\n# おまけ\n\n# git reflog が長すぎてターミナルに戻れない\nキーボードの`q`を押せばターミナルへ戻れます。\n\n# 間違えて git reset --hard してしまった\nつまりこれやったってことですね。\n```\ngit reset --hard HEAD^\n```\n\n落ち着いてください！どうにかなります\n\n## git reflog は見ている\n以下のコマンドを叩きます\n```\ngit reflog\n```\n\nすると`git log`よりも詳細な履歴が見れるはずです\n\n```\n30eac0d (HEAD -> master) HEAD@{0}: reset: moving to HEAD^\nb621189 HEAD@{1}: commit: 取り消し予定\n30eac0d (HEAD -> master) HEAD@{2}: reset: moving to HEAD^\nb1469aa HEAD@{3}: commit: 取り消し予定\n30eac0d (HEAD -> master) HEAD@{4}: reset: moving to HEAD^\n8cd8de9 HEAD@{5}: commit: 取り消すコミット\n30eac0d (HEAD -> master) HEAD@{6}: reset: moving to HEAD@{1}\n8780022 HEAD@{7}: commit: メモだよ\n30eac0d (HEAD -> master) HEAD@{8}: commit: コミット練習\nae1c993 HEAD@{9}: commit (initial): メモ追加\n```\n\n## 目的のコミットまで戻る\n戻りたいコミットを探し（今回は：`b621189 HEAD@{1}: commit: 取り消し予定`）、`HEAD@{1}`の部分を控えます。\n\nそして以下のコマンドを叩きます。\n```\ngit reset --hard HEAD@{1}\n```\n\n`--hard`じゃないとダメみたいです\n\nこれで無事に戻ってこれるはずです。\n\nGit難しいね\n\n# 参考にしました\nhttps://qiita.com/ritukiii/items/74ee3274c3f218511a0c\n\nhttps://reasonable-code.com/git-push-cancel/#git_reset"},{"title":"Gitでコンフリクトしたから直す（Android Studio）","link":"/posts/git_conflict/","markdown":"\r\nスーツ高いね\r\n\r\n# 本題\r\n- しれっと仕様変更が入る  \r\n- アプリが動かなくなる\r\n- いったんリリース用のブランチに切り替える\r\n    - 開発中はまだリリースできないのでリリース時までいったんタイムスリップ\r\n- 修正する\r\n- リリースする\r\n- 開発用ブランチにリリース用ブランチの内容を反映させる\r\n    - (masterブランチに切り替えて) git merge release\r\n- 競合（コンフリクト）を起こす\r\n- <p style=\"color:red\">↑今ここ</p>\r\n\r\n# Android Studio で直す\r\n`git merge release`（releaseはブランチ名）を実行してコンフリクトを起こすとこうなります\r\n\r\n```\r\nAuto-merging app/src/main/res/values/strings.xml\r\nCONFLICT (content): Merge conflict in app/src/main/res/values/strings.xml\r\nAuto-merging app/src/main/res/values-ja/strings.xml\r\nCONFLICT (content): Merge conflict in app/src/main/res/values-ja/strings.xml\r\n```\r\n\r\n*反映しようと思ったら同じところが編集されていて動けなくなってるGitのメッセージ*\r\n\r\nこのままでは実行できないので直しに行きます。\r\n\r\nちなみにAndroid Studioでは赤く表示されます\r\n\r\n![Imgur](https://imgur.com/5rx8pRF.png)\r\n\r\n該当のファイルを開いて（もしかしたら何でもいいかもしれない）、右クリック→Git→`Resolve Conflicts...`を選びます。\r\n\r\n![Imgur](https://imgur.com/IRe64dn.png)\r\n\r\nそしたらこんな感じになるので、どっちを取るか、もしくはマージするか選びます。  \r\n今回は両方取るマージを押しますが、プログラムによっては`}`とか終了タグが足りなくなったりするかもしれないので気をつけて。\r\n\r\n![Imgur](https://imgur.com/R7N8v0k.png)\r\n\r\nするとこんな感じになる。真ん中がマージ結果。左が今のブランチ、右が取り込んだブランチになってます。\r\n\r\n![Imgur](https://imgur.com/qYE2nLl.png)\r\n\r\nまずは今のブランチの内容を結果へ取り込みます。`>>`ってところを押せば取り込めます。\r\n\r\n![Imgur](https://imgur.com/ras2mpG.png)\r\n\r\nこれで結果へ取り込めました。\r\n\r\n![Imgur](https://imgur.com/XXUHBAc.png)\r\n\r\n次は、取り込んだブランチ先の変更も取り込みます。  \r\n右側のところにある`└└`みたいなところを押します。\r\n\r\n![Imgur](https://imgur.com/Nd9wqFn.png)\r\n\r\nこれで両方を取り込む事ができました。  \r\n`Apply`を押して閉じましょう。\r\n\r\n![Imgur](https://imgur.com/LICxKod.png)\r\n\r\n他のファイルも同じ手順で直して行きましょう。（直せれば）\r\n"},{"title":"ideaフォルダをバージョン管理対象外にする","link":"/posts/git_idea_dir_ignore/","markdown":"どうもこんばんわ。  \nGitよくわからんからやらかすとまじで焦る\n\n# 本題\nプロジェクト作成すると出来る`.ideaフォルダ`を追跡対象外にしたい\n\n# .gitignore に書き足す\n`.gitignore`を開き、`/.idea/`を足します。\n\n![Imgur](https://imgur.com/NlexAey.png)\n\n# キャッシュを消します\nここで**どーせキャッシュなんだし全部消してしまえｗ**ってやって消すと後で、  \n`git add .`を叩くことになるんですが、これ`.gitignore`に記述していないファイル全部が対象になってしまうのでやめとけ。  \n(まぁ`git add`で追加されたくない→`わざと git add しない`んじゃなくて`.gitignore書け`って話なんでしょうが)\n\nファイル名を指定してキャッシュを消すことができるので、以下のコマンドを叩きます\n\n```\ngit rm -r --cached .idea\n```\n\n# コミットとプッシュ\n\nそしたらコミットとプッシュします。おしまい\n\n# 終わりに\nてか初めから`.idea`対象外にしてほしくない？  \n他のパソコンで私のリポジトリをクローンして実行しようとすると、`.idea`のせいで`JDKのパスが間違ってまーす`って言われることあるしなあ。  \nちなみに`.idea`消すと整形の設定とか二回目以降開いたかどうかとかのローカルの設定内容が飛ぶだけなのでなんか昨日と違うなってときは消してみるといいかも？"},{"title":"GitHubへSSHで入れるようにする","link":"/posts/git_ssh_setup/","markdown":"どうもこんばんわ。  \r\n特に書くことがなかった。\r\n\r\n# 本題\r\nGitHubへSSHで入るまでやります。  \r\nいつの間にかパスワード使えなくなったみたいなので。\r\n\r\n## 設定したら何ができるの\r\nGitHubへ`push`とかプライベートリポジトリの`clone`とか。  \r\nGitHubにログインしないといけない系のやつ。\r\n\r\n## Android Studio じゃ聞かれない問題\r\nこの優秀IDE（HDD接続の種類じゃない）たちはGitHubのアクセストークンを使ってるので。\r\n\r\n# 環境\r\n| なまえ     | あたい         |\r\n|------------|----------------|\r\n| OS         | Windows 10 Pro |\r\n| ターミナル | Git Bash       |\r\n\r\n\r\n# 公式\r\n\r\nhttps://docs.github.com/ja/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\r\n\r\nhttps://docs.github.com/ja/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account\r\n\r\n# SSHのキーを作成する\r\n\r\n## 保存するフォルダを作成する\r\n\r\n`C:\\Users\\<ユーザー名>`に`.ssh`フォルダがあればいいのですが、ない場合は作ります。  \r\n\r\n![Imgur](https://imgur.com/b6e2Gdl.png)\r\n\r\n`.ssh`を開いて、その中で右クリックをして、`Git Bash Here`を押して開きます。  \r\nちなみになんかファイルがありますが気にしないでください。\r\n\r\n![Imgur](https://imgur.com/sd4iPRw.png)\r\n\r\n## SSHキーを作成\r\n\r\nGit Bashに以下を打ち込みます。  \r\n`ssh-keygen -t ed25519`だけでもいいらしいですが公式はGitHubで使ってるメアドを入れてたので私も入れた\r\n\r\n```terminal\r\nssh-keygen -t ed25519 -C \"GitHubで使ってるメアド\"\r\n```\r\n\r\n入力してEnterを叩くと、3回聞かれます。  \r\n\r\n- Enter a file in which to save the key\r\n    - 保存先ここなのでそのままEnter\r\n- Enter passphrase\r\n    - パスワード。パスワードを入れたほうがいいらしい。空でもいいのでEnter\r\n- Enter same passphrase again\r\n    - 空にしたのでEnter\r\n\r\nこれでさっきのフォルダに2つのファイルが出来ているはずです。  \r\n`.pub`の方をGitHubへ教えてあげることでSSHで入れるようになります。\r\n\r\n![Imgur](https://imgur.com/6bQnNan.png)\r\n\r\nGit Bashはまだ使うので開いておいてください。\r\n\r\n# GitHubの設定を開く\r\n\r\nここです。  \r\n\r\n![Imgur](https://imgur.com/Txpfhgu.png)\r\n\r\n開いたら、横のメニューの`SSH and GPG keys`を押します。押したらSSH keysの隣りにある、`New SSH key`を選びます。\r\n\r\n![Imgur](https://imgur.com/fLgHxK3.png)\r\n\r\nこんな画面になるはずなので、項目を埋めていきます。\r\n\r\n![Imgur](https://imgur.com/atWouU8.png)\r\n\r\n- Title\r\n    - 名前です。今使ってるパソコンの名前とか入れておけばいいでしょう（Windows とか）\r\n- Key\r\n    - さっきのGit Bashを使います。消しちゃった場合は`.ssh`フォルダを開いてまたGit Bashで開けばいいです。\r\n    - 以下のコマンドを打ちます。\r\n        - `clip < ~/.ssh/id_ed25519.pub`\r\n\r\nこれでクリップボードに公開鍵の中身がコピーされました。  \r\nあとはこれを`GitHub`の`Key`に貼り付けて、`Add SSH key`を押して保存します。\r\n\r\n# 疎通確認\r\n\r\n以下のコマンドをGit Bash打ちます。  \r\nGitHub Enterprise の場合は`git@github.com`の部分を各自変えてください。\r\n\r\n```\r\nssh -T git@github.com\r\n```\r\n\r\nGitHubのユーザー名以外は同じ文字列が返ってくるはずです。お疲れさまでした。\r\n\r\n```\r\nHi takusan23! You've successfully authenticated, but GitHub does not provide shell access.\r\n```\r\n\r\n秘密鍵なんですが、`.ssh`フォルダから移動せず、名前も変更してない場合は自動で探してくれます。\r\n\r\nこれで自分のプライベートリポジトリもクローンできるようになったはず？\r\n\r\n以上です。お疲れさまでした。"},{"title":"赤外線のNECフォーマット調査まとめ？","link":"/posts/ir_nec_format/","markdown":"\r\n[この記事](/posts/summer_vacation_android_ir/)の赤外線パターン解説編？\r\n\r\n\r\n# 変換用Webページ出来ました\r\n\r\n多分使えます。\r\n\r\nhttps://nec-ir-pattern-hex.netlify.app/\r\n\r\nソースコード(`Kotlin/JS製Webアプリ`)：https://github.com/takusan23/IRPatternHex\r\n\r\n![Imgur](https://imgur.com/cs6t3lv.png)\r\n\r\n## 赤外線のパターンを16進数に変換する\r\n\r\nスタートはこれ\r\n\r\n```js\r\n[8925, 4540, 514, 626, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 626, 514]\r\n```\r\n\r\nそしてゴールはこれです。\r\n\r\n```\r\n0x41b67d82\r\n```\r\n\r\n調べていると赤外線のパターンではなく、`データは 0x~ です！`みたいなのを見かけたので調査。\r\n\r\n**合っているかは知りません。**\r\n\r\n参考にしました：\r\n\r\nhttp://shrkn65.nobody.jp/remocon/nec.html  \r\nhttp://elm-chan.org/docs/ir_format.html  \r\nhttps://qiita.com/katsumin/items/517cd9fbe66e26d72fa7  \r\nhttps://god-support.blogspot.com/2020/08/nec.html  \r\n\r\n### やってること\r\n\r\n- 赤外線パターンからどこのフォーマットを使っているかを調べる。\r\n- フォーマットの仕様に沿って、データ部(後述)を0と1に変換\r\n- 最後に16進数に変換\r\n\r\nいくつかあるフォーマット（NEC / 家製協(AEHA) / SONY）の中から今回はNECフォーマットの解説を。\r\n\r\n### そもそも赤外線パターンの数値何？\r\n\r\n赤外線LEDを`8.925ミリ秒`ONにして、`4.540ミリ秒`OFFにして、`5.14ミリ秒`ONにする...って意味です。\r\n\r\n```json\r\n[8925, 4540, 514, 626, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 626, 514]\r\n```\r\n\r\n### この先出る T(変調単位) について\r\n\r\n`NECフォーマット`の場合はおおよそ`562`が使われています。リモコンによってばらつきがあると思う。  \r\nので、`Tの1倍`って書いてあった場合は、`T*1 = 562`、`Tの3倍`って書いてあった場合は`T*3 = 1686`ってことです\r\n\r\n### 赤外線パターンの構造\r\n\r\n```\r\n+---------------------------------------------------------------------------------------------------\r\n| リーダー部 2bit | データ部 32bit         | トレーラー部 1bit |\r\n+---------------------------------------------------------------------------------------------------\r\n```\r\n\r\n上記のアスキーアートのようになってます。良くわからんと思いますのでもう少し解説続けます。\r\n\r\n### リーダー部\r\n\r\n最初のON、OFFのデータがリーダー部となっております。  \r\nNECフォーマットの場合おおよそ、ONは`9ミリ秒(Tの16倍)`、OFFは`4.5ミリ秒(Tの9倍)`に近い値になるみたいです。\r\n\r\n実際のデータ（省略版）を見てもNECフォーマットっぽいです。（NECのシーリングライトなのでそれはそう）  \r\n\r\n```js\r\n[\r\n    8925, 4540, // ここが 9000 , 4500 ぐらいならNECフォーマット\r\n    514, 626,\r\n    514,\r\n]\r\n```\r\n\r\n### データ部\r\n\r\n3番目からデータになっています。ここで見てほしいのは右と左のペア（下のコードでは隣同士に整形しておいた）です。    \r\n実際のデータを見ると**なんか近い値**と**明らかに2、3倍になってる**数値が見えてくると思います。\r\n\r\n```js\r\n[\r\n    8925, 4540, // リーダー部 NECフォーマットと判明\r\n    514, 626, // 近い数値だな...\r\n    514, 1730,  // 3倍ぐらいになってる！？\r\n    514, 626,  // 近い数値だな...\r\n    514\r\n]\r\n```\r\n\r\nNECフォーマットの仕様では、  \r\n\r\nONが `Tの1倍 -> Tの1倍` の順番になってて、データは`0`  \r\nOFFが `Tの1倍 -> Tの3倍`の順番になっていて、データは`1`になっているみたいです。？\r\n\r\n実際のデータにコメントとして書き足すと\r\n\r\n```js\r\n[\r\n    8925, 4540, // リーダー部 \r\n    514, 626, // ON データ0\r\n    514, 1730,  // OFF データ1\r\n    514, 626,  // ON データ0\r\n    514\r\n]\r\n```\r\n\r\nって感じになっています。`514`->`626`で正確に1倍にはなっていないのですが多分データ0で合ってます。  \r\nこの`0`と`1`がNECフォーマットでは32個続きます（`32bit`）\r\n\r\n### 32bitのデータの中身\r\n`16bit`で区切ります。  \r\n区切って、前の`16bit`がカスタマーコード、後ろの`16bit`がデータです。  \r\n\r\n```\r\n0100000110110110 0110010110011010\r\n```\r\n\r\n後ろの`16bit`は、さらに`8bit`に分けることが出来ます。\r\n\r\n```\r\n01100101 10011010\r\n```\r\n\r\n前の`8bit`がデータ、後ろの`8bit`は前の`8bit`の反転になっていて、正しいデータか検証出来るようにしているそうです。(0なら1、1なら0)\r\n\r\n```js\r\n01100101 // 前の8bit\r\n10011010 // 後ろの8bit。前の8bitと比べて0と1が反転している。\r\n```\r\n\r\n### トレーラー部\r\n\r\nよくわからん。取得したデータの最後の`Tの1倍`の値がそうだと思う。  \r\n\r\n### データ部を2進数に変換する\r\n取得したデータの中から、まずリーダー部(最初の2個)とトレーラー部(最後の1個)を消します。\r\n\r\n解説用に短くしています。\r\n\r\n```js\r\n[8925, 4540, 514, 626, 514, 1730, 514, 626, 514]\r\n```\r\n\r\nこんな感じ？\r\n\r\n```js\r\n[514, 626, 514, 1730, 514, 626]\r\n```\r\n\r\n次に、`[1,2]`、`[3,4]`...のようにまとめていきます\r\n\r\n```js\r\n[[514, 626], [514, 1730], [514, 626]]\r\n```\r\n\r\nその後、まとめた数値を比較して、最初の値を2倍してももう一方が大きい場合は`1`、そうでない場合は`0`を入れていきます  \r\n仕様では`Tの3倍`です。がばらつきがあるのでしゃーない。\r\n\r\n```js\r\n[\r\n    [514, 626],  // 2倍以上ではない => 0\r\n    [514, 1730],  // 2倍以上 => 1\r\n    [514, 626]  // 2倍以上ではない => 0\r\n]\r\n```\r\n\r\nこんな風に\r\n\r\n```js\r\n[0, 1, 0]\r\n```\r\n\r\nそしたらくっつけて完成です。お好みで16進数に変換してもいいと思う。\r\n\r\n```js\r\nlet bin = \"010\";\r\n```\r\n\r\n### 16進数(2進数)を赤外線パターンに変換する\r\nこの場合は、16進数（もしくは2進数）の赤外線のデータがどこのフォーマットのものなのかがわかっている必要があります。  \r\n16進数のデータにはリーダー部が含まれていないため分かりません。\r\n\r\n今回は`NECフォーマット`だとして、`T`は`562`という設定で行きます。\r\n\r\nまず、配列を用意して、リーダー部を追加しておきます。\r\n\r\n```js\r\n[8992, 5058]\r\n```\r\n\r\nそしたら、16進数の場合は2進数に戻します。  \r\n戻したら、データ`1`が[`Tの1倍`,`Tの3倍`]、`0`が[`Tの1倍`,`Tの1倍`]であることがNECフォーマットの仕様に書いてあるので、そのとおり作ります。\r\n\r\n```js\r\nlet bin = \"010\";\r\n[\r\n    8992, 5058, \r\n    562, 562, // 0\r\n    562, 1686, // 1\r\n    562, 562 // 0\r\n]\r\n```\r\n\r\n最後にストップビットとして配列の最後に`Tの1倍`を入れれば終わり。\r\n\r\n```js\r\n[8992, 5058, 562, 562, 562, 1686, 562, 562, 562]\r\n```\r\n\r\n### 以下変換用のコード。Kotlin版\r\n\r\n```kotlin\r\n\r\nfun main() {\r\n    val pattern = listOf(\r\n        8925, 4540, 514, 626, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 626, 514\r\n    )\r\n    // グループ化\r\n    val onOffGroupList = patternToOnOffPairList(pattern)\r\n    println(\"赤外線パターン ---\")\r\n    println(onOffGroupList)\r\n    // データ部2進数変換\r\n    val bin = patternToBinCode(pattern)\r\n    println(\"データ部 2進数 ---\")\r\n    println(bin)\r\n    // データ部16進数変換\r\n    val hex = binStringToHexString(bin)\r\n    println(\"データ部 16進数 ---\")\r\n    println(hex)\r\n}\r\n\r\n/**\r\n * [8955, 4510]を[Pair(8955, 4510)]にしていく関数。戻す際はflatMapを使ってください。\r\n * */\r\nfun patternToOnOffPairList(patternList: List<Int>) =\r\n    patternList\r\n        .toMutableList()\r\n        .mapIndexed { index, _ ->\r\n            if ((index + 1) % 2 != 0) {\r\n                Pair(patternList[index], patternList.getOrNull(index + 1) ?: 0)\r\n            } else null\r\n        }\r\n        .filterNotNull()\r\n\r\n/**\r\n * [patternList]のデータ部を2進数にして返す。\r\n *\r\n * ONとOFFが1:3の比率（だいたい）の場合は1、違う場合は0になる\r\n *\r\n * 32bit(32文字)になるはず\r\n *\r\n * リーダー部（9000,4500）（だいたいONが9000、OFFが4500）の次からがデータ部なので\r\n *\r\n * 例\r\n *\r\n * (607, 520) =（ON607、OFF520） なら 0\r\n * (607, 1703) =（ON607、OFF1703）なら 1\r\n *\r\n * 変換例\r\n * 010000 ...\r\n *\r\n * @param patternList ON/OFFパターン配列\r\n * */\r\nfun patternToBinCode(patternList: List<Int>) =\r\n    patternToOnOffPairList(patternList)\r\n        .drop(1) // リーダー部を消す\r\n        .dropLast(1) // ストップビット部も消す\r\n        .map { (on, off) -> if (off > on * 2) \"1\" else \"0\" } // ONの2倍以上で T*3 ってことで\r\n        .joinToString(separator = \"\") { it }\r\n\r\n/**\r\n * ２進数からパターン生成。先頭にトレーラーつけて、最後にストップビットを入れる\r\n *\r\n * @param t 変調。NECなら 562 前後？\r\n * @param binCode ２進数\r\n * */\r\nfun binCodeToPattern(t: Int, binCode: String) =\r\n    listOf(t * 16, t * 9) + binCode.toList().flatMap { if (it == '1') listOf(t * 1, t * 3) else listOf(t * 1, t * 1) } + listOf(t * 1) // 1なら[T*1,T*3]、0なら[T*1,T*1]を配列に足していく\r\n\r\n/**\r\n * 2進数の文字列を16進数の文字列に変換する\r\n *\r\n * \"1010\"を\"A\"に変換する\r\n *\r\n * @param binString 変換前2進数の文字列\r\n * */\r\nfun binStringToHexString(binString: String) = \"0x\" + binString.toInt(2).toString(16)\r\n```\r\n\r\n出力例です。\r\n\r\n```terminal\r\n赤外線パターン ---\r\n[(8925, 4540), (514, 626), (514, 1730), (514, 626), (514, 626), (514, 626), (514, 626), (514, 626), (514, 1730), (514, 1730), (514, 626), (514, 1730), (514, 1730), (514, 626), (514, 1730), (514, 1730), (514, 626), (514, 626), (514, 1730), (514, 1730), (514, 1730), (514, 1730), (514, 1730), (514, 626), (514, 1730), (514, 1730), (514, 626), (514, 626), (514, 626), (514, 626), (514, 626), (514, 1730), (514, 626), (514, 0)]\r\nデータ部 2進数 ---\r\n01000001101101100111110110000010\r\nデータ部 16進数 ---\r\n0x41b67d82\r\n```\r\n\r\n長くなるのでGitHubに置いておきますが、データ部とかも見れる完全版も置いておきます。\r\n\r\nhttps://github.com/takusan23/IrPatternToBin"},{"title":"JavaScriptでパソコンの画面録画とMPEG-DASHでライブ配信","link":"/posts/javascript_webm_livestreaming/","markdown":"\r\nどうもこんにちは  \r\nDreamin'Her -僕は、彼女の夢を見る。- 攻略しました。(全年齢)  \r\n\r\n声優さんが良かったです（詳しくないので分からないですが）\r\n![Imgur](https://imgur.com/70hd72N.png)\r\n\r\n中盤がけっこう？重いのですがエンディングはよく出来てていいと思います。\r\n\r\nタイトル通りだ...\r\n\r\n![Imgur](https://imgur.com/qFAMtAP.png)\r\n\r\n![Imgur](https://imgur.com/sPKP4BO.png)\r\n\r\n![Imgur](https://imgur.com/FYY4Cyy.png)\r\n\r\nあとOP曲がめっちゃいい。  \r\n作品とリンクしてる！！！\r\n\r\n*せめて 私を 過去にして 今紡ごう 未来を ...*  \r\n\r\nOP曲の`おやすみモノクローム`、めっちゃいい\r\n\r\n（ゲームはSteamで買えます。）\r\n\r\n# 本題\r\n\r\n最近のブラウザって数行かけば画面の録画が出来るらしいんですよね、試してみます。  \r\n前回の記事の副産物になります [これ](/posts/android_standalone_webm_livestreaming/)\r\n\r\n# ブラウザで録画するまで\r\n\r\n- `getDisplayMedia`で画面録画の`MediaStream`を取得\r\n- ↑`MediaRecorder`の入力にする\r\n- `webm`が出来る\r\n\r\nなんやこれ...Androidでやるより簡単！ ( https://takusan23.github.io/Bibouroku/2020/04/06/MediaProjection/ )、JSすげ～  \r\n\r\n流石にPC版にしか実装されてませんでしたが、そりゃそうか→ https://caniuse.com/?search=getDisplayMedia\r\n\r\n# 環境\r\n\r\n| なまえ  | あたい                                                                      |\r\n|---------|-----------------------------------------------------------------------------|\r\n| Windows | 10 Pro 21H2 (Win11のコンテキストメニュー使いにくいのどうにかならないの；；) |\r\n| Chrome  | 105                                                                         |\r\n\r\n多分`localhost`みたいな内部サーバーを立てなくても、`file`スキーマで動く...？\r\n\r\n## ブラウザでパソコンの画面を取得する（ミラーリング）\r\n`<video>`でパソコンの画面をミラーするだけならこれだけで動きます、何やこれ一体...\r\n\r\n![Imgur](https://imgur.com/wrmpuFZ.png)\r\n\r\nこれだけ（Promiseがリジェクトされた場合などは見てないですが）でパソコンの画面がvideo要素内で再生できています！\r\n\r\n![Imgur](https://imgur.com/aCMWFR9.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ja\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>getUserMedia</title>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"parent\">\r\n        <button id=\"rec_button\">録画開始</button>\r\n        <video id=\"video\" width=\"640\" height=\"320\" muted autoplay />\r\n    </div>\r\n</body>\r\n\r\n<style>\r\n    .parent {\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: flex-start;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    const recordButton = document.getElementById('rec_button')\r\n    const videoElement = document.getElementById('video')\r\n\r\n    // 録画を開始して、canvasに描画する\r\n    const startRec = async () => {\r\n        // 画面をキャプチャーしてくれるやつ\r\n        const displayMedia = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true })\r\n        // とりあえず video要素 で再生\r\n        videoElement.srcObject = displayMedia\r\n    }\r\n\r\n    // 録画ボタン投下時\r\n    recordButton.onclick = () => {\r\n        startRec()\r\n    }\r\n\r\n</script>\r\n\r\n</html>\r\n```\r\n\r\n## パソコンの画面を録画する\r\n`MediaRecorder`に`getDisplayMedia()`の返り値を入れることで、録画もできます！  \r\n\r\n参考になりました！  \r\nhttps://qiita.com/miyataku/items/6ed855a7fb7507ccc244\r\n\r\nちゃんとダウンロードできる\r\n\r\n![Imgur](https://imgur.com/3wnkTpl.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ja\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>getUserMedia</title>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"parent\">\r\n        <button id=\"rec_button\">録画開始</button>\r\n        <button id=\"stop_button\">録画終了</button>\r\n        <video id=\"video\" width=\"640\" height=\"320\" muted autoplay />\r\n    </div>\r\n</body>\r\n\r\n<style>\r\n    .parent {\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: flex-start;\r\n    }\r\n</style>\r\n\r\n<script>\r\n\r\n    // @ts-check\r\n\r\n    // 今回利用するコンテナフォーマット、コーデック\r\n    const MIME_TYPE = `video/webm; codecs=\"vp9,opus\"`\r\n    // 録画するやつ\r\n    let mediaRecorder\r\n    // WebMデータが細切れになって来るので一時的に保存する\r\n    let chunks = []\r\n\r\n    const recordButton = document.getElementById('rec_button')\r\n    const stopButton = document.getElementById('stop_button')\r\n    const videoElement = document.getElementById('video')\r\n\r\n    // 録画を開始して、canvasに描画する\r\n    const startRec = async () => {\r\n        // 画面をキャプチャーしてくれるやつ\r\n        const displayMedia = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true })\r\n        // パソコンの画面を流す\r\n        mediaRecorder = new MediaRecorder(displayMedia, { mimeType: MIME_TYPE })\r\n        // 録画データが着たら呼ばれる\r\n        mediaRecorder.ondataavailable = (ev) => {\r\n            chunks.push(ev.data)\r\n        }\r\n        // 録画開始。100msごとに ondataavailable が呼ばれてデータが貰えるように。\r\n        mediaRecorder.start(100)\r\n        // とりあえず video要素 で再生\r\n        videoElement.srcObject = displayMedia\r\n    }\r\n\r\n    // 録画ボタン投下時\r\n    recordButton.onclick = () => {\r\n        startRec()\r\n    }\r\n\r\n    // 終了ボタン投下時\r\n    stopButton.onclick = () => {\r\n        // 録画を止める\r\n        mediaRecorder.stop()\r\n        // BlobUrlを作成し、a要素でリンクを作りJSで押すことでダウンロードさせる（DL出来るんだ！\r\n        const blob = new Blob(chunks, { type: MIME_TYPE })\r\n        const blobUrl = URL.createObjectURL(blob)\r\n        const aElement = document.createElement('a')\r\n        aElement.style.display = 'none'\r\n        aElement.href = blobUrl\r\n        aElement.download = `record-${Date.now()}.webm`\r\n        document.body.appendChild(aElement)\r\n        aElement.click()\r\n        // TODO BlobUrlのリソース開放\r\n    }\r\n\r\n</script>\r\n\r\n</html>\r\n```\r\n\r\nちなみにこれで生成される`webm`は再生時間がヘッダー部分に入っていないため、シークが遅いらしい。  \r\nここまでのソースコードおいておきます\r\n\r\nhttps://github.com/takusan23/browser-screen-record  \r\n\r\n`index.html`をコピペしてブラウザで開けば使えると思います。\r\n\r\n## しくみ\r\n`MediaRecorder`の`ondataavailable`は録画したデータが貰えるコールバックになってます。  \r\n`MediaRecorder#start()`の引数に時間をミリ秒で入れると（上記だと100ミリ秒（0.1秒））、その時間の間隔で`ondataavailable`が呼ばれます。  \r\nこれを配列に順次保存して、最後に結合してダウンロードしています。\r\n\r\nつまり、`ondataavailable`で貰えるデータを他のブラウザとかに何らかの方法（`WebSocket`とか）で送信できれば、ローカルライブ配信の完成になります。！！！\r\n\r\n**ちなみに、**`ondataavailable`はあくまでもデータを分割してるだけなので、全部揃わないと動画ファイルとしては成り立たないです。  \r\n最初の動画は単独で再生できますが、２個目以降はメタデータ？が入ってないので再生できません。  \r\n（もしかすると最初のヘッダー部分があればなんか再生できるかもしれないです...）\r\n\r\n# これができれば WebM でライブ配信が出来るのでは？\r\n[前回の記事](/posts/android_standalone_webm_livestreaming/) のAndroidと違い、サーバー側が必要ですが似たようなことができそうなのでやってみます。\r\n\r\n## 環境\r\n\r\n| なまえ         | あたい                    |\r\n|----------------|---------------------------|\r\n| サーバー側言語 | Kotlin (Ktor使いたい...!) |\r\n| サーバー側技術 | Ktor                      |\r\n| フロント側技術 | dash.js                   |\r\n\r\n## WebM / MPEG-DASH でライブ配信\r\n`MPEG-DASH`で出来るのですが、ただ`WebM`を公開すればいいという**わけではなく**、`初期化セグメント`と`メディアセグメント`に分ける必要があります。  \r\nが、今回は面倒なので最初に出てきた`webm`を初期化セグメントとして使おうかなと  \r\nちなみに`初期化セグメント`は多分`Clusterの開始タグ`（`0x1F 0x43 0xB6 0x75`）の前までです。ちゃんとやるならその範囲だけのファイル(`init.webm`)みたいなのを作るべきだと思います。\r\n\r\n詳しくは [前回の記事](/posts/android_standalone_webm_livestreaming/) で\r\n\r\n### ちなみ に最初に出てきた`webm`を初期化セグメントとして利用できる理由\r\n単純に`Clusterの開始タグ`より前の部分が含まれているから。  \r\nデコーダーの起動に必要なメタデータが含まれているのが、最初に呼ばれる`ondataavailable`にはある。\r\n\r\n(２個目以降には含まれていないため、２個目以降のバイナリを渡したところで再生できない；；)\r\n\r\n## Ktorで適当にAPIをつくる\r\nバックエンドは何も詳しくないので...\r\n\r\n- `/api/upload`\r\n    - Webフロントの`MediaRecorder`の`ondataavailable`が呼ばれたらバイナリを送るAPI。POST\r\n    - よく知らんけど `multipart-formdata` にする\r\n- `/`\r\n    - `index.html`を返す、視聴ページ 兼 録画ページ\r\n- `manifest.mpd`\r\n    - `MPEG-DASH`のマニフェストを返します。`dash.js`に渡す\r\n- `segment1.webm`、`segment2.webm`...\r\n    - `/api/upload`のファイルを保存しているフォルダを静的配信する\r\n    - Ktorのstatic公開機能で\r\n\r\n# サクサクっと作る\r\n\r\n適当に`IDEA`でプロジェクトを作ります。  \r\n`Ktor`、簡単にWebサーバーが立てれていい感じ。バックエンドよく分からんけど；；\r\n\r\n![Imgur](https://imgur.com/5PXwH3j.png)\r\n\r\n## ライブラリを入れる\r\n`build.gradle.kts`に書き足します。\r\n\r\n```kotlin\r\ndependencies {\r\n\r\n    // Ktor\r\n    val ktorVersion = \"2.1.1\"\r\n    implementation(\"io.ktor:ktor-server-core:$ktorVersion\")\r\n    implementation(\"io.ktor:ktor-server-netty:$ktorVersion\")\r\n\r\n    testImplementation(kotlin(\"test\"))\r\n}\r\n```\r\n\r\n## Main.kt\r\nなんか`Main.kt`がドメインのパッケージに居ない（と言うかドメインのパッケージすら無い）ので作って移動させます。  \r\n`Kotlin`だといらないんですかね（そんな事ある？）\r\n\r\n`ドメイン名.アプリ名`みたいな感じのパッケージを作って移動させました。`io.github.takusan23.browserdashmirroring`\r\n\r\n![Imgur](https://imgur.com/WasHxwe.png)\r\n\r\n\r\n```kotlin\r\npackage io.github.takusan23.browserdashmirroring\r\n\r\nimport io.ktor.http.*\r\nimport io.ktor.http.content.*\r\nimport io.ktor.server.application.*\r\nimport io.ktor.server.engine.*\r\nimport io.ktor.server.http.content.*\r\nimport io.ktor.server.netty.*\r\nimport io.ktor.server.request.*\r\nimport io.ktor.server.response.*\r\nimport io.ktor.server.routing.*\r\nimport java.io.File\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    // 映像の保存先\r\n    // プロジェクトのフォルダに作る\r\n    // Node.js の process.cwd() みたいな\r\n    val projectFolder = System.getProperty(\"user.dir\")\r\n    val segmentSaveFolder = File(projectFolder, \"static\").apply {\r\n        listFiles()?.forEach { it.delete() }\r\n        mkdir()\r\n    }\r\n\r\n    // セグメントのインデックス\r\n    var index = 0\r\n\r\n    println(\"http://localhost:8080\")\r\n\r\n    embeddedServer(Netty, port = 8080) {\r\n        routing {\r\n            // プロジェクトの resources フォルダから取得\r\n            // index.html を返す\r\n            resource(\"/\", \"index.html\")\r\n            // マニフェストを返す\r\n            resource(\"/manifest.mpd\", \"manifest.mpd\")\r\n\r\n            // フロント側からWebMの細切れが送られてくるので保存していく\r\n            post(\"/api/upload\") {\r\n                // Multipart-FormDataを受け取る\r\n                call.receiveMultipart().forEachPart { partData ->\r\n                    if (partData is PartData.FileItem) {\r\n                        // ファイルを作って保存\r\n                        File(segmentSaveFolder, \"segment${index++}.webm\").apply {\r\n                            createNewFile()\r\n                            writeBytes(partData.streamProvider().readAllBytes())\r\n                        }\r\n                    }\r\n                }\r\n                call.respond(HttpStatusCode.OK, \"保存できました\")\r\n            }\r\n\r\n            // 静的ファイル公開するように。動画を配信する\r\n            static {\r\n                staticRootFolder = segmentSaveFolder\r\n                files(segmentSaveFolder)\r\n            }\r\n        }\r\n    }.start(true)\r\n}\r\n```\r\n\r\nフロントが投げてきたデータは上記の例だとここに保存されます。  \r\n\r\n![Imgur](https://imgur.com/xlqra1d.png)\r\n\r\n## index.html\r\n`resources`に置きます。こ↑こ↓です\r\n\r\n![Imgur](https://imgur.com/cHSV5Oi.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ja\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>getUserMedia</title>\r\n    <!-- MPEG-DASH 視聴用 -->\r\n    <script src=\"https://cdn.dashjs.org/latest/dash.all.debug.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"parent\">\r\n        <button id=\"live_button\">配信開始</button>\r\n        <button id=\"watch_button\">視聴開始</button>\r\n        <video id=\"video\" width=\"640\" height=\"320\" muted autoplay />\r\n    </div>\r\n</body>\r\n\r\n<style>\r\n    .parent {\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: flex-start;\r\n    }\r\n</style>\r\n\r\n<script>\r\n\r\n    // @ts-check\r\n\r\n    // 今回利用するコンテナフォーマット、コーデック\r\n    const MIME_TYPE = `video/webm; codecs=\"vp9\"`\r\n    // 録画するやつ\r\n    let mediaRecorder\r\n    // WebMデータが細切れになって来るので一時的に保存する\r\n    let chunks = []\r\n    // 映像を送る間隔\r\n    const SEND_INTERVAL_MS = 3_000\r\n\r\n    const recordButton = document.getElementById('live_button')\r\n    const watchButton = document.getElementById('watch_button')\r\n    const videoElement = document.getElementById('video')\r\n\r\n    // サーバーに映像を送る\r\n    const sendSegment = (segment) => {\r\n        const form = new FormData()\r\n        form.append('data', segment)\r\n        fetch('/api/upload', { method: 'POST', body: form })\r\n    }\r\n\r\n    // 録画を開始して、canvasに描画する\r\n    const startRec = async () => {\r\n        // 画面をキャプチャーしてくれるやつ\r\n        const displayMedia = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true })\r\n        // パソコンの画面を流す\r\n        mediaRecorder = new MediaRecorder(displayMedia, { mimeType: MIME_TYPE })\r\n        // 録画データが着たら呼ばれる。サーバーに送る\r\n        mediaRecorder.ondataavailable = (ev) => {\r\n            sendSegment(ev.data)\r\n        }\r\n        // 録画開始\r\n        mediaRecorder.start(SEND_INTERVAL_MS)\r\n        // とりあえず video要素 で再生\r\n        videoElement.srcObject = displayMedia\r\n    }\r\n\r\n    // 配信ボタン投下時\r\n    recordButton.onclick = () => {\r\n        startRec()\r\n    }\r\n\r\n    // 視聴ボタン投下時\r\n    // dash.js による MPEG-DASH の再生を試みる\r\n    watchButton.onclick = () => {\r\n        const url = \"/manifest.mpd\";\r\n        const player = dashjs.MediaPlayer().create();\r\n        player.initialize(videoElement, url, true);\r\n    }\r\n\r\n</script>\r\n\r\n</html>\r\n```\r\n\r\n## manifest.mpd\r\nこれも`resources`に置きます。  \r\nとりあえず動いたのを書いてるので、多分なんか無駄なことしてると思います。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" maxSegmentDuration=\"PT3S\" minBufferTime=\"PT3S\" type=\"dynamic\" profiles=\"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple\">\r\n  <BaseURL>/</BaseURL>\r\n  <Period start=\"PT0S\">\r\n    <AdaptationSet mimeType=\"video/webm\">\r\n      <Role schemeIdUri=\"urn:mpeg:dash:role:2011\" value=\"main\" />\r\n      <SegmentTemplate duration=\"3\" initialization=\"/segment0.webm\" media=\"/segment$Number$.webm\" startNumber=\"1\"/>\r\n      <Representation id=\"default\" codecs=\"vp9\"/>\r\n    </AdaptationSet>\r\n  </Period>\r\n</MPD>\r\n```\r\n\r\n# 起動\r\n\r\n`main関数`の再生ボタンみたいなのを押すと起動できます。  \r\n<span style=\"color:green\">▶</span> ←これ\r\n\r\n![Imgur](https://imgur.com/lalzp0P.png)\r\n\r\n`http://localhost:8080`を開き、`配信開始`を押します。配信でもプレビューが流れます。  \r\n数秒後にもう一つブラウザで`http://localhost:8080`を開き、今度は`視聴開始`を押します。これで配信側の映像が流れてくると思います。\r\n\r\nスマホでも視聴なら出来るはず。\r\n\r\n![Imgur](https://imgur.com/dRvd2Rg.png)\r\n\r\n**すごい！！サーバー側は仲介しかして無いのになんちゃってライブ配信が完成しました！**\r\n\r\n# 真面目に作るには\r\n動いたことに満足したのですが、まだ直したほうがいいところがあります。\r\n\r\n- 配信をやめて再配信する場合\r\n    - 再度配信するためにはセグメントフォルダの中身を消すのと、インデックスを0に戻す必要があります。\r\n    - 現状はサーバーを再起動しないと再配信できません。\r\n- 視聴側が最初から再生されてしまう（すでにセグメントが生成されているのに）\r\n    - リロードして視聴を再度始めると最初から始まる\r\n    - $Number$ を`0`から開始しないようにすればいい\r\n    - マニフェストで`availabilityStartTime`をセットすることで、途中から視聴した場合も最新のが取得されるはずです。\r\n        - `availabilityStartTime`はライブ配信が利用可能になる時間（ISO 8601）\r\n        - `availabilityStartTime=\"2022-09-13T00:00:00+09:00\"`\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" availabilityStartTime=\"2022-09-13T00:00:00+09:00\" maxSegmentDuration=\"PT3S\" minBufferTime=\"PT3S\" type=\"dynamic\" profiles=\"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple\">\r\n  <BaseURL>/</BaseURL>\r\n  <Period start=\"PT0S\">\r\n    <AdaptationSet mimeType=\"video/webm\">\r\n      <Role schemeIdUri=\"urn:mpeg:dash:role:2011\" value=\"main\" />\r\n      <SegmentTemplate duration=\"3\" initialization=\"/segment0.webm\" media=\"/segment$Number$.webm\" startNumber=\"1\"/>\r\n      <Representation id=\"default\" codecs=\"vp9\"/>\r\n    </AdaptationSet>\r\n  </Period>\r\n</MPD>\r\n```\r\n\r\n# Q&A\r\n\r\n## iOS と iPad OS で再生できますか\r\n\r\n- iPad OS なら再生できると思います\r\n- iOS は `MediaSource Extensions API`に対応すれば動くと思います。\r\n\r\n詳しくは [前回の記事](/posts/android_standalone_webm_livestreaming/) で\r\n\r\n# 参考になりました\r\n助かります！！！\r\n\r\n- https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API\r\n- https://www.slideshare.net/mganeko/media-recorder-and-webm\r\n- https://qiita.com/tomoyukilabs/items/57ba8a982ab372611669\r\n\r\n# おわりに\r\nお疲れ様でした、ﾉｼ 888888\r\n\r\n## ソースコードです\r\nhttps://github.com/takusan23/BrowserDashMirroring\r\n"},{"title":"JitPackでAndroidライブラリを公開する","link":"/posts/jitpack/","markdown":"\r\n自分用メモ（記事更新：2021/03/11）\r\n\r\n# ライブラリ作成\r\n## 適当なプロジェクトを作成します。\r\nここで作成したプロジェクトはExample的な役割をする。\r\n\r\n## ライブラリを作成\r\n上の`File`を押して、`New`を押して、`New Module...`を選択して、  \r\n`Android Library`を選択して、ライブラリ名をつけます。\r\n\r\n![Imgur](https://imgur.com/tQF3cW2.png)\r\n\r\n## 最初に作ったプロジェクトでライブラリを参照できるようにする\r\n`app`フォルダにある`build.gradle`(`app/build.gradle`)を開き、`dependencies { }`に書き足します。\r\n\r\n```gradle\r\ndependencies {\r\n    // 作ったライブラリ\r\n    implementation project(':ライブラリ名')\r\n}\r\n```\r\n\r\nライブラリ名が、`SearchPreferenceFragment`だった場合は、\r\n\r\n```gradle\r\ndependencies {\r\n    // 作ったライブラリ\r\n    implementation project(':SearchPreferenceFragment')\r\n}\r\n```\r\n\r\nとなります。\r\n\r\n# JitPackで公開する流れ\r\n## library/build.gradle\r\n`ライブラリ名/build.gradle`（ライブラリ名のフォルダに有るbuild.gradle）を開いて、上の部分を書き換えます。\r\n\r\n```gradle\r\nplugins {\r\n    id 'com.android.library'\r\n    id 'kotlin-android'\r\n    id 'kotlin-android-extensions'\r\n    // JitPackで必要\r\n    id 'maven-publish'\r\n}\r\n\r\n// これもJitPackで使う\r\ngroup = 'com.github.takusan23'\r\n```\r\n\r\n`takusan23`の部分は各自違うと思う。\r\n\r\nそれから、一番下に行って数行書き足す必要があるみたいです。\r\n\r\n```kotlin\r\nafterEvaluate {\r\n    publishing {\r\n        publications {\r\n            release(MavenPublication) {\r\n                from components.release\r\n                groupId = 'com.github.takusan23'\r\n                artifactId = 'ComposeOrigamiLayout'\r\n                version = '1.0'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`groupId`は`group`と同じでいいと思う。  \r\n`artifactId`にはGitHubのリポジトリ名を入れてね。\r\n \r\n## jitpack.yml\r\nってファイルを作成します。場所はsrcフォルダとか.ideaフォルダがあるところです。  \r\nファイル名は`jitpack.yml`で。  \r\n\r\n中身なんですけど、Javaのバージョンを指定します。なんかJava11が必要になったみたい。\r\n\r\n```yml\r\njdk:\r\n  - openjdk11\r\n```\r\n\r\n# 他の人に使ってもらう\r\n## build.gradle\r\nappフォルダでもない、ライブラリ名のついたフォルダでもない、`build.gradle`を開いて、以下のように書き足します\r\n\r\n```gradle\r\nallprojects {\r\n    repositories {\r\n        google()\r\n        jcenter()\r\n        maven { url 'https://jitpack.io' }\r\n    }\r\n}\r\n```\r\n\r\n`allprojects{ repositories{ } }`がない場合は、`settings.gradle`を開いてこうです。  \r\n\r\n```gradle\r\ndependencyResolutionManagement {\r\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    repositories {\r\n        google()\r\n        mavenCentral()\r\n        jcenter() // Warning: this repository is going to shut down soon\r\n        maven { url 'https://jitpack.io' } // これ\r\n    }\r\n}\r\n```\r\n\r\n## app/build.gradle\r\nを開き、`dependencies{ }`に書き足します。\r\n\r\n```gradle\r\ndependencies {\r\n    // 検索できるPreference\r\n    implementation 'com.github.takusan23:SearchPreferenceFragment:1.0.0'\r\n}\r\n```\r\n\r\n以上です。"},{"title":"Kotlin Coroutines の Flow で collect したら別の Flow を collect したい","link":"/posts/kotlin_coroutines_flow_latest/","markdown":"\r\nどうもこんばんわ。  \r\niPhone 15 の発表会があったそうですが普通に寝てました、  \r\nみんな`USB Type-C`やら`ミリ波アンテナ非搭載`ばっか目が行ってるけど、`Pro`の方だと`AV1のハードウェアデコーダー`が入ってるらしいじゃん！！  \r\nまぁ`AV1 コーデック`使う機会が来るのかはまた...  \r\n\r\n# 本題\r\n`flow`で`collect`した値を元に、別の`flow`を`collect`したい。  \r\n\r\n適当に例を書いたけど、こんな感じにユーザーを返す`Flow`の値を使って、下のコメントを返す`Flow`を収集したい。\r\n\r\n```kotlin\r\nsuspend fun collectValue() {\r\n    // ユーザー一覧を Flow で返す\r\n    val userFlow: Flow<List<User>> = getRealtimeUserIdList()\r\n\r\n    // ↑の flow が新しい値で発行されたら ↓ の flow に渡して、flow を購読したい。\r\n    // ↑の flow から新しい値が来たら、既に動いている ↓ の flow をキャンセルして、作り直して欲しい\r\n\r\n    // ユーザーを渡すとコメントが Flow で返される\r\n    val commentFlow: Flow<List<Message>> = getRealtimeUserComment(user = /* TODO */)\r\n}\r\n```\r\n\r\n# 解決\r\n\r\nhttps://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map-latest.html\r\n\r\n`mapLatest` か `collectLatest` を使えば解決  \r\n前回の収集をキャンセルして、常に最新の値で別の`Flow`を`collect`できる\r\n\r\n```kotlin\r\ngetRealtimeUserIdList()\r\n    // ユーザー一覧を貰ったら、コメント取得 flow をそれぞれ呼び出す\r\n    // Latest を使うと、一個前に呼ばれたこの↓のブロックはキャンセルされる\r\n    .collectLatest { userIdList ->\r\n        println(\"receive new user list\")\r\n        userIdList\r\n            // flow を作る\r\n            .map { user -> getRealtimeUserComment(user) }\r\n            // 複数の flow なので（List<Flow>）、一つにまとめる（型が同じなので問題ない）\r\n            .merge()\r\n            // ↑の Flow の収集を始める\r\n            // 先述の通り、新しい値（この場合 getRealtimeUserIdList() から新しい値が流れてきた場合）\r\n            // ここの収集はキャンセルされ、新しい値で再度実行される\r\n            .collect {\r\n                println(it)\r\n            }\r\n    }\r\n```\r\n\r\nこんな感じに、`getRealtimeUserIdList()`が新しい値を発行したら、既に動いている`getRealtimeUserComment()`の方はキャンセルされ、新しく`getRealtimeUserComment()`を作り購読するようにしています！これがやりたかったんだよな～\r\n\r\n```plaintext\r\nreceive new user list\r\nMessage(user=User(id=0), message=[うっさ, ミュート芸, ミュート芸, 延長しろ])\r\nMessage(user=User(id=1), message=[ミュート芸, わこつ, ミュート芸, あ でも い でも良いから書け])\r\nMessage(user=User(id=0), message=[わこつ, わこつ, わこつ, 延長しろ])\r\nMessage(user=User(id=1), message=[あ でも い でも良いから書け, わこつ, 延長しろ, 延長しろ])\r\nMessage(user=User(id=0), message=[あ でも い でも良いから書け, 延長しろ, 延長しろ, 延長しろ])\r\nMessage(user=User(id=1), message=[あ でも い でも良いから書け, わこつ, ミュート芸, おつ])\r\nMessage(user=User(id=0), message=[あ でも い でも良いから書け, おつ, わこつ, あ でも い でも良いから書け])\r\nMessage(user=User(id=1), message=[おつ, あ でも い でも良いから書け, わこつ, うっさ])\r\nreceive new user list\r\nMessage(user=User(id=2), message=[わこつ, あ でも い でも良いから書け, うっさ, おつ])\r\nMessage(user=User(id=3), message=[わこつ, あ でも い でも良いから書け, 延長しろ, うっさ])\r\nMessage(user=User(id=2), message=[あ でも い でも良いから書け, うっさ, あ でも い でも良いから書け, おつ])\r\n```\r\n\r\n## transformLatest\r\nhttps://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform-latest.html\r\n\r\nまた、`Android`の`Jetpack Compose`とかで使いたい場合は、`Flow#collectAsState`したいと思うので、  \r\nその場合は`collectLatest`ではなく、変換した`Flow`を返す`transformLatest`を選ばないとダメですね。  \r\n\r\n```kotlin\r\nval commentFlow: Flow<Message> = getRealtimeUserIdList()\r\n    // ユーザー一覧を貰ったら、コメント取得 flow をそれぞれ呼び出す\r\n    // Latest を使うと、一個前に呼ばれたこの↓のブロックはキャンセルされる\r\n    .transformLatest { userIdList ->\r\n        println(\"receive new user list\")\r\n        userIdList\r\n            // flow を作る\r\n            .map { user -> getRealtimeUserComment(user) }\r\n            // 複数の flow なので（List<Flow>）、一つにまとめる（型が同じなので問題ない）\r\n            .merge()\r\n            // ↑の Flow の収集を始める\r\n            // 先述の通り、新しい値（この場合 getRealtimeUserIdList() から新しい値が流れてきた場合）\r\n            // ここの収集はキャンセルされ、新しい値で再度実行される\r\n            .collect {\r\n                // 収集した値を、Flow の返り値として使う\r\n                emit(it)\r\n            }\r\n    }\r\n```\r\n\r\n```\r\n// collect するもよし\r\ncommentFlow.collect {\r\n    println(it)\r\n}\r\n\r\n// Jetpack Compose の State として使うのもよし\r\ncommentFlow.collectAsState()\r\n```\r\n\r\nほかにも、`List<User>`みたいに配列で欲しい（`Flow`の返り値を`Flow<Message>`ではなく、`Flow<List<Message?>>`にしたい）場合はこんな感じですかね  \r\nうーーんあんまりきれいに書けなかった...\r\n\r\n```kotlin\r\nval commentFlow: Flow<List<Message?>> = getRealtimeUserIdList()\r\n    // ユーザー一覧を貰ったら、コメント取得 flow をそれぞれ呼び出す\r\n    // Latest を使うと、一個前に呼ばれたこの↓のブロックはキャンセルされる\r\n    .transformLatest { userIdList ->\r\n        println(\"receive new user list\")\r\n        // 入れておく配列\r\n        val commentArray = Array<Message?>(userIdList.size) { null }\r\n        userIdList\r\n            // ユーザーの数だけ flow を作って\r\n            // onEach で値を受け取った際に、array に入れるようにする、その後値を transformLatest へ返してあげると、flow の返り値になる\r\n            .mapIndexed { index, user ->\r\n                getRealtimeUserComment(user)\r\n                    .onEach {\r\n                        commentArray[index] = it\r\n                        emit(commentArray.toList())\r\n                    }\r\n            }\r\n            // 複数件あるのでマージする\r\n            .merge()\r\n            // 収集する\r\n            .collect()\r\n    }\r\n```\r\n\r\n```plaintext\r\nreceive new user list\r\n[Message(user=User(id=0), message=[あ でも い でも良いから書け, 延長しろ, あ でも い でも良いから書け, あ でも い でも良いから書け]), null]\r\n[Message(user=User(id=0), message=[あ でも い でも良いから書け, 延長しろ, あ でも い でも良いから書け, あ でも い でも良いから書け]), Message(user=User(id=1), message=[延長しろ, あ でも い でも良いから書け, おつ, ミュート芸])]\r\n[Message(user=User(id=0), message=[うっさ, 延長しろ, ミュート芸, 延長しろ]), Message(user=User(id=1), message=[延長しろ, あ でも い でも良いから書け, おつ, ミュート芸])]\r\n[Message(user=User(id=0), message=[うっさ, 延長しろ, ミュート芸, 延長しろ]), Message(user=User(id=1), message=[延長しろ, あ でも い でも良いから書け, あ でも い でも良いから書け, うっさ])]\r\n[Message(user=User(id=0), message=[おつ, ミュート芸, おつ, うっさ]), Message(user=User(id=1), message=[延長しろ, あ でも い でも良いから書け, あ でも い でも良いから書け, うっさ])]\r\n[Message(user=User(id=0), message=[おつ, ミュート芸, おつ, うっさ]), Message(user=User(id=1), message=[わこつ, うっさ, ミュート芸, おつ])]\r\n[Message(user=User(id=0), message=[ミュート芸, おつ, うっさ, ミュート芸]), Message(user=User(id=1), message=[わこつ, うっさ, ミュート芸, おつ])]\r\n[Message(user=User(id=0), message=[ミュート芸, おつ, うっさ, ミュート芸]), Message(user=User(id=1), message=[わこつ, おつ, わこつ, 延長しろ])]\r\nreceive new user list\r\n[Message(user=User(id=2), message=[あ でも い でも良いから書け, 延長しろ, おつ, うっさ]), null]\r\n[Message(user=User(id=2), message=[あ でも い でも良いから書け, 延長しろ, おつ, うっさ]), Message(user=User(id=3), message=[わこつ, 延長しろ, 延長しろ, わこつ])]\r\n```\r\n\r\n# ちなみに\r\n`Flow<List<User>>`ではなく、`Flow<User>`みたいに、配列ではない場合はもっと簡単にかけます。  \r\nまぁ複数あったとしても`Flow#merge`で１つの`Flow`にしてしまえばおっけーだと思います。\r\n\r\n```kotlin\r\n\r\nfun getRealtimeOneUserId(): Flow<User> = flow {\r\n    var index = 0\r\n    while (currentCoroutineContext().isActive) {\r\n        // いい感じのダイナモ感覚\r\n        delay(5_000)\r\n        emit(User(index++))\r\n    }\r\n}\r\n\r\nval commentList: Flow<Message> = getRealtimeOneUserId()\r\n    .transformLatest { user ->\r\n        println(\"receive new user\")\r\n        getRealtimeUserComment(user)\r\n            .collect { message -> emit(message) }\r\n    }\r\ncommentList.collect { println(it) }\r\n```\r\n\r\n```plaintext\r\nreceive new user\r\nMessage(user=User(id=0), message=[延長しろ, うっさ, ミュート芸, わこつ])\r\nMessage(user=User(id=0), message=[ミュート芸, 延長しろ, おつ, あ でも い でも良いから書け])\r\nMessage(user=User(id=0), message=[ミュート芸, おつ, わこつ, おつ])\r\nMessage(user=User(id=0), message=[わこつ, 延長しろ, うっさ, 延長しろ])\r\nreceive new user\r\nMessage(user=User(id=1), message=[おつ, あ でも い でも良いから書け, おつ, うっさ])\r\nMessage(user=User(id=1), message=[わこつ, 延長しろ, 延長しろ, おつ])\r\n```\r\n\r\n## ちなみ2\r\n`println(\"receive new user\")`や`println(\"receive new user list\")`は分かりやすくしているだけなので、なくても動く（当たり前）\r\n\r\n# もっと詳しく話せ\r\n\r\nまず前提になるコードです  \r\n適当にデータクラスを用意して、それぞれ定期的に適当に`Flow`を用意しました、\r\n\r\n```kotlin\r\ndata class User(val id: Int)\r\ndata class Message(val user: User, val message: List<String>)\r\n\r\nfun getRealtimeUserIdList(): Flow<List<User>> = flow {\r\n    var index = 0\r\n    while (currentCoroutineContext().isActive) {\r\n        // いい感じのダイナモ感覚\r\n        delay(5_000)\r\n        // 適当な数のユーザーを用意して返す\r\n        val randomUserList = (0 until 2).map { User(index++) }\r\n        emit(randomUserList)\r\n    }\r\n}\r\n\r\nfun getRealtimeUserComment(user: User): Flow<Message> = flow {\r\n    val commentList = listOf(\"わこつ\", \"ミュート芸\", \"延長しろ\", \"うっさ\", \"おつ\", \"あ でも い でも良いから書け\")\r\n    while (currentCoroutineContext().isActive) {\r\n        delay(1_000)\r\n        // 適当に3件選んで返す\r\n        val randomCommentList = (0..3).map { commentList.random() }\r\n        emit(\r\n            Message(\r\n                user = user,\r\n                message = randomCommentList\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n\r\nユーザーを購読して～コメントを購読するとするとまずこう\r\n\r\n```kotlin\r\ngetRealtimeUserIdList().collect { userIdList ->\r\n    println(\"receive new user list\")\r\n\r\n    // ユーザーの数だけ flow を購読\r\n    userIdList.map { user ->\r\n        // collect { } だと collect 中は一時停止になる\r\n        // ので、onEach と launchIn にした\r\n        getRealtimeUserComment(user).onEach { message ->\r\n            println(message)\r\n        }.launchIn(this)\r\n    }\r\n}\r\n```\r\n\r\nしかし、これだと、`Flow`の更新のたびに`getRealtimeUserComment()`を呼び出しています。  \r\n\r\n```plaintext\r\nreceive new user list\r\nMessage(user=User(id=8), message=[\r\nMessage(user=User(id=9), message=[\r\nMessage(user=User(id=6), message=[\r\nMessage(user=User(id=7), message=[\r\nMessage(user=User(id=4), message=[\r\nMessage(user=User(id=5), message=[\r\nMessage(user=User(id=2), message=[\r\nMessage(user=User(id=3), message=[\r\nMessage(user=User(id=0), message=[\r\nMessage(user=User(id=1), message=[\r\n```\r\n\r\nこれが期待値の場合もありますが、今回は値を受け取ったら既に動いている`flow`をキャンセルしてほしい  \r\nと思った時に書くやつ\r\n\r\n```kotlin\r\nval commentScope = CoroutineScope(Dispatchers.Default)\r\n\r\ngetRealtimeUserIdList().collect { userIdList ->\r\n    println(\"receive new user list\")\r\n    // 新しい値が来たので既に動いてるやつをキャンセル\r\n    commentScope.coroutineContext.cancelChildren()\r\n\r\n    // ユーザーの数だけ flow を購読\r\n    userIdList.map { user ->\r\n        // collect { } だと collect 中は一時停止になる\r\n        // ので、onEach と launchIn にした\r\n        getRealtimeUserComment(user).onEach { message ->\r\n            println(message)\r\n        }.launchIn(commentScope)\r\n    }\r\n}\r\n```\r\n\r\n別のコルーチンスコープを作って、ユーザー用とコメント用で分けて、コメント用は更新のたびにキャンセルする。  \r\nたしかにこれでも動くのですが、、、もっとなんかいい方法があるはず！\r\n\r\n```plaintext\r\nreceive new user list\r\nMessage(user=User(id=1), message=[ミュート芸, 延長しろ, うっさ, あ でも い でも良いから書け])\r\nMessage(user=User(id=0), message=[ミュート芸, わこつ, わこつ, あ でも い でも良いから書け])\r\nMessage(user=User(id=0), message=[おつ, ミュート芸, わこつ, 延長しろ])\r\nMessage(user=User(id=1), message=[延長しろ, ミュート芸, あ でも い でも良いから書け, おつ])\r\nMessage(user=User(id=0), message=[うっさ, おつ, わこつ, あ でも い でも良いから書け])\r\nMessage(user=User(id=1), message=[延長しろ, わこつ, あ でも い でも良いから書け, あ でも い でも良いから書け])\r\nMessage(user=User(id=0), message=[ミュート芸, わこつ, わこつ, うっさ])\r\nMessage(user=User(id=1), message=[うっさ, うっさ, 延長しろ, 延長しろ])\r\nreceive new user list\r\nMessage(user=User(id=2), message=[おつ, あ でも い でも良いから書け, うっさ, わこつ])\r\nMessage(user=User(id=3), message=[ミュート芸, おつ, 延長しろ, おつ])\r\nMessage(user=User(id=2), message=[あ でも い でも良いから書け, わこつ, 延長しろ, ミュート芸])\r\n```\r\n\r\nというわけで`collectLatest`/`mapLatest`/`transformLatest`の登場。  \r\n前回のブロックをキャンセルしてくれます。以上です。\r\n\r\n# つまり...\r\n\r\nhttps://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map-latest.html\r\n\r\n`collect { }`の中でコルーチン使いたい時（`collect { }`したい等）ときは、`collectLatest { }`を親にする？と次の値が来た時にキャンセルして再起動してくれる。  \r\n\r\n# コードおいていきます\r\n\r\nhttps://github.com/takusan23/FlowLatest\r\n\r\n# おわりに\r\n\r\n`Latest`系のオペレーターはなぜか`@OptIn`しないと`Lint`で怒られます...  \r\n早く安定になって欲しい\r\n\r\n![Imgur](https://imgur.com/PQgRznT.png)"},{"title":"Kotlin/JSでサイトを作って公開する","link":"/posts/kotlin_js_hosting/","markdown":"\r\n夜勤明け ~~(のなんでも出来そうな気分の中)~~ `Kotlin/JS`を初めて触ったら面白かったので記事にする。  \r\n\r\n# 本題\r\n残りの日数を数えるWebサイトを`Kotlin/JS`で作ります。  \r\nこれなら簡単に作れそう。\r\n\r\n# Kotlin/JS #とは\r\nKotlinコードをJSにトランスパイルする。  \r\nJSみたいにDOM操作とかも出来る。\r\n\r\n# IDEAを開き新規プロジェクトを作成します\r\n\r\n`Gradle`を押して、`Kotlin DSL build script`にチェックを入れ、`Kotlin/JS for browser`を選択します。\r\n\r\n![Imgur](https://imgur.com/mjYwnR1.png)\r\n\r\n名前とかは適当に入れてください。\r\n\r\n![Imgur](https://imgur.com/hg9WgLW.png)\r\n\r\n生成後しばらく待ちます。\r\n\r\n# 起動する\r\n\r\nIDEA右下の`Terminal`をおして、以下のコマンドを入れます。\r\n\r\n```\r\n./gradlew run --continuous\r\n```\r\n\r\nこれはホットリロード付きで開発サーバーを起動するコマンドです。勝手にブラウザが起動するはずです。\r\n\r\n初回起動時は、ファイアウォールが許可するか聞いてくるので許可してあげてください。\r\n\r\n無事ブラウザに`Hello World`が出てれば成功です。\r\n\r\n![Imgur](https://imgur.com/EihsdkV.png)\r\n\r\n# index.html を書き換える\r\n\r\n`src/main/resources/index.html`が`index.html`になります。  \r\n\r\n## `script`タグを移動\r\n`<script>タグ`を`<body>`タグの下に移動させます。  \r\nこれをしないと多分`DOM操作時にぬるぽ吐きます。`\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>CountdownKotlinJS</title>\r\n</head>\r\n<body>\r\n\r\n</body>\r\n\r\n<script src=\"CountdownKotlinJS.js\"></script>\r\n\r\n</html>\r\n```\r\n\r\n## 適当にUIを作る\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ja\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>CountdownKotlinJS</title>\r\n</head>\r\n\r\n<style>\r\n    .title {\r\n        font-size: 30px;\r\n    }\r\n\r\n    .subtitle {\r\n        font-size: 20px;\r\n    }\r\n\r\n    .card {\r\n        width: 50%;\r\n        margin-left: auto;\r\n        margin-right: auto;\r\n        margin-bottom: 10px;\r\n        border-radius: 5px;\r\n        padding: 10px;\r\n        box-shadow: 0 2px 5px #ccc;\r\n    }\r\n\r\n    .divider {\r\n        border-top: 1px solid #ccc\r\n    }\r\n</style>\r\n\r\n<body>\r\n\r\n    <div class=\"card\">\r\n        <p class=\"title\">カウントダウン</p>\r\n        <div class=\"divider\"></div>\r\n        <p class=\"subtitle\">日付の選択</p>\r\n        <p align=\"center\">\r\n            <input type=\"date\" id=\"date_input\">\r\n            <input type=\"button\" id=\"calc_button\" value=\"残り日数計算\">\r\n        </p>\r\n        <div class=\"divider\"></div>\r\n        <p class=\"subtitle\">残り</p>\r\n        <p align=\"center\" class=\"title\" id=\"countdown_text\"></p>\r\n    </div>\r\n</body>\r\n\r\n<script src=\"CountdownKotlinJS.js\"></script>\r\n\r\n</html>\r\n```\r\n\r\n# Kotlin\r\n\r\nとりあえず日付を取得するまで\r\n\r\n```kotlin\r\nimport kotlinx.browser.document\r\nimport kotlinx.browser.window\r\nimport org.w3c.dom.HTMLInputElement\r\n\r\nfun main() {\r\n\r\n    // 残り日数表示要素\r\n    val countdownTextElement = document.getElementById(\"countdown_text\")!!\r\n    // ボタン\r\n    val calcButton = document.getElementById(\"calc_button\")!!\r\n    // 日付入力要素\r\n    val dateInputElement = document.getElementById(\"date_input\")!! as HTMLInputElement\r\n\r\n    // ボタン押したとき\r\n    calcButton.addEventListener(\"click\", {\r\n        // 日付取得\r\n        val dateString = dateInputElement.value\r\n        window.alert(dateString)\r\n    })\r\n}\r\n```\r\n\r\n日付を入れてボタンを押したらアラートが出ると思います。\r\n\r\n![Imgur](https://imgur.com/GckVewI.png)\r\n\r\n## 日付計算ライブラリ\r\n別にJS標準の`Date`を使うって手もある。\r\n\r\n今回は`dayjs`を入れようと思います。  \r\n`Kotlin/JS`でも`npm`からライブラリを入れることが出来ます。\r\n\r\n`build.gradle.kts`に書き足します。  \r\n日付ライブラリといえば`moment.js`ですが、今回は`dayjs`を使います。軽いらしい？\r\n\r\n```gradle\r\nplugins {\r\n    id(\"org.jetbrains.kotlin.js\") version \"1.5.10\"\r\n}\r\n\r\ngroup = \"io.github.takusan23\"\r\nversion = \"1.0.0\"\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation(kotlin(\"stdlib-js\"))\r\n\r\n    // 日付計算\r\n    implementation(npm(\"dayjs\", \"1.10.6\"))\r\n\r\n}\r\n```\r\n\r\n## JSのライブラリをKotlinで使う\r\n`JS`は動的に型をつけますが、`Kotlin`では静的に型をつけます。  \r\n普通に考えるとJSライブラリが使えないように見えますが、`Kotlin/JS`には`dynamic`型が用意されています。\r\n\r\nこれを使うと`JS`みたいに書くことが出来ます。なおこれを使うと`Kotlin`の`Null安全`等の恩恵が受けれなくなるので`Kotlinで書く意味・・・？`\r\n\r\n```kotlin\r\n/** dayjs読み込み */\r\n@JsModule(\"dayjs\")\r\n@JsNonModule\r\nexternal fun dayjs(): dynamic\r\n```\r\n\r\n## 残り日数計算\r\n\r\nを含めた完全版です。\r\n\r\n```kotlin\r\nimport kotlinx.browser.document\r\nimport org.w3c.dom.HTMLInputElement\r\n\r\n/** dayjs（コンストラクタあり）読み込み */\r\n@JsModule(\"dayjs\")\r\n@JsNonModule\r\nexternal fun dayjs(d: dynamic): dynamic\r\n\r\n/** dayjs読み込み */\r\n@JsModule(\"dayjs\")\r\n@JsNonModule\r\nexternal fun dayjs(): dynamic\r\n\r\nfun main() {\r\n\r\n    // 残り日数表示要素\r\n    val countdownTextElement = document.getElementById(\"countdown_text\")!!\r\n    // ボタン\r\n    val calcButton = document.getElementById(\"calc_button\")!!\r\n    // 日付入力要素\r\n    val dateInputElement = document.getElementById(\"date_input\")!! as HTMLInputElement\r\n\r\n    // ボタン押したとき\r\n    calcButton.addEventListener(\"click\", {\r\n        // 日付取得\r\n        val dateString = dateInputElement.value\r\n        val countdown = dayjs(dateString).diff(dayjs(), \"day\") as Int\r\n        countdownTextElement.textContent = \"残り $countdown 日\"\r\n    })\r\n}\r\n```\r\n\r\nこれで残りの日数を表示できます。やったね。\r\n\r\n![Imgur](https://imgur.com/gCc7Z3I.png)\r\n\r\n# 書き出す(ビルド)\r\n\r\nターミナルに以下のコマンドを入力すことでHTMLを書き出すことが出来ます。  \r\n\r\n```gradle\r\n./gradlew browserWebpack\r\n```\r\n\r\n`build/distributions`に書き出されます。\r\n\r\n![Imgur](https://imgur.com/zJ3U8Iw.png)\r\n\r\n# ホスティング\r\n今回は`Netlify`にホスティングして公開します。  \r\n\r\n## とりあえずGitHubに公開する\r\nここから出来ます。\r\n\r\n![Imgur](https://imgur.com/jJn3857.png)\r\n\r\n## Netlifyで公開\r\n\r\nビルドコマンドのところを空白にします。  \r\nおま環だろうけど、`Netlify`でビルド出来なかったので`GitHub Actions`でビルドして、結果だけNetlifyに公開するようにする。\r\n\r\nビルドしないように設定を変更します。`Site settings`から`Build & deploy`をおし、`Stop builds`します。\r\n\r\n![Imgur](https://imgur.com/Bb945fO.png)\r\n\r\n# GitHub Actions の前に\r\nリポジトリの設定を開いて、`Secrets`を開きます。  \r\nこの中に、必要な値を保存しておきます。\r\n\r\n## NETLIFY_AUTH_TOKEN\r\nNetlifyのアカウント設定へ進んで、`Applications`の中の`Personal access tokens`までスクロールして、`New access token`を押して払い出してもらいます。\r\n\r\n## NETLIFY_SITE_ID\r\nこれはさっき公開したサイトの設定へすすんで、`Site information`の中の`API ID:`の値です\r\n\r\nこんなふう\r\n\r\n![Imgur](https://imgur.com/LUm0oxZ.png)\r\n\r\n# GitHub Actions を組む\r\nリポジトリの`Actions`を選択して、`set up a workflow yourself`を押して作成します。\r\n\r\n![Imgur](https://imgur.com/Pd2OpNz.png)\r\n\r\nそしたら以下コピペ\r\n\r\n```yml\r\n# 参考にした。thx!：https://qiita.com/nwtgck/items/e9a355c2ccb03d8e8eb0\r\n\r\nname: Netlify\r\n\r\non:\r\n  push:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      \r\n      # 権限の変更\r\n      - name: Grant permission\r\n        run: chmod +x ./gradlew\r\n      \r\n      # HTML書き出し（ビルド）\r\n      - name: Making html\r\n        run: ./gradlew browserWebpack \r\n      \r\n      # Netlifyにデプロイする\r\n      - name: Upload netlify\r\n        run: npx netlify-cli deploy --dir=./build/distributions --prod\r\n        env:\r\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\r\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\r\n```\r\n\r\nできたら`Commit`して`Actions`へ移動して見てみます。\r\n\r\n作業進行中\r\n\r\n![Imgur](https://imgur.com/gwxC5in.png)\r\n\r\n終わったらNetlifyで公開したサイトのURLを開いてます。無事開けたら成功です。\r\n\r\n# 終わりに\r\n完成品です：https://countdown-kotlinjs.netlify.app/  \r\nソースコードです：https://github.com/takusan23/CountdownKotlinJS"},{"title":"LINE Messaging API を試す","link":"/posts/line_messaging_api_nodejs/","markdown":"\n始業式オンラインの予定だったのになんで中止になったの？\n\n# LINE Messaging API\nを使うことで、LINE公式アカウント(LINE Bot)を作成できます。  \n一ヶ月1000通までは無料で、プッシュ通知も利用できます(つよい)。\n\n# 今回やること\nNode.jsからLINE公式アカウントと友達になっている人全員に送信するやつを作成。（ブロードキャストメッセージ）  \n今回はこっち（Node.js側）からメッセージを送信できれば完成ってことで\n\n## Messaging API 登録\n(LINEのログインとか開発者登録は済ませておいて)  \nドキュメントに登録のやり方あります：https://developers.line.biz/ja/docs/messaging-api/getting-started/#using-console\n\nhttps://developers.line.biz/ja/services/messaging-api/  \nを開いて、`今すぐはじめよう`を選びます。\n\n![Imgur](https://imgur.com/4Wm5Iu7.png)\n\n### なんか英語なんだけど？\n右下のところから日本語選べます。\n\n![Imgur](https://imgur.com/MDNDRzS.png)\n\n### プロバイダー\nまあ開発者の名前とか入れておけばいいんじゃないですかね。  \n[ドキュメントによると](https://developers.line.biz/ja/docs/messaging-api/getting-started/#_4-%E3%83%81%E3%83%A3%E3%83%8D%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B)この項目は表示されないそうです。\n\n![Imgur](https://imgur.com/T1lOCmP.png)\n\n### チャンネル名、説明文\n名前ですね。\n\n[ドキュメントによると](https://developers.line.biz/ja/docs/messaging-api/getting-started/#_4-%E3%83%81%E3%83%A3%E3%83%8D%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B)名前はユーザーに表示されるそうです。（まあ当たり前）  \n説明はLINE Botを作る分には表示されない模様。\n\n![Imgur](https://imgur.com/7NgoM0x.png)\n\n### チャンネルアイコン\nめんどいので飛ばします。任意ですので\n\n### 職種\n適当に\n\n![Imgur](https://imgur.com/KautfJe.png)\n\nあとはメアドとかを入力して同意すれば作成できます。\n\n(ちなみにスクショのまんま作ると名前が予約済みでなんとかって言われて怒られる)\n\n# 友達登録\nチャンネル基本設定のとなりにある`Messaging API設定`を選ぶと、QRコードが表示されてるので、  \nGoogleレンズなり、LINEのQRコード読み取りなんかで友達登録をしてください。\n\n# アクセストークンを生成する\n`Messaging API設定`の一番下に、チャンネルアクセストークンってのが有るので、そこで発行してください。  \n他の人に教えちゃだめなやつです。\n\n![Imgur](https://imgur.com/66q8qv4.png)\n\n# Node.jsから叩く\n\nNode.jsの環境を揃えます。適当なフォルダを開いて、ターミナルを開き以下を実行\n\n```\nnpm init -y\n```\n\nライブラリを入れます\n\n```\nnpm install @line/bot-sdk --save\n```\n\nそしたら、次のJSを書いていきましょう。`src`フォルダを作って`index.js`って名前をつけてコピペして\n\n```js\n// NodeJS用 LINE SDK\nconst line = require('@line/bot-sdk');\n\n// アクセストークン\nconst client = new line.Client({\n    channelAccessToken: '生成したアクセストークン'\n})\n\n// 全員に送信するやつ\nclient.broadcast(\n    // 送信内容\n    {\n        type: 'text',\n        text: 'Hello World'\n    }\n).then(res => console.log('Ok'))\n```\n\n最後に実行\n\n```\nnode src/index.js\n```\n\nこれは友達になっている人全てに送信されるやつですね。ドキュメントでは`ブロードキャストメッセージ`って言ってるやつ。\n\n# おわりに\nOSの壁を超えてプッシュ通知できるのは強いと思った"},{"title":"Minecraft Fabric の環境構築をしてアイテムを追加してみる","link":"/posts/minecraft_fabric_dev_environment/","markdown":"どうもこんにちは。  \r\nハジラブ -Making\\*Lovers-（Making\\*Lovers フルHDリマスター付き）予約しました。月末が楽しみですね。\r\n\r\n# 本題\r\nTwitterでForgeより快適と聞いて。  \r\nしかもKotlinでModdingができる!!!\r\n\r\n# 環境\r\n\r\n| なまえ    | あたい                                                                                            |\r\n|-----------|---------------------------------------------------------------------------------------------------|\r\n| IDE       | Intellij IDEA 2021.1.2 Community Edition                                                          |\r\n| Windows   | 10 Pro (そういえば発表会があるんだっけ？いい加減設定がコンパネと散らばってんのどうにかしてほしい) |\r\n| Minecraft | 1.17 (1.7.10と空目しないで)                                                                       |\r\n| Java      | 16（後述）                                                                                        |\r\n| 言語      | Kotlin                                                                                            |\r\n\r\n# Minecraft 1.17\r\n調べた感じ、Extra UtilitiesにあったDark Glassがバニラに逆輸入？されたみたい。TTの監視で使えそう。\r\n\r\n技術的な話をするとJava 16以上が必要です。JDKの有償化よくわからんけどAdoptOpenJDKの方なら多分大丈夫。  \r\nついにJavaのModdingでも型推論が（使っていいのかはよくわからん）（というか`Record`も使えるようになったのかええやん）（てかそもそも今回はKotlin使うから別に）\r\n\r\n#### 読まなくていい　Java有償化の話\r\n- Javaは今でも無料で使える\r\n- JavaのJDKは色んな会社が作ってる\r\n    - AmazonとかMicrosoftとか\r\n    - Oracleも作ってる\r\n- その中でOracleの作ってるOracle JDKが商用利用するなら金払えになった。\r\n    - Java 11から出てきた話。今までのマイクラはJava 8で利用できたので。\r\n    - Oracle JDK\r\n        - こいつは一部を除いて有償\r\n    - Open JDK\r\n        - こいつは無料。ただしサポート期間が半年\r\n- Oracle以外のJDKを選べばええ\r\n    - AdoptOpenJDK\r\n        - こいつは無料+サポート4年+商用利用可。もうこれ代替品だろ\r\n    - Corretto\r\n        - Amazon製JDK\r\n\r\n多分間違ってる気がするのでチラシの裏的な感覚で\r\n\r\n#### Oracle JDK 有償化の話の続き 2021/10/06 追記\r\nどうやら、Java 17から`Oracle JDK`が無償提供されるようになりました。再び無償化。  \r\nまーたややこしくして何がしたいんや...\r\n\r\nというわけで`Java 17以降`は`Oracle JDK`使っても大丈夫になりました。でも今の所オラクル以外のJDKでやって行けてるのでそのまま行こうと思います。\r\n\r\n# Java 16 を入れる\r\n今回は`AdoptOpenJDK`を入れます。  \r\nhttps://adoptopenjdk.net/ を開いて、`OpenJDK 16 (Latest)`と、`HotSpot`のラジオボタンを選んで`Latest release`を押してダウンロードしましょう。\r\n\r\n![Imgur](https://imgur.com/IilPXDc.png)\r\n\r\nインストールはまあ適当に進めてください。（画像ない）\r\n\r\n一応Java 16がインストールできたか確認するために、コマンドプロンプトとかで、`javac -version`を叩きます。`javac 16.0.1`が帰ってくればおｋ\r\n\r\n```cmd\r\njavac -version\r\n```\r\n\r\n```cmd\r\njavac 16.0.1\r\n```\r\n\r\n# 追記：2021/07/28 JAVA_HOMEの設定\r\nなんか久しぶりにやったらまだJava8使ってんのかよって言われたので直します。\r\n\r\n環境変数の設定開いて、システム環境変数の中から`JAVA_HOME`を選んで、`AdoptOpenJDK`のパスを設定します。\r\n\r\n![Imgur](https://imgur.com/qna3UJ5.png)\r\n\r\n\r\n# IDEAを入れる\r\n入れておいてください。Community Editionでいいです\r\n\r\n# テンプレートをクローン\r\n\r\nIDEAのスタート画面から、`Get from VCS`を押して、いかのURLを指定して`Clone`します。\r\n\r\n![Imgur](https://imgur.com/j5tEO0u.png)\r\n\r\n| なまえ | あたい                                                  |\r\n|--------|---------------------------------------------------------|\r\n| URL    | https://github.com/natanfudge/fabric-example-mod-kotlin |\r\n\r\nプロジェクトを信頼するか聞かれるので`Trust project`を押してください。\r\n\r\n# そううまく行かない\r\n\r\n## Could not merge JARs! Deleting source JARs - please re-run the command and move on.\r\n\r\n`gradle.properties`を開いて、`loom_version`を`0.8`にします\r\n\r\n![Imgur](https://imgur.com/NmjERlf.png)\r\n\r\n## You are using an outdated version of Java (8). Java 16 or higher is required\r\n\r\n### プロジェクトの設定\r\n右上の`File`から`Project Structure`を選択して、`Project SDK`を`16`に、`Project language level`も`16`にします。\r\n\r\n![Imgur](https://imgur.com/6sn3TEy.png)\r\n\r\n適用したら、このボタンを探して押します。\r\n\r\n![Imgur](https://imgur.com/Q7hdIIO.png)\r\n\r\nボタンが見つからない場合は`IDEA`の右上にある？`Gradle`を押して、`Sync`ボタンを押してもいいです。\r\n\r\n![Imgur](https://imgur.com/0ra6jbW.png)\r\n\r\nこれで終わればいいんですが、これでも同じエラーで進めないときがあります。\r\n\r\n### IDEAの設定\r\n右上の`File`から`Settings`を選択して、`Build,Execution,Deployment`を押し、`Build Tools`を押し、`Gradle`へ進み、  \r\n`Gradle JVM`を`16`にしてみてください。できたらさっきみたいにボタンを押します。\r\n\r\n![Imgur](https://imgur.com/ejjN51l.png)\r\n\r\nうまく行けば処理が進みます。私の環境では10分ちょっとかかった。  \r\n`Gradle Build`が終わったら一旦IDEAを閉じます。その後もう一度起動するとマイクラのクライアントが起動できるようになります。  \r\n\r\n![Imgur](https://imgur.com/NhEtyaF.png)\r\n\r\n早速再生ボタンみたいなやつを押して起動してみましょう。\r\n\r\n# 1.17 Fabric\r\n（私だったら）起動直後設定へ進みBGMを0にします。うるさいし\r\n\r\n![Imgur](https://imgur.com/rS1ziQj.png)\r\n\r\n# MOD情報の変更\r\n`gradle.properties`を開いて、以下の内容を変えます\r\n\r\n| なまえ             | あたい                                                                             |\r\n|--------------------|------------------------------------------------------------------------------------|\r\n| maven_group        | 自分の持ってるドメインを逆から。持ってないならGithub Pagesとか他とかぶらない文字列 |\r\n| archives_base_name | MODのID（小文字）                                                                  |\r\n\r\n私ならこんな感じ？\r\n\r\n```\r\n#Fabric api\r\nfabric_version=0.34.10+1.17\r\n\r\n\tloom_version=0.8-SNAPSHOT\r\n\r\n\t# Mod Properties\r\n\tmod_version = 1.0.0\r\n\tmaven_group = io.github.takusan23\r\n\tarchives_base_name = clickmanaita\r\n```\r\n\r\nまた、`fabric_version`等は、以下のサイトから更新があるか確認できるので見てみるといいと思います。  \r\n\r\nhttps://fabricmc.net/versions.html\r\n\r\n# Javaのパッケージ名修正\r\nIDEAのProject(ファイルが表示されてるところ)から`net.fabricmc.example`を選択状態にして、`Shift押しながらF6を押します`。  \r\n押したら`Rename Package`を選び、ドメイン名(逆から)+MOD名小文字 を入力します\r\n\r\n![Imgur](https://imgur.com/JAPuJUz.png)\r\n\r\n続いて`resources`の方も修正します。同じように`assets.modid`を選択状態にして、`Shift押しながらF6を押します`。 \r\nそしたら先程入力したMODのIDを入力すればいいです。\r\n\r\nなんか残ってる`net.fabricmc`ってのは多分消して大丈夫です。\r\n\r\nこうなっていればおｋ\r\n\r\n![Imgur](https://imgur.com/jZ7odV0.png)\r\n\r\n# ExampleMod.kt のファイル名修正\r\n味気ないので`MOD名.kt`とでもしておきましょう。名前変更は先程と同じです。\r\n\r\n![Imgur](https://imgur.com/DQvTCV5.png)\r\n\r\n# MOD情報の修正\r\n`resources`の中にある`fabric.mod.json`を開きます。  \r\n開いたら、`modid`、`entrypoints.main`の部分を最低限書き換えておけばいいと思います。\r\n\r\n```json\r\n  \"id\": \"clickmanaita\",\r\n```\r\n\r\n`ドメイン(逆から)`.`MODのID`.`ExampleMod.ktだったファイル名`Kt::init\r\n\r\n**クラス名+Kt**、Ktを付けないとダメっぽい。\r\n\r\n```json\r\n  \"entrypoints\": {\r\n    \"main\": [\r\n      \"io.github.takusan23.clickmanaita.ClickManaitaKt::init\"\r\n    ]\r\n  },\r\n```\r\n\r\nあとアイコンのところの`modid`もさっき変えちゃったので直しといてください。\r\n\r\nその他は各自好きなように。以下例\r\n\r\n```json\r\n{\r\n  \"schemaVersion\": 1,\r\n  \"id\": \"clickmanaita\",\r\n  \"version\": \"${version}\",\r\n\r\n  \"name\": \"ClickManaita\",\r\n  \"description\": \"CheatMod\",\r\n  \"authors\": [\r\n    \"takusan_23\"\r\n  ],\r\n  \"contact\": {\r\n    \"homepage\": \"https://www.curseforge.com/minecraft/mc-mods/clickmanaita\",\r\n    \"sources\": \"https://github.com/takusan23/ClickManaita2\"\r\n  },\r\n\r\n  \"license\": \"Apache-2.0 License\",\r\n  \"icon\": \"assets/clickmanaita/icon.png\",\r\n\r\n  \"environment\": \"*\",\r\n  \"entrypoints\": {\r\n    \"main\": [\r\n      \"io.github.takusan23.clickmanaita.ClickManaitaKt::init\"\r\n    ]\r\n  },\r\n  \"mixins\": [\r\n    \"modid.mixins.json\"\r\n  ],\r\n  \"depends\": {\r\n    \"fabricloader\": \">=0.8.7\",\r\n    \"fabric\": \"*\",\r\n    \"fabric-language-kotlin\": \"*\",\r\n    \"minecraft\": \"1.17.x\"\r\n  },\r\n  \"suggests\": {\r\n    \"flamingo\": \"*\"\r\n  }\r\n}\r\n```\r\n\r\n# よくわからんけど Mixin も修正\r\n`resources`内の`modid.mixins.json`を開いて、`package`の部分を直します。これなんなの？  \r\n`ドメイン`.`MODのID`.`mixin`\r\n\r\n```json\r\n{\r\n  \"required\": true,\r\n  \"package\": \"io.github.takusan23.clickmanaita.mixin\",\r\n  \"compatibilityLevel\": \"JAVA_8\",\r\n  \"mixins\": [\r\n  ],\r\n  \"client\": [\r\n    \"ExampleMixin\"\r\n  ],\r\n  \"injectors\": {\r\n    \"defaultRequire\": 1\r\n  }\r\n}\r\n```\r\n\r\n# 起動してみる\r\n\r\nこれで起動するはず。多分\r\n\r\n# アイテムを追加してみる\r\n\r\nhttps://fabricmc.net/wiki/tutorial:items\r\n\r\nこの通りにやってみる\r\n\r\nまずアイテムクラス(Kotlinだしobjectでもいいわ)を作ります。\r\n\r\n```kotlin\r\nobject ClickManaitaItem {\r\n\r\n    /** 特になんの機能もないアイテム */\r\n    val CLICKMANAITA_WOOD = Item(FabricItemSettings().group(ItemGroup.TOOLS))\r\n\r\n}\r\n```\r\n\r\n![Imgur](https://imgur.com/ap6YcZj.png)\r\n\r\nそしたら`ExampleModKt`だったファイルを開いて、`init`関数内でアイテムを登録します。\r\n\r\n```kotlin\r\n@Suppress(\"unused\")\r\nfun init() {\r\n    // This code runs as soon as Minecraft is in a mod-load-ready state.\r\n    // However, some things (like resources) may still be uninitialized.\r\n    // Proceed with mild caution.\r\n\r\n    // アイテム追加。clickmanaita_woodのところはアイテムID\r\n    Registry.register(Registry.ITEM, Identifier(\"clickmanaita\", \"clickmanaita_wood\"), ClickManaitaItem.CLICKMANAITA_WOOD)\r\n\r\n}\r\n```\r\n\r\nそしたら起動してみましょう。  \r\n画面のようにアイテムが追加できていれば成功。\r\n\r\n![Imgur](https://imgur.com/5ZrM8r6.png)\r\n\r\n# テクスチャ\r\n画像ファイルを用意します。用意できたら、`resources/assets/MODのID/textures/item/アイテムID.png`って感じで置きます。\r\n\r\n![Imgur](https://imgur.com/ezwosDY.png)\r\n\r\nそしたら今度は、`resources/assets/MODのID/models/item/アイテムID.json`って感じでJSONファイルを作成します。  \r\n中身はこうです。\r\n\r\n```json\r\n{\r\n  \"parent\": \"item/generated\",\r\n  \"textures\": {\r\n    \"layer0\": \"clickmanaita:item/clickmanaita_wood\"\r\n  }\r\n}\r\n```\r\n\r\n`modのID:item/アイテムのID`って感じですね。このテキスチャ指定まじでややこしいからやめてほしい。  \r\nというかJSONは人間が書くもんじゃないだろ。本当に\r\n\r\n成功してました。失敗してたらまじでつらい\r\n\r\n![Imgur](https://imgur.com/4M5ParB.png)\r\n\r\n### おまけ　クリックまな板みたいにクリックしたら増えるように\r\n\r\nそのためには`Item`クラスを継承する必要があります。ので`ClickManaitaBaseItem`みたいなクラスを作成します。\r\n\r\n```kotlin\r\n/**\r\n * 右クリックしたらアイテムが増えるアイテムを追加する\r\n *\r\n * @param settings クリエタブとか\r\n * @param dropSize 増える数\r\n * */\r\nclass ClickManaitaBaseItem(settings: Settings?, private val dropSize: Int = 2) : Item(settings) {\r\n\r\n}\r\n```\r\n\r\nそしたら`useOnBlock`メソッドをオーバーライドします。多分これがブロックを右クリックしたときに呼ばれる関数です。  \r\n\r\n```kotlin\r\n/**\r\n * ブロックを右クリックしたときに呼ばれる関数\r\n * */\r\noverride fun useOnBlock(context: ItemUsageContext?): ActionResult {\r\n    val world = context?.world\r\n    val state = world?.getBlockState(context.blockPos)\r\n    val copyBlock = state?.block\r\n    repeat(dropSize) {\r\n        copyBlock?.afterBreak(world, context.player, context.blockPos, state, null, context.stack)\r\n    }\r\n    return ActionResult.SUCCESS\r\n}\r\n```\r\n\r\nそしたらItem()の部分をClickManaitaBaseItem()に書き換えて実行してみると\r\n\r\n```kotlin\r\nobject ClickManaitaItem {\r\n\r\n    /** 右クリックしたらアイテムが増える */\r\n    val CLICKMANAITA_WOOD = ClickManaitaBaseItem(settings = FabricItemSettings().group(ItemGroup.TOOLS), dropSize = 2)\r\n\r\n}\r\n```\r\n\r\n\r\n増えます。まだチェストの中身とかは増えないのでまだまだって感じですかね。\r\n\r\n![Imgur](https://imgur.com/xsXFHrp.png)\r\n\r\n# ソースを読めるようにする\r\nMinecraftのソースを読めるようにします。IDEAには逆コンパイラーが搭載されているのでなくても最悪いいですが、検索機能が使えないのでソースを生成しといたほうがいいと思います。\r\n\r\nIDEAの`Gradle`を押して、`Tasks` > `fabric` > `genSources` をダブルクリックすることで生成されます。\r\n\r\n![Imgur](https://imgur.com/U0U2TCL.png)\r\n\r\nその後、適当にBlockクラスとかを参照した際に、上に出てくる`Choose Sources...`を押して、`なんとか-sources.jar`を選択することで生成したソースを読むことができるようになります。\r\n\r\n![Imgur](https://imgur.com/qHRSVnB.png)\r\n\r\n`Shift`+`Ctrl`+`F`の検索機能も開放されました。\r\n\r\n![Imgur](https://imgur.com/PCDBcwG.png)\r\n\r\n# 配布可能ファイルを生成する\r\n\r\nIDEA右上の`Gradle`から、`Tasks`>`build`へ進み`build`を選択することで配布可能なJarファイルを生成します。  \r\n成功すると、`build/libs/`に生成したファイルが有るはずです。（dev、sources、sources-dev じゃない方）  \r\nあとはこのJarファイルをCurseForgeとかで公開すればいいんじゃない？\r\n\r\n![Imgur](https://imgur.com/6J6OyJb.png)\r\n\r\n# エンドユーザー向けの説明とか\r\nこのModは`Fabric`導入後、`mods`フォルダに以下のファイルをダウンロードして放り込んでおく必要があります。\r\n\r\n- Fabric API\r\n  - https://www.curseforge.com/minecraft/mc-mods/fabric-api/files\r\n- Fabric Language Kotlin\r\n  - Kotlinという言語で書かれたため、他のMODと違い必要になる。\r\n  - https://www.curseforge.com/minecraft/mc-mods/fabric-language-kotlin/files\r\n- Mod本体\r\n\r\n# ソースコード\r\nソースコードです。  \r\nhttps://github.com/takusan23/ClickManaita2/tree/1.17-fabric\r\n\r\nクローンしたあとブランチ名「1.17-fabric」をチェックアウトしてください。一発でビルド通らないと思う。\r\n\r\n# 追記：2021/07/28 1.17.1への対応\r\ngit使ってる場合はコミットするなりブランチ作るなりして現状の環境壊れても大丈夫な状態にしてください。  \r\n使ってなければどっかにバックアップしておけばいいのでは\r\n\r\n`gradle.properties`を、最新の情報に更新します。  \r\n最新の値は「https://fabricmc.net/versions.html」から確認することが出来ます。\r\n\r\n以下一例 (なんかコードブロックの言語にproperties指定したらシンタックスハイライト動いててちょっと感動)\r\n\r\n```properties\r\nkotlin.code.style=official\r\norg.gradle.jvmargs=-Xmx1G\r\n\r\n# Fabric Properties\r\n\t# Check these on https://modmuss50.me/fabric.html\r\nminecraft_version=1.17.1\r\nyarn_mappings=1.17.1+build.31\r\nloader_version=0.11.6\r\n\r\n#Fabric api\r\nfabric_version=0.37.1+1.17\r\n\r\n\tloom_version=0.8-SNAPSHOT\r\n\r\n\t# Mod Properties\r\n\tmod_version = 1.0.0\r\n\tmaven_group = io.github.takusan23\r\n\tarchives_base_name = clickmanaita\r\n\r\n# Kotlin\r\n\tkotlin_version=1.5.0\r\n\tfabric_kotlin_version=1.6.0+kotlin.1.5.0\r\n```\r\n\r\nこれで後は`Minecraft Client`を起動するだけで1.17.1へ対応できました。  \r\nマイナーアップデートなのでクラスの変更とか無いけど大型アップデートならそううまく行かないと思う。\r\n\r\n# 終わりに\r\nいつもAndroidで書いてるKotlinでModdingできるので快適。Fabricへ移植したいから会社辞めたい。  \r\nそういえば私のマイクラ全盛期はナポアンのマイクラが最新Ver追いかけてたけどあのサイトどうなってんの？"},{"title":"クリックまな板を1.18に移行した話","link":"/posts/minecraft_mod_1_18_migration/","markdown":"どうもこんばんわ。  \nけもの道☆ガーリッシュスクエア 攻略しました。  \nhttps://whirlpool.co.jp/kemonomichi-gs/\n\nかわいい。\n\n![Imgur](https://imgur.com/Ms6q4Ag.png)\n\n一本道のハーレムルート！誰も不幸にならない幸せルートでいいね\n\n![Imgur](https://imgur.com/thklLcG.png)\n\n# 本題\nクリックまな板を**Minecraft 1.18**に更新したときに遭遇したエラーなど(ほぼFabricの話)\n\n# --- Fabric 編 ---\n\n## 1.17との変更点\n\n- `Java 17` が必要になりました\n    - 私の環境では`Eclipse Adoptium`の`Java 17`を利用しています。\n        - IDEA右上のFileからProject Structureを選択して、JDKのバージョンを17にします。\n        - IDEAの設定を開き、Build,Execution,Deployment > Build Tools > Gradle へ進み、Gradle JVMを17にします。\n    - OracleJDKも無償提供に戻ったので、別にOracleJDKつかってもいいはず？\n- `Gradle`は`7.3`以降が必要です\n    - 1.17から引き継ぐ際は注意\n- loader_version\n    - `0.12.8`\n- fabric_version\n    - `0.43.1+1.18`\n- loom_version\n    - `0.10-SNAPSHOT`\n- fabric_kotlin_version\n    - `1.7.0+kotlin.1.6.0`\n\n### build.gradle\n\n全部載せると長いので変更点だけ\n\nJava 17 を利用するように\n\n```java\nsourceCompatibility = JavaVersion.VERSION_17\ntargetCompatibility = JavaVersion.VERSION_17\n```\n\n```java\ntasks.withType(JavaCompile) {\n    it.options.encoding = \"UTF-8\"\n\n    // Minecraft 1.18 (1.18) upwards uses Java 17.\n    it.options.release = 17\n}\n```\n\n```java\ncompileKotlin.kotlinOptions.jvmTarget = \"17\"\n```\n\n### gradle.properties\n\nいっぱい変更点がある。\n\n```properties\nkotlin.code.style=official\norg.gradle.jvmargs=-Xmx1G\n\n# Fabric Properties\n\t# Check these on https://modmuss50.me/fabric.html\nminecraft_version=1.18\nyarn_mappings=1.18+build.1\nloader_version=0.12.8\n\n#Fabric api\nfabric_version=0.43.1+1.18\n\n\tloom_version=0.10-SNAPSHOT\n\n\t# Mod Properties\n\tmod_version = 1.0.0\n\tmaven_group = io.github.takusan23\n\tarchives_base_name = ClickManaita-Fabric-1.18\n\n\t# Kotlin\n\tkotlin_version=1.6.0\n\tfabric_kotlin_version=1.7.0+kotlin.1.6.0\n```\n\n### gradle-wrapper.properties\n\nGradle 7.3 を利用するようにします。\n\n```\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-7.3-bin.zip\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n```\n\n### fabric.mod.json\n\nこっちは変更部分だけ\n\nエントリーポイントの登録、なんか変わってたので修正\n\n```json\n\"entrypoints\": {\n  \"main\": [\n    {\n      \"adapter\": \"kotlin\",\n      \"value\": \"io.github.takusan23.clickmanaita.ClickManaitaKt::init\"\n    }\n  ]\n},\n```\n\nMinecraft 1.18、Java 17、loader 0.12.8 を指定します\n\n```json\n\"depends\": {\n  \"fabricloader\": \">=0.12.8\",\n  \"fabric\": \"*\",\n  \"fabric-language-kotlin\": \"*\",\n  \"minecraft\": \"1.18.x\",\n  \"java\": \">=17\"\n},\n```\n\n### modid.mixins.json\n\n使ってないけど一応\n\nJava 17 を指定します。\n\n```\n\"compatibilityLevel\": \"JAVA_17\",\n```\n\n## 直してもそう簡単に動かない\n3回ぐらい壁にぶち当たった。しんどい\n\n### Exception in thread \"main\" java.lang.NoClassDefFoundError: joptsimple/OptionSpec\n\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: joptsimple/OptionSpec\nCaused by: java.lang.RuntimeException: Unsupported access widener format (v2)\n```\n\n- IDEAのキャッシュを消したら治りました。\n    - ここから消せます\n\n![Imgur](https://imgur.com/Qb0Db6s.png)\n\n### Failed to read accessWidener file from mod fabric-content-registries-v0\n\n- コマンドプロンプトを開いて、以下のコマンドを実行したら治りました。\n\n```\ngradlew --refresh-dependencies\n```\n\n![Imgur](https://imgur.com/NhDFypB.png)\n\n### There is insufficient memory for the Java Runtime Environment to continue\n\nメモリが足りません！！！！  \n(もしかしたらCドライブの空きがなくて、スワップでも無理だったからこれが出たのかも)\n\n# --- Forge 編 ---\n\n## 1.17.1 との違い\nFabricと同じ？\n\n- `Java 17` が必要になりました\n    - 私の環境では`Eclipse Adoptium`の`Java 17`を利用しています。\n        - IDEA右上のFileからProject Structureを選択して、JDKのバージョンを17にします。\n        - IDEAの設定を開き、Build,Execution,Deployment > Build Tools > Gradle へ進み、Gradle JVMを17にします。\n    - OracleJDKも無償提供に戻ったので、別にOracleJDKつかってもいいはず？\n- `Gradle`は`7.3`以降が必要です\n    - mdk落としてくればついてくるので特に関係ないはず\n\n更新の仕方よく知らないので**Forgeのmdk落としてきて1.17.1の環境にコピペした**。  \n多分`build.gradle`をいじれば更新できると思うけど。  \n\n1.18のmdkコピーしたらIDEA開き直して右上の`Gradle`から`Tasks > forgegradle runs > genIntellijRuns`を実行。\n\n### Caused by: java.lang.UnsupportedClassVersionError: net/minecraftforge/fml/loading/targets/FMLClientLaunchHandler has been compiled by a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 60.0\n\nIDEAのFileから、`Project Strcture`を開き、`Project SDK`にJava 17を指定します。\n\n![Imgur](https://imgur.com/dTueBHD.png)\n\n影響あったのは、クリエイティブタブのローカライズがちょっとだけ変わってたって所かな。  \n(そもそもアップデートが大規模過ぎて1.18に分割したって話だっけ？そうなら影響あまりなさそう？)\n\n# 終わりに\n**Forge / Fabric 共に`1.18`へ移行した際のコードの書き換えはほぼ無かったです。**  \n(いや気付いて無いだけかもしれない)\n\nソースコード置いておきます\n- 1.18 Fabric版\n    - https://github.com/takusan23/ClickManaita2/tree/1.18-fabric\n- 1.18 Forge版\n    - https://github.com/takusan23/ClickManaita2/tree/1.18-forge\n\nMOD開発者さんがんばってください。おつ。８８８８８８"},{"title":"AWS の Lightsail でお一人様 Misskey サーバーを立ててみた (v10)","link":"/posts/misskey_ohitorisama/","markdown":"どうもこんばんわ。  \r\nニコニコ動画版はこちらです\r\n\r\nhttps://www.nicovideo.jp/watch/sm42546302\r\n\r\n<script type=\"application/javascript\" src=\"https://embed.nicovideo.jp/watch/sm42546302/script?w=640&h=360\"></script><noscript><a href=\"https://www.nicovideo.jp/watch/sm42546302\">お一人様 Misskey サーバー立ててみた</a></noscript>\r\n\r\n# Misskey お一人様を作ってみたい！！！\r\nいや、別にお一人様じゃなくても、ローカルタイムラインが無いインスタンスにアカウントを作れば良いのですが（`LTL は流れについて行けない...`）・・・  \r\nいや、、なんか、、、あの、、、、`AWS`とか使ってみたかったんですよ・・・（多分値段が高く付くのでもっとちゃんと考えるべきです）\r\n\r\n# さんこうにしました\r\nthx!!!!!!!!!!\r\n\r\n- https://misskey-hub.net/docs/install/manual.html\r\n- https://github.com/mei23/memo/blob/master/misskey/Setup-Meisskey-Quick.md\r\n- https://blog.noellabo.jp/entry/2019/08/14/8i3RHuZ1wJNDinIn\r\n- https://seritude.com/misskey-alone-server/\r\n\r\n# 更新 2023/08/13\r\n以下を変更しないと、一部のサーバー（インスタンス）との通信に失敗します  \r\n（リクエスト結果が`403`になり通信できません）\r\n\r\n- Ubuntu ( OS )\r\n    -  `20.04` ではなく `22.04` を選ぶ\r\n        - そのままでは`MongoDB`の導入に失敗します。追記しました。\r\n- Node.js\r\n    - バージョンを 16 ではなく 18 を使う\r\n        - おそらく`Misskey v10`でも動くはず\r\n\r\n# ひつようなもの\r\n今回は**v13**ではなく**v10**を建てます。（めいすきー）  \r\n古いので最新版を建てたい人からしたらあんまり参考にならないと思う（`https`化くらい？同じなの）\r\n\r\n- VPS\r\n    - AWS Lightsail を使います\r\n    - 後述しますが、もしかしたら`国産 VPS`とか他の方が使っている`VPS`を選ぶべきかもしれません・・・もしくは`EC2`？\r\n    - 1コアCPU / 1GB RAM / 40GB SSD にしました\r\n- ドメイン\r\n    - サブドメインを使います\r\n        - `diary.negitoro.dev`\r\n    - `Cloudflare`が使えません（後述）\r\n- SSH クライアント\r\n    - `Tera Term`など\r\n    - 最悪`VPS`に付いてくるブラウザベースの`SSH クライアント`でも出来なくはないと思う・・・\r\n- オブジェクトストレージ\r\n    - 今回は AWS の S3\r\n- Mastodon / Misskey のアカウント\r\n    - 他からアクセスできるか確認用\r\n\r\n## 構成図？\r\n\r\n![Imgur](https://imgur.com/A4ruvgv.png)\r\n\r\n## 一部のサーバーと繋がらない話\r\n`Cloudflare`が使えないせいなのか、はたまた`AWS の Lightsail（VPS）`のせいなのかよく分からないのですが、  \r\n一部のMisskeyサーバーと接続できません（知ってる限り2つくらいあります）\r\n\r\n![Imgur](https://imgur.com/mwNyT7m.png)\r\n\r\nおそらく相手側のサーバーが`Cloudflare`で保護されていて、なんか私側の`IP アドレス`がブラックリスト入りしているっぽいんですよね？  \r\nこちらも`Cloudflare`で保護すれば良いのかなと思いましたが、`.dev`ドメインが対応していないんですよね。`Google Domains`終了するし頼みますよ・・・！  \r\nというわけで`VPS`を変える以外で解決策が無いです。皆さんは他の`VPS`を使ったほうが良いかもしれません・・・  \r\n\r\n# 立てる\r\n動画作ってたら何やったか忘れたのでざっくり行きます  \r\n\r\n資料です： https://github.com/mei23/memo/blob/master/misskey/Setup-Meisskey-Quick.md\r\n\r\n## Misskey をフォークする\r\nこれはカスタマイズしない場合はスキップで良いはず。  \r\n私はフロントエンドくらいはいじりたいなと思ったのでフォークすることにしました\r\n\r\n![Imgur](https://imgur.com/umfOvtv.png)\r\n\r\n## AWS のアカウントを用意する\r\n\r\n用意してください。  \r\n作業用の`IAMユーザー`を作ったり、2段階認証にするなり、最低限のこともやっておいたほうが良いかも。\r\n\r\n## AWS Lightsail で VPS を借りる\r\n`Linux`で`Ubuntu 20.04`で行きます\r\n\r\n![Imgur](https://imgur.com/6jdbpjr.png)\r\n\r\n![Imgur](https://imgur.com/9M5P43F.png)\r\n\r\n## パブリック IP アドレスを固定化する\r\nすでに固定化した状態ですが・・・  \r\nここから固定化が出来ます。\r\n\r\n![Imgur](https://imgur.com/8dee2EE.png)\r\n\r\nアタッチしている場合は追加費用はかからないそう\r\n\r\n## HTTPS 通信で使うポートを開ける\r\n`https`は`TCP`の`443`番を使うので、受け入れられるようにします。  \r\n`Misskey`は`https`でないと接続できないです\r\n\r\n![Imgur](https://imgur.com/jEAY8Et.png)\r\n\r\n## 鍵ファイルを使ってSSHでログインする\r\nここから鍵ファイルをダウンロード出来ます。\r\n\r\n![Imgur](https://imgur.com/0vT2JX4.png)\r\n\r\nまず`Tera Term`でIPアドレスを入れて...\r\n\r\n![Imgur](https://imgur.com/bpSOxRC.png)\r\n\r\n`Lightsail`に表示されているユーザー名と、先ほどダウンロードした鍵ファイルのパスをそれぞれ入れます。\r\n\r\n![Imgur](https://imgur.com/d0Ix1qv.png)\r\n\r\n## VPS の設定\r\nテキストエディタに`vim`を使いますが（それしか分からん）、他のエディタが好きな場合はその都度読み替えてください。\r\n\r\n### スワップ（仮想メモリ）の設定をする\r\n物理メモリが多い場合は多分いらないかも？  \r\n今回みたいに物理メモリが`1GB`しかない場合は後でやる`webpack`周りでこけちゃいます  \r\n一行ずつ打ち込んでいってください。\r\n\r\n```bash\r\nsudo fallocate -l 2G /swapfile\r\nsudo chmod 600 /swapfile\r\nsudo mkswap /swapfile\r\nsudo swapon /swapfile\r\n```\r\n\r\n次に`vim`で以下のファイルを編集します。\r\n\r\n```bash\r\nsudo vim /etc/fstab\r\n```\r\n\r\n改行して以下の行を足します。  \r\n`i`を押して編集モード、`Esc`で戻れます。`:wq`で保存です。\r\n\r\n```plaintext\r\n/swapfile none swap sw 0 0\r\n```\r\n\r\n最後に、以下のコマンドを叩いてスワップ領域が増えていれば成功です。\r\n\r\n```bash\r\nfree -h\r\n```\r\n\r\nこんなふうな出力があるはず\r\n\r\n```bash\r\n              total        used        free      shared  buff/cache   available\r\nMem:          929Mi       450Mi        71Mi       0.0Ki       408Mi       332Mi\r\nSwap:         2.0Gi       174Mi       1.8Gi\r\n```\r\n\r\n### パッケージの更新をする\r\n`Ubuntu ( Debian 系 )`は多分`apt`なので、以下のコマンドを叩いて更新します。  \r\n`Misskey`構築に関係なく、`Linux`マシンを貰ったらまずやらないといけないと思います。\r\n\r\n```bash\r\nsudo apt update\r\nsudo apt upgrade\r\n```\r\n\r\n`upgrade`の方は、本当に実行するかどうか聞かれるので、`Y`を押してエンターします。\r\n\r\n`Do you want to continue? [Y/n]` ←これ\r\n\r\nもし、更新中にピンク色の怖い画面（多分 `want to do about modified configuration file sshd_config?` 的なメッセージ？）がでたら、矢印キーで`Keep`の方を選んでエンターすれば良いと思います。\r\n\r\n## Misskey 構築\r\n\r\n### Misskey 用ユーザーを作る\r\n特に言うことはないかな\r\n\r\n```bash\r\nsudo adduser --disabled-password --disabled-login misskey\r\n```\r\n\r\n### 必要なパッケージを入れる\r\n`Node.js`（MisskeyはバックエンドJavaScriptで出来ている）\r\n\r\n```bash\r\ncurl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\r\nsudo apt-get install -y nodejs\r\nsudo npm i -g pnpm\r\n```\r\n\r\n`MongoDB`（データベース）\r\n\r\n```bash\r\nsudo apt-get install gnupg\r\nwget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | sudo apt-key add -\r\necho \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/4.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list\r\nsudo apt-get update\r\nsudo apt-get install -y mongodb-org\r\n```\r\n\r\n```bash\r\nsudo systemctl start mongod\r\nsudo systemctl enable mongod\r\n```\r\n\r\nその他、ソースコードを落としてくる`git`などを入れます\r\n\r\n```bash\r\nsudo apt -y install redis git build-essential nginx ssl-cert letsencrypt ffmpeg\r\n```\r\n\r\n#### 追記 2023/08/13 MongoDB が Ubuntu 22.04 でインストールできない\r\nどうやら必要な`libssl`が`22.04`から同梱されなくなったみたい...  \r\n取りあえず入れることで回避することにします。\r\n\r\nhttps://stackoverflow.com/questions/73656873\r\n\r\n```bash\r\nsudo wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2_amd64.deb\r\nsudo dpkg -i libssl1.1_1.1.1f-1ubuntu2_amd64.deb\r\n```\r\n\r\n### ソースコードをダウンロード（git clone）してくる\r\nまず Misskey ユーザーに切り替えて、\r\n\r\n```bash\r\nsudo su - misskey\r\n```\r\n\r\nソースコードをダウンロードします。今回は自分のリポジトリのをダウンロードします  \r\n（`takusan_23-diary`と`https://github.com/takusan23/misskey`は各自変えてね）\r\n\r\n```bash\r\ngit clone -b takusan_23-diary https://github.com/takusan23/misskey\r\n```\r\n\r\nクローンしたフォルダへ移動します\r\n\r\n```bash\r\ncd ~/misskey\r\n```\r\n\r\nコンフィグファイルをコピーして、自分の環境用に直します\r\n\r\n```bash\r\ncp .config/example.yml .config/default.yml\r\nvim .config/default.yml\r\n```\r\n\r\nそしたら、`url`を直して、`mongodb`の`user`/`pass`、`redis`の`pass`をコメントアウトします。  \r\n以下は例です。これ以降の部分はいじりません。（後でいじりますが）\r\n\r\n```yml\r\n# Final accessible URL seen by a user.\r\nurl: https://diary.negitoro.dev/\r\n\r\n# Listen port\r\nport: 3000\r\n\r\n# Listen address (default is probably any)\r\n# addr: '127.0.0.0'\r\n\r\nmongodb:\r\n  host: localhost\r\n  port: 27017\r\n  db: misskey\r\n  #user: example-misskey-user\r\n  #pass: example-misskey-pass\r\n  #options:\r\n  #  poolSize: 10\r\n\r\n# Redis\r\nredis:\r\n  host: localhost\r\n  port: 6379\r\n  #family: 0 # 0=Both, 4=IPv4, 6=IPv6\r\n  #pass: example-pass\r\n  #prefix: example-prefix\r\n  #db: 0\r\n```\r\n\r\n編集が終わったら保存してターミナルに戻ってきてください。  \r\nビルドをします。\r\n\r\nスペックが低いので、しばらく時間がかかります\r\n\r\n```bash\r\nNODE_ENV=production pnpm i\r\nNODE_ENV=production pnpm build\r\n```\r\n\r\n無事成功したら、戻ります\r\n\r\n```bash\r\nexit\r\n```\r\n\r\n## nginx の設定\r\nMisskey ユーザーの場合は戻ってください（`exit`）  \r\n`whoami`を叩くと今誰なのかわかります。\r\n\r\n### コンフィグファイルをコピー\r\n私もわかんないんですけど、多分シンボリックリンクを使うのが正解らしい・・・\r\n\r\n```bash\r\nsudo cp ~misskey/misskey/docs/examples/misskey.nginx /etc/nginx/sites-enabled/\r\nsudo vim /etc/nginx/sites-enabled/misskey.nginx\r\n```\r\n\r\nまた`vim`が開くので、`example.tld`になっている部分を自分のドメインに直します。多分二箇所ぐらいだと思う\r\n\r\n`server_name example.tld`を`server_name diary.negitoro.dev`にする感じです（自分のドメインね！）\r\n\r\nできたら保存してターミナルに戻ってきてください。  \r\n`nginx`をリロードします\r\n\r\n```bash\r\nsudo service nginx reload\r\n```\r\n\r\n## Misskey 起動\r\n\r\n### Misskey ユーザーに切り替えます\r\n\r\n```bash\r\nsudo su - misskey\r\n```\r\n\r\n### サーバーお試し起動\r\n\r\n次に、`Misskey サーバー`が起動できるか試してみます。\r\n\r\n```bash\r\ncd ~/misskey\r\npnpm start\r\n```\r\n\r\n多分アスキーアートみたいなのが出るはず。\r\n\r\n起動できたら（`listen 3000 ～`）止めます  \r\n`Ctrl + C`同時押しでターミナルに戻ってこられるはず。\r\n\r\nそしたらまたユーザーを戻してください\r\n\r\n```bash\r\nexit\r\n```\r\n\r\n## 自動起動の設定\r\n`Windows`のスタートアップみたいな\r\n\r\n### コンフィグを書く\r\nと言ってもこれは全部コピーできるやつです。\r\n\r\n```bash\r\nsudo cp ~misskey/misskey/docs/examples/misskey.service /etc/systemd/system/\r\nsudo systemctl daemon-reload\r\nsudo systemctl enable misskey\r\nsudo systemctl start misskey\r\nsudo systemctl status misskey\r\n```\r\n\r\n最後のコマンドを叩くと、さっきみたいなアスキーアート（欠けてるかも）が出ているはず。  \r\n出て無くてもログが出ていれば成功なはず。  \r\n`INFO *  [core boot]     Welcome to Meisskey!`  \r\nとか  \r\n`INFO *  [core boot]     Meisskey v10.xxxxxxx`  \r\nとか？出ていれば OK なはず\r\n\r\n## DNS の設定\r\nIPアドレスとサブドメインを紐付けます\r\n\r\n### サブドメインのAレコードに VPS の IP アドレスを指定します\r\n`IPv6`の設定が必要なのかは不明（後述する`Let's Encrypt / Certbot`は`IPv4`だけでいいはず）\r\n\r\n`Google Domains`なら`DNS`の項目で、新しいレコードを追加します。  \r\n`IPv4`なので`Aレコード`で、使いたいサブドメインと、`VPS`の`IPv4`アドレスを指定します。\r\n\r\n![Imgur](https://imgur.com/cc5Ajf7.png)\r\n\r\nこんな感じです。\r\n\r\n![Imgur](https://imgur.com/KOd6RpP.png)\r\n\r\n### 反映されるのを待つ\r\n`nslookup`とかして、サブドメインから`IPアドレス`を引けるようになるまで待ちます  \r\nなお、`Misskey`は`https`でないと接続できないらしく、まだURLを入力しても開けないはず。\r\n\r\n## SSL の設定（https でアクセスできるようにする）\r\n`Cloudflare`使える場合はもっといい方法があるはず\r\n\r\n### Certbot / Let\r\nここから、`Nginx`と`Ubuntu 20`を選びます。  \r\n\r\nhttps://certbot.eff.org/\r\n\r\n![Imgur](https://imgur.com/i6DlDJR.png)\r\n\r\nもし内容がおかしかったら↑が正しいです\r\n\r\nまずは`snap`というパッケージマネージャを入れます。\r\n\r\n```bash\r\nsudo snap install core; sudo snap refresh core\r\n```\r\n\r\nいれたら、一応既に入っているかもしれないので`certbot`を消します。  \r\n`snap`経由で入れないといけないので、`apt`とかで既に入っていれば消しちゃいます。\r\n\r\n```bash\r\nsudo apt remove certbot\r\ncertbot --version\r\n```\r\n\r\n`certbot --version`でエラーが帰ってくれば成功（`bin`に`certbot`なんて存在しねえよ！的な）\r\n\r\n次は`snap`経由で`certbot`を入れます。\r\n\r\n```bash\r\nsudo snap install --classic certbot\r\nsudo ln -s /snap/bin/certbot /usr/bin/certbot\r\n```\r\n\r\nそしたらついに`https`でアクセスできるように`nginx`を構成します。  \r\nコンフィグファイルを書き換えるのですが、多分`Misskey`に影響ない状態で書き換えてくれます。\r\n\r\n```bash\r\nsudo certbot --nginx\r\n```\r\n\r\nこのコマンドを叩いた後に以下のことが聞かれます\r\n- メールアドレス\r\n    - `SSL`証明書の更新が出来なかったら通知が来る？\r\n        - `https`でアクセスできなくなってしまうのでメールで教えてくれるそう\r\n- 利用規約に同意するか\r\n- ニュースレターを希望するか（No でいいはず）\r\n- `https`にしたいドメインの最終確認（`nginx`のコンフィグファイルからドメインを探してくれるそう）\r\n\r\n![Imgur](https://imgur.com/ry5LjDy.png)\r\n\r\n![Imgur](https://imgur.com/DFgIOOh.png)\r\n\r\nキーボードぽちぽちしてたら`https`化作業終わった。神だろこれ\r\n\r\n### 自動更新ができるか確認\r\nどうやら自動的に自動更新の`cron ?`が設定されているらしく、自前で`cron`をスケジュールしておく必要も無いらしい。  \r\nただ、成功するかはわからないので、お試し更新機能を使い本当に更新できるか試します。\r\n\r\n```bash\r\nsudo certbot renew --dry-run\r\n```\r\n\r\n`--dry-run`しないと更新されてしまう（そもそも有効期限が十分残っていると更新できない）\r\n\r\n![Imgur](https://imgur.com/J8E7lYf.png)\r\n\r\n成功するとこんな感じになるはず。\r\n\r\n## Misskey 開ける？\r\n`https://ドメイン`で開けるはず。  \r\n\r\n![Imgur](https://imgur.com/ZiolQ3B.png)\r\n\r\nちゃんと`https`で、鍵マークも付いています！！！！  \r\n\r\n一番乗りでアカウントを作ると管理者ユーザーとしてマークされ（コンフィグで変更可能？）、管理画面に入れます。\r\n\r\n![Imgur](https://imgur.com/pHi7FqG.png)\r\n\r\n## オブジェクトストレージの設定\r\n`Misskey`の投稿のメディアは、後からURLを変更できないため、やるなら建てた今しかない！  \r\nデフォルトでは`VPS`のストレージに書き込まれますが、`VPS`のストレージは高いのと拡張が面倒なのでオブジェクトストレージを使うのが良いはず（容量増やし放題だけどお金もかかるよ）。\r\n\r\n参考：  \r\nhttps://docs.aws.amazon.com/ja_jp/AmazonS3/latest/userguide/HostingWebsiteOnS3Setup.html#step4-add-bucket-policy-make-content-public\r\n\r\n### AWS の S3 を使います\r\nただ、これちょっと高い（なんか転送量とリクエスト回数に課金されるややこしい）ので、`S3 互換サービス`を使うのも考えたほうが良さそう。  \r\n今回は今後のことを考え、`S3 互換サービス`に移行できるような設計にもしてみます。\r\n\r\nというわけで`S3`のバケットを作ります。  \r\n名前とかはよしなに...\r\n\r\n![Imgur](https://imgur.com/9Wlwx4A.png)\r\n\r\n下にスクロールして、パブリックアクセスの項目で外からアクセスできるようにします。  \r\nまだバケットポリシーを書いていないのでアクセスは出来ないと思いますが...\r\n\r\n![Imgur](https://imgur.com/ogrkowi.png)\r\n\r\nこれで作成します。\r\n\r\n### バケットポリシー を書く\r\n作ったバケットを開いて、`アクセス許可`に進み、`バケットポリシー`を編集します\r\n\r\n![Imgur](https://imgur.com/6mF1MxS.png)\r\n\r\n\r\n```json\r\n{\r\n    \"Version\": \"2012-10-17\",\r\n    \"Statement\": [\r\n        {\r\n            \"Sid\": \"PublicReadGetObject\",\r\n            \"Effect\": \"Allow\",\r\n            \"Principal\": \"*\",\r\n            \"Action\": [\r\n                \"s3:GetObject\"\r\n            ],\r\n            \"Resource\": [\r\n                \"arn:aws:s3:::作ったバケットの名前/*\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n## API でアクセスするため、キーを IAM で払い出してもらう\r\n`S3`に`API`で操作するには、`IAM`で認可情報を作って貰う必要があります。  \r\n\r\n### IAM ユーザーの作成\r\n\r\n`IAM`の画面を開いて、適当にユーザーを作ります、\r\n\r\n![Imgur](https://imgur.com/xSjT5HT.png)\r\n\r\n次の画面で出てくる権限のところでは、`AmazonS3FullAccess`をつけておけば良さそう\r\n\r\n![Imgur](https://imgur.com/1gRN1XG.png)\r\n\r\n### アクセスキーを払い出してもらう\r\n\r\n作った`IAM ユーザー`の詳細を開いて、`アクセスキー`の作成をします\r\n\r\n![Imgur](https://imgur.com/qXAayIK.png)\r\n\r\n`Misskey`で必要なのは一番下の`その他`の項目のやつです。\r\n\r\n![Imgur](https://imgur.com/XRymShw.png)\r\n\r\n2つ出てくると思います。\r\n\r\n![Imgur](https://imgur.com/7r828eY.png)\r\n\r\n### オブジェクトストレージの設定をコンフィグに記述する\r\n**v13 では Web UI からオブジェクトストレージの設定ができます**  \r\n\r\nまず`Misskey`を止めて\r\n\r\n```bash\r\nsudo systemctl stop misskey\r\n```\r\n\r\n`Misskey`ユーザーに切り替えて、コンフィグを更新します。\r\n\r\n```bash\r\nsudo su - misskey\r\ncd ~/misskey\r\nvim .config/default.yml\r\n```\r\n\r\nそしたら、ファイルシステムに書き込む設定をコメントアウト（`#`でコメントアウトできる）して、  \r\nちょっと下にあるオブジェクトストレージ用の設定を書きます。\r\n\r\n```yml\r\n\r\n### drive ###\r\n#drive:\r\n#  storage: 'fs' # ここをコメントアウトする\r\n\r\n# OR\r\n#drive:\r\n#  storage: 'db'\r\n\r\n# OR\r\ndrive:\r\n  storage: 'minio' # ここは買えなくて良いはず\r\n  bucket: 'xxxxxxxx' # バケット名です\r\n  prefix: 'files' # フォルダを作るなら\r\n  baseUrl: 'https://diary.negitoro.dev/objectstorage' # nginx のリバースプロキシする URL\r\n  config:\r\n    endPoint: '' # S3 の場合は空文字。S3 互換サービスなら入れる\r\n    region: 'ap-northeast-1' # バケットのリージョン\r\n    useSSL: true\r\n    accessKey: 'xxxx' # IAM ユーザーのアクセスキーのアクセスキー\r\n    secretKey: 'xxxx' # IAM ユーザーのアクセスキーのシークレットキー\r\n    useProxy: true\r\n    setPublicRead: false\r\n    s3ForcePathStyle: true\r\n```\r\n\r\nもし、リバースプロキシしない場合（`S3`の公開URLをそのまま使う場合）は、`baseUrl`は`https://s3.ap-northeast-1.amazonaws.com/バケット名`になるはずです。  \r\nリバースプロキシが必要かどうかは`S3`以外を使う予定があるかどうかで決まります。詳しくは ↓ で。  \r\n\r\n`CloudFront`を経由するとか、後述する`nginx`を経由する設計の場合は`baseUrl`が変わるはず  \r\n\r\n後はターミナルを閉じて、おまじない程度にビルドしておきました（必要かどうかは不明）\r\n\r\n```bash\r\nNODE_ENV=production pnpm build\r\nexit\r\n```\r\n\r\n`Misskey`起動させます\r\n\r\n```bash\r\nsudo systemctl start misskey\r\n```\r\n\r\n## メディアのURLをリバースプロキシする（nginx を経由するようにする）\r\n先述の通り`S3`以外のオブジェクトストレージに引っ越しできるように、メディアのURLでは`S3`の`外部公開用URL`を使わないようにします。  \r\n代わりに、メディアのURLを用意して（`https://ドメイン/objectstorage/xxxxx`）、`/objectstorage`に来たリクエストはすべて`nginx`を使い`S3`のURLに向き先を変えるようにします（リバースプロキシ）\r\n\r\n```plaintext\r\nクライアント ( PC / スマホ 等 )\r\n\r\n↓ リクエスト\r\n\r\nnginx が待ち受ける\r\n\r\n↓\r\n\r\nもし URL が /objectstorage だったら ---> [S3 の外部公開用URLへアクセス] \r\nそれ以外 / だったら ---> [Misskey サーバー]\r\n```\r\n\r\n本当（というか他のサーバーだと）はオブジェクトストレージ用のドメイン、`files.ドメイン`みたいなサブドメインを用意して、`S3 + CloudFront`とかで公開して、`CNAME`で`CloudFront`を指すようにするのが良いかもしれないです。  \r\n（何言ってるか分からんと思うけど・・・）\r\n\r\n### nginx のコンフィグをいじる\r\nコンフィグファイルを編集します。\r\n\r\n```bash\r\nsudo vim sudo cat /etc/nginx/sites-enabled/misskey.nginx\r\n```\r\n\r\nそしたら、`/objectstorage`に来たリクエストは`S3`のURLへリバースプロキシするようにします。  \r\nURL は都度買えてください。\r\n\r\nよく知らないけど、`location /`の上に書いておけばよいのかな？  \r\n\r\n`nginx server { } 443` の方です\r\n\r\n```config\r\n\r\n# Media file storage is AWS S3.\r\n# Use nginx proxy in AWS S3 to Internet transfer.\r\n# thats because, Cant edit media file url.\r\nlocation /objectstorage {\r\n    proxy_pass https://s3.ap-northeast-1.amazonaws.com/バケット名;\r\n}\r\n\r\n# Proxy to Node\r\nlocation / {\r\n    proxy_pass http://127.0.0.1:3000;\r\n    proxy_set_header Host $host;\r\n```\r\n\r\n![Imgur](https://imgur.com/FNcgOxb.png)\r\n\r\nそしたら保存してターミナルに戻って、`nginx`へ適用します。\r\n\r\n```bash\r\nsudo systemctl restart nginx\r\n```\r\n\r\n### 動作確認\r\n実際に`Misskey`のドライブにファイルを投げて、`S3`に上がっていれば成功です。  \r\nURL が `/objectstorage`で始まっていればうまく行ってます！！！\r\n\r\n![Imgur](https://imgur.com/1JfWkc5.png)\r\n\r\n![Imgur](https://imgur.com/T4a1855.png)\r\n\r\n![Imgur](https://imgur.com/QykrHbN.png)\r\n\r\n## お疲れ様でした！！！\r\n多分これで構築は良いはず。\r\n\r\nあとは適当にメモを残しておきます。\r\n\r\n### おすすめ設定？\r\n管理画面から出来ます\r\n\r\n- ユーザー登録の受付を停止する を ON\r\n    - お一人様なので\r\n- リモートのファイルをキャッシュする は OFF\r\n    - 多分デフォルト OFF\r\n\r\n### Misskey サーバーの 停止 開始 再起動\r\n\r\n- 開始\r\n    - `sudo systemctl start misskey`\r\n- 停止\r\n    - `sudo systemctl stop misskey`\r\n- 再起動\r\n    - `sudo systemctl restart misskey`\r\n\r\n### 本体更新方法\r\nフォークしたので本家に追従するにはまず`git rebase`とかやって更新を取り込む必要がある  \r\nこっちに書いた\r\n\r\nhttps://github.com/takusan23/misskey#変更を本番に入れる本番更新手順\r\n\r\n### データベースのバックアップ\r\n**データベース**を吹っ飛ばすと同じドメインでサーバーを建てられないらしい？ので、定期的にやる必要があります  \r\n\r\nまずは`Misskey`を止めます\r\n\r\n```bash\r\nsudo systemctl stop misskey\r\n```\r\n\r\n次に、`Misskey`で利用している`MongoDB`のバックアップを取ります。  \r\n今回はホームディレクトリにバックアップしたデータを保存するようにしました。`dump`フォルダが出来ます。  \r\n（ホームディレクトリは `~`←チルダ で移動できます）\r\n\r\n```bash\r\ncd ~\r\nmongodump -o \"./dump\"\r\n```\r\n\r\n**次に、PowerShell を開き（SSH クライアントとは別に）**以下のコマンドを叩いて手元の Windows マシンへバックアップデータを転送します。  \r\n`scp`コマンドです。\r\n\r\n```shell\r\nscp -i {鍵のパス} -r {リモートのユーザー名}@{IPアドレス}:{フォルダのパス} {ローカルのWindowsマシンの保存先パス}\r\n```\r\n\r\n例です\r\n\r\n```shell\r\nscp -i C:\\Users\\takusan23\\key.pem -r ubuntu@000.000.000.000:~/dump C:\\Users\\takusan23\\misskey_backup\\\r\n```\r\n\r\nこれで、ユーザー名のフォルダのところにあるはず（`C:\\Users\\takusan23` みたいな）\r\n\r\n後はこれを`zip`とかにして安全なところに保存しておきます（ Google Drive とか？ AWS S3 Glacier とか？ ）\r\n\r\n### Misskey をカスタマイズしたい（VPS ではなく、手元の Windows で Misskey を構築したい）\r\n書いた。`v10`なので`v13`だと直さないと使えない\r\n\r\nhttps://github.com/takusan23/misskey#手元の開発環境構築\r\n\r\n### 2023/08/06 追記 Cloudflare を利用して Misskey サーバーを保護する？\r\n`Certbot`で`HTTPS`通信できるようにしましたが、`Misskey`的には`Cloudflare`で`SSL (HTTPS)`するのが良いらしい。  \r\n\r\nあらかじめ、`Cloudflare`にドメインを移管しておく必要があります。（いや`Cloudflare DNS`を使えるようしておく必要があります）\r\n\r\nまずは`Cloudflare ダッシュボード`から`Webサイト`を選び、稼働しているドメインを選びます。  \r\nそして`SSL/TLS`を押して、`概要`の`暗号化モード`を`フル`にします。不具合の原因になるみたい。\r\n\r\n![Imgur](https://imgur.com/H6Kgw28.png)\r\n\r\n次に、`DNS`>`レコード`と進み、`Misskey`の`IPアドレス`のレコードが`プロキシ済み`かどうか確認します。  \r\n`プロキシ済み`じゃない場合はしてください。雲のアイコンがオレンジ色になれば良いはず。  \r\nこれで、`Misskey サーバー`との通信の前に`Cloudflare`が入るようになります。  \r\n\r\n```plaintext\r\n[ブラウザ (PC / スマホ) ] <---> [Cloudflare] <---> [Misskey サーバー (VPS)]\r\n```\r\n\r\nさっきの`SSL/TLS`の設定はこの間に入る`Cloudflare`の設定のために必要でした。\r\n\r\n次に`VPS`へログインします。  \r\nまずは`Misskey`を止めて、お好みでバックアップを取ってください。\r\n\r\n```bash\r\nsudo systemctl stop misskey\r\n```\r\n\r\n次に`nginx`のコンフィグを開いて、`Let's Encrypt`ではなく、`自己署名証明書`をセットします。\r\n\r\n```bash\r\nsudo vim /etc/nginx/sites-enabled/misskey.nginx\r\n```\r\n\r\n```nginx\r\nserver {\r\n    listen 443 ssl http2;\r\n    listen [::]:443 ssl http2;\r\n    server_name diary.negitoro.dev;\r\n    ssl_session_cache shared:ssl_session_cache:10m;\r\n\r\n    # Self-Certificate\r\n    ssl_certificate     /etc/ssl/certs/ssl-cert-snakeoil.pem;\r\n    ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;\r\n\r\n    # Disbaled Certbot ( thats because, use Cloudflare )\r\n    # To use Debian/Ubuntu's self-signed certificate (For testing or before issuing a certificate)\r\n    # ssl_certificate /etc/letsencrypt/live/diary.negitoro.dev/fullchain.pem; # managed by Certbot\r\n    # ssl_certificate_key /etc/letsencrypt/live/diary.negitoro.dev/privkey.pem; # managed by Certbot\r\n```\r\n\r\n保存して、`Misskey`を起動し、ブラウザで開けるか確認します。\r\n\r\n```bash\r\nsudo systemctl start misskey\r\n```\r\n\r\n成功していれば、リクエストのレスポンスヘッダーに`Cloudflare`関連の値が入るようになっているはずです。  \r\n![Imgur](https://imgur.com/7AUss7f.png)\r\n\r\nそしたらもう、今使っている`Let's Encrypt`の証明書は不要になるので、消してしまいます。  \r\n\r\n```bash\r\nsudo certbot revoke --cert-path /etc/letsencrypt/live/ドメイン名/cert.pem\r\n```\r\n\r\n```plaintext\r\nWould you like to delete the certificate(s) you just revoked, along with all\r\nearlier and later versions of the certificate?\r\n```\r\n`Y`で\r\n\r\n```plaintext\r\nWARNING: Before continuing, ensure that the listed certificates are not being\r\nused by any installed server software (e.g. Apache, nginx, mail servers).\r\nDeleting a certificate that is still being used will cause the server software\r\nto stop working. See https://certbot.org/deleting-certs for information on\r\ndeleting certificates safely.\r\n\r\nAre you sure you want to delete the above certificate(s)?\r\n```\r\n`Y`で\r\n\r\n`Deleted all files relating to certificate ドメイン名.`が表示されれば完了です。"},{"title":"Misskey サーバーをお引越したメモ","link":"/posts/misskey_server_ohikkosi/","markdown":"`v10`だからあんまり参考にならないかもしれない\r\n\r\n# 環境\r\n\r\n- `AWS Lightsail`\r\n- `Cloudflare`で`SSL`化した\r\n    - `Cloudflare`の`SSL/TLS 暗号化モード`は`フル`\r\n        - これで`https`でアクセスできる\r\n- オブジェクトストレージは`S3`\r\n    - `VPS`のストレージに書き込んでいる場合はそれも引き継ぐ必要があります。\r\n\r\n`Let's Encrypt + Certbot`でも移行後に証明書再発行で良いはず...？（`IPアドレス`ではなくドメインに対して払い出される？）\r\n\r\n# 新しいマシンを用意\r\n`Ubuntu 22.04`を用意しました。  \r\n`TeraTerm`が使えない...取りあえず`PowerShell`に入ってる？`ssh`を使うことにします。  \r\n\r\n鍵ファイルのパスとIPアドレスを直して叩けば使えるはず。\r\n\r\n```powershell\r\nssh -i '鍵ファイルのパス.pem' ubuntu@000.000.000.000\r\n```\r\n\r\n# 移行先を構築する\r\n\r\nメモリを増やして、`sudo apt update`と`sudo apt upgrade`して、`Misskey`のソースいれてビルドして、`nginx`して、、  \r\nってん感じで、`DNS`の設定の前までやっておいてください。\r\n\r\nhttps://takusan.negitoro.dev/posts/misskey_ohitorisama/#dns-の設定\r\n\r\n## MongoDB が入らない\r\n`mongodb`を入れてる途中で...\r\n\r\n```\r\nsudo apt-get install gnupg\r\nwget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | sudo apt-key add -\r\necho \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/4.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list\r\nsudo apt-get update\r\nsudo apt-get install -y mongodb-org\r\n```\r\n\r\nこんな感じに、失敗してしまいます...\r\n\r\n```bash\r\nThe following packages have unmet dependencies:\r\n mongodb-org-mongos : Depends: libssl1.1 (>= 1.1.0) but it is not installable\r\n mongodb-org-server : Depends: libssl1.1 (>= 1.1.0) but it is not installable\r\n mongodb-org-shell : Depends: libssl1.1 (>= 1.1.0) but it is not installable\r\nE: Unable to correct problems, you have held broken packages.\r\n```\r\n\r\n`libssl1.1`が必要なのですが、どうやら`Ubuntu 22.04`からは同梱されなくなったみたいです。  \r\n`MongoDB`の最新版にすると治るそうですが、、、`Misskey`のバックエンドいじるのこわい（というか`DB`が何もわからない）ので、一旦`libssl`を入れる方面でいきます。\r\n\r\nhttps://stackoverflow.com/questions/73656873\r\n\r\n```bash\r\nsudo wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2_amd64.deb\r\nsudo dpkg -i libssl1.1_1.1.1f-1ubuntu2_amd64.deb\r\n```\r\n\r\n`amd`版（`Intel`、`AMD`系`CPU`）なので、`arm`とかの場合は読み替えてください  \r\nこれで`MongoDB`入れられるはず\r\n\r\n```\r\nsudo apt-get install -y mongodb-org\r\n```\r\n\r\n## 移行先でやること（新規で立てる際との違い）\r\n\r\n`Misskey`のコンフィグ、`nginx`のコンフィグを元のサーバーからコピーしてきます。  \r\nコピーは`Vim`のペーストモードが便利です（そのまま貼り付けると`#`でコメントアウトされたり、インデントされてしまう）\r\n\r\n# MongoDB の引き継ぎ\r\n\r\n## 移行前サーバー\r\n\r\n`Misskey`を止めます\r\n\r\n```bash\r\nsudo systemctl stop misskey\r\n```\r\n\r\n次にルートユーザーでログインしたあと、ホームディレクトリ（`~`）にバックアップします\r\n\r\n```bash\r\ncd ~\r\nmongodump -o \"./dump\"\r\n```\r\n\r\nつぎに、手元の`Windows`マシンを使い、バックアップデータを一旦`Windows`マシンへコピーします。  \r\nもしかしたら直接転送できるかも...（お互いのサーバーの鍵ファイルないので一旦経由することにした）\r\n\r\n`PowerShell`を開いて、`SCP`コマンドを使います\r\n\r\n```bash\r\nscp -i '鍵ファイルのパス.pem' -r ubuntu@000.000.000.000:Linuxの保存先 Windowsの保存先\r\n```\r\n\r\n以下例\r\n\r\n```bash\r\nscp -i 'C:\\Users\\takusan23\\.ssh\\key.pem' -r ubuntu@000.000.000.000:~/dump C:\\Users\\takusan23\\misskey_backup\\\r\n```\r\n\r\n## 移行後サーバー\r\nフォルダごと移行先のサーバーへアップロードします  \r\nまた`PowerShell`を開いて、以下のコマンドを叩きます\r\n\r\n```bash\r\nscp -i '鍵ファイルのパス' -r Windowsの保存先 ubuntu@000.000.000.000:Linuxの保存先\r\n```\r\n\r\n以下例\r\n\r\n```bash\r\nscp -i 'C:\\Users\\takusan23\\.ssh\\key.pem' -r C:\\Users\\takusan23\\misskey_backup\\ ubuntu@18.176.65.230:~/dump\r\n```\r\n\r\nそしたら、リストア用コマンドを叩きます。  \r\n移行後サーバーに`SSH`で入って、以下のコマンドを叩きます。（間違えてパス深くなっちゃった...）\r\n\r\n`Misskey`が動いていない場合は一行目はいらないはず。\r\n\r\n```bash\r\nsudo systemctl stop misskey\r\nmongorestore --drop ~/dump/dump/\r\n```\r\n\r\n`-drop`で既にあるデータを消した後、リストアをしてくれます。構築手順の`systemctl`のところで`misskey`を起動してしまったので、おそらくデータベースが作られてしまっていると思います。\r\n\r\nデータが復元できたか見てみます。まず以下のコマンドを叩いて\r\n\r\n```bash\r\nmongo\r\nshow dbs;\r\n```\r\n\r\nデータベース一覧が表示されますが、ここで容量が`0GB`でなければ成功なはず。\r\n\r\n```bash\r\n> show dbs;\r\nadmin    0.000GB\r\nconfig   0.000GB\r\nlocal    0.000GB\r\nmisskey  0.011GB\r\n```\r\n\r\n`exit`を叩くと抜けれます。\r\n\r\n# 起動する\r\n移行後サーバーで叩きます\r\n\r\n```bash\r\nsudo systemctl start misskey\r\nsudo systemctl start nginx\r\n```\r\n\r\n# DNS の設定を直す\r\n\r\n移行先のサーバーへ`DNS`のレコードを向けます。\r\n\r\n# 動作確認\r\n\r\nどうでしょう、アクセスできましたか？？？  \r\n一応新サーバーで見れているかの確認をするのに、移行後サーバーの`nginx`のアクセスログを見るという手があります。  \r\nまあする必要もないでしょうが。\r\n\r\n```bash\r\ncat /var/log/nginx/access.log\r\n```\r\n\r\n携帯回線からも見れました\r\n\r\n![Imgur](https://imgur.com/4rzqtqH.png)\r\n\r\n# 移行前の VPS をお片付けする\r\n金ないのでさっさと止めます。\r\n\r\n![Imgur](https://imgur.com/qtZ8GP6.png)\r\n\r\n以上です!!!!!!!!!\r\n\r\n# おわりに\r\n\r\n今回はギリギリまで（`DB`引っ越し）まで移行前のサーバーを動かす方法で行きました。  \r\nが、多分データベース、画像とかのメディア（S3とかのオブジェクトストレージを使ってないなら）、コンフィグファイル（`misskey`と`nginx`）を`手元の Windows マシン`とかにバックアップしておいて、  \r\n`VPS`を消す方法でも良いはずです。（最後まで残す方法だと、移行作業中は二台`VPS`を動かすことになるので、お一人様にそこまでのお金をかけられるか...）\r\n\r\n# そのほか\r\n\r\n## JavaScript heap out of memory\r\n`Linux`の場合は、`npm`コマンドの先頭に以下のコマンドを入れることで、メモリ割り当てを手動で調整できます。  \r\n単位は`MB`っぽい\r\n\r\n```bash\r\nNODE_OPTIONS=\"--max-old-space-size=2048\"\r\n```\r\n\r\n以下例：\r\n\r\n```bash\r\nNODE_OPTIONS=\"--max-old-space-size=2048\" NODE_ENV=production npm build\r\n```"},{"title":"マウスカーソルの速度変えるアプリ作った","link":"/posts/mousecursor_wpf/","markdown":"\r\nWindowsむずくね？  \r\nC#とWPFは良いとして、.Net Core（.Net Framework）ってなに？\r\n\r\n# 本題\r\nマウスカーソルの速度変えられるやつ(WPF製)作った。\r\n\r\n![Imgur](https://i.imgur.com/gAxYowU.png)\r\n\r\n- マウスの速度に変更\r\n    - Windowsの設定で`5`\r\n- タッチパッドの速度に変更\r\n    - Windowsの設定で`10`\r\n\r\nにするだけのアプリ！！！\r\n\r\n# ダウンロード\r\nhttps://github.com/takusan23/MouseCursorSpeedChanger/releases/tag/1.0\r\n\r\n# 作るのに大変だったこと\r\nを別の記事で書きたいと思います。\r\n\r\n# なんで作ったの？\r\nお友達から無線マウスもらった。（うれしい🥳）  \r\nそれでカーソルの速度が遅かったからWindowsの設定を変えたら、タッチパッドのときの操作が遅くなっちゃった。  \r\nその都度変えれば良いんだけどめんどいので解決してみた。\r\n\r\n## C#でマウスカーソルの速度が変更できるらしい。\r\n参考：https://ez-net.jp/article/D8/VnBq1qVD/s7VwewtZmDws/\r\n\r\nC#ほぼ書かないからわからん\r\n\r\n```cs\r\n/** マウスのカーソルの速度変更関係 */\r\npublic const uint SPI_GETMOUSESPEED = 0x70;\r\npublic const uint SPI_SETMOUSESPEED = 0x71;\r\n\r\n[DllImport(\"User32.dll\")]\r\nstatic extern Boolean SystemParametersInfo(\r\n    UInt32 uiAction,\r\n    UInt32 uiParam,\r\n    IntPtr pvParam,\r\n    UInt32 fWinIni);\r\n```\r\n\r\n使い方はこうです。  \r\nこれはカーソルの速度を5にするコードですね。\r\n```cs\r\nint speed = 5;\r\nSystemParametersInfo(SPI_SETMOUSESPEED, 0, new IntPtr(speed), 0);\r\n```\r\n\r\n以上です。  \r\n話変わるけど午後登校長く寝れるから良いね。早起きしたら学校までのカウントダウンのせいで苦痛だろうけど。"},{"title":"AndroidのMediaBrowserServiceを作る","link":"/posts/nakinagara_media_browser_service/","markdown":"\nどうもこんばんは。  \n8月に学校あるってクソ違和感だよな。日付のところに8月って書くと**あ、まだ8月なのか**って。不思議\n\n# 本題\nAndroid 11でメディアの再開ってのができたので、~~真面目に~~MediaSessionとMediaBrowserServiceを作る。  \n\n# 環境\nこれを書かないと（記事書いた後に）仕様変更があるかもしれんしな。\n\n|なまえ|あたい|\n|---|---|\n|Android|11 Beta 3|\n|Kotlin|1.4 ←JSみたいに配列の最後に「,」入れても怒られなくなった！|\n\n# そもそも MediaSession て何？\n**Always on Display** っていうずっっっと時計を表示できたりする機能があるんですけど、音楽を再生しているとそこに曲名が出るんですよね。  \n他にも**Google Assistant**で音楽の操作ができたり。\n\nこれ、MediaSessionを利用してExoPlayer等のメディアプレイヤーの状態を公開してくれてるからなんですね。\n\nよってMediaSessionはExoPlayerみたいに音楽を再生するものでは無いです。\n\n# 今回の設計\n\n- 音楽再生\n    - ExoPlayer\n- 音楽の情報\n    - ハードコート（めんどいしややこしくなる）\n- Activity\n    - 曲の操作は申し訳ないがActivityではやらずに、通知でのみ行うように。今回はMediaBrowserServiceがやりたいので\n\n# Android 11 の メディアの再開 #とは\n\nhttps://developer.android.com/preview/features/media-controls?hl=ja\n\nhttps://android-developers.googleblog.com/2020/08/playing-nicely-with-media-controls.html\n\n詳しくはここらへん読んで。  \nまあ何ができるようになるかって言うと、**デバイス再起動後に最後に聞いていた曲を再生できる**って機能だと思います。  \n\n![Imgur](https://imgur.com/IpX69hG.png)\n\nこのMediaSession通知が表示されるまでに、  \n- `onGetRoot`が呼ばれる（実装で詳しく）\n- `onLoadChildren`が呼ばれる（実装で詳しく）\n    - 最後の曲をここで返す（非同期おｋ）\n\n再生ボタンだけが表示されてる。これを押すと、\n- `MediaSessionCompat.setCallBack`の`onPrepare()`が呼ばれる\n- `MediaSessionCompat.setCallBack`の`onPlay()`が呼ばれる\n    - ここらへんで通知を更新する？\n\n## 実装わからん\nhttps://github.com/android/uamp  \n読めば分かるって書いてあるけど、**MediaSessionのコールバック関係を別ライブラリ（exoplayer:extension-mediasession）** に任せてるので~~あんま参考に~~  \n\nそれでも共通部分はまあまあわかった気がした。\n\n# 今回の記事はコピペでは動かないと思います。\n中級者向けの記事になりますね。\n\n# 作り方\n\n# build.gradle\n\n```gradle\n// ExoPlayer\nimplementation 'com.google.android.exoplayer:exoplayer-core:2.11.3'\nimplementation 'com.google.android.exoplayer:exoplayer-hls:2.11.3'\nimplementation 'com.google.android.exoplayer:extension-mediasession:2.10.4'\n// Preference\nimplementation \"androidx.preference:preference:1.1.1\"\n```\n\nまず`AndroidManifest.xml`に書き足す内容です\n\n```xml\n<service\n        android:name=\".Service.BackgroundPlaylistCachePlayService\"\n        android:enabled=\"true\"\n        android:exported=\"true\"\n        android:label=\"@string/cache_background_play\">\n    <intent-filter>\n        <action android:name=\"android.media.browse.MediaBrowserService\" />\n    </intent-filter>\n</service>\n<!-- これ書かないと通知から操作一生こない -->\n<receiver android:name=\"androidx.media.session.MediaButtonReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MEDIA_BUTTON\" />\n    </intent-filter>\n</receiver>\n```\n\n`android:name`、`android:label`は各自書き換えてください。\n\nそれと別に、フォアグラウンドサービスを利用するので、上に権限を書いてください。\n\n```xml\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n```\n\n# BackgroundPlaylistCachePlayService.kt\nを作成して、（クラス名は別になんでもいい）`MediaBrowserServiceCompat`を継承してね。\n\n```kotlin\nclass BackgroundPlaylistCachePlayService : MediaBrowserServiceCompat() {\n\n\n    override fun onGetRoot(clientPackageName: String, clientUid: Int, rootHints: Bundle?): BrowserRoot? {\n\n    }\n\n    override fun onLoadChildren(parentId: String, result: Result<MutableList<MediaBrowserCompat.MediaItem>>) {\n\n    }\n\n}\n```\n\nあれ？`onCreate`とか書かないのって話ですが**ちょっとまって。時期が悪い**\n\n## onGetRoot\nこれは`MediaBrowserService`に接続しようとした時に呼ばれます。  \n**Android 11 のメディアの再開かどうか**はここで判断する必要があるのですね。\n\n### Android 11 の メディアの再開 かどうか判断する\n`rootHints?.getBoolean(BrowserRoot.EXTRA_RECENT)`が`true`なら**システムが最後の曲をリクエストしている**ことになります。\n\n```kotlin\n/** [onLoadChildren]でparentIdに入ってくる。Android 11のメディアの再開の場合はこの値 */\nprivate val ROOT_RECENT = \"root_recent\"\n/** [onLoadChildren]でparentIdに入ってくる。[ROOT_RECENT]以外の場合 */\nprivate val ROOT = \"root\"\n/**\n * [MediaBrowserServiceCompat]へ接続しようとした時に呼ばれる\n * Android 11 のメディアの再開では重要になっている\n * */\noverride fun onGetRoot(clientPackageName: String, clientUid: Int, rootHints: Bundle?): BrowserRoot? {\n    // 最後の曲をリクエストしている場合はtrue\n    val isRequestRecentMusic = rootHints?.getBoolean(BrowserRoot.EXTRA_RECENT) ?: false\n    // BrowserRootに入れる値を変える\n    val rootPath = if (isRequestRecentMusic) ROOT_RECENT else ROOT\n    return BrowserRoot(rootPath, null)\n}\n```\n\nこれで、この後にある`onLoadChildren`で**メディアの再開**かどうか分かるようになりました。\n\n**あ、ここでは曲一覧を読み込むとかの重い処理はしないでね。曲一覧はこの後の`onLoadChildren`でやってください。**\n\n## onLoadChildren\nここでは、Activityや他デバイス（Wear OSとか車とか？）に返す曲を読み込みます。  \n**Android 11 の メディアの再開**に対応するにはここで最後に聞いていた曲を返す必要があります。  \nだから`onGetRoot`が必要だったのですね。\n\n```kotlin\n/**\n * Activityとかのクライアントへ曲一覧を返す\n * */\noverride fun onLoadChildren(parentId: String, result: Result<MutableList<MediaBrowserCompat.MediaItem>>) {\n    // 保険。遅くなると怒られるぽい？\n    result.detach()\n    if (parentId == ROOT_RECENT) {\n        // 動画情報いれる\n        result.sendResult(arrayListOf(createMediaItem(\"sm157\",\"てすとです\",\"さぶたいとる\")))\n    }\n}\n/**\n * [onLoadChildren]で返すアイテムを作成する\n * */\nprivate fun createMediaItem(videoId: String, title: String, subTitle: String): MediaBrowserCompat.MediaItem {\n    val mediaDescriptionCompat = MediaDescriptionCompat.Builder().apply {\n        setTitle(title)\n        setSubtitle(subTitle)\n        setMediaId(videoId)\n    }.build()\n    return MediaBrowserCompat.MediaItem(mediaDescriptionCompat, MediaBrowserCompat.MediaItem.FLAG_PLAYABLE)\n}\n```\n\nここで`SharedPreferenceに最後の曲のIDを保存しておく`とか書いてありますが、最後の曲の情報（タイトルとか）が取れればここは自由に作ってください。  \n今回はめんどいのでハードコートしました。\n\n## onCreate\nさて、ようやくですね。  \nここでは`MediaSession`、`ExoPlayer`の初期化を行います。　　\n\n```kotlin\n/** 音楽再生のExoPlayer */\nlateinit var exoPlayer: SimpleExoPlayer\n/** MediaSession */\nlateinit var mediaSessionCompat: MediaSessionCompat\n/** 通知出すのに使う */\nlateinit var notificationManager: NotificationManager\n/** MediaSession初期化など */\noverride fun onCreate() {\n    super.onCreate()\n    // 通知出すのに使う\n    notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n    // ExoPlayer用意\n    exoPlayer = SimpleExoPlayer.Builder(this).build()\n    // MediaSession用意\n    mediaSessionCompat = MediaSessionCompat(this, \"media_session\").apply {\n        // MediaButtons と TransportControls の操作を受け付ける\n        setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS or MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS)\n        // MediaSessionの操作のコールバック\n        setCallback(object : MediaSessionCompat.Callback() {\n            /** 再生準備 */\n            override fun onPrepare() {\n                super.onPrepare()\n                val dataSourceFactory = DefaultDataSourceFactory(this@BackgroundPlaylistCachePlayService, \"TatimiDroid;@takusan_23\")\n                val mediaSource = ProgressiveMediaSource.Factory(dataSourceFactory)\n                    .createMediaSource(\"各自ファイルパスを入れてね\".toUri()) // 動画の場所\n                exoPlayer.prepare(mediaSource)\n            }\n            /** 再生 */\n            override fun onPlay() {\n                super.onPlay()\n                exoPlayer.playWhenReady = true\n                isActive = true\n            }\n            /** 一時停止 */\n            override fun onPause() {\n                super.onPause()\n                exoPlayer.playWhenReady = false\n            }\n            /** 通知のシーク動かした時 */\n            override fun onSeekTo(pos: Long) {\n                super.onSeekTo(pos)\n                exoPlayer.seekTo(pos)\n            }\n            /** 止めた時 */\n            override fun onStop() {\n                super.onStop()\n                isActive = false\n                stopSelf()\n            }\n        })\n        // 忘れずに\n        setSessionToken(sessionToken)\n    }\n    // ExoPlayerの再生状態が更新されたときも通知を更新する\n    exoPlayer.addListener(object : Player.EventListener {\n        override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\n            super.onPlayerStateChanged(playWhenReady, playbackState)\n        }\n    })\n}\n```\n\n動画のファイルパスは各自書き換えてください。  \n\n### これ何してるの？\n`MediaSession`経由で`再生・一時停止`した際にExoPlayerでは何をすれば良いのかって言うのを書いてます。  \n\n## MediaSessionのCallbackのonPlayでサービスを起動する\nこれしないと、**Android 11のメディアの再開**までできたのに、いざ再生しようとすると数秒で止まるようになります。  \n~~これで一日ぐらい無駄にした~~\n\nというかマジで`onPlay`でサービス起動するの？って話ですが、**書 い て あ り ま し た 。**\n\nhttps://developer.android.com/guide/topics/media-apps/audio-app/building-a-mediabrowserservice#service-lifecycle\n\n<p style=\"border: 1px solid;padding:10px\">\nThe media session onPlay() callback should include code that calls startService(). This ensures that the service starts and continues to run, even when all UI MediaBrowser activities that are bound to it unbind.\n</p>\n\n<p style=\"color:red\">最初から読んでればよかったですねえ！</p>\n\nというわけで`onPlay`に（多分フォアグラウンド）サービスを起動するコードを書きましょう\n\n```kotlin\n/** 再生 */\noverride fun onPlay() {\n    super.onPlay()\n    startThisService()\n    exoPlayer.playWhenReady = true\n    isActive = true\n}\n```\n\n`startThisService()`関数は以下\n```kotlin\n/** フォアグラウンドサービスを起動する */\nprivate fun startThisService() {\n    val playlistPlayServiceIntent = Intent(this, BackgroundPlaylistCachePlayService::class.java)\n    // 起動\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        startForegroundService(playlistPlayServiceIntent)\n    } else {\n        startService(playlistPlayServiceIntent)\n    }\n}\n```\n\n# 音楽の情報と再生状態を更新する\nここで用意した情報が、AODやGoogleAssistantで使われるんですね。  \n\nもし音楽の時間が取れる場合は、一緒に入れておくとAndroid 10以降で通知シークができます。  \n今回はめんどいのでハードコートします\n\n```kotlin\n/**\n * 再生状態とメタデータを設定する。今回はメタデータはハードコートする\n *\n * MediaSessionのsetCallBackで扱う操作([MediaSessionCompat.Callback.onPlay]など)も[PlaybackStateCompat.Builder.setState]に書かないと何も起きない\n * */\nprivate fun updateState() {\n    val stateBuilder = PlaybackStateCompat.Builder().apply {\n        // 取り扱う操作。とりあえず 再生準備 再生 一時停止 シーク を扱うようにする。書き忘れると何も起きない\n        setActions(PlaybackStateCompat.ACTION_PREPARE or PlaybackStateCompat.ACTION_PLAY or PlaybackStateCompat.ACTION_PAUSE or PlaybackStateCompat.ACTION_STOP or PlaybackStateCompat.ACTION_SEEK_TO or PlaybackStateCompat.ACTION_STOP)\n        // 再生してるか。ExoPlayerを参照\n        val state = if (exoPlayer.isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED\n        // 位置\n        val position = exoPlayer.currentPosition\n        // 再生状態を更新\n        setState(state, position, 1.0f) // 最後は再生速度\n    }.build()\n    mediaSessionCompat.setPlaybackState(stateBuilder)\n    // メタデータの設定\n    val duration = 288L // 再生時間\n    val mediaMetadataCompat = MediaMetadataCompat.Builder().apply {\n        // Android 11 の MediaSession で使われるやつ\n        putString(MediaMetadataCompat.METADATA_KEY_TITLE, \"音楽のタイトル\")\n        putString(MediaMetadataCompat.METADATA_KEY_ARTIST, \"音楽のアーティスト\")\n        putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration * 1000) // これあるとAndroid 10でシーク使えます\n    }.build()\n    mediaSessionCompat.setMetadata(mediaMetadataCompat)\n}\n```\n\nこれを、ExoPlayerの`onPlayerStateChanged`に書いておきましょう。再生状態が変わったら勝手に関数を呼んで更新されるようになります。\n\n```kotlin\n// ExoPlayerの再生状態が更新されたときも通知を更新する\nexoPlayer.addListener(object : Player.EventListener {\n    override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\n        super.onPlayerStateChanged(playWhenReady, playbackState)\n        updateState()\n    }\n})\n```\n\n## はい注意事項\n`setActions()`に入れた内容のみが扱えます。  \nこの中に書いてない操作は、MediaSessionの`setCallback`に書いても一生呼ばれません。悲しいね\n\n# ForegroundServiceを維持するために通知を出す\nサービス起動から5秒経過する前に、通知を出しましょう。  \nこれでメモリが足りないときも動かすことができます（？）\n\n```kotlin\n/** 通知を表示する */\nprivate fun showNotification() {\n    // 通知を作成。通知チャンネルのせいで長い\n    val notification = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        // 通知チャンネル\n        val channelId = \"playlist_play\"\n        val notificationChannel = NotificationChannel(channelId, \"音楽コントローラー\", NotificationManager.IMPORTANCE_LOW)\n        if (notificationManager.getNotificationChannel(channelId) == null) {\n            // 登録\n            notificationManager.createNotificationChannel(notificationChannel)\n        }\n        NotificationCompat.Builder(this, channelId)\n    } else {\n        NotificationCompat.Builder(this)\n    }\n    notification.apply {\n        setStyle(androidx.media.app.NotificationCompat.MediaStyle().setMediaSession(mediaSessionCompat.sessionToken).setShowActionsInCompactView(0))\n        setSmallIcon(R.drawable.ic_background_icon)\n        // 通知領域に置くボタン\n        if (exoPlayer.isPlaying) {\n            addAction(NotificationCompat.Action(R.drawable.ic_pause_black_24dp, \"一時停止\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_PAUSE)))\n        } else {\n            addAction(NotificationCompat.Action(R.drawable.ic_play_arrow_24px, \"再生\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_PLAY)))\n        }\n        addAction(NotificationCompat.Action(R.drawable.ic_clear_black, \"停止\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_STOP)))\n    }\n    // 通知表示\n    startForeground(84, notification.build())\n}\n```\n\nあ、アイコンは各自用意してください。  \n`ResourceManager → + `から好きなアイコンを選んできてください。\n\nこれも、ExoPlayerの`onPlayerStateChanged`に書いておきましょう\n\n```kotlin\n// ExoPlayerの再生状態が更新されたときも通知を更新する\nexoPlayer.addListener(object : Player.EventListener {\n    override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\n        super.onPlayerStateChanged(playWhenReady, playbackState)\n        updateState()\n        showNotification()\n    }\n})\n```\n\nこれで生きていけます。  \nあとなんかしらんけど、通知のテキストとか入れてないんだけどこれ`MediaStyle`だと勝手に曲の名前とか入れてくれるのかな。\n\n### はい注意事項\nsetSmallIconが無くても **通知は出せますが、MediaStyleな通知を出すためには、アイコンの指定が必要です。**  \nアイコンはちゃんと指定しよう。\n\n# あとしまつ\n```kotlin\noverride fun onDestroy() {\n    super.onDestroy()\n    mediaSessionCompat.release()\n    exoPlayer.release()\n}\n```\n\n# Fragment(Activity)から操作できるように\n\n~~startForegroundService()で起動したほうが早くね~~\n\nまず使う関数たちです\n\n```kotlin\nprivate fun initCachePlaylistPlay() {\n    bottom_fragment_nicovideo_list_menu_playlist_background.setOnClickListener {\n        // ボタン押した時\n        mediaControllerCompat.transportControls.play()\n    }\n}\n/** [BackgroundPlaylistCachePlayService]と接続する関数 */\nprivate fun initMediaBrowserConnect() {\n    // MediaBrowser\n    mediaBrowserCompat = MediaBrowserCompat(requireContext(), ComponentName(requireContext(), BackgroundPlaylistCachePlayService::class.java), object : MediaBrowserCompat.ConnectionCallback() {\n        override fun onConnected() {\n            super.onConnected()\n            mediaControllerCompat = MediaControllerCompat(requireContext(), mediaBrowserCompat.sessionToken)\n            // とりあえずprepareを呼ぶ\n            mediaControllerCompat.transportControls.prepare()\n        }\n    }, null)\n    // 接続\n    mediaBrowserCompat.connect()\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n    mediaBrowserCompat.disconnect()\n}\n```\n\nそれから`onViewCreated`でこんな感じに\n\n```kotlin\noverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n    // MediaBrowserと接続\n    initMediaBrowserConnect()\n    \n    // キャッシュ用連続再生\n    initCachePlaylistPlay()\n}\n```\n\nActivityでも同じようにできると思います。\n\n## 何してるの？\nわからん。  \n`今回作ったMediaBrowserService`を操作する`MediaControllerCompat`を用意するために、なんかやってる。\n\nとりあえず再生できるように操作できるようになったら`prepare()`を呼んでる。\n\n`bottom_fragment_nicovideo_list_menu_playlist_background`は私の環境にしか無いので、各自ActivityかFragmentにボタンを置いて、`setOnClickListener{ }`の中に`mediaControllerCompat.transportControls.play()`を書けばいいです。\n\nところで`requireContext()`っていつの間にできたの？\n\n# `mediaControllerCompat.transportControls.play()`の結果\n![Imgur](https://imgur.com/9BWwp5X.png)\n\nいかがでしょうか！！こんな感じになりましたか！？！？\n\n### play()の時に値を渡したい\n`playFromMediaId()`あたりを使えばできそう。  \n使う際は、\n- `setCallBack()`に`override fun onPlayFromUri`を追加\n- `updateState()`関数にある、`setActions()`の中に`PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID`追加\n\nしないとダメだと思います。\n\n# 果たして再起動後も音楽の再開ができるのか\nできました。onLoadChildrenで返してる内容が表示されてますね。\n\n![Imgur](https://imgur.com/blfcxsI.png)\n\n# 全コード\n```kotlin\nclass BackgroundPlaylistCachePlayService : MediaBrowserServiceCompat() {\n\n    /** [onLoadChildren]でparentIdに入ってくる。Android 11のメディアの再開の場合はこの値 */\n    private val ROOT_RECENT = \"root_recent\"\n\n    /** [onLoadChildren]でparentIdに入ってくる。[ROOT_RECENT]以外の場合 */\n    private val ROOT = \"root\"\n\n    /** 音楽再生のExoPlayer */\n    lateinit var exoPlayer: SimpleExoPlayer\n\n    /** MediaSession */\n    lateinit var mediaSessionCompat: MediaSessionCompat\n\n    /** 通知出すのに使う */\n    lateinit var notificationManager: NotificationManager\n\n    /** MediaSession初期化など */\n    override fun onCreate() {\n        super.onCreate()\n\n        // 通知出すのに使う\n        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n\n        // ExoPlayer用意\n        exoPlayer = SimpleExoPlayer.Builder(this).build()\n\n        // MediaSession用意\n        mediaSessionCompat = MediaSessionCompat(this, \"media_session\").apply {\n\n            // MediaButtons と TransportControls の操作を受け付ける\n            setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS or MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS)\n\n            // MediaSessionの操作のコールバック\n            setCallback(object : MediaSessionCompat.Callback() {\n\n                /** 再生準備 */\n                override fun onPrepare() {\n                    super.onPrepare()\n                    val dataSourceFactory = DefaultDataSourceFactory(this@BackgroundPlaylistCachePlayService, \"TatimiDroid;@takusan_23\")\n                    val mediaSource = ProgressiveMediaSource.Factory(dataSourceFactory)\n                        .createMediaSource(\"各自いれて\".toUri()) // 動画の場所\n                    exoPlayer.prepare(mediaSource)\n                }\n\n                /** 再生 */\n                override fun onPlay() {\n                    super.onPlay()\n                    startThisService()\n                    exoPlayer.playWhenReady = true\n                }\n\n                /** 一時停止 */\n                override fun onPause() {\n                    super.onPause()\n                    exoPlayer.playWhenReady = false\n                }\n\n                /** 通知のシーク動かした時 */\n                override fun onSeekTo(pos: Long) {\n                    super.onSeekTo(pos)\n                    exoPlayer.seekTo(pos)\n                }\n\n                /** 止めた時 */\n                override fun onStop() {\n                    super.onStop()\n                    isActive = false\n                    stopSelf()\n                }\n\n            })\n\n            // 忘れずに\n            setSessionToken(sessionToken)\n        }\n\n        // ExoPlayerの再生状態が更新されたときも通知を更新する\n        exoPlayer.addListener(object : Player.EventListener {\n            override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\n                super.onPlayerStateChanged(playWhenReady, playbackState)\n                updateState()\n                showNotification()\n            }\n        })\n    }\n\n    /**\n     * 再生状態とメタデータを設定する。今回はメタデータはハードコートする\n     *\n     * MediaSessionのsetCallBackで扱う操作([MediaSessionCompat.Callback.onPlay]など)も[PlaybackStateCompat.Builder.setState]に書かないと何も起きない\n     * */\n    private fun updateState() {\n        val stateBuilder = PlaybackStateCompat.Builder().apply {\n            // 取り扱う操作。とりあえず 再生準備 再生 一時停止 シーク を扱うようにする。書き忘れると何も起きない\n            setActions(PlaybackStateCompat.ACTION_PREPARE or PlaybackStateCompat.ACTION_PLAY or PlaybackStateCompat.ACTION_PAUSE or PlaybackStateCompat.ACTION_STOP or PlaybackStateCompat.ACTION_SEEK_TO or PlaybackStateCompat.ACTION_STOP)\n            // 再生してるか。ExoPlayerを参照\n            val state = if (exoPlayer.isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED\n            // 位置\n            val position = exoPlayer.currentPosition\n            // 再生状態を更新\n            setState(state, position, 1.0f) // 最後は再生速度\n        }.build()\n        mediaSessionCompat.setPlaybackState(stateBuilder)\n        // メタデータの設定\n        val duration = 288L // 再生時間\n        val mediaMetadataCompat = MediaMetadataCompat.Builder().apply {\n            // Android 11 の MediaSession で使われるやつ\n            putString(MediaMetadataCompat.METADATA_KEY_TITLE, \"音楽のタイトル\")\n            putString(MediaMetadataCompat.METADATA_KEY_ARTIST, \"音楽のアーティスト\")\n            putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration * 1000) // これあるとAndroid 10でシーク使えます\n        }.build()\n        mediaSessionCompat.setMetadata(mediaMetadataCompat)\n    }\n\n    /** 通知を表示する */\n    private fun showNotification() {\n        // 通知を作成。通知チャンネルのせいで長い\n        val notification = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            // 通知チャンネル\n            val channelId = \"playlist_play\"\n            val notificationChannel = NotificationChannel(channelId, getString(R.string.background_playlist_play_channel), NotificationManager.IMPORTANCE_LOW)\n            if (notificationManager.getNotificationChannel(channelId) == null) {\n                // 登録\n                notificationManager.createNotificationChannel(notificationChannel)\n            }\n            NotificationCompat.Builder(this, channelId)\n        } else {\n            NotificationCompat.Builder(this)\n        }\n        notification.apply {\n            setStyle(androidx.media.app.NotificationCompat.MediaStyle().setMediaSession(mediaSessionCompat.sessionToken).setShowActionsInCompactView(0))\n            setSmallIcon(R.drawable.ic_background_icon)\n            // 通知領域に置くボタン\n            if (exoPlayer.isPlaying) {\n                addAction(NotificationCompat.Action(R.drawable.ic_pause_black_24dp, \"一時停止\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_PAUSE)))\n            } else {\n                addAction(NotificationCompat.Action(R.drawable.ic_play_arrow_24px, \"再生\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_PLAY)))\n            }\n            addAction(NotificationCompat.Action(R.drawable.ic_clear_black, \"停止\", MediaButtonReceiver.buildMediaButtonPendingIntent(this@BackgroundPlaylistCachePlayService, PlaybackStateCompat.ACTION_STOP)))\n        }\n        // 通知表示\n        startForeground(84, notification.build())\n    }\n\n    /** フォアグラウンドサービスを起動する */\n    private fun startThisService() {\n        val playlistPlayServiceIntent = Intent(this, BackgroundPlaylistCachePlayService::class.java)\n        // 起動\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            startForegroundService(playlistPlayServiceIntent)\n        } else {\n            startService(playlistPlayServiceIntent)\n        }\n    }\n\n    /**\n     * [MediaBrowserServiceCompat]へ接続しようとした時に呼ばれる\n     * Android 11 のメディアの再開では重要になっている\n     * */\n    override fun onGetRoot(clientPackageName: String, clientUid: Int, rootHints: Bundle?): BrowserRoot? {\n        // 最後の曲をリクエストしている場合はtrue\n        val isRequestRecentMusic = rootHints?.getBoolean(BrowserRoot.EXTRA_RECENT) ?: false\n        // BrowserRootに入れる値を変える\n        val rootPath = if (isRequestRecentMusic) ROOT_RECENT else ROOT\n        return BrowserRoot(rootPath, null)\n    }\n\n    /**\n     * Activityとかのクライアントへ曲一覧を返す\n     * */\n    override fun onLoadChildren(parentId: String, result: Result<MutableList<MediaBrowserCompat.MediaItem>>) {\n        // 保険。遅くなると怒られるぽい？\n        result.detach()\n        if (parentId == ROOT_RECENT) {\n            // 動画情報いれる\n            result.sendResult(arrayListOf(createMediaItem(\"sm157\", \"てすとです\", \"さぶたいとる\")))\n        }\n    }\n\n    /**\n     * [onLoadChildren]で返すアイテムを作成する\n     * */\n    private fun createMediaItem(videoId: String, title: String, subTitle: String): MediaBrowserCompat.MediaItem {\n        val mediaDescriptionCompat = MediaDescriptionCompat.Builder().apply {\n            setTitle(title)\n            setSubtitle(subTitle)\n            setMediaId(videoId)\n        }.build()\n        return MediaBrowserCompat.MediaItem(mediaDescriptionCompat, MediaBrowserCompat.MediaItem.FLAG_PLAYABLE)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mediaSessionCompat.release()\n        exoPlayer.release()\n    }\n\n}\n```\n\n# おわりに\nMediaSession、よくわからん。  \n**なんかしらんけど `setMetadata()` で複雑なことすると通知が二重ででる。**  \nいや私の設計が悪いのかもしれない。(ExoPlayerにTagがなければ表示しないとかいう仕様だから、Tagが無いときは適当な情報を入れておくことで(今ん所)解決)  \n\nうーん。わからん！  \nMediaStyle通知が二重で表示される場合はとりあえず仮でメタデータを作っておいて、その後に本番を入れてあげるとうまくいくかもしれない。\n\n~~まあ動いてよかったわ（よくない）~~\n\n```kotlin\nval stateBuilder = PlaybackStateCompat.Builder().apply {\n    // 取り扱う操作。とりあえず 再生準備 再生 一時停止 シーク を扱うようにする。書き忘れると何も起きない\n    setActions(PlaybackStateCompat.ACTION_PREPARE or PlaybackStateCompat.ACTION_PLAY or PlaybackStateCompat.ACTION_PAUSE or PlaybackStateCompat.ACTION_STOP or PlaybackStateCompat.ACTION_SEEK_TO or PlaybackStateCompat.ACTION_STOP)\n    // 再生してるか。ExoPlayerを参照\n    val state = if (exoPlayer.isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED\n    // 位置\n    val position = exoPlayer.currentPosition\n    // 再生状態を更新\n    setState(state, position, 1.0f) // 最後は再生速度\n}.build()\nmediaSessionCompat.setPlaybackState(stateBuilder)\n// なんかここらへんがおかしいと通知が二重で発行される。のでとりあえず仮のメタデータを送って\nval mediaMetadataCompat = MediaMetadataCompat.Builder().apply {\n    // Android 11 の MediaSession で使われるやつ\n    putString(MediaMetadataCompat.METADATA_KEY_TITLE, \"タイトル\")\n    putString(MediaMetadataCompat.METADATA_KEY_ARTIST, \"アーティスト\")\n    putLong(MediaMetadataCompat.METADATA_KEY_DURATION, 0 * 1000) // これあるとAndroid 10でシーク使えます\n}.build()\nmediaSessionCompat.setMetadata(mediaMetadataCompat)\n// 取れそうなら本番のメタデータを送る。なぜか上の setMetadata を省略すると動かない。\nif (exoPlayer.currentTag is String) {\n    mediaSessionCompat.setMetadata(createMetaData(exoPlayer.currentTag as String))\n}\n```\n\n\nあと再起動から起動→再生ボタン押す→なぜかこれ以降押せなくなる  \nバグなの・・・？でもUAMPのサンプルだとそんなこと無いし？わからん。  \nBetaのせい？（人のせいにするな）\n\n初音ミクさん誕生日おめでとうございます。\n\n\n### そういえば\n```koltin\nimplementation \"androidx.media:media:1.1.0\"\n```\n\nこれ入れると`setFlags`が省略できる？\n\n# 参考にしました\nhttps://dev.classmethod.jp/articles/how-to-android-media-player/\n\nhttps://qiita.com/siy1121/items/f01167186a6677c22435\n\nhttps://android-developers.googleblog.com/2020/08/playing-nicely-with-media-controls.html\n\nhttps://developer.android.com/guide/topics/media-apps/audio-app/building-a-mediabrowserservice\n\nhttps://developer.android.com/preview/features/media-controls"},{"title":"Next.js の AppRouter に移行する","link":"/posts/next_js_13_app_router_migration/","markdown":"\r\nどうもこんばんわ。\r\n恋にはあまえが必要です 攻略しました。  \r\nゆびさきのときとは違ってちゃんとメッセージアプリのテキストも読み上げてくれます神。  \r\n\r\nこの子のBルートの最後のイベントCGがめっちゃ好みです。\r\n\r\n![Imgur](https://imgur.com/KvcE0Gh.png)\r\n\r\n![Imgur](https://imgur.com/tB5j7YX.png)\r\n\r\n個人的には 満留さん と 千羽ちゃん のルートが好きです、  \r\nAルートのほうが好みでした。\r\n\r\n![Imgur](https://imgur.com/UTyFiFD.png)\r\n\r\n![Imgur](https://imgur.com/62BW6gS.png)\r\n\r\nかわいい\r\n\r\n![Imgur](https://imgur.com/bOC7SP1.png)\r\n\r\n↑ ヒロイン視点がめっちゃいい\r\n\r\n![Imgur](https://imgur.com/PYaEeQ2.png)\r\n\r\nルート選択、妹ちゃんルートはちゃんと午後からしか出現しないようになってた（それはそうか\r\n\r\n![Imgur](https://imgur.com/d4bVeUR.png)\r\n\r\nあつい・・・あついね  \r\n予想よりもめっちゃよかったです！！おすすめ（様子見しようかと思ってたけど予約してよかった）\r\n\r\nあとめっちゃ関係ないですが`Misskeyのお一人様インスタンス`立ててみました。しばらく見てないうちに`インスタンス`ではなく`サーバー`って言うようになったらしい。  \r\nこちらです。立ててしまった以上使わないとお金かかかるので使います・・・多分（？？？）\r\n\r\n- URL\r\n    - https://diary.negitoro.dev/@takusan_23\r\n- ID と 鯖\r\n    - `@takusan_23@diary.negitoro.dev`\r\n\r\nなぜか私の鯖からリモートのユーザー情報が取れない鯖があるんですけどよく分かりません・・・  \r\nio鯖とかは普通にリモートフォロー出来たのでほんとに謎です・・・\r\n\r\n# 本題\r\n`Next.js`の`AppRouter`に移行しようと思います。いい加減やります。  \r\nおそらく日が経ったので、`PromiseでJSX`を返してもエラーにならないはず・・・！\r\n\r\n# 環境\r\n\r\n|            |                     |\r\n|------------|---------------------|\r\n| Next.js    | 13.4.4              |\r\n| React      | 18.2.0              |\r\n| TypeScript | 5.1.3 (後述)        |\r\n| リポジトリ | app_router ブランチ |\r\n\r\n\r\n# Next.js の AppRouter\r\n\r\n`React Server Components`が採用されているので、デフォルトで`.tsx`を作った場合はサーバー側で描画されます。  \r\n\r\n???\r\n\r\nサーバー側（このブログは`SSG`ですが）で`React (JSX)`から`HTML`を作ってクライアントに返そう言っています。？  \r\n動きのない（タイトルを表示している部分など）はこれを使うと、追加の`JavaScript`が無いので軽くなるとか？？  \r\n\r\nサーバー側で描画するため、直接`データベース / API`へアクセスし、コンポーネントをクライアントへ返すことができるらしい。うーん難しい  \r\nサーバー側で描画されるので、`useState`や、`onClick`、`Context`は使えない（動的な要素が必要ならクライアントコンポーネントが必要）  \r\n\r\nてなことがここに書いてある。  \r\nhttps://nextjs.org/docs/getting-started/react-essentials#when-to-use-server-and-client-components\r\n\r\n### データ取得の新しい考え方？\r\n`getStaticProps`は無くなったそう。かわりにコンポーネントが非同期で返せる（！？）ので、直接`await`でブログ記事とかを読み込めばいいらしい。  \r\nコンポーネントでAPI叩くとか非同期なことできるようになったのが`RSC`なのか・・・？  \r\n\r\n上に関連してなんですが、どうやらページの作り方の考え方も変わってるそうで、  \r\n今までは`getStaticProps`でデータを取ったら、`Props`を他のコンポーネントにバケツリレーしてたと思うのですが、、  \r\n`AppRouter`ではできる限り、非同期コンポーネント内でそれぞれ`getStaticProps`に当たる取得処理をするのが良いらしい。どゆこと？  \r\n\r\n```tsx\r\n// これより ----\r\nexport default async function DetailPage() {\r\n    const data = await getArticle() // 記事を読み込む関数 Promise\r\n    return (\r\n        <>\r\n            <Title>{data.title}</Title>\r\n            <Detail body={data.html} />\r\n        </>\r\n    )\r\n}\r\n\r\n// こっちの方がいいらしい ----\r\nasync function Title() {\r\n    const data = await getArticle()\r\n    return (<h1>{data.title}</h1>)\r\n}\r\nasync function Detail() {\r\n    const data = await getArticle()\r\n    return (<body dangerouslySetInnerHTML={data.html} />)\r\n}\r\n\r\nexport default async function DetailPage() {\r\n  return (\r\n    <>\r\n        <Title/>\r\n        <Detail />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n- https://nextjs.org/docs/app/building-your-application/data-fetching#fetching-data-on-the-server\r\n    - サーバーコンポーネントでロードしろ\r\n- https://nextjs.org/docs/app/building-your-application/data-fetching#automatic-fetch-request-deduping\r\n    - `fetch()`は重複リクエストしても、複数回`API`を叩くような処理にはならないよ\r\n- https://nextjs.org/docs/app/building-your-application/data-fetching/caching#react-cache\r\n    - `fetch()`が使えない（このブログのように、`Node.js`の`fs モジュール`を使うなど）場合は`cache()`を用意したから使ってね！\r\n\r\n## Material-UI\r\nこのブログは`Material-UI`を使っていて、`Material-UI`はクライアントコンポーネントで描画する必要があります。  \r\nというわけで、`\"use client\";`をひたすら書いていくのが今回の移行作業だと思います・・・\r\n\r\n- https://github.com/mui/material-ui/issues/34905#issuecomment-1587760474\r\n- https://github.com/mui/material-ui/issues/34905#issuecomment-1401306594\r\n\r\nせっかく`App Router`なのに、全部に全部`\"use client\"`したら意味がないんじゃないかと思っていましたが、  \r\nサーバーコンポーネント以外にもメリットがあると言ってくれているので、`pages`から移行したほうが良さそう  \r\n（ 非同期なコンポーネントや、`Next.js 用 fetch API`、`pages ディレクトリ`よりも柔軟なファイル構成 など。特に最後のやつはそれだけでも旨味ありそう？ ）\r\n\r\n# 移行します\r\n公式  \r\nhttps://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration\r\n\r\n手順としては・・・\r\n\r\n- もろもろ更新する\r\n    - 暗黙的な`children`が無くなったりとめんどいかも\r\n- `pages`のルーティングを`app`に移動する\r\n- 既存の`pages`で動いてたページをクライアントコンポーネントとして使えるようにする（`\"use client\"`をひたすら付ける）\r\n- `app`へサーバーコンポーネントとして動くページを作り、データ取得と↑で作ったクライアントコンポーネントを呼び出す\r\n- `generateStaticParams`を使って動的ルーティングを実装する\r\n- `GoogleAnalytics`や`グローバルCSS`を動くように調節する\r\n\r\nがんばりましょう。。。\r\n\r\n## 更新\r\n`Next.js`を更新します  \r\n```\r\nnpm install next@latest react@latest react-dom@latest \r\n```\r\n\r\n`TypeScript`だけは`npm i -D typescript`で更新されなかったので直接`package.json`をいじりました。  \r\n`typescript`を`5.1.3`以降へ、`@types/react`を`18.2.8`以降にします。  \r\n直接いじった場合、`package-lock.json`、`node_module`を消して`npm i`しないとだめです。\r\n\r\n```json\r\n  \"devDependencies\": {\r\n    \"@types/react\": \"^18.2.8\",\r\n    \"typescript\": \"^5.1.3\"\r\n  }\r\n}\r\n```\r\n\r\n## app フォルダを作る\r\n`pages`のように`app`を作りました。\r\n\r\n## _app.tsx を layout.tsx にする\r\n`_app.tsx`を使って共通レイアウトを作ってましたが、`App Router`では`layout.tsx`を作ることで共通レイアウトを作れるようになりました。  \r\n\r\n![Imgur](https://imgur.com/msvtbZg.png)\r\n\r\n`app/layout.tsx`  \r\n```tsx\r\nimport ClientLayout from \"./ClientLayout\"\r\n\r\n/** 共通レイアウト部分 */\r\nexport default function RootLayout({ children, }: { children: React.ReactNode }) {\r\n    // クライアントコンポーネントとして描画する必要があるため\r\n    return (<ClientLayout children={children} />)\r\n}\r\n```\r\n\r\n`app/ClientLayout.tsx`  \r\n```tsx\r\n// Material-UI を使うためクライアントコンポーネント\r\n\"use client\"\r\n\r\nimport { ThemeProvider } from '@mui/material/styles'\r\nimport Layout from '../../components/Layout'\r\nimport useCustomTheme from '../../src/ZiyuutyouTheme'\r\nimport { useEffect, useState } from \"react\"\r\nimport useMediaQuery from '@mui/material/useMediaQuery'\r\n\r\n/** ClientLayout へ渡す値  */\r\ntype ClientLayoutProps = {\r\n    /** 子要素 */\r\n    children: React.ReactNode\r\n}\r\n\r\n/** 共通レイアウト */\r\nexport default function ClientLayout({ children }: ClientLayoutProps) {\r\n    // ダークモードスイッチ\r\n    const [isDarkmode, setDarkmode] = useState(false)\r\n    // テーマ。カスタムフック？何もわからん\r\n    const theme = useCustomTheme(isDarkmode)\r\n    // システム設定がダークモードならダークモードにする。Win10で確認済み\r\n    const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)')\r\n    // システム設定のダークモード切り替え時にテーマも切り替え\r\n    useEffect(() => {\r\n        setDarkmode(prefersDarkMode)\r\n    }, [prefersDarkMode])\r\n\r\n    return (\r\n        <>\r\n            <ThemeProvider theme={theme}>\r\n                {/* ナビゲーションドロワーとタイトルバーをAppで描画する。各Pageでは描画しない */}\r\n                <Layout\r\n                    isDarkmode={isDarkmode}\r\n                    onDarkmodeChange={() => setDarkmode(!isDarkmode)}\r\n                >\r\n                    {/* 各Pageはここで切り替える。これでタイトルバー等は共通化される */}\r\n                    {children}\r\n                </Layout>\r\n            </ThemeProvider>\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n## _document.tsx を layout.tsx にする\r\nまた、`next/head`も変更されており、メタデータを公開するような形になっています。  \r\n`_document.tsx`で`head`いじってた場合はここに書くっぽい。\r\n\r\n`pages/_document.tsx`  \r\n```tsx\r\nexport default class Document extends NextDocument {\r\n    render() {\r\n        return (\r\n            <Html>\r\n                <Head>\r\n                    {/* PWA */}\r\n                    <link rel=\"icon\" sizes=\"192x192\" href=\"/icon.png\" />\r\n                    <link rel=\"manifest\" href=\"/manifest.json\" />\r\n                </Head>\r\n                <body>\r\n                    <Main />\r\n                    <NextScript />\r\n                </body>\r\n            </Html>\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n`app/layout.tsx`  \r\n```tsx\r\nimport { Metadata } from \"next\"\r\nimport ClientLayout from \"./ClientLayout\"\r\n\r\nexport const metadata: Metadata = {\r\n    manifest: '/manifest.json'\r\n}\r\n\r\n/** 共通レイアウト部分 */\r\nexport default function RootLayout({ children, }: { children: React.ReactNode }) {\r\n    // TODO Google Analytics\r\n    // クライアントコンポーネントとして描画する必要があるため\r\n    return (<ClientLayout children={children} />)\r\n}\r\n```\r\n\r\n`icon`、`favicon`は、`appフォルダ`内に入れておくことで自動で認識して追加してくれるそうです。  \r\n![Imgur](https://imgur.com/J4KEWCE.png)\r\n\r\nhttps://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons#image-files-ico-jpg-png\r\n\r\n## pages を app に移動する\r\n`pages/index.tsx`をクライアントコンポーネントにします。\r\n\r\n`app/ClientHomePage.tsx`  \r\n```tsx\r\n// Material-UI を使うため クライアントコンポーネント\r\n\"use client\"\r\n\r\nimport LinkCard from \"../../components/LinkCard\";\r\nimport MakingAppCard from \"../../components/MakingAppCard\";\r\nimport ProfileCard from \"../../components/ProfileCard\";\r\nimport Spacer from \"../../components/Spacer\";\r\nimport LinkData from \"../../src/data/LinkData\";\r\nimport { MakingAppData } from \"../../src/data/MakingAppData\";\r\n\r\n/** ClientHomePage へ渡すデータ */\r\ntype ClientHomePageProps = {\r\n    /** ランダムメッセージの配列 */\r\n    randomMessageList: Array<string>,\r\n    /** 作ったアプリ配列 */\r\n    makingAppList: MakingAppData[],\r\n    /** リンク集 */\r\n    linkList: LinkData[]\r\n}\r\n\r\n/** 最初に表示する画面 */\r\nexport default function ClientHomePage(props: ClientHomePageProps) {\r\n    return (\r\n        <>\r\n            <ProfileCard randomMessageList={props.randomMessageList} />\r\n            <Spacer value={1} />\r\n            <LinkCard linkList={props.linkList} />\r\n            <Spacer value={1} />\r\n            <MakingAppCard makingAppList={props.makingAppList} />\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n次に、`app/page.tsx`を作り、`getStaticProps`でやっていたロード処理を非同期コンポーネント内でやるようにします。  \r\n\r\n`app/page.tsx`  \r\n```tsx\r\nimport { Metadata } from \"next\";\r\nimport JsonFolderManager from \"../src/JsonFolderManager\";\r\nimport ClientHomePage from \"./ClientHomePage\";\r\n\r\n/** <head> に入れる値 */\r\nexport const metadata: Metadata = {\r\n    title: 'トップページ - たくさんの自由帳'\r\n}\r\n\r\n/** 最初に表示されるページ */\r\nexport default async function Home() {\r\n    // データを async/await を使って取得する\r\n    // なんとなく並列にしてみた\r\n    const [randomMessageList, makingAppList, linkList] = await Promise.all([\r\n        // ランダムメッセージ\r\n        JsonFolderManager.getRandomMessageList(),\r\n        // 作ったアプリ\r\n        JsonFolderManager.getMakingAppMap(),\r\n        // リンク集\r\n        JsonFolderManager.getLinkList()\r\n    ])\r\n\r\n    return (<ClientHomePage randomMessageList={randomMessageList} makingAppList={makingAppList} linkList={linkList} />)\r\n}\r\n```\r\n\r\nなんとなく並列にしてみただけで、大人しく一個一個`await`しても問題ないはずです。  \r\n\r\n```ts\r\n// これでもいい\r\n// ランダムメッセージ\r\nconst randomMessageList = await JsonFolderManager.getRandomMessageList()\r\n// 作ったアプリ\r\nconst makingLovers = await JsonFolderManager.getMakingAppMap()\r\n// リンク集\r\nconst linkList = await JsonFolderManager.getLinkList()\r\n```\r\n\r\n最後に、`pages/index.tsx`、`pages/_app.tsx`、`pages/_document.tsx`を消します。残しておくと、`app`なのか`pages`なのかどっちなんだい！ってなっちゃうので  \r\n\r\nどうだろう、これで見れるはず？  \r\n![Imgur](https://imgur.com/5p4dvJN.png)\r\n\r\n## ひたすら pages を app にする作業をする\r\nこれを繰り返します。  \r\n`getStaticPaths`は後でやります。  \r\n\r\n### ルーティング\r\n`App Router`は、フォルダを作っただけではパスとしては認識されません。  \r\nフォルダの中に`page.tsx`があるかでパスとしては認識するかどうかが決まります。\r\n\r\nなので`pages`でこうだった構成だと\r\n- pages\r\n    - pages\r\n        - [page].tsx\r\n    - posts\r\n        - page\r\n            - [page].tsx\r\n        - tag\r\n            - [tag].tsx\r\n            - all_tags.tsx\r\n        - [blog].tsx\r\n\r\n`app`だとこうなるはず\r\n\r\n- app\r\n    - pages\r\n        - [page]\r\n            - page.tsx\r\n    - posts\r\n        - [blog]\r\n            - page.tsx\r\n        - page\r\n            - [page]\r\n                - page.tsx\r\n        - tag\r\n            - [tag]\r\n                - page.tsx\r\n            - all_tags\r\n                - page.tsx\r\n\r\nパスの名前のフォルダを作る必要がある感じですね。  \r\n一見ややこしいように見えますが、`page.tsx`を置いてないフォルダはさっきの通りパスとしては認識されないので、  \r\n同じ場所にテストコード、コンポーネントを置くなどができるようになりました。\r\n\r\n- app\r\n    - posts\r\n        - posts-components // 記事表示で使うコンポーネント置き場\r\n            - Title.tsx\r\n        - tests // テストコード\r\n            - test.tsx\r\n        - [blog]\r\n            - page.tsx // 記事表示\r\n\r\nわかりやすいような・・・ややこしいような・・・\r\n\r\nあと動的ルーティングはフォルダ名を`[動的ルーティング名]`にすればいいです。（`[id]`とか`[page]`とか）  \r\n`page.tsx`からは以下のように引数で動的ルーティングのパス名が取れるようになります。  \r\n\r\n```tsx\r\n// slug は [slug] だから。\r\n// フォルダ名が [id] なら { id: string } が正解\r\nexport default function Page({ params }: { params: { slug: string } }) {\r\n  return <div>My Post: {params.slug}</div>\r\n}\r\n```\r\n\r\nhttps://nextjs.org/docs/app/building-your-application/routing/dynamic-routes\r\n\r\nどうでしょう、`CSS`が当たってなかったりしますが、、、、とりあえずは出るようになりましたか？\r\n\r\n![Imgur](https://imgur.com/hC0jLrc.png)\r\n\r\nもし`Conflicting app and page file found`がでてしまったら、一度開発サーバーを起動し直すといいかもしれないです。  \r\n`npm run dev`\r\n\r\n## 動的ルーティング を返してあげる\r\n動的ルーティングで生成されるパス一覧を返してあげます。  \r\n`getStaticPaths`は`AppRouter`では`generateStaticParams`になります。  \r\n`API`はそんなに変わってないはずです。  \r\n\r\n`pages/posts/[blog].tsx`  \r\n```ts\r\n/**\r\n * ここで生成するページを列挙して返す。（実際にはパスの一部）\r\n * \r\n * /posts/<ここ> ←ここの部分の名前を渡して生成すべきページを全部列挙して返してる\r\n * \r\n * これも上記同様クライアント側では呼ばれない。\r\n */\r\nexport const getStaticPaths: GetStaticPaths = async () => {\r\n    const fileNameList = (await ContentFolderManager.getBlogNameList())\r\n        // この場合はキーが blog になるけどこれはファイル名によって変わる（[page].tsxなら page がキーになる）\r\n        .map(name => ({ params: { blog: name } }))\r\n    return {\r\n        paths: fileNameList,\r\n        fallback: false\r\n    }\r\n}\r\n```\r\n\r\n`app/posts/[blog]/page.tsx`  \r\n```ts\r\n/**\r\n * ここで生成するページを列挙して返す。（実際にはパスの一部）\r\n * \r\n * /posts/<ここ> ←ここの部分の名前を渡して生成すべきページを全部列挙して返してる\r\n * \r\n * これも上記同様クライアント側では呼ばれない。\r\n */\r\nexport async function generateStaticParams() {\r\n    const fileNameList = await ContentFolderManager.getBlogNameList()\r\n    // この場合はキーが blog になるけどこれはファイル名によって変わる（[page].tsxなら page がキーになる）\r\n    return fileNameList.map((name) => ({ blog: name }))\r\n}\r\n```\r\n\r\n## 404.tsx を not-found.tsx へ移行する\r\n`pages/404.tsx`も`app/not-found.tsx`へ移動します。  \r\nこれで`pages`フォルダーは削除できるようになるはず・・・！\r\n\r\n## CSS をなおす\r\n`layout.tsx`で`css`を読み込むことが出来ます\r\n\r\n```tsx\r\nimport { Metadata } from \"next\"\r\nimport ClientLayout from \"./ClientLayout\"\r\n// コードブロックのCSS\r\nimport \"highlight.js/styles/vs2015.css\"\r\n// グローバルCSS\r\nimport \"../styles/css/global.css\"\r\n```\r\n\r\n## GoogleAnalytics をなおす\r\nこれは`GA4`で`SPA`でも使える設定（なんだっけ？、パスの変化を検知するみたいなやつ）をしていない場合に必要です。  \r\n`useRouter`で遷移時にイベントを取得し、そのタイミングで`GAの遷移イベント`を飛ばしていたやつは修正が必要です。  \r\n\r\nこーゆーやつ ↓↓↓  \r\n```tsx\r\nuseEffect(() => {\r\n    const handleRouteChange = (url: string) => {\r\n        pageview(url)\r\n    }\r\n    router.events.on('routeChangeComplete', handleRouteChange)\r\n    return () => {\r\n        router.events.off('routeChangeComplete', handleRouteChange)\r\n    }\r\n}, [router.events])\r\n```\r\n\r\nで、`useRouter usePathname useSearchParams`の3つに分裂したそうなので置き換えます。  \r\nクライアントコンポーネントである必要があります。  \r\n\r\nhttps://nextjs.org/docs/app/api-reference/functions/use-router#router-events\r\n\r\n```tsx  \r\n/** Google Analytics 4 で利用するJavaScriptを差し込むやつ。本番（意味深）のみ実行 */\r\nexport default function GoogleAnalytics() {\r\n    const pathname = usePathname()\r\n    const searchParams = useSearchParams()\r\n\r\n    // Google Analytics へnext/routerのページ遷移の状態を通知する\r\n    useEffect(() => {\r\n        const url = `${pathname}${searchParams}`\r\n        pageview(url)\r\n    }, [pathname, searchParams])\r\n\r\n    // 本番ビルド時のみ GoogleAnalytics をセットアップする\r\n    return (\r\n        <>\r\n            {!isDevelopment && <>\r\n                <Script\r\n                    strategy=\"afterInteractive\"\r\n                    src={`https://www.googletagmanager.com/gtag/js?id=${UA_TRACKING_ID}`}\r\n                />\r\n                <Script\r\n                    strategy=\"afterInteractive\"\r\n                    dangerouslySetInnerHTML={{\r\n                        __html: `\r\n                        window.dataLayer = window.dataLayer || [];\r\n                        function gtag(){dataLayer.push(arguments);}\r\n                        gtag('js', new Date());\r\n                        gtag('config', '${UA_TRACKING_ID}');\r\n                        gtag('config', '${GA_TRACKING_ID}');\r\n                    `}}\r\n                />\r\n            </>}\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n`app/layout.tsx`で呼び出せば良いのですが、`<suspense>`でくくらないと怒られます。  \r\n\r\n```tsx\r\n/** 共通レイアウト部分 */\r\nexport default function RootLayout({ children, }: { children: React.ReactNode }) {\r\n    // クライアントコンポーネントとして描画する必要があるため\r\n    return (\r\n        <html>\r\n            <body className={koruriFont.variable}>\r\n                {/* 共通レイアウト。ナビゲーションドロワーとか */}\r\n                <ClientLayout children={children} />\r\n                {/* GoogleAnalytics */}\r\n                <Suspense fallback={null}>\r\n                    <GoogleAnalytics />\r\n                </Suspense>\r\n            </body>\r\n        </html>\r\n    )\r\n}\r\n```\r\n\r\nこれで一通り出来たかな？？？\r\n\r\n## 静的サイト書き出しを有効にして、本番ビルドしてみる\r\nhttps://nextjs.org/docs/pages/building-your-application/deploying/static-exports\r\n\r\n`next.config.js`に追記する必要があります。\r\n\r\n```js\r\n// https://github.com/vercel/next.js/blob/canary/examples/progressive-web-app/next.config.js\r\nconst withPWA = require('next-pwa')({\r\n    // https://github.com/GoogleChrome/workbox/issues/1790#issuecomment-729698643\r\n    disable: process.env.NODE_ENV === 'development',\r\n    dest: 'public',\r\n})\r\n\r\nmodule.exports = withPWA({\r\n    output: 'export', // これ\r\n    trailingSlash: true,\r\n    experimental: {\r\n        scrollRestoration: true,\r\n    }\r\n})\r\n```\r\n\r\nまた、`output: 'export'`が追加された影響で、`npx next export`が無くなったため、`package.json`に書いたビルドコマンドも修正する必要があります。（`npx next build`だけでよくなりました）  \r\n\r\n```diff\r\n- \"deploy\": \"npm run build && npm run export && npm run postbuild\"\r\n+ \"deploy\": \"npm run build && npm run postbuild\"\r\n```\r\n\r\nこれでビルドしてみる。多分動くはず。  \r\n流石に全部やると時間かかりすぎるので記事を2個ぐらいにした。\r\n\r\n### 型チェックが厳しくなった？\r\n型のチェックが厳しくなっている？\r\n\r\n```ts\r\n./components/MakingAppCard.tsx:120:20\r\nType error: Object is possibly 'undefined'.\r\n\r\n  118 |     const changeAppListPlatform = (platformName: string) => {\r\n  119 |         // あれTypeScriptくんこれ通すんか？\r\n> 120 |         setAppList(makingAppList.find(platformObj => platformObj.platfromName === platformName).appList)\r\n      |                    ^\r\n  121 |     }\r\n  122 | \r\n  123 |     /**\r\n```\r\n\r\n```ts\r\nconst makingApp = makingAppList.find(platformObj => platformObj.platfromName === platformName)\r\nif (makingApp) {\r\n    setAppList(makingApp.appList)\r\n}\r\n```\r\n\r\n`TypeScript`、エラーがわかりにくい気がするんですけど、私だけなんですかね・・・\r\n\r\n```ts\r\n./src/MarkdownParser.ts:97:15\r\nType error: Type '{ label: string | null; level: number; hashTag: string; }[]' is not assignable to type 'TocData[]'.\r\n  Type '{ label: string | null; level: number; hashTag: string; }' is not assignable to type 'TocData'.\r\n    Types of property 'label' are incompatible.\r\n      Type 'string | null' is not assignable to type 'string'.\r\n        Type 'null' is not assignable to type 'string'.\r\n```\r\n\r\n`Kotlin`の`filterNotNull`に当たる処理が思いつかないので調べたんですが、`flatMap`を使う方法だと型を予測して解決してくれていい感じ。  \r\nhttps://stackoverflow.com/questions/43118692/typescript-filter-out-nulls-from-an-array\r\n\r\n```ts\r\n/**\r\n * HTML を解析して 目次データを作成する。結構時間がかかる。\r\n * \r\n * @param html HTML\r\n * @returns 目次データの配列\r\n */\r\nstatic parseToc(html: string): TocData[] {\r\n    // HTML パーサー ライブラリを利用して h1 , h2 ... を取得する\r\n    // この関数は ブラウザ ではなく Node.js から呼び出されるため、document は使えない。\r\n    const window = (new JSDOM(html)).window\r\n    const document = window.document\r\n    const tocElementList = document.querySelectorAll('h1, h2, h3, h4, h5, h6')\r\n    // 目次データに変換して返す\r\n    const tocDataList: TocData[] = Array.from(tocElementList)\r\n        .map(element => {\r\n            if (element.textContent) {\r\n                return {\r\n                    label: element.textContent,\r\n                    level: Number(element.tagName.charAt(1)), // h1 の 1 だけ取り出し数値型へ\r\n                    hashTag: `#${element.getAttribute('id')}` // id属性 を取り出し、先頭に#をつける\r\n                }\r\n            } else {\r\n                return null\r\n            }\r\n        })\r\n        // null を配列から消す技です\r\n        .flatMap(tocDataOrNull => tocDataOrNull ? [tocDataOrNull] : [])\r\n    window.close()\r\n    return tocDataList\r\n}\r\n```\r\n\r\n### 静的書き出し結果を見てみる\r\n`npx next start`は使えなくなりました。  \r\n\r\n```plaintext\r\nError: \"next start\" does not work with \"output: export\" configuration. Use \"npx serve@latest out\" instead.\r\n```\r\n\r\nかわりに、以下のコマンドで起動できます。  \r\n\r\n```shell\r\nnpx serve@latest out\r\n```\r\n\r\nうーんなんか全然動いて無くないか？  \r\n~~`/posts/page/1/`を押してもなんかパスが中途半端なんですけど？~~ → `generateStaticParams`間違ってました。ごめんなさい\r\n\r\n![Imgur](https://imgur.com/Kfoniwd.png)\r\n\r\n# ついでに直したいところ\r\n他に直したい部分が何個かあるんですよね...\r\n\r\n- ドメインをハードコートするのをやめて、環境変数にする\r\n- ドキュメント通りのサイトマップ生成を使う\r\n- app/README.md 更新する\r\n- Babel をやめたい\r\n- ServiceWorker やめたい\r\n- next/font を利用したい\r\n- トップページの画像変えたい\r\n- サイトマップ生成も変えたい\r\n- 404 の画像変えたい\r\n- OSSライセンス画面更新\r\n- ビルドコマンドの修正（ライブラリ無しでサイトマップ生成したので`postbuild`なしでよくなった。`npx next build`だけでいいはず）\r\n\r\n## サイトマップ生成\r\n`App Router`から、サイトマップ生成がライブラリ無しで作れるようになったっぽいので、移行します。  \r\nhttps://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap\r\n\r\n`app/sitemap.ts`  \r\n```ts\r\nimport { MetadataRoute } from \"next\";\r\nimport UrlTool from \"../src/UrlTool\";\r\nimport ContentFolderManager from \"../src/ContentFolderManager\";\r\n\r\n/**\r\n * サイトマップを生成する。Next.js 単体で作れるようになった。\r\n * Trailing Slash が有効なので最後にスラッシュ入れました。\r\n */\r\nexport default async function sitemap(): Promise<MetadataRoute.Sitemap> {\r\n    const currentTime = new Date()\r\n\r\n    // 静的ページ\r\n    const staticPathList: MetadataRoute.Sitemap = [\r\n        {\r\n            url: `${UrlTool.BASE_URL}/`,\r\n            lastModified: currentTime\r\n        }\r\n    ]\r\n\r\n    // ブログ記事\r\n    const blogPathList = (await ContentFolderManager.getBlogNameList())\r\n        .map(name => ({\r\n            url: `${UrlTool.BASE_URL}/posts/${name}/`,\r\n            lastModified: currentTime\r\n        }))\r\n\r\n    // 固定ページ\r\n    const pagePathList = (await ContentFolderManager.getPageNameList())\r\n        .map(name => ({\r\n            url: `${UrlTool.BASE_URL}/pages/${name}/`,\r\n            lastModified: currentTime\r\n        }))\r\n\r\n    return [...staticPathList, ...blogPathList, ...pagePathList]\r\n}\r\n```\r\n\r\n`npm run build`したあと`out/sitemap.xml`が出来て、こんなのが出てきます。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n<url>\r\n<loc>https://takusan.negitoro.dev/</loc>\r\n<lastmod>2023-06-18T17:15:15.809Z</lastmod>\r\n</url>\r\n<url>\r\n<loc>https://takusan.negitoro.dev/posts/next_js_13_app_router_migration/</loc>\r\n<lastmod>2023-06-18T17:15:15.809Z</lastmod>\r\n</url>\r\n<url>\r\n<loc>https://takusan.negitoro.dev/posts/windows_winui3_installer_and_virtual_desktop/</loc>\r\n<lastmod>2023-06-18T17:15:15.809Z</lastmod>\r\n</url>\r\n<url>\r\n<loc>https://takusan.negitoro.dev/pages/about/</loc>\r\n<lastmod>2023-06-18T17:15:15.809Z</lastmod>\r\n</url>\r\n</urlset>\r\n```\r\n\r\n## Babel をやめて SWC にする\r\nhttps://nextjs.org/docs/architecture/nextjs-compiler\r\n\r\nそもそも何だこれはという話ですが、なんか`SWC`を使ったほうが高速に動くらしい。  \r\nで、`SWC`にしたいところなんですが、、`Babel`で`svg`をコンポーネント化するプラグインを使っているので、この代わりをどうにかする必要があります。  \r\n\r\n困ってる人私以外にもいた  \r\nhttps://github.com/vercel/next.js/discussions/33161\r\n\r\n`SVGR`を使っている人が多そうかな、じゃあこれで  \r\nhttps://react-svgr.com/docs/next/\r\n\r\n`.babelrc`を消して、プラグインも消しちゃいます。  \r\n\r\n次に入れて  \r\n`npm install --save-dev @svgr/webpack`\r\n\r\n`next.config.js`に書き足します。  \r\n`webpack`の箇所ですね。  \r\n\r\n```js\r\noutput: 'export',\r\ntrailingSlash: true,\r\nwebpack(config) {\r\n    // SVG をコンポーネントにできる\r\n    config.module.rules.push({\r\n        test: /\\.svg$/,\r\n        use: ['@svgr/webpack'],\r\n    })\r\n    return config\r\n},\r\nexperimental: {\r\n    scrollRestoration: true,\r\n}\r\n```\r\n\r\nあとは`svg`のパスをインポートして、JSX書けば良いはず！すごい！  \r\n\r\n```tsx\r\n// https://react-svgr.com/docs/next/ 参照\r\nimport NotFoundIcon from \"../public/not_found.svg\"\r\n\r\nexport default function Component() {\r\n    return (\r\n        <>\r\n            <NotFoundIcon\r\n                className={'theme_color'}\r\n                height={250}\r\n                width={250}\r\n            />\r\n```\r\n\r\n## next/font を使う\r\nこっちの方がいいらしい。ので  \r\n前は`@next/font`を入れる必要があったみたいですが、`Next.js`に組み込まれたみたいなので、入れなくても使えるらしい。  \r\n`app/layout.tsx`で読み込めば良さそう。  \r\n\r\n用意したフォントを読み込みたいので、`local`の方を使うぽい  \r\nhttps://nextjs.org/docs/app/building-your-application/optimizing/fonts#local-fonts\r\n\r\n`variable`を指定すると、`.css`などから参照できるようになります。  \r\n`<body className={koruriFont.variable}>`を忘れないようにしてください。（一敗）\r\n\r\n`app/layout.tsx`  \r\n```tsx\r\nimport localFont from \"next/font/local\"\r\n\r\n/** フォントを読み込む */\r\nconst koruriFont = localFont({\r\n    // CSS 変数として使う\r\n    variable: '--koruri-font',\r\n    src: [\r\n        { path: '../styles/css/fonts/Koruri-Regular-sub.eot' },\r\n        { path: '../styles/css/fonts/Koruri-Regular-sub.ttf' },\r\n        { path: '../styles/css/fonts/Koruri-Regular-sub.woff' },\r\n    ]\r\n})\r\n\r\n/** 共通レイアウト部分 */\r\nexport default function RootLayout({ children, }: { children: React.ReactNode }) {\r\n    // クライアントコンポーネントとして描画する必要があるため\r\n    return (\r\n        <html>\r\n            <body className={koruriFont.variable}>\r\n                {/* 共通レイアウト。ナビゲーションドロワーとか */}\r\n                <ClientLayout children={children} />\r\n                {/* GoogleAnalytics */}\r\n                <Suspense fallback={null}>\r\n                    <GoogleAnalytics />\r\n                </Suspense>\r\n            </body>\r\n        </html>\r\n    )\r\n}\r\n```\r\n\r\n`CSS`からは`var()`で参照できます。  \r\n`global.css`  \r\n```css\r\n/* コードブロック */\r\ncode {\r\n    overflow-x: scroll;\r\n    font-family: var(--koruri-font);\r\n    background-color: rgba(0, 0, 0, 0.05);\r\n}\r\n```\r\n\r\n`Material-UI`の`createTheme`も多分これで参照できているはず。  \r\n```ts\r\ncreateTheme({\r\n    typography: {\r\n        fontFamily: [\r\n            'var(--koruri-font)'\r\n        ].join(','),\r\n    }\r\n})\r\n```\r\n\r\nはい  \r\n![Imgur](https://imgur.com/fiMT1nU.png)\r\n\r\n## next/head が無くなってしまったので、クライアントコンポーネントで head が操作できない？\r\n唯一困ったかもしれない。  \r\n`next/head`を使って、テーマの色に合わせて`Android`のステータスバーの色も同じ色に合わせるようにしていたのですが、`AppRouter`で使えなくなってしまった。  \r\nとりあえず`DOM`を`JavaScript`で無理やり変えてるんですけど、、、これでいいの？  \r\n\r\n```ts\r\n\"use client\"\r\n\r\nimport { useEffect, useRef } from \"react\"\r\n\r\n/**\r\n * Androidのステータスバーに色を設定する\r\n * AppRouter だと next/head が使えない。多分現状クライアントコンポーネントで head の中身を変える方法が Next.js にはなさそう？\r\n * 仕方ないので、DOM を触る。\r\n * \r\n * @param colorCode カラーコード\r\n */\r\nexport default function useAndroidStatusBarColor(colorCode: string) {\r\n    const statusBarColorMeta = useRef<HTMLMetaElement>()\r\n\r\n    // 追加する\r\n    useEffect(() => {\r\n        statusBarColorMeta.current = document.createElement('meta')\r\n        statusBarColorMeta.current.setAttribute('name', 'theme-color')\r\n        document.head.append(statusBarColorMeta.current)\r\n    }, [])\r\n\r\n    // 色が変化したら更新する\r\n    useEffect(() => {\r\n        statusBarColorMeta.current?.setAttribute('content', colorCode)\r\n    }, [colorCode])\r\n}\r\n```\r\n\r\n# 動きました！\r\n`pages`→`app`差分はこんな感じになります。  \r\n\r\nhttps://github.com/takusan23/ziyuutyou-next/pull/1\r\n\r\n実際に適当に公開しても問題なさそうだったので、人がいなさそうな時にあげようかな。いや別にいつでも良いか・・？  \r\n\r\n## 2023/07/11 午前2~3時 くらいに入れました\r\n`Next.js` `AppRouter` 対応を入れます。  \r\n見てる人無さそうだったので（そもそもあんまり居ない；；\r\n\r\n# おわりに\r\nめちゃ関係ないけど`Tailwind CSS`ﾁｮｯﾄだけ触ってみましたが、これで良くない？  \r\nサーバーコンポーネントとしても`Tailwind CSS`は使えるみたいなので`Material-UI`をやめてもいいかもしれない  \r\n\r\nあと公式ドキュメント、Chromeの翻訳してるとルーティング失敗しない？  \r\nあと`VSCode`は`Altキー`を押しながらスクロールすると高速でスクロールできます。  \r\n\r\n# おわりに2\r\nストレージがたりない！！！\r\n\r\n`[Error: ENOSPC: no space left on device, write]`"},{"title":"Next.js 13 にした (しただけ)","link":"/posts/next_js_13_migration/","markdown":"アップデートするだけして`pagesディレクトリ`のまま使う。\r\n\r\n# 本題\r\n`Next.js`を`13`へアップデートします\r\n\r\n```\r\nnpm i next@latest react@latest react-dom@latest\r\n```\r\n\r\nアップデートしました\r\n\r\n```\r\n+ react@18.2.0\r\n+ react-dom@18.2.0\r\n+ next@13.0.4\r\nadded 2 packages from 1 contributor, updated 9 packages and audited 679 packages in 29.044s\r\n```\r\n\r\nなんか脆弱性があると言われたので、`npm audit`でライブラリを特定したのち、\r\n\r\n```\r\nnpm i next-pwa@latest\r\n```\r\n\r\nを実行しました。\r\n\r\n```\r\n+ next-pwa@5.6.0\r\nadded 1 package from 1 contributor, removed 2 packages, updated 124 packages and audited 678 packages in 47.296s\r\n```\r\n\r\nはい！動かなくなりました！\r\n\r\n![Imgur](https://imgur.com/j6iRaTB.png)\r\n\r\n# ついでに Material UI のアップデート\r\n\r\n```\r\nnpm install @mui/material @emotion/react @emotion/styled\r\n```\r\n\r\nアップデートできました\r\n\r\n```\r\n+ @mui/material@5.10.14\r\n+ @emotion/styled@11.10.5\r\n+ @emotion/react@11.10.5\r\nadded 23 packages from 8 contributors, removed 4 packages, updated 36 packages and audited 697 packages in 34.223s\r\n```\r\n\r\nしかし動かず...ぐぬぬ\r\n\r\n# 原因は next/link の子要素を aタグ でくくってたから\r\nどうやら`Next.js 13`から子要素を`a`にする必要がなくなった模様。なので`MUI`の`component=\"a\"`を消せばいいらしい。\r\n\r\n```tsx\r\n/** ナビゲーション一覧コンポーネント */\r\nconst NavigationLink = () => {\r\n    return (\r\n        <Box>\r\n            <List>\r\n                {\r\n                    // mapでElementを返す\r\n                    linkList.map(linkData => (\r\n                        <Link href={linkData.link} passHref key={linkData.link}>\r\n                            <ListItemButton component=\"a\">\r\n                                <ListItemIcon>{linkData.icon}</ListItemIcon>\r\n                                <ListItemText primary={linkData.title} />\r\n                            </ListItemButton>\r\n                        </Link>\r\n                    ))\r\n                }\r\n            </List>\r\n        </Box>\r\n    )\r\n}\r\n```\r\n\r\n消したらレイアウトがダサくなったので、`aタグ`の下の線と色を消すような`CSS`をセットします。`CSS`ガチでどこにかけば反映されるのかわからん；；\r\n\r\n```tsx\r\n/** ナビゲーション一覧コンポーネント */\r\nconst NavigationLink = () => {\r\n    return (\r\n        <Box>\r\n            <List>\r\n                {\r\n                    // mapでElementを返す\r\n                    linkList.map(linkData => (\r\n                        <Link\r\n                            style={{\r\n                                textDecoration: 'none',\r\n                                color: 'inherit'\r\n                            }}\r\n                            href={linkData.link}\r\n                            key={linkData.link}\r\n                        >\r\n                            <ListItemButton>\r\n                                <ListItemIcon>{linkData.icon}</ListItemIcon>\r\n                                <ListItemText primary={linkData.title} />\r\n                            </ListItemButton>\r\n                        </Link>\r\n                    ))\r\n                }\r\n            </List>\r\n        </Box>\r\n    )\r\n}\r\n```\r\n\r\n以下のように`<a>`でくくってた部分も以下のように置き換えられます。\r\n\r\n```tsx\r\n<Link passHref href={props.blogItem.link}>\r\n    <a style={{ color: theme.palette.primary.main, fontSize: 25 }} >\r\n        {props.blogItem.title}\r\n    </a>\r\n</Link>\r\n```\r\n\r\n↓\r\n\r\n```tsx\r\n<Link\r\n    style={{\r\n        color: theme.palette.primary.main,\r\n        fontSize: 25\r\n    }}\r\n    href={props.blogItem.link}\r\n>\r\n    {props.blogItem.title}\r\n</Link>\r\n```\r\n\r\n`<Chip>`の場合は`clickable`属性をつけるとマウスポインタもいい感じに出来ます\r\n\r\n```tsx\r\n<Link\r\n    style={{\r\n        textDecoration: 'none',\r\n        color: 'inherit'\r\n    }}\r\n    href={`/posts/tag/${data.name}/`}\r\n    key={data.name}\r\n>\r\n    <Chip\r\n        sx={{\r\n            marginRight: 1,\r\n            marginTop: 1\r\n        }}\r\n        clickable\r\n        color=\"primary\"\r\n        icon={<LocalOfferOutlined />}\r\n        label={`${data.name} - ${data.count} 件`}\r\n    />\r\n</Link>\r\n```\r\n\r\nおわり。  \r\n`appディレクトリ`はなんか難しそう...だし`Netlify`で動くか分からんので様子見します ( ˘ω˘)ｽﾔｧ\r\n\r\n# おまけ\r\n`Netlify`の`Build image`が古くてコケてました。  \r\n`Ubuntu`のバージョンアップ？どうやら警告が来ていたそうですが見落としてました。すいません\r\n\r\n![Imgur](https://imgur.com/k5yYXC4.png)\r\n\r\n## テストする\r\n多分動くと思うのですが、一応ちゃんと見れるか確認したいです。  \r\n自動公開をオフにすると動作確認できるそうです。\r\n\r\n`Lock to stop auto publishing` を押します。\r\n\r\n![Imgur](https://imgur.com/fy4lEKx.png)\r\n\r\nそのあと`Site setting`へ進み`Build & Deploy`の`Build image`を新しいのにします。\r\n\r\n![Imgur](https://imgur.com/WdiYnJg.png)\r\n\r\n出来たら`Deploys`に戻り、手動デプロイをします。  \r\n\r\n![Imgur](https://imgur.com/206PDDO.png)\r\n\r\nロックされているのでまだ古いままの成果物がホスティングされています。\r\n\r\n![Imgur](https://imgur.com/VDRodqk.png)\r\n\r\nちなみに今回は特に何事もなくデプロイされていました。以上です。"},{"title":"Next.jsへGoogleアナリティクスのGA4とUAを共存させる","link":"/posts/next_js_google_analytics_ua_ga4/","markdown":"\r\nどうもこんばんわ。  \r\n\r\nキスから始まるギャルの恋 〜くるみのウワサとホントのキモチ〜 攻略しました。\r\n\r\nいいね！次回作も予約した\r\n\r\n![Imgur](https://imgur.com/kBGvFeJ.png)\r\n\r\n丁寧に書かれてて？良かったと思います\r\n\r\n![Imgur](https://imgur.com/gZpbJXu.png)\r\n\r\n# 本題\r\n\r\nGoogleアナリティクスからGA4を使ってみませんかって定期的にメールでお知らせしてくるので対応してみた。  \r\nNext.jsで作り直した記念に\r\n\r\n# 環境\r\n\r\n| なまえ  | あたい                                                                       |\r\n|---------|------------------------------------------------------------------------------|\r\n| Windows | 10 Pro                                                                       |\r\n| Next.js | 記述時時点最新版                                                             |\r\n| React   | 17                                                                           |\r\n| 言語    | TypeScript。JavaScriptの場合はコピペ出来ないのでにらめっこして書き換えて；； |\r\n\r\n# 参考\r\n\r\nthx!!!!!\r\n\r\nhttps://github.com/vercel/next.js/tree/main/examples/with-google-analytics\r\n\r\nhttps://panda-program.com/posts/nextjs-google-analytics\r\n\r\n## GA4 と UA はぜんぜん違う？\r\nなんか後継みたいな雰囲気（なぜか変換できない（できてる））出してますが、UIからして結構違うシステムらしい？  \r\nなんなら`ユニバーサルアナリティクス (UA)`時代に集計したデータは`Google アナリティクス 4 (GA4)`には引き継げないみたいですよ？\r\n\r\nデータがGA4に引き継げないのはしんどいので、とりあえずは`ユニバーサルアナリティクス`と`Google アナリティクス 4`の同時利用で行きます（同じ結果が集計されるはず）。\r\n\r\n(ちょっと時間が経っちゃったからうろ覚え)\r\n\r\n## 単語集\r\n\r\n| きー                       | ばりゅー                                                   |\r\n|----------------------------|------------------------------------------------------------|\r\n| ユニバーサルアナリティクス | 略してUA。設定を開いた際に`GA4 設定アシスタント`があればUA |\r\n| Google アナリティクス 4    | 略してGA4。リアルタイムのページに地図が表示されていればGA4 |\r\n| 測定 ID                    | GA4で使うID。 **G-** から始まる                            |\r\n| トラッキングコード         | UAで使うID。 **UA-** から始まる                            |\r\n\r\n# 既存のユニバーサルアナリティクスでGA4を有効にする\r\nブラウザでUAの方の設定画面を開いて、`Google アナリティクス 4 プロパティの設定アシスタント`を選んで、始めます\r\n\r\n![Imgur](https://imgur.com/FPOrU2F.png)\r\n\r\nこんな画面が出るけど、今回は UA → GA4 へイベントの転送は行わずに、それぞれ対応するのでチェックマークはそのままにして、プロパティを作成をおします。  \r\n(自分でHTMLを書き換えることが出来ない場合のための処置だと思う)\r\n\r\n![Imgur](https://imgur.com/pv04NvW.png)\r\n\r\n作成できるとGA4の管理ページへ移動できるボタンが現れるのでそのままおします。\r\n\r\n![Imgur](https://imgur.com/FB4Gd2Y.png)\r\n\r\n移動したら、`タグの設定`を押して、一つだけデータストリームがあると思うのでそれを選択します。\r\n\r\n![Imgur](https://imgur.com/hpg4USI.png)\r\n\r\nそしたら、表示されている`測定 ID`を控えます。`G-`から始まるやつですね。\r\n\r\n![Imgur](https://imgur.com/pTpOTPf.png)\r\n\r\n## Next.js(のnext/router)でも動くように対応する\r\n`測定 ID`を控えた画面にある歯車マーク⚙を押して、拡張計測機能の設定をします。  \r\nここの`ページビュー数`の`詳細設定`を押して、**ブラウザの履歴イベントに基づくページの変更**のチェックマークを外して、保存を押します。\r\n\r\n![Imgur](https://imgur.com/SciZSld.png)\r\n\r\n### なぜ？\r\n\r\n`Next.js 等のJSフレームワーク`では画面を動的に書き換えて（ブラウザのロードを挟まない）画面遷移が行われるため、Googleアナリティクスではページ遷移イベントを捕捉出来ません。  \r\nので、自分でページ遷移イベントを送信する必要があるのですが、なんか**GA4**にロードを挟まない遷移を捕まえることが出来るようになったらしく、このままでは二重で計測されてしまう。  \r\nそこで**GA4**の計測の設定を変えます。\r\n\r\nもしかしたら、上記のチェックマークをONにしておくと、ページの変更イベントをわざわざ送信する必要もなくなるかもしれないけど、UAと合わせたいので今回はOFFで行きます。\r\n\r\n## (analytics.js から gtag.js へ移行する)\r\nもし`gtag.js`で書いていた場合はここは飛ばしていいと思います。  \r\n\r\nUAの方の設定画面を開いて、**トラッキング情報 > トラッキングコード**へ進み、**トラッキング ID**をコピーします。`UA-`から始まるやつですね。\r\n\r\n## Next.js での作業\r\n`_app.tsx`(jsxかもしれん)を開きます。  \r\n作っていない場合は他調べて作って下さい。\r\n\r\nそしたら、以下を参考に書いて下さい（まるなげ）  \r\nanalytics.js時代のコードは消しちゃえ～。  \r\n定数`UA_TRACKING_ID`の中には各自UAのトラッキングIDを入れて下さい。\r\n\r\n```tsx\r\n\r\n// 各自ここに UA トラッキング ID\r\nconst UA_TRACKING_ID = `UA-`\r\n\r\nconst App = ({ Component, pageProps }) => {\r\n    return (\r\n        <>            \r\n            {/* Google アナリティクス GA4 / UA */}\r\n            <Head>\r\n                <script async src={`https://www.googletagmanager.com/gtag/js?id=${UA_TRACKING_ID}`}></script>\r\n                <script dangerouslySetInnerHTML={{\r\n                    __html: `\r\n                        window.dataLayer = window.dataLayer || [];\r\n                        function gtag(){dataLayer.push(arguments);}\r\n                        gtag('js', new Date());\r\n                        gtag('config', '${UA_TRACKING_ID}');\r\n                    `}}\r\n                />\r\n            </Head>\r\n\r\n            <Component {...pageProps} />\r\n        </>\r\n    )\r\n}\r\nexport default App\r\n```\r\n\r\n# gtag.js に GA4 も計測するように書き足す\r\n`gtag('config', '${UA_TRACKING_ID}');`と同じ様にGA4の測定 IDを登録します。  \r\n`gtag.js`を読み込んでる`<script>`タグはそのままUAのを使えるみたいです。\r\n\r\n以下例：\r\n\r\n```tsx\r\n// 各自ここに UA トラッキング ID\r\nconst UA_TRACKING_ID = `UA-`\r\n// 各自ここに GA4 測定 ID\r\nconst GA_TRACKING_ID = `G-`\r\n\r\nconst App = ({ Component, pageProps }) => {\r\n    return (\r\n        <>            \r\n            {/* Google アナリティクス GA4 / UA */}\r\n            <Head>\r\n                <script async src={`https://www.googletagmanager.com/gtag/js?id=${UA_TRACKING_ID}`}></script>\r\n                <script dangerouslySetInnerHTML={{\r\n                    __html: `\r\n                        window.dataLayer = window.dataLayer || [];\r\n                        function gtag(){dataLayer.push(arguments);}\r\n                        gtag('js', new Date());\r\n                        gtag('config', '${UA_TRACKING_ID}');\r\n                        gtag('config', '${GA_TRACKING_ID}');\r\n                    `}}\r\n                />\r\n            </Head>\r\n\r\n            <Component {...pageProps} />\r\n        </>\r\n    )\r\n}\r\nexport default App\r\n```\r\n\r\n## Next.jsの next/script 使えないの？\r\nこれ使うと`<body>`内に`<script>`埋め込んでるっぽいんだけどどうなんだろう。Googleアナリティクスは`<head>`内に書いてって言われてるので...\r\n\r\n## UAの gtag.js 転用して使えんのかよwww\r\n\r\n既存の gtag.js を読み込んでいる場合は**GA4の測定IDを登録する一行**をそのまま書き足せばOKらしい。やるやん\r\n\r\n<https://support.google.com/analytics/answer/9310895?hl=ja&utm_id=ad#which_product&zippy=%2Cこの記事の内容>\r\n\r\n# next/router のページ遷移イベントを登録する\r\nこのままだと初回の読み込みは正しく送信されますが、ページを切り替えた際には対応できません。  \r\nので`next/router`の遷移イベントをGA4とUAへ飛ばします。\r\n\r\n以下例：  \r\nTSなのに`as any`してるから参考にするには良くないかも。  \r\nJavaScript派閥の方はTypeScriptの型注釈(とキャスト)を消して、どうぞ。\r\n\r\n```tsx\r\n// 各自ここに UA トラッキング ID\r\nconst UA_TRACKING_ID = `UA-`\r\n// 各自ここに GA4 測定 ID\r\nconst GA_TRACKING_ID = `G-`\r\n\r\n/**\r\n * ページ遷移のたびに呼ぶ\r\n * \r\n * @param {string} url うらる\r\n */\r\nconst pageview = (url: string) => {\r\n    // 多分 UA と GA4 両方それぞれ送信しないといけない\r\n    (window as any).gtag('config', UA_TRACKING_ID, {\r\n        page_path: url,\r\n    });\r\n    (window as any).gtag('config', GA_TRACKING_ID, {\r\n        page_path: url,\r\n    });\r\n}\r\n\r\nconst App = ({ Component, pageProps }) => {\r\n\r\n    // Google アナリティクスへページ遷移を通知\r\n    const router = useRouter()\r\n    useEffect(() => {\r\n        const handleRouteChange = (url: string) => {\r\n            pageview(url)\r\n        }\r\n        router.events.on('routeChangeComplete', handleRouteChange)\r\n        return () => {\r\n            router.events.off('routeChangeComplete', handleRouteChange)\r\n        }\r\n    }, [router.events])\r\n\r\n    return (\r\n        <>            \r\n            {/* Google アナリティクス GA4 / UA */}\r\n            <Head>\r\n                <script async src={`https://www.googletagmanager.com/gtag/js?id=${UA_TRACKING_ID}`}></script>\r\n                <script dangerouslySetInnerHTML={{\r\n                    __html: `\r\n                        window.dataLayer = window.dataLayer || [];\r\n                        function gtag(){dataLayer.push(arguments);}\r\n                        gtag('js', new Date());\r\n                        gtag('config', '${UA_TRACKING_ID}');\r\n                        gtag('config', '${GA_TRACKING_ID}');\r\n                    `}}\r\n                />\r\n            </Head>\r\n\r\n            <Component {...pageProps} />\r\n        </>\r\n    )\r\n}\r\nexport default App\r\n```\r\n\r\nこれで多分対応は終了です。  \r\nGA4とUAそれぞれ開いて、ちゃんとリアルタイムに現れたら成功だと思います。\r\n\r\n## 番外編 GoogleAnalytics.tsx にまとめる編\r\n\r\n`_app.tsx`が長くなるとしんどいので分けておくと良いと思います。  \r\nついでに本番環境のみGoogle アナリティクスを動作させるようにしました。\r\n\r\n```tsx\r\n// GoogleAnalytics.tsx\r\n\r\n/** Google アナリティクス (UA) の 測定ID */\r\nexport const UA_TRACKING_ID = `UA-`\r\n\r\n/** Google アナリティクス (GA4) の 測定ID */\r\nexport const GA_TRACKING_ID = `G-`\r\n\r\n/** 開発モード。本番（意味深）だけアナリティクスを動作させるため */\r\nconst isDevelopment = process.env.NODE_ENV === 'development'\r\n\r\n/**\r\n * ページ遷移のたびに呼ぶ\r\n * \r\n * @param {string} url うらる\r\n */\r\nconst pageview = (url: string) => {\r\n    // 本番のみ実行\r\n    if (isDevelopment) {\r\n        return\r\n    }\r\n    (window as any).gtag('config', UA_TRACKING_ID, {\r\n        page_path: url,\r\n    });\r\n    (window as any).gtag('config', GA_TRACKING_ID, {\r\n        page_path: url,\r\n    });\r\n}\r\n\r\n/** Google Analytics へnext/routerのページ遷移の状態を通知する */\r\nexport const useGoogleAnalytics = () => {\r\n    // Google アナリティクスへページ遷移を通知\r\n    const router = useRouter()\r\n    useEffect(() => {\r\n        const handleRouteChange = (url: string) => {\r\n            pageview(url)\r\n        }\r\n        router.events.on('routeChangeComplete', handleRouteChange)\r\n        return () => {\r\n            router.events.off('routeChangeComplete', handleRouteChange)\r\n        }\r\n    }, [router.events])\r\n}\r\n\r\n/** Google Analytics 4 で利用するJavaScriptを差し込むやつ。本番（意味深）のみ実行 */\r\nexport const GoogleAnalyticsHead = () => {\r\n    return (\r\n        <>\r\n            {!isDevelopment && <Head>\r\n                <script async src={`https://www.googletagmanager.com/gtag/js?id=${UA_TRACKING_ID}`}></script>\r\n                <script dangerouslySetInnerHTML={{\r\n                    __html: `\r\n                        window.dataLayer = window.dataLayer || [];\r\n                        function gtag(){dataLayer.push(arguments);}\r\n                        gtag('js', new Date());\r\n                        gtag('config', '${UA_TRACKING_ID}');\r\n                        gtag('config', '${GA_TRACKING_ID}');\r\n                    `}}\r\n                />\r\n            </Head>}\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\nこれを`_app.tsx`で呼ぶようにすればおっけ\r\n\r\n```tsx\r\nimport { GoogleAnalyticsHead, useGoogleAnalytics } from '../src/GoogleAnalytics'\r\n\r\nconst App = ({ Component, pageProps }) => {\r\n\r\n    // GoogleAnalyticsへnext/routerのページ遷移を通知する。\r\n    useGoogleAnalytics()\r\n\r\n    return (\r\n        <>            \r\n            {/* Google アナリティクス GA4 / UA */}\r\n            <GoogleAnalyticsHead />\r\n\r\n            <Component {...pageProps} />\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\nもしパクった場合は本番環境のみで動くので、動いてるか確認したい場合は\r\n\r\n```\r\nnpm run build\r\nnpm run start\r\n```\r\n\r\nすれば本番環境のビルド成果物をホストした開発サーバーが立ち上がります。\r\n\r\n![Imgur](https://imgur.com/DwEizfq.png)"},{"title":"MaterialUIのアイコンを使うとビルド時間が遅くなるのを直す","link":"/posts/next_js_mui_material_icon_build_speed/","markdown":"\r\nどうもおはようございます。  \r\nこのサイトはNuxt.jsなんですけどね初見さん（記述時時点）\r\n\r\n# 本題\r\n`Next.js`に`Material UI`を入れたあと、`import`の書き方次第でビルド時間が長くなってしまう。\r\n\r\n## どういうこと\r\n\r\n```js\r\nimport { AndroidOutlined } from '@mui/icons-material'\r\n```\r\n\r\nよりも\r\n\r\n```js\r\nimport AndroidOutlined from '@mui/icons-material/AndroidOutlined'\r\n```\r\n\r\nの方がビルド時間が高速になり、サイズが小さくなる\r\n\r\n# 試してみる\r\n\r\n```tsx\r\n// index.tsx\r\n\r\nimport type { NextPage } from 'next'\r\nimport AndroidOutlined from '@mui/icons-material/AndroidOutlined'\r\n\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <AndroidOutlined />\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\n```tsx\r\n// index.tsx\r\n\r\nimport type { NextPage } from 'next'\r\nimport { AndroidOutlined } from '@mui/icons-material'\r\n\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <AndroidOutlined />\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\nどちらも同じアイコンを画面に表示するコードです\r\n\r\n\r\n# 検証結果\r\n\r\n## import { AndroidOutlined } from '@mui/icons-material'\r\n\r\n3.1 MB\r\n\r\n![Imgur](https://imgur.com/z4ZXCC2.png)\r\n\r\n## import AndroidOutlined from '@mui/icons-material/AndroidOutlined'\r\n\r\n965 kB\r\n\r\n![Imgur](https://imgur.com/ojVnl0z.png)\r\n\r\nまじ？\r\n\r\n# 本番ビルドは？\r\n\r\nNext.jsの静的HTMLエクスポートをして比較してみる\r\n\r\n## package.jsonにスクリプト追加\r\n\r\n`npm run export`コマンドを追加します\r\n\r\n```json\r\n{\r\n  \"name\": \"next-material-ui\",\r\n  \"version\": \"0.1.0\",\r\n  \"private\": true,\r\n  \"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"build\": \"next build\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"next lint\",\r\n    \"export\": \"next build && next export\"\r\n  },\r\n```\r\n\r\n## import { AndroidOutlined } from '@mui/icons-material'\r\n\r\n```\r\nPage                              Size     First Load JS\r\n┌ ○ / (5246 ms)                   18.1 kB          85 kB\r\n├   /_app                         0 B              67 kB\r\n├ ○ /404                          194 B          67.2 kB\r\n└ λ /api/hello                    0 B              67 kB\r\n+ First Load JS shared by all     67 kB\r\n  ├ chunks/framework.0441fa.js    42.4 kB\r\n  ├ chunks/main.62b8ca.js         23.3 kB\r\n  ├ chunks/pages/_app.d6feaf.js   557 B\r\n  ├ chunks/webpack.1a8a25.js      729 B\r\n  └ css/120f2e2270820d49a21f.css  209 B\r\n```\r\n\r\n## import AndroidOutlined from '@mui/icons-material/AndroidOutlined'\r\n\r\n```\r\nPage                              Size     First Load JS\r\n┌ ○ / (444 ms)                    19.3 kB        86.3 kB\r\n├   /_app                         0 B              67 kB\r\n├ ○ /404                          194 B          67.2 kB\r\n└ λ /api/hello                    0 B              67 kB\r\n+ First Load JS shared by all     67 kB\r\n  ├ chunks/framework.2191d1.js    42.4 kB\r\n  ├ chunks/main.62b8ca.js         23.3 kB\r\n  ├ chunks/pages/_app.d6feaf.js   557 B\r\n  ├ chunks/webpack.1a8a25.js      729 B\r\n  └ css/120f2e2270820d49a21f.css  209 B\r\n```\r\n\r\nなんか後者の方がファイルサイズ大きいんだけど。  \r\nまぁ検証結果としては本番ビルドなら上記の書き方でもツリーシェイキング？で最適化が行われるのだと思う。だた時間はかかりますね、、、  \r\n\r\nhttps://mui.com/guides/minimizing-bundle-size/#when-and-how-to-use-tree-shaking\r\n\r\n# 開発時でもほしい\r\n\r\nBabelを正しく設定すると同じパフォーマンスを出せるらしいです。\r\n\r\n## プラグインを入れる\r\n\r\n```\r\nnpm install babel-plugin-import --save-dev\r\n```\r\n\r\n## .babelrcに追記\r\nプロジェクトのルートディレクトリ（package.jsonがあるフォルダ）に`.babelrc`って名前のファイルを追加します。  \r\n追加したら、以下の内容を入れます。\r\n\r\n```json\r\n{\r\n  \"presets\": [\r\n    \"next/babel\"\r\n  ],\r\n  \"plugins\": [\r\n    [\r\n      \"babel-plugin-import\",\r\n      {\r\n        \"libraryName\": \"@mui/material\",\r\n        \"libraryDirectory\": \"\",\r\n        \"camel2DashComponentName\": false\r\n      },\r\n      \"core\"\r\n    ],\r\n    [\r\n      \"babel-plugin-import\",\r\n      {\r\n        \"libraryName\": \"@mui/icons-material\",\r\n        \"libraryDirectory\": \"\",\r\n        \"camel2DashComponentName\": false\r\n      },\r\n      \"icons\"\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n## 内部サーバー起動\r\n\r\n`npm run dev`\r\n\r\n以上です。これで有効になるはずです。\r\n\r\n![Imgur](https://imgur.com/wGoVOy8.png)\r\n\r\n## ソースコード\r\nほい\r\n\r\nhttps://github.com/takusan23/next-js-materialui-icon-babel"},{"title":"作ったニコ生ゲームを AWS を使っていつでも遊べるようにする","link":"/posts/nicolive_game_hosting_aws/","markdown":"\r\nRPGアツマールが終了したことにより、ニコ生ゲームを遊ぶには実際にニコ生で枠取って放送しないといけないらしい。  \r\n遊ぶ側からするととても不便になったと思う。\r\n\r\nというわけで今回はニコ生ゲームを AWS の静的サイトホスティングを使って、ニコ生で枠を取らずにいつでも遊べるようにしようと思います。  \r\n\r\n# 今回行く構成\r\n\r\n```plaintext\r\n[ S3 ] -> [ CloudFront ] -> internet -> スマホ/PC\r\n```\r\n\r\n`AWS Amplify`ではなく、`S3 + CloudFront`で作ります。  \r\n`S3`にニコ生ゲームの`html`を置いて、`CloudFront`を一回経由してインターネットと通じてスマホ/PCのブラウザへレスポンスを送ります。\r\n\r\nまた、今回は`S3`の静的サイトホスティングは使わず、`OAC`でリクエストするようにします。\r\n\r\n# でめりっと\r\n他のホスティングサービスと違いこの方法だと`S3`の料金がどうしてもかかってしまうので、完全無料にしたい場合は`Netlify`や`Cloudflare Pages`、`GitHub Pages`や`Vercel`等のサービスを使うとほぼ無料だと思います。\r\n\r\n`Cloudflare Pages`がぱっと見た感じ無料ユーザーに優しそう、  \r\n（カスタムドメインにしたい + トップレベルドメインで運用したい場合は`Cloudflare DNS`にする必要があるぐらい）  \r\n\r\n**でも単にホスティングするだけならどこでも良いはず。**  \r\n名前上げたやつは一応使ったことがある、選択肢が多くていいですね\r\n\r\nちなみに、この方法でお金がかかると言いましたが、**1ドル**かかるか怪しいので、`AWS`既に使ってるとかなら多分安い方？  \r\n（私は`お一人様 Misskey`が`Lightsail`で動いてるので）\r\n\r\n# かかるお金？\r\nドメイン代を除けば...\r\n\r\n- CloudFront\r\n    - データ転送\r\n        - １か月 1 TB まで無料。二年目以降もこの無料枠はもらえます\r\n            - AWS -> インターネット -> スマホ/PC の通信の事です\r\n    - CloudFront Functions\r\n        - 200 万リクエストまで無料。二年目以降もあります\r\n            - 今回はこちらを使う構成で行きます、これを使わない方法もあります。\r\n- S3\r\n    - データ転送料金\r\n        - 0 円\r\n        - S3 - CloudFront 間の転送は無料\r\n        - 受信は無料\r\n    - データの操作（リクエスト）\r\n        - 少なからずかかる\r\n            - 転送料金とは別に課金される、ややこしい\r\n        - `CloudFront`が間に入ればキャッシュされるので、この料金を抑えられる\r\n    - データ保存\r\n        - これも少なからずかかります（初年度は無料枠があります）\r\n\r\nただ、先述の通り`お一人様 Misskey`が動いているので、ちょっと請求が増えてもまぁいいかなと  \r\n`無料のホスティングサービス`よりも`AWS`使ってみたさが勝ってしまった...\r\n\r\n# AWS で静的サイトホスティングする\r\n\r\n`AWS`で静的サイトホスティングする場合、2つパターンがあって\r\n\r\n- `AWS Amplify`を使う\r\n- `S3 + CloudFront`を使う\r\n\r\nの2パターンあって、前者は使いやすさに全振りしているそう。  \r\nただ、`CloudFront`よりも若干高いかな？\r\n\r\nというわけで後者を使おうと思うのですが、これも2パターンあります。  \r\nが、この2つどっちも一長一短があります。\r\n\r\n- `S3`の静的サイトホスティング機能を使いながら、`CloudFront`を経由する方法\r\n    - `S3`単品だと`https`が使えないので、`CloudFront`を経由させます\r\n- `S3`の静的サイトホスティング機能は使わず、`CloudFront`が`S3`に問い合わせて返す方法\r\n\r\nまず後者から、こちらは難しいです。  \r\n`example.com/example`にリクエストが来た場合に、`example.html`に変換して`S3`に問い合わせる方法が標準では提供されていません。  \r\nなので、`CloudFront Functions`を使い、`S3`に問い合わせる前に`.html`をつける処理を書く必要があります（コード自体は JS なので全然難しくないです。）  \r\nが、お手軽と言われると微妙、`CloudFront Functions`に関しては二年目以降無料枠があるとは言えうーん  \r\n\r\n前者は楽です。`CloudFront Functions`なんて使わずに作れます。  \r\nこれでいいじゃん！とはいきません、デメリットは`S3`の静的サイトホスティングで使っている`URL`がバレたらアクセスされてしまいます。  \r\n（`S3`自体を静的サイトホスティングしているため）  \r\n\r\nこれを`CloudFront`のみに制限する方法がありません（暫定対応みたいなのならある）。バレないとは思いますがバレたら`SEO`的に良くない（正規 URL）のと、  \r\n`CloudFront`を経由すると値段が安くなる（無料枠で収まる）が、`S3`に直接アクセスされるとその分高くなってしまいます。\r\n\r\n# S3 と CloudFront で静的サイトホスティングするながれ\r\n\r\n- ドメインとパスの構成を決める\r\n- `S3` のバケットを用意する\r\n- `html` を格納する\r\n- `CloudFront` のディストリビューションを作って、`OAC`で`S3`から取れるように\r\n- `CloudFront` にカスタムドメインと`HTTPS`でアクセスできるように\r\n- `CloudFront` で`URL`末尾に`.html`が無くてもアクセスできるように`CloudFront Functions`を書く\r\n\r\nながい  \r\nまた、今回はフレームワークは使わず、`HTML`とかを手動で置いていく感じで行きます  \r\n（あんまり参考にならんかも！）\r\n\r\n## ドメインとパスの構成を決める\r\n\r\n適当にサブドメインで。  \r\nパスの構成はこんな感じで行こうと思います。  \r\n`Next.js`とかのフレームワークを使っている場合は、既にパスが決まっているのでこの工程はドメイン決めるだけだと思います。\r\n\r\n- namagame.negitoro.dev\r\n    - /game\r\n        - /game1\r\n            - index.html\r\n        - /game2\r\n            - index.html\r\n    - index.html\r\n\r\n最後の index.html は `/game/game1` `/game/game2`へアクセスできるようのリンク集にする予定。  \r\n親の`/game`を作るか微妙だったけど`index.js`とか`favicon`とか置きたくなったら、どれが`index.html`で必要なファイルか分からなくなるのでまあ良いか。\r\n\r\n- /game\r\n    - /game1\r\n        - index.html\r\n    - /game2\r\n        - index.html\r\n- favicon.ico\r\n- index.js\r\n- index.html\r\n\r\n## S3 のバケットを作る\r\n\r\nバケット名はおまかせします、`S3`の中でユニークである必要があったはず？なのでドメイン名とかを入れておけば良いのではないでしょうか。  \r\nリージョンは東京にしました。  \r\nお金を考えるとアメリカのオレゴンとかのほうが安いし、`CloudFront`を経由するので物理的に離れてても問題はないはずですが・・・まあ\r\n\r\n## html を格納する\r\n`index.html`を作ります。  \r\n動作確認用なので適当に、全部終わってからちゃんと`html`を書こうと思います。\r\n\r\n`Next.js`とかで既に静的書き出しした場合は`out`フォルダの中身を全部`S3`のバケットに入れちゃっても良いかもしれません。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ja\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>作ったニコ生ゲームのリンク集</title>\r\n</head>\r\n\r\n<body>\r\n\r\n    <p>アツマールが終了したので、とりあえずニコ生以外でも遊べるようにしました。ランキングとかはないです。</p>\r\n\r\n    <ul>\r\n        <li>\r\n            <a href=\"/game/baitoomo/\">ばいとーも</a>\r\n        </li>\r\n        <li>\r\n            <a href=\"/game/tobetoomo/\">とべとーも</a>\r\n        </li>\r\n        <li>\r\n            <a href=\"/game/toritoomo/\">とりとーも</a>\r\n        </li>\r\n        <li>\r\n            <a href=\"/game/tumitoomo/\">つみとーも</a>\r\n        </li>\r\n        <li>\r\n            <a href=\"/game/turitoomo/\">つりとーも</a>\r\n        </li>\r\n    </ul>\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n`Markdown`って偉大ですね、`html`ひっさびさに書いた  \r\n多分トレイリングスラッシュは必要です？\r\n\r\n![Imgur](https://imgur.com/c7ywpmc.png)\r\n\r\nこれをさっき作った`S3`のバケットにドラッグアンドドロップして、アップロードします。\r\n\r\n![Imgur](https://imgur.com/NTeLN1A.png)\r\n\r\n`index.html`が一覧にあれば成功  \r\n`/game`は後でニコ生ゲームを置いておくフォルダとして作っただけで、無くていいです。てか最後で良かった\r\n\r\n![Imgur](https://imgur.com/1ZbPWZ5.png)\r\n\r\n## CloudFront のディストリビューションを作る\r\n\r\nさんこう：https://repost.aws/ja/knowledge-center/cloudfront-serve-static-website\r\n\r\n`CloudFront`の画面を出します\r\n\r\n![Imgur](https://imgur.com/cxZXYRg.png)\r\n\r\nディストリビューションを作成を押します\r\n\r\n![Imgur](https://imgur.com/6HzYKs7.png)\r\n\r\nオリジンドメイン  \r\nにはさっき作った`S3`のバケットを選びます、ドロップダウンメニューで選べます\r\n\r\n![Imgur](https://imgur.com/NjvBN5L.png)\r\n\r\n次は オリジンアクセス  \r\nこれは`Origin access control settings (recommended)`を選びます  \r\n選ぶとドロップダウンメニューが増えるので、その横の`コントロール設定を作成`を押します\r\n\r\n![Imgur](https://imgur.com/5s4jlkt.png)\r\n\r\n多分デフォルト設定で良いはず、説明とかは書きたければ書いてね\r\n\r\n![Imgur](https://imgur.com/QKIIa7i.png)\r\n\r\nこの警告は後で対応するので一旦飛ばします\r\n\r\n![Imgur](https://imgur.com/OvHFDSo.png)\r\n\r\nあと WAF がなんとかとか言われているのですが、使わないで良いはずなので使わないで\r\n\r\n![Imgur](https://imgur.com/U96KwPW.png)\r\n\r\nとりあえず一番下まで移動して作成します。\r\n\r\n![Imgur](https://imgur.com/NXiIJ0j.png)\r\n\r\n作成できると、ご丁寧に`S3`の設定を変更しないとだめの旨が表示されるので、それに従います  \r\n`ポリシーをコピー`を押してコピーした後、`S3 バケットの権限に移動してポリシーを更新する`を押します\r\n\r\n![Imgur](https://imgur.com/oJt8SI4.png)\r\n\r\n押したら`バケットポリシー`まで移動して、`編集`を押します  \r\nそして入力欄へさっきコピーしたのをペーストします！\r\n\r\n![Imgur](https://imgur.com/jKclOM6.png)\r\n\r\n`JSON`が貼り付けられれば成功です。\r\n\r\n![Imgur](https://imgur.com/P5q2fVm.png)\r\n\r\n`CloudFront`に戻って、`一般タブ`へ移動し、`ディストリビューションドメイン名`をコピーします。  \r\nそしてブラウザのアドレス欄へ、コピーしたやつを貼り付け、その後に`/index.html`をつけます\r\n\r\n![Imgur](https://imgur.com/ur3eGgc.png)\r\n\r\n![Imgur](https://imgur.com/gZGPpnt.png)\r\n\r\nどうでしょう、ちゃんとページが表示されているでしょうか？  \r\n\r\n## カスタムドメインと HTTPS\r\n\r\nカスタムドメイン（`CNAME`）も`HTTPS`も無料で出来ます（ドメイン代は別）\r\n\r\nさんこう：https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html\r\n\r\nちゃんとページが見れたところで、次はカスタムドメインの適用と HTTPS 化を行います  \r\n`CloudFront`の設定の`編集`を押します\r\n\r\n![Imgur](https://imgur.com/PBaxR4z.png)\r\n\r\n代替ドメイン名の項目で、`追加`を押し使いたいサブドメイン名を入力します。  \r\n\r\n![Imgur](https://imgur.com/ZAjHqso.png)\r\n\r\n![Imgur](https://imgur.com/KcWfkXy.png)\r\n\r\n![Imgur](https://imgur.com/6LaAU7w.png)\r\n\r\nこれで`変更を保存`しようとすると怒られます。\r\n\r\n![Imgur](https://imgur.com/UcmP0A9.png)\r\n\r\n```plaintext\r\nTo add an alternate domain name (CNAME) to a CloudFront distribution, you must attach a trusted certificate that validates your authorization to use the domain name. For more details, see: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-requirements\r\n```\r\n\r\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-requirements\r\n\r\nつまり、`HTTPS化 ( SSL/TLS 証明書 ) `も一緒にしないと`CNAME`の設定が出来ないようです。  \r\n\r\nというわけで、上にスクロールし`カスタム SSL 証明書`の項目を見つけて、`証明書をリクエスト`を押します。\r\n\r\n![Imgur](https://imgur.com/24lE43J.png)\r\n\r\n`Amazon Certificate Manager`とか言う画面が開きましたか？  \r\n\r\n![Imgur](https://imgur.com/dqjIaAV.png)\r\n\r\n**で、ここにワナがあって**、`CloudFront`で使うためには`ACM`のリージョンが`us-east-1 (バージニア北部)`になっている必要があります\r\n\r\n![Imgur](https://imgur.com/rvZzw0s.png)\r\n\r\nできたら証明書をリクエストします、`リクエスト`を押します。\r\n\r\n![Imgur](https://imgur.com/rtJ1TY7.png)\r\n\r\nデフォルトで次に行きます\r\n\r\n![Imgur](https://imgur.com/HidjfV1.png)\r\n\r\n完全修飾ドメイン名 は使いたいドメイン名を入れます。  \r\n検証方法 は`DNS`で良いはず。  \r\n本当に本人が持っているドメインかどうかを検証するために、持ち主が`DNS`のレコードを追加して`Amazon`側から引けるかどうかを見るんだと思います。\r\n\r\n![Imgur](https://imgur.com/5BT5Dq9.png)\r\n\r\n作成すると、作業が必要な旨が上に表示されるので、`証明書を表示`を押します\r\n\r\n![Imgur](https://imgur.com/AESm2a2.png)\r\n\r\nドメイン の項目で、`CNAME 名` と `CNAME 値`というのがあると思う！  \r\nこれを`DNS`のレコードとして追加します\r\n\r\n![Imgur](https://imgur.com/x0MMQiu.png)\r\n\r\n### DNS 検証\r\n\r\n私はドメインの`DNS`に`Cloudflare`（くらうどふれあ）を使ってます  \r\nこの記事では`CloudFront`というキーワードが何度も出ていますが、これは`AWS`のサービスです。  \r\n`Cloudflare`は会社の名前です、ごっちゃにならないよう気をつけてください\r\n\r\n今回は`Cloudflare DNS`の場合ですが、多分ほかでも同じ感じだと思います。\r\n\r\nドメインを選んで、`DNS`のレコードを追加する画面に来たら、`CNAME`で追加します  \r\nName と Target をそれぞれ`CNAME 名` `CNAME 値`にします。\r\n\r\n![Imgur](https://imgur.com/Y5Q6PBd.png)\r\n\r\n![Imgur](https://imgur.com/3tiCc2B.png)\r\n\r\nなんか入力すると、最後の`.`が消えちゃうんだけど`Cloudflare`だからなのかな、別に最後のドットは消えても検証出来たのでまあ良いのか？\r\n\r\nしばらく待ちます\r\n\r\n![Imgur](https://imgur.com/Xpc4fhW.png)\r\n\r\n数分待ってリロードすると 発行済み になります。\r\n\r\n![Imgur](https://imgur.com/bv77LVh.png)\r\n\r\nあ、`DNS`の設定画面はもう一回使うので開いておいたほうが良いかも（開き直せば良い話だけど）\r\n\r\n### CloudFront に戻る\r\n\r\nこれで`カスタム SSL 証明書`の項目も埋めることが出来るはず。さっき作ったやつを選べばオッケーです\r\n\r\n![Imgur](https://imgur.com/xvJQbRj.png)\r\n\r\n`変更を保存`を押して閉じちゃいましょう。\r\n\r\n### DNS に戻る\r\nさっきまで開いてた`DNS`のページを開きます、もし閉じた場合は開き直してね。  \r\n`CNAME`の設定をします、`CNAME`で`CloudFront`を指すように変更します。\r\n\r\n`CNAME`レコードを追加します、名前はカスタムドメイン名、値は`CloudFront`の`ディストリビューションドメイン名`を入れます\r\n\r\n![Imgur](https://imgur.com/cWKXQ2m.png)\r\n\r\n![Imgur](https://imgur.com/Re2vOHg.png)\r\n\r\nここまで出来たら、  \r\nカスタムドメイン + `/index.html`をブラウザのアドレス欄に入力してみましょう。どうですか？見れますか？\r\n\r\n![Imgur](https://imgur.com/qro53Lk.png)\r\n\r\n## .html 無しでアクセスできるように CloudFront Functions を書く\r\nこれも二年目以降も付く無料枠の範囲内に入るとは思うけどなあ\r\n\r\nさんこう：https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/example-function-add-index.html\r\n\r\n今のこのままだと、URLの最後に`.html`拡張子を付ける必要があるのですが、これは面倒です。  \r\n\r\n![Imgur](https://imgur.com/2P3lHbT.png)\r\n\r\n`S3`の静的サイトホスティング機能を使う場合や、ほとんどのホスティングサービスは勝手にやってくれますが、`CloudFront OAC`で作った場合はこの問題にぶち当たります。  \r\nというわけで、`CloudFront Functions`で`S3`にアクセスする際に`URL`を加工して`.html`をつける処理を書きます。\r\n\r\n`CloudFront`を開き関数を選びます\r\n\r\n![Imgur](https://imgur.com/JfkXJBm.png)\r\n\r\n関数を作成を選びます！！！\r\n\r\n![Imgur](https://imgur.com/sROEgZL.png)\r\n\r\nいい感じの名前をつけて\r\n\r\n![Imgur](https://imgur.com/4mGOxc3.png)\r\n\r\nコードは以下のをそのまま使おうと思います  \r\nhttps://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/example-function-add-index.html\r\n\r\n![Imgur](https://imgur.com/RSbI2b9.png)\r\n\r\n`index.html`がなければつける処理です。  \r\n`JavaScript`ですが結構制限があります：https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/edge-functions.html\r\n\r\n保存したら発行タブを開き、`関数の発行`を押します。\r\n\r\n![Imgur](https://imgur.com/4wJjXBs.png)\r\n\r\nそのあと、下に 関連付けされているディストリビューション の項目があると思うので、ここで`関連付けを追加`を押します\r\n\r\n![Imgur](https://imgur.com/T7VNnNi.png)\r\n\r\n以下を埋めます\r\n\r\n- ディストリビューション はさっき作った`CloudFront`を選ぶ\r\n- イベントタイプ は`Viewer request`を選ぶ\r\n- キャッシュビヘイビア は多分`default`？\r\n\r\n![Imgur](https://imgur.com/iGsb5tk.png)\r\n\r\nこれで`URL`の末尾に`index.html`をつけなくても見れるようになりました！！！\r\n\r\n![Imgur](https://imgur.com/SYoWLpR.png)\r\n\r\n長かった...\r\n\r\n# おわりに\r\n結構大変！\r\nそれじゃ後はニコ生ゲームを`html / js`に書き出して `S3` に上げるだけ。  \r\n\r\nさて、、、、ニコ生ゲーム、古いやつだと3年前くらい前になるんだけどちゃんと書き出しできるかな...（`package-lock.json`消したら出来た\r\n\r\n![Imgur](https://imgur.com/QFP82El.png)\r\n\r\n![Imgur](https://imgur.com/BQwx4W0.png)"},{"title":"npm i すると cb() never called npm","link":"/posts/node_js_cb_called_npm/","markdown":"\n<p style=\"color:red;font-size:30px\">何回か npm i してたら直りました</p>\n\n休日が終わる。社会人しんどくない？\n\n```\ntiming npm Completed in 7273ms\nerror cb() never called!\nerror This is an error with npm itself. Please report this error a\nerror <https://npm.community>\n```\n\n# 直らなかった\n- キャッシュを消す\n    - `npm cache clean --force`\n    - 直らない\n- `node_module`を消す\n    - 直らない\n- `package-lock.json`を消す\n    - 直らない\n- Node.js再インストール\n    - （確か）直らなかった\n- Wi-Fiを無効にしたり有効にしたりした。再起動もしてみる\n    - （確か）直らなかった\n\n# 仕方なくレポートを開く\n\nこんなやつ↓\n\n```\nnpm-cache\\_logs\\2021-04-04T09_40_13_200Z-debug.log\n```\n\nで見てみると、毎回違うところでコケてるんですよね。\n\n```\n1597 http fetch GET 200 https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz 56ms\n1598 silly pacote range manifest for escape-string-regexp@^4.0.0 fetched in 60ms\n1599 timing npm Completed in 16630ms\n1600 error cb() never called!\n1601 error This is an error with npm itself. Please report this error at:\n1602 error <https://npm.community>\n```\n\n↓\n\n```\n3459 http fetch GET 200 https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz 44ms\n3460 silly pacote version manifest for file-uri-to-path@1.0.0 fetched in 133ms\n3461 timing npm Completed in 15087ms\n3462 error cb() never called!\n3463 error This is an error with npm itself. Please report this error at:\n3464 error <https://npm.community>\n```\n\n↓\n\n```\n2712 http fetch GET 304 https://registry.npmjs.org/iferr 41ms (from cache)\n2713 silly pacote range manifest for iferr@^0.1.5 fetched in 42ms\n2714 timing npm Completed in 7273ms\n2715 error cb() never called!\n2716 error This is an error with npm itself. Please report this error at:\n2717 error <https://npm.community>\n```\n\nなので、何回か`npm i`してたらなんか直ってました。なんでや"},{"title":"Node.jsのプロジェクトをGitHubで開いたら脆弱性があると言われたとき","link":"/posts/node_js_github_dependencies/","markdown":"\r\nどうもこんばんわ、自分用メモ。\r\n\r\n# 本題\r\nNode.jsなプロジェクトをGitHubで開いたらなんか警告が出ていたので消してみる。\r\n\r\n```bash\r\nWe found potential security vulnerabilities in your dependencies.\r\nOnly the owner of this repository can see this message.\r\n```\r\n\r\n![Imgur](https://imgur.com/9yLmNje.png)\r\n\r\n## 自分で入れたライブラリの場合は\r\n\r\n`npm i ライブラリ名`\r\n\r\nすれば良いはず\r\n\r\n## 直し方1 ( 追記 2023/07/11 )\r\n自分で入れたライブラリではない（ライブラリの中で使われているライブラリの場合）  \r\nもしかしたらライブラリ開発者さんが対応してくれているかもしれません。\r\n\r\n`package-lock.json` と `node_modules` を消した後、ターミナル（コマンドプロンプト PowerShellとか）を開いて  \r\n`npm i` をすると対応終了するかもしれません。\r\n\r\n## 直し方2\r\n\r\nとりあえず `package.json` があるフォルダ内でターミナル（PowerShellとか）を開き、 `npm audit` を叩きます。  \r\n\r\nそしたらこんなふうなメッセージが。\r\n```bash\r\nnpm audit\r\n\r\n=== npm audit security report ===\r\n\r\n# Run  npm update minimist --depth 2  to resolve 1 vulnerability\r\n\r\n  Critical        Prototype Pollution in minimist\r\n\r\n  Package         minimist\r\n\r\n  Dependency of   next-sitemap [dev]\r\n\r\n  Path            next-sitemap > minimist\r\n\r\n  More info       https://github.com/advisories/GHSA-xvch-5gv4-984h\r\n\r\n\r\n\r\nfound 1 critical severity vulnerability in 607 scanned packages\r\n  run `npm audit fix` to fix 1 of them.\r\n\r\n```\r\n`Path`の部分を見ると、`next-sitemap > minimist`と書かれてますね。  \r\n`next-sitemap`の中で使っている`minimist`ってライブラリ（モジュール）に対して脆弱性があるみたいですね。  \r\nなんか`npm audit fix`で直せるらしいですが、今回は`npm i next-sitemap`を叩いて大本のライブラリを更新する方針で行きます。\r\n\r\n## 大本のライブラリを更新する\r\nはい。  \r\n各自大本のライブラリを更新するようにしてください。\r\n\r\n```bash\r\nnpm i next-sitemap\r\n```\r\n\r\nインストール出来たので、再度確認します。\r\n\r\n```bash\r\nnpm audit\r\n\r\n=== npm audit security report ===                        \r\n\r\nfound 0 vulnerabilities\r\n in 605 scanned packages\r\n```\r\n\r\n消えていました。  \r\n以上です。\r\n\r\n# GitHubへPush\r\n\r\nGitHubへPushし、数十秒後にちゃんと消えていました。よかった\r\n\r\n![Imgur](https://imgur.com/zAKmxGs.png)\r\n\r\n# おわりに\r\n\r\nよく知らんけど`package-lock.json`基本いじったら駄目だよね？"},{"title":"Nuxt.jsのFull Staticがすごい","link":"/posts/nuxt_2_13_sugoi/","markdown":"\r\n歯磨きしたら血が出た。ちょっとびっくりした\r\n\r\n# 本題\r\nNuxt.jsの2.13から`完全な静的生成`機能がついた模様。  \r\nむしろ今までは完全ではなかったのか？って話でよくわからないけど、この中にある`ルーティング自動生成`が多分強い。\r\n\r\n詳しくはこれ  \r\n[本家ブログ](https://nuxtjs.org/blog/going-full-static)\r\n\r\n\r\n# こんなん読んでられんわ\r\n\r\n- 1.Nuxt.jsをアップデートする\r\n- 2.`nuxt.config.js`にこんな感じで`target:static`を指定\r\n```js\r\nexport default {\r\n  // 静的サイト書き出し。universalとstatic入れてね\r\n  mode: 'universal',\r\n  target: 'static',\r\n}\r\n```\r\n- 3.`package.json`の`generate`スクリプトを以下に変更\r\n```json\r\n\"scripts\": {\r\n  \"generate\": \"nuxt build && nuxt export\",\r\n}\r\n```\r\n- 4.`npm run generate`を実行する。`dist`フォルダができる。おつかれ様です。\r\n- おまけ：`npx nuxt serve`で静的生成したサイトをすぐに確認できるようになりました。\r\n\r\n# 何ができるようになるの？\r\n- 新しくなった静的生成\r\n    - `nuxt generate`から\r\n    - `nuxt build && nuxt export`へ\r\n- 怖くないルーティング\r\n    - 勝手にページを解析し、リンクを自動で見つけて勝手に生成します。\r\n    - どういうことかと言うと、以下のJSの用に`generate.routes`を書く必要がもうないということです。**コメントと化した結構重要（多分一番めんどい）な部分**\r\n```js\r\nexport default {\r\n  generate: {\r\n    // routes: generateRoutes, // 生成する\r\n    dir: 'docs'\r\n  },\r\n}\r\n```\r\n\r\n# Nuxt.jsのアップデート\r\n2.0から2.13へ上げます。  \r\n## package.json 開いて\r\n\r\n`dependencies`の中の`nuxt`を`^2.13.1`にします。以下は一例\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@nuxtjs/google-analytics\": \"^2.3.0\",\r\n  \"@nuxtjs/markdownit\": \"^1.2.9\",\r\n  \"@nuxtjs/pwa\": \"^3.0.0-0\",\r\n  \"markdown-it-footnote\": \"^3.0.2\",\r\n  \"markdown-it-highlight\": \"^0.2.0\",\r\n  \"nuxt\": \"^2.13.1\"\r\n},\r\n```\r\n\r\nなお私もよく分かっていない。`^`←これなに？\r\n\r\n## package-lock.json ファイルと node_modules フォルダを消す\r\n\r\nnpm installで再召喚するので大丈夫\r\n\r\n## npm install を実行\r\n`npm install`を実行します。  \r\nおそらくおま環だろうけど私の環境では**管理者権限**ないとできませんでした。\r\n\r\n### こける\r\nまあうまく行かないよね\r\n- `Unexpected end of JSON input while parsing`なんとか\r\n    - 管理者権限でcmd等を開いて`npm cache clean --force`を実行する。**何してるか分かってるよな？** って言われた。分からない  \r\n    `npm WARN using --force I sure hope you know what you are doing.`\r\n\r\n# nuxt.config.js を開く\r\n開いたら、静的生成して＾～ってNuxtに伝えます。  \r\n`target:static`を追加します。\r\n\r\n```js\r\nexport default {\r\n  // 静的サイト書き出し。universalとstatic入れてね\r\n  mode: 'universal',\r\n  target: 'static',\r\n}\r\n```\r\n\r\n# nuxt build && nuxt export\r\n`package.json`を開いて、`script`にある、`generate`を書き換えます。\r\n\r\n```json\r\n\"scripts\": {\r\n  \"generate\": \"nuxt build && nuxt export\",\r\n}\r\n```\r\n\r\n# npm run generate 実行\r\nすると生成されます。お疲れ様でした～\r\n\r\n# 怖くないルーティング  \r\n今回のNuxt.jsさんは、勝手にリンクを見つけてリンクの分だけ生成するようになったのでもう不要です。  \r\nいやールーティング面倒だったのでこれはとてもありがたい。\r\n\r\n一応、`nuxt.config.js`で明示的に無効にする（`generate.crawler: false`）ことで旧仕様（`generate.routes`）を利用できるっぽい。\r\n\r\n# 静的生成したサイトを確認できる機能\r\n本番環境（私ならNetlify）に公開された場合どんな感じに見れるのか（多分変わらんと思うけど）を確認できる機能が付きました。\r\n\r\n- 一度きりなら\r\n    - `npx nuxt serve`（package.jsonにscript書かなくても、`npx`使えば直接使える）\r\n- package.jsonに書くなら\r\n```json\r\n\"scripts\": {\r\n  \"staticdev\": \"nuxt serve\",\r\n}\r\n```\r\n実行は`npm run staticdev`（別に`staticdev`って名前である必要はない。みんなはかっこいい名前をつけてあげよう）\r\n\r\n# おまけ\r\n## Vuetifyが変わった？\r\n\r\n`v-content`から`v-main`になった模様\r\n\r\nあと強制上書きCSSがまた動かなくなってた（力技やめとけ）  \r\nそれでふと`SCSS`ってやつでVuetifyが適用するCSSの内容変えられるやんって思って見てみると、あるんですね～\r\n\r\n```scss\r\n// Vuetifyが勝手に色つける問題\r\n$code-background-color: '#000000';\r\n```\r\n\r\n`code-background-color`なんていつの間に追加してたの？\r\n\r\nまた今度やろうと思います\r\n\r\n# おわりに\r\n`npx`なんて便利な機能あったんですね（え）\r\n\r\n# 参考にしました。\r\nhttps://nuxtjs.org/blog/going-full-static  \r\nhttps://ja.nuxtjs.org/guide/upgrading/  \r\nhttps://microcms.io/blog/nuxt-full-static-generation/"},{"title":"nuxtでcssを指定すると Could not compile template","link":"/posts/nuxt_css_err/","markdown":"どうもこんにちは。そろそろ虫の季節かー嫌だなー\r\n\r\n# 本題\r\n\r\n`nuxt.config.js`で`CSS`を指定すると怒られる\r\n\r\n```\r\nCould not compile template ~\r\n```\r\n\r\n# 直す\r\n\r\nhttps://ja.nuxtjs.org/docs/2.x/configuration-glossary/configuration-css/\r\n\r\nこれ見ると`@`が必要みたいだけどなんかいらなかったわ。\r\n\r\n```js\r\n  css: [\r\n    \"assets/css/styles.css\" // @ なしで書く\r\n  ],\r\n```"},{"title":"Nuxt.jsのプリフェッチがはやい","link":"/posts/nuxt_link_hayai/","markdown":"\r\nまずはこちらのGIFを見てください（3MBぐらい）\r\n\r\n![Imgur](https://i.imgur.com/oyePdWI.gif)\r\n\r\n左側は今まで、右側はNuxt.jsのSmart Prefeching機能を使ったページ遷移です。  \r\n\r\n押した瞬間に切り替わっていることが分かると思います。\r\n\r\n# Smart Prefeching とは\r\n[本家ブログ](https://nuxtjs.org/blog/introducing-smart-prefetching)\r\n\r\nブラウザの表示領域にリンク`<nuxt-link>`を見つけたらそのリンクをブラウザが先読みする機能。これをプリフェッチ機能っていうらしい。\r\n\r\n# 使い方\r\n- `<nuxt-link>`を使う\r\n- Vuetifyの場合\r\n    - `to=\"遷移先\"`と`nuxt`を属性に付けることで利用可能。`nuxt`を付け忘れると機能しない。\r\n    - GIFの用に`<v-card>`をページ遷移に使う際はこんな風に\r\n```html\r\n<v-card\r\n  class=\"ma-2 pa-5\"\r\n  to=\"`/posts/taihendattakoto\"\r\n  nuxt\r\n>\r\n</v-card>\r\n```\r\n\r\n以上です。"},{"title":"Nuxtの静的サイトジェネレートはモードをuniversalにしよう","link":"/posts/nuxt_universal/","markdown":"\r\n静的サイト書き出せてたと思ったら書き出せてなかった話です。  \r\nこれ以外にも大変だったことがいっぱいあるのでもしよければ見てね。→[大変だったこと](/posts/taihendattakoto)\r\n\r\n# なにがあったの\r\nMastodonの認証マークが付かなかった。  \r\nMastodonの認証マークはサイトにaタグ置いて、hrefと`rel=\"me\"`付けば通る。ちゃんとChromeであってるか確認したんだけど、なぜか認証されなかった。\r\n\r\n## さらに\r\nJavaScriptを無効にすると（めったにないけど）真っ白になった。  \r\n静的サイト書き出しならただHTMLを表示するだけなのになんでJS消すと動かなくなるんだ？。JSがどうこう関係なくね？  \r\n\r\n**あれこれJavaScriptで動的にDOM操作？**\r\n\r\n# 静的サイトを書き出す方法\r\n\r\n`nuxt.config.js`の`mode`を`universal`にする必要があります。  \r\n\r\nそうすればHTMLファイルにちゃんと内容がまんま入ってるはずです。\r\n\r\nこんな感じに↓  \r\n![Imgur](https://imgur.com/WkV9GT2.png)\r\n\r\n(ちなみにVSCode、`Ctrlと+`で拡大、`Ctrlと-`で縮小ができます。間違えて押した時に覚えておけば良いかも？)\r\n\r\n以上です。\r\n\r\n# おまけ\r\n`mode:'universal'`にしたせいか、VuetifyのChipのところでエラーが出るようになっちゃった。  \r\nよくわからないのでとりあえず`<client-only>`で黙らせた（え）\r\n\r\n# 参考にしました\r\nhttps://jamstack.jp/blog/nuxt_stumble_point/"},{"title":"Vue packages version mismatch を直す","link":"/posts/nuxt_vue_version_missing/","markdown":"\r\n`npm audit fix`したらこうなった\r\n\r\n# 本題\r\n\r\n```\r\n✖ Nuxt Fatal Error                                                                   \r\n                                                                                      \r\nError:                                                                                \r\n                                                                                      \r\nVue packages version mismatch:                                                        \r\n                                                                                      \r\n- vue@2.6.11                                                                          \r\n- vue-server-renderer@2.6.12                                                          \r\n                                                                                      \r\nThis may cause things to work incorrectly. Make sure to use the same version for both.\r\n```\r\n\r\nはい\r\n\r\n# 直し方\r\n`vue`のバージョンをあげます\r\n\r\n```\r\nnpm i vue\r\n```\r\n\r\n`+ vue@2.6.12`とか出てればおｋだと思う\r\n\r\nこれで実行できると思いきや、できない\r\n\r\n```\r\nVue packages version mismatch:\r\n\r\n- vue@2.6.12\r\n- vue-template-compiler@2.6.11\r\n```\r\n\r\nというわけで`npm i vue-template-compiler`の方もバージョンをあげます\r\n\r\n```\r\nnpm i vue-template-compiler\r\n```\r\n\r\nこれで実行できるようになりました。おつ"},{"title":"OkHttpとCoroutineで分割ダウンロードを実装する","link":"/posts/okhttp_split_download/","markdown":"\r\n高校生ブランドがあと数日でなくなりますね\r\n\r\n# 本題\r\nファイルダウンロードが遅いのでいくつかに分けて並列ダウンロードしたい  \r\nただでさえ速度が遅いんだからさあ\r\n\r\n## 分割ダウンロードの調査\r\nhttps://developer.mozilla.org/ja/docs/Web/HTTP/Range_requests\r\n\r\n指定した範囲（バイト）をリクエストできるらしい  \r\nダウンローダーによくある一時停止からの再開機能はこれを使ってるそう  \r\n他のブラウザはしらんけど、`Chrome`の`videoタグ`でシークバーを動かすとそのたびにこの部分リクエストを飛ばしてるっぽい\r\n\r\nリクエストヘッダに、\r\n\r\n| name  | value      |\r\n|-------|------------|\r\n| Range | bytes=0-50 |\r\n\r\nと入れると0から50までのデータが返ってくるそう。  \r\nちなみに次のデータ(例えば50バイト分)をリクエストする際は`50`ではなく`51`からにする必要がある？  \r\n\r\n| name  | value        |\r\n|-------|--------------|\r\n| Range | bytes=51-100 |\r\n\r\nhttps://triple-underscore.github.io/RFC7233-ja.html#p.byte-ranges-specifier  \r\n\r\nちなみにステータスコードは`206`になる\r\n\r\n# 使うもの\r\n## OkHttp\r\nHTTPクライアント。WebAPI叩いたり色んな所で使ってる。  \r\nAndroid 5以上対応\r\n\r\n## Coroutine\r\n難しい。非同期処理(アプリの画面を止めない)を書くときに幸せになれるやつ。  \r\n難しいんで例をあげると\r\n\r\n- コールバック地獄を脱却（たとえなので動きませんが）\r\n    - `lifecycleScope.launch`、省略時はUIスレッドになります\r\n```kotlin\r\n// 地獄\r\ngetLocation { location ->\r\n    getWeatherId(location) { id ->\r\n        getWeather(id) { weather ->\r\n            runOnUiThread {\r\n                // UI Thread\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 天国\r\nlifecycleScope.launch {\r\n    val location = suspendGetLocation()\r\n    val weatherId = suspendGetWeatherId(location)\r\n    val weather = suspendGetWeather(weatherId)\r\n    withContext(Dispatchers.Main) {\r\n        // UI Thread\r\n    }\r\n}\r\n\r\nfun getLocation(callback: (String) -> Unit) {\r\n}\r\nfun getWeatherId(location: String, callback: (String) -> Unit) {\r\n}\r\nfun getWeather(id: String, callback: (String) -> Unit) {\r\n}\r\nsuspend fun suspendGetLocation() = withContext(Dispatchers.IO) {\r\n    \"tokyo\"\r\n}\r\nsuspend fun suspendGetWeatherId(location: String) = withContext(Dispatchers.IO) {\r\n    \"tokyo\"\r\n}\r\nsuspend fun suspendGetWeather(id: String) = withContext(Dispatchers.IO) {\r\n}\r\n```\r\n\r\n- キャンセルもできる\r\n\r\n```kotlin\r\nval job = lifecycleScope.launch { \r\n    while (true){\r\n        delay(1000)\r\n        Toast.makeText(this@MainActivity, \"閉じられませんよ～\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\nlifecycleScope.launch { \r\n    delay(5000)\r\n    job.cancel() // やめにする\r\n}\r\n```\r\n\r\n- コルーチン内の例外をキャッチ\r\n\r\n```kotlin\r\nval errorHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\r\n    throwable.printStackTrace()\r\n    runOnUiThread {\r\n        Toast.makeText(this, \"問題が発生しました。${throwable}\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\nlifecycleScope.launch(errorHandler + Dispatchers.Main) {\r\n    // もし通信エラーが起きてもCoroutineExceptionHandlerが拾ってくれる？\r\n    val videoFile = getLargeFile()\r\n}\r\n\r\nprivate suspend fun getLargeFile() = withContext(Dispatchers.IO) {\r\n}\r\n```\r\n\r\nそして今回使う予定の、`asunc { }`  \r\n\r\n- すべて直列にする（おそい）\r\n\r\n```kotlin\r\nlifecycleScope.launch {\r\n    val gameCategoryTop = getVideoRankingTopItem(\"game\")\r\n    val vocaloidCategoryTop = getVideoRankingTopItem(\"vocaloid\")\r\n    val animeCategoryTop = getVideoRankingTopItem(\"anime\")\r\n    val cookCategoryTop = getVideoRankingTopItem(\"cook\")\r\n    textView.text = \"\"\"\r\n        ゲームランキング一位:${gameCategoryTop}\r\n        ボカロランキング一位:${vocaloidCategoryTop}\r\n        アニメランキング一位:${animeCategoryTop}\r\n        料理ランキング一位:${cookCategoryTop}\r\n        \"\"\".trimIndent()\r\n}\r\n\r\nprivate suspend fun getVideoRankingTopItem(categoryId: String) = withContext(Dispatchers.IO) {\r\n    return@withContext \"\"\r\n}\r\n```\r\n\r\nので、並列にリクエストしたいですよね？そこで使うのが`async { }`です。  \r\n\r\n```kotlin\r\nlifecycleScope.launch {\r\n    // すぐに実行される\r\n    val gameCategoryTop = async { getVideoRankingTopItem(\"game\") }\r\n    val vocaloidCategoryTop = async { getVideoRankingTopItem(\"vocaloid\") }\r\n    val animeCategoryTop = async { getVideoRankingTopItem(\"anime\") }\r\n    val cookCategoryTop = async { getVideoRankingTopItem(\"cook\") }\r\n\r\n    // 並列で実行した結果を待つ\r\n    gameCategoryTop.await()\r\n    vocaloidCategoryTop.await()\r\n    animeCategoryTop.await()\r\n    cookCategoryTop.await()\r\n    \r\n    textView.text = \"\"\"\r\n        ゲームランキング一位:${gameCategoryTop}\r\n        ボカロランキング一位:${vocaloidCategoryTop}\r\n        アニメランキング一位:${animeCategoryTop}\r\n        料理ランキング一位:${cookCategoryTop}\r\n        \"\"\".trimIndent()\r\n}\r\n\r\nprivate suspend fun getVideoRankingTopItem(categoryId: String) = withContext(Dispatchers.IO) {\r\n    return@withContext \"\"\r\n}\r\n```\r\n\r\nまた、配列を使うともう少しきれいに書くことができます。  \r\n\r\n```kotlin\r\nlifecycleScope.launch {\r\n    val categoryList = arrayListOf(\"game\", \"vocaloid\", \"anime\", \"cook\")\r\n    val topItemList = categoryList\r\n        .map { id -> async { getVideoRankingTopItem(id) } } // すぐに実行される\r\n        .map { deferred -> deferred.await() } // すべての結果を待つ\r\n    textView.text = \"\"\"\r\n        ゲームランキング一位:${topItemList[0]}\r\n        ボカロランキング一位:${topItemList[1]}\r\n        アニメランキング一位:${topItemList[2]}\r\n        料理ランキング一位:${topItemList[3]}\r\n        \"\"\".trimIndent()\r\n}\r\n\r\nprivate suspend fun getVideoRankingTopItem(categoryId: String) = withContext(Dispatchers.IO) {\r\n    return@withContext \"\"\r\n}\r\n```\r\n\r\n他のプログラミング言語では、関数を作る際に`async`を使うと思うんですが、  \r\n`KotlinのCoroutine`では呼ぶ際に`async { }`を使うことになります。(ので`async/await`のことは忘れたほうがわかるかも)\r\n\r\n# 本編\r\n話題が逸れ過ぎた。\r\n\r\n## 環境\r\n\r\nKotlinで行きます\r\n\r\n```kotlin\r\nmutableMapOf(\r\n    \"Android Studio\" to \"4.1.1\",\r\n    \"端末\" to \"Pixel 3 XL\", // エミュレーターだとなんか失敗するので実機を強く推奨\r\n)\r\n```\r\n\r\nダウンロードしたいファイルのURLを確保しておいてね\r\n\r\n## 仕様\r\n保存先はユーザーに選んでもらう形式を取る。  \r\n本当はダウンロードディレクトリに自動で入れたいんだけど、`Android 10`以降しか提供されていない  \r\n(すいませんこれは嘘でAndroid 9以前でもできるんだけど実装方法が全然違うのでめんどい)  \r\n\r\n私がやりたいのはファイルダウンロードであって、  \r\nAndroidの`MediaStore`ではない。やりだしたらもう収集がつかない。  \r\n(Androidは生（意味深）ファイルパスでのファイルアクセスが一部を除き禁止されているため)  \r\n```kotlin\r\nFile(\"sdcard/Download\") // Android 10以降禁止\r\n```\r\n\r\nダウンロード処理は`ViewModel`に書くとします\r\n\r\n## ライブラリ\r\n`OkHttp`と`Coroutine`(とそれ関係)を入れます。\r\n\r\n`app/build.gradle`に書き足す。ViewBindingも有効にしてください。\r\n\r\n```gradle\r\ndependencies {\r\n    // コルーチン\r\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1'\r\n    // コルーチンをActivityで使いやすくするやつ\r\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.3.0\"\r\n    // OkHttp\r\n    implementation(\"com.squareup.okhttp3:okhttp:4.9.0\")\r\n    // ViewModel\r\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.0\"\r\n    // LiveData\r\n    implementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.3.0\"\r\n    // Activity Result API\r\n    implementation \"androidx.activity:activity-ktx:1.2.0\"\r\n    implementation \"androidx.fragment:fragment-ktx:1.3.0\"\r\n\r\n    // 省略\r\n}\r\n```\r\n\r\n## AndroidManifest.xml\r\n\r\nインターネット権限が必要です。（よく書き忘れる）\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n```\r\n\r\n## activity_main.xml\r\n\r\n開始ボタンとプログレスバーをおきます\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <Button\r\n        android:id=\"@+id/start_button\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Start\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <ProgressBar\r\n        android:id=\"@+id/progress_bar\"\r\n        style=\"?android:attr/progressBarStyleHorizontal\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginStart=\"16dp\"\r\n        android:layout_marginEnd=\"16dp\"\r\n        android:max=\"100\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintTop_toBottomOf=\"@+id/start_button\" />\r\n</androidx.constraintlayout.widget.ConstraintLayout>\r\n```\r\n\r\n## MainActivity.kt\r\nとりあえず`ViewBinding`を使えるようにしておいてください\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n    }\r\n}\r\n```\r\n\r\n## MainActivityViewModel.kt\r\nを作成して、コピペします。  \r\nしばらくはこのクラスにプログラムを書いていきます\r\n\r\n```kotlin\r\n/**\r\n * [MainActivity]からUI以外のコードを持ってきた。\r\n * */\r\nclass MainActivityViewModel(application: Application) : AndroidViewModel(application) {\r\n\r\n    private val context = application.applicationContext\r\n\r\n}\r\n```\r\n\r\n### ファイルのサイズを取得する\r\nこれからファイルをダウンロードするわけですが、分割してダウンロードするにはまず元のファイルサイズを求めておく必要があります。\r\n\r\nここでほしいのはレスポンスヘッダなので、レスポンスボディをリクエストしない`HEAD`リクエストを飛ばします。\r\n\r\n```kotlin\r\nprivate val okHttpClient = OkHttpClient()\r\n/** HEADリクエストを送信する */\r\nprivate suspend fun getResponseHeader(url: String) = withContext(Dispatchers.IO) {\r\n    // リクエスト\r\n    val request = Request.Builder().apply {\r\n        url(url)\r\n        head() // bodyいらん\r\n    }.build()\r\n    return@withContext okHttpClient.newCall(request).execute()\r\n}\r\n```\r\n\r\n### 分割する関数\r\n長ったらしい。\r\n\r\n```kotlin\r\n/**\r\n * 分割して配列にして返す\r\n * \r\n * @param totalBytes 合計サイズ\r\n * @param splitCount 分割数\r\n * */\r\nprivate fun splitByteList(totalBytes: Long, splitCount: Int): ArrayList<Pair<Long, Long>> {\r\n    // あまりが出ないほうがおかしいので余りを出す\r\n    val amari = totalBytes % splitCount\r\n    // あまり分を引いて一個のリクエストでのバイト数を決定\r\n    val splitByte = (totalBytes - amari) / splitCount\r\n    // 配列にして返す\r\n    val byteList = arrayListOf<Pair<Long, Long>>()\r\n    // 2回目のループなら1回目の値が入ってる。前の値\r\n    var prevByte = 0L\r\n    while (true) {\r\n        // ピッタリ分けたいので\r\n        if (totalBytes >= prevByte) {\r\n            /***\r\n             * 最後余分に取得しないように。\r\n             * true(splitByte足しても足りない)ならsplitByteを足して、falseならtotalByteを渡して終了\r\n             * */\r\n            val toByte =\r\n                if (totalBytes > (prevByte + splitByte)) prevByte + splitByte else totalBytes\r\n            byteList.add(Pair(prevByte, toByte))\r\n            prevByte += splitByte + 1 // 1足して次のバイトからリクエストする\r\n        } else break\r\n    }\r\n    return byteList\r\n}\r\n```\r\n\r\nちなみにこの関数の返り値はこんな感じになります\r\n\r\n```kotlin\r\n// 685MB\r\nviewModel.splitByteList(719200584, 5)\r\n// return\r\n[\r\nPair(0, 143840116),\r\nPair(143840117, 287680233),\r\nPair(287680234, 431520350),\r\nPair(431520351, 575360467),\r\nPair(575360468, 719200584),\r\n]\r\n```\r\n\r\n\r\n### ファイルをダウンロードする\r\n今回は`HEAD`ではなく`GET`リクエストですよ！  \r\n\r\nと、その前にダウンロードした分割ファイルを持っておくわけにもいかないので、一旦ファイルに書き込みます。その保存先フォルダを先に作っておきます\r\n\r\n```kotlin\r\n/** 一時保存先 */\r\nprivate val tmpFolder = File(context.externalCacheDir, \"split_file\").apply { mkdir() }\r\n```\r\n\r\nそしたらダウンロードする関数を書きましょう。拡張子にファイルの順番を付けてます\r\n\r\n```kotlin\r\n/**\r\n * 範囲リクエストを送信する\r\n *\r\n * @param fromByte こっから\r\n * @param toByte ここまで\r\n * @param count 何個目か\r\n * @param fileName ファイル名\r\n * */\r\nprivate suspend fun requestFile(url: String, fromByte: Long, toByte: Long, count: Int,fileName: String) = withContext(Dispatchers.IO) {\r\n    // リクエスト\r\n    val request = Request.Builder().apply {\r\n        url(url)\r\n        addHeader(\"Range\", \"bytes=${fromByte}-${toByte}\")\r\n        get()\r\n    }.build()\r\n    val response = okHttpClient.newCall(request).execute()\r\n    val inputStream = response.body?.byteStream()\r\n    // ファイル作成。拡張子に順番を入れる\r\n    val splitFile = File(tmpFolder, \"${fileName}.${count}\").apply { createNewFile() }\r\n    val splitFileOutputStream = splitFile.outputStream()\r\n    // 書き込む\r\n    val buffer = ByteArray(1024 * 1024)\r\n    while (true) {\r\n        val read = inputStream?.read(buffer)\r\n        if (read == -1 || read == null) {\r\n            // 終わりなら無限ループ抜け\r\n            break\r\n        }\r\n        splitFileOutputStream.write(buffer, 0, read)\r\n    }\r\n    inputStream?.close()\r\n    splitFileOutputStream.close()\r\n}\r\n```\r\n\r\n### ファイルを結合する関数\r\n\r\n結合したファイル(`File`)を返してあげてください。後で使う  \r\n\r\n```kotlin\r\n/**\r\n * すべてのファイルを一つにまとめ\r\n * @param fileName ファイル名\r\n * @return 結合ファイル\r\n * */\r\nprivate suspend fun multipleFileToOneFile(fileName: String) = withContext(Dispatchers.Default) {\r\n    // 最終的なファイル\r\n    val resultFile = File(context.getExternalFilesDir(null), fileName).apply { createNewFile() }\r\n    tmpFolder.listFiles()\r\n        ?.sortedBy { file -> file.extension } // 並び替え。男女男男女男女\r\n        ?.map { file -> file.readBytes() } // readBytes()は2GBまでしか対応してない(さすがにないやろ)\r\n        ?.forEach { bytes -> resultFile.appendBytes(bytes) }\r\n    // フォルダを消す\r\n    tmpFolder.deleteRecursively()\r\n    // ファイルを返す\r\n    return@withContext resultFile\r\n}\r\n```\r\n\r\n### ユーザーの選んだ保存先に保存する\r\nまだユーザーに保存先を選んでもらう処理は書いてませんが。保存先を選ぶとファイルパス、、、ではなく`Uri`が返ってくるのでこれを使います。  \r\n\r\n\r\n```kotlin\r\n/**\r\n * ファイルをUriの場所に書き込んで、元のファイル（[resultFile]）を削除する\r\n *\r\n * @param resultFile 完成したファイル\r\n * @param uri Activity Result APIでもらえるUri\r\n * */\r\nprivate suspend fun moveFile(resultFile: File, uri: Uri) = withContext(Dispatchers.IO) {\r\n    val contentResolver = context.contentResolver\r\n    // outputStreamをもらう\r\n    val outputStream = contentResolver.openOutputStream(uri)\r\n    outputStream?.write(resultFile.readBytes()) // readBytes()は大きいファイルでは使うべきではない\r\n    outputStream?.close()\r\n    // 元のファイルを消す\r\n    resultFile.deleteRecursively()\r\n}\r\n```\r\n\r\n### Activityから呼ぶ関数を書く\r\n\r\n`start`関数を書いて、Activityからはこの関数を呼ぶことにします\r\n\r\n```kotlin\r\n/**\r\n * ファイルダウンロードを開始する\r\n * @param fileName ファイル名\r\n * @param uri 保存先\r\n * @param url URL\r\n * */\r\nfun start(url: String, uri: Uri, fileName: String) {\r\n    viewModelScope.launch {\r\n        val responseHeader = getResponseHeader(url)\r\n        // 合計サイズ\r\n        val contentLength = responseHeader.headers[\"Content-Length\"]!!.toLong()\r\n        // 分割。とりあえず5分割\r\n        val splitList = splitByteList(contentLength, 5)\r\n        // リクエスト\r\n        splitList\r\n            .mapIndexed { index, pair ->\r\n                // asyncで並列実行\r\n                async { requestFile(url, pair.first, pair.second, index, fileName) }\r\n            }.map { deferred ->\r\n                // すべてのasyncを待つ\r\n                deferred.await()\r\n            }\r\n        // ファイルを結合\r\n        val resultFile = multipleFileToOneFile(fileName)\r\n        // ファイルを移動させて完成\r\n        moveFile(resultFile, uri)\r\n        // おしまい\r\n        Toast.makeText(context, \"おわり\", Toast.LENGTH_SHORT).show()\r\n    }\r\n}\r\n```\r\n\r\n### ここまでのコード\r\n\r\n```kotlin\r\n/**\r\n * [MainActivity]からUI以外のコードを持ってきた。\r\n * */\r\nclass MainActivityViewModel(application: Application) : AndroidViewModel(application) {\r\n\r\n    private val context = application.applicationContext\r\n\r\n    /** シングルトンにすべき */\r\n    private val okHttpClient = OkHttpClient()\r\n\r\n    /** 一時保存先 */\r\n    private val tmpFolder = File(context.externalCacheDir, \"split_file\").apply { mkdir() }\r\n\r\n    /**\r\n     * ファイルダウンロードを開始する\r\n     * @param fileName ファイル名\r\n     * @param uri 保存先\r\n     * @param url URL\r\n     * */\r\n    fun start(url: String, uri: Uri, fileName: String) {\r\n        viewModelScope.launch {\r\n            val responseHeader = getResponseHeader(url)\r\n            // 合計サイズ\r\n            val contentLength = responseHeader.headers[\"Content-Length\"]!!.toLong()\r\n            // 分割。とりあえず5分割\r\n            val splitList = splitByteList(contentLength, 5)\r\n            // リクエスト\r\n            splitList\r\n                .mapIndexed { index, pair ->\r\n                    // asyncで並列実行\r\n                    async { requestFile(url, pair.first, pair.second, index, fileName) }\r\n                }.map { deferred ->\r\n                    // すべてのasyncを待つ\r\n                    deferred.await()\r\n                }\r\n            // ファイルを結合\r\n            val resultFile = multipleFileToOneFile(fileName)\r\n            // ファイルを移動させて完成\r\n            moveFile(resultFile, uri)\r\n            // おしまい\r\n            println(\"おわり\")\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * HEADリクエストを送信する\r\n     * @param url URL\r\n     * */\r\n    private suspend fun getResponseHeader(url: String) = withContext(Dispatchers.IO) {\r\n        // リクエスト\r\n        val request = Request.Builder().apply {\r\n            url(url)\r\n            head() // bodyいらん\r\n        }.build()\r\n        return@withContext okHttpClient.newCall(request).execute()\r\n    }\r\n\r\n    /**\r\n     * 分割して配列にして返す\r\n     *\r\n     * @param totalBytes 合計サイズ\r\n     * @param splitCount 分割数\r\n     * */\r\n    private fun splitByteList(totalBytes: Long, splitCount: Int): ArrayList<Pair<Long, Long>> {\r\n        // あまりが出ないほうがおかしいので余りを出す\r\n        val amari = totalBytes % splitCount\r\n        // あまり分を引いて一個のリクエストでのバイト数を決定\r\n        val splitByte = (totalBytes - amari) / splitCount\r\n        // 配列にして返す\r\n        val byteList = arrayListOf<Pair<Long, Long>>()\r\n        // 2回目のループなら1回目の値が入ってる。前の値\r\n        var prevByte = 0L\r\n        while (true) {\r\n            // ピッタリ分けたいので\r\n            if (totalBytes >= prevByte) {\r\n                /***\r\n                 * 最後余分に取得しないように。\r\n                 * true(splitByte足しても足りない)ならsplitByteを足して、falseならtotalByteを渡して終了\r\n                 * */\r\n                val toByte =\r\n                    if (totalBytes > (prevByte + splitByte)) prevByte + splitByte else totalBytes\r\n                byteList.add(Pair(prevByte, toByte))\r\n                prevByte += splitByte + 1 // 1足して次のバイトからリクエストする\r\n            } else break\r\n        }\r\n        return byteList\r\n    }\r\n\r\n    /**\r\n     * 範囲リクエストを送信する\r\n     *\r\n     * @param fromByte こっから\r\n     * @param toByte ここまでのバイト数を返す\r\n     * @param count 何個目か\r\n     * @param fileName ファイル名\r\n     * */\r\n    private suspend fun requestFile(url: String, fromByte: Long, toByte: Long, count: Int, fileName: String) = withContext(Dispatchers.IO) {\r\n        // リクエスト\r\n        val request = Request.Builder().apply {\r\n            url(url)\r\n            addHeader(\"Range\", \"bytes=${fromByte}-${toByte}\")\r\n            get()\r\n        }.build()\r\n        val response = okHttpClient.newCall(request).execute()\r\n        val inputStream = response.body?.byteStream()\r\n        // ファイル作成。拡張子に順番を入れる\r\n        val splitFile = File(tmpFolder, \"${fileName}.${count}\").apply { createNewFile() }\r\n        val splitFileOutputStream = splitFile.outputStream()\r\n        // 書き込む\r\n        val buffer = ByteArray(1024 * 1024)\r\n        while (true) {\r\n            val read = inputStream?.read(buffer)\r\n            if (read == -1 || read == null) {\r\n                // 終わりなら無限ループ抜けて高階関数よぶ\r\n                break\r\n            }\r\n            splitFileOutputStream.write(buffer, 0, read)\r\n        }\r\n        inputStream?.close()\r\n        splitFileOutputStream.close()\r\n    }\r\n\r\n    /**\r\n     * すべてのファイルを一つにまとめて完成\r\n     * @param fileName ファイル名\r\n     * @return 結合ファイル\r\n     * */\r\n    private suspend fun multipleFileToOneFile(fileName: String) = withContext(Dispatchers.Default) {\r\n        // 最終的なファイル\r\n        val resultFile = File(context.getExternalFilesDir(null), fileName).apply { createNewFile() }\r\n        tmpFolder.listFiles()\r\n            ?.sortedBy { file -> file.extension } // 並び替え。男女男男女男女\r\n            ?.map { file -> file.readBytes() } // readBytes()は2GBまでしか対応してない(さすがにないやろ)\r\n            ?.forEach { bytes -> resultFile.appendBytes(bytes) }\r\n        // フォルダを消す\r\n        tmpFolder.deleteRecursively()\r\n        // ファイルを返す\r\n        return@withContext resultFile\r\n    }\r\n\r\n    /**\r\n     * ファイルをUriの場所に書き込んで、元のファイル（[resultFile]）を削除する\r\n     *\r\n     * @param resultFile 完成したファイル\r\n     * @param uri Activity Result APIでもらえるUri\r\n     * */\r\n    private suspend fun moveFile(resultFile: File, uri: Uri) = withContext(Dispatchers.IO) {\r\n        val contentResolver = context.contentResolver\r\n        // outputStreamをもらう\r\n        val outputStream = contentResolver.openOutputStream(uri)\r\n        outputStream?.write(resultFile.readBytes()) // readBytes()は大きいファイルでは使うべきではない\r\n        outputStream?.close()\r\n        // 元のファイルを消す\r\n        resultFile.deleteRecursively()\r\n    }\r\n\r\n}\r\n```\r\n\r\n## MainActivity.kt\r\n\r\nStorage Access Frameworkを開いてユーザーに保存先を選んでもらいます  \r\nあと`ViewModel`も使えるようにしておいてね  \r\nあとURLにはダウンロードしたいファイルのURLを入れておいてください。\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    private val viewModel by viewModels<MainActivityViewModel>()\r\n\r\n    /** URL */\r\n    private val URL = \"\"\r\n\r\n    /** ファイル名 */\r\n    private val FILE_NAME = \"download.mp4\"\r\n\r\n    /** Activity Result API コールバック */\r\n    private val callback = registerForActivityResult(ActivityResultContracts.CreateDocument()) { uri ->\r\n        if (uri != null) {\r\n            // ViewModelに書いたダウンロード関数を呼ぶ\r\n            viewModel.start(URL, uri, FILE_NAME)\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        viewBinding.startButton.setOnClickListener {\r\n            // 選ばせる\r\n            callback.launch(FILE_NAME)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nこれでボタンを押して、保存先を選ぶとダウンロードが開始されるはずです。  \r\nプログレスバーは動きませんが\r\n\r\n## プログレスバーを動かす\r\n\r\n変数を宣言して\r\n\r\n```kotlin\r\n/** 合計バイト */\r\nprivate var totalByte = 0L\r\n\r\n/** 書き込みが終わったバイト */\r\nprivate var progressByte = 0L\r\n\r\n/** 進捗LiveData */\r\nprivate val _progressLiveData = MutableLiveData<Int>()\r\n\r\n/** 外部に公開する進捗LiveData */\r\nval progressLiveData: LiveData<Int> = _progressLiveData\r\n```\r\n\r\nstart関数を少し書き足す\r\n\r\n```kotlin\r\n/**\r\n * ファイルダウンロードを開始する\r\n * @param fileName ファイル名\r\n * @param uri 保存先\r\n * @param url URL\r\n * */\r\nfun start(url: String, uri: Uri, fileName: String) {\r\n    totalByte = 0L\r\n    progressByte = 0L\r\n    viewModelScope.launch {\r\n        val responseHeader = getResponseHeader(url)\r\n        // 合計サイズ\r\n        val contentLength = responseHeader.headers[\"Content-Length\"]!!.toLong()\r\n        totalByte = contentLength\r\n        // 分割。とりあえず5分割\r\n        val splitList = splitByteList(contentLength, 5)\r\n        // リクエスト\r\n        splitList\r\n            .mapIndexed { index, pair ->\r\n                // asyncで並列実行\r\n                async { requestFile(url, pair.first, pair.second, index, fileName) }\r\n            }.map { deferred ->\r\n                // すべてのasyncを待つ\r\n                deferred.await()\r\n            }\r\n        // ファイルを結合\r\n        val resultFile = multipleFileToOneFile(fileName)\r\n        // ファイルを移動させて完成\r\n        moveFile(resultFile, uri)\r\n        // おしまい\r\n        _progressLiveData.postValue(100)\r\n        println(\"おわり\")\r\n    }\r\n}\r\n```\r\n\r\n`requestFile`関数に書き足す\r\n\r\n```kotlin\r\n/**\r\n * 範囲リクエストを送信する\r\n *\r\n * @param fromByte こっから\r\n * @param toByte ここまでのバイト数を返す\r\n * @param count 何個目か\r\n * @param fileName ファイル名\r\n * */\r\nprivate suspend fun requestFile(url: String, fromByte: Long, toByte: Long, count: Int, fileName: String) = withContext(Dispatchers.IO) {\r\n    // リクエスト\r\n    val request = Request.Builder().apply {\r\n        url(url)\r\n        addHeader(\"Range\", \"bytes=${fromByte}-${toByte}\")\r\n        get()\r\n    }.build()\r\n    val response = okHttpClient.newCall(request).execute()\r\n    val inputStream = response.body?.byteStream()\r\n    // ファイル作成。拡張子に順番を入れる\r\n    val splitFile = File(tmpFolder, \"${fileName}.${count}\").apply { createNewFile() }\r\n    val splitFileOutputStream = splitFile.outputStream()\r\n    // 書き込む\r\n    val buffer = ByteArray(1024 * 1024)\r\n    while (true) {\r\n        val read = inputStream?.read(buffer)\r\n        if (read == -1 || read == null) {\r\n            // 終わりなら無限ループ抜けて高階関数よぶ\r\n            break\r\n        }\r\n        splitFileOutputStream.write(buffer, 0, read)\r\n        // 進捗\r\n        progressByte += read\r\n        val progress = ((progressByte / totalByte.toFloat()) * 100).toInt()\r\n        // LiveData送信\r\n        if (_progressLiveData.value != progress) {\r\n            _progressLiveData.postValue(progress)\r\n        }\r\n    }\r\n    inputStream?.close()\r\n    splitFileOutputStream.close()\r\n}\r\n```\r\n\r\n\r\n最後に`MainActivity`\r\n\r\n```kotlin\r\noverride fun onCreate(savedInstanceState: Bundle?) {\r\n    super.onCreate(savedInstanceState)\r\n    setContentView(viewBinding.root)\r\n    viewBinding.startButton.setOnClickListener {\r\n        // 選ばせる\r\n        callback.launch(FILE_NAME)\r\n    }\r\n    // 進捗\r\n    viewModel.progressLiveData.observe(this) { progress ->\r\n        println(progress)\r\n        viewBinding.progressBar.progress = progress\r\n        if (progress == 100) {\r\n            Toast.makeText(this, \"おわり\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nこれでプログレスバーも動くと思います。\r\n\r\n# やってること\r\n- ファイルのサイズを求める\r\n- 分割数に合わせてバイト数を決定\r\n- 並列ダウンロード。一旦保存\r\n- 一旦保存したファイルを一つにまとめて保存\r\n- UriからOutputStreamを取得して書き込む\r\n- まとめたファイル、一旦保存したファイルを削除\r\n\r\n# MediaStore.Download の例\r\n\r\nまーじでAndroidのファイル操作どうにかならねえのこれ\r\n\r\n```kotlin\r\n/**\r\n * MediaStore.Downloadを利用してダウンロードフォルダに入れる\r\n * \r\n * Android 10以降のみ対応\r\n * */\r\nprivate fun insertFileToDownloadFolder(fileName: String): Uri? {\r\n    val contentResolver = context.contentResolver\r\n    val contentUri = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)\r\n    val contentValues = ContentValues().apply {\r\n        put(MediaStore.Downloads.DISPLAY_NAME, fileName)\r\n    }\r\n    // ダウンロードフォルダにデータを追加。Uriを受け取る\r\n    val uri = contentResolver.insert(contentUri, contentValues)\r\n    return uri\r\n}\r\n```\r\n\r\nそして`start`関数を少し書き換える\r\n\r\n```kotlin\r\n/**\r\n * ファイルダウンロードを開始する\r\n * @param fileName ファイル名\r\n * @param url URL\r\n * */\r\nfun start(url: String, fileName: String) {\r\n    totalByte = 0L\r\n    progressByte = 0L\r\n    viewModelScope.launch {\r\n        val responseHeader = getResponseHeader(url)\r\n        // 合計サイズ\r\n        val contentLength = responseHeader.headers[\"Content-Length\"]!!.toLong()\r\n        totalByte = contentLength\r\n        // 分割。とりあえず5分割\r\n        val splitList = splitByteList(contentLength, 5)\r\n        // リクエスト\r\n        splitList\r\n            .mapIndexed { index, pair ->\r\n                // asyncで並列実行\r\n                async { requestFile(url, pair.first, pair.second, index, fileName) }\r\n            }.map { deferred ->\r\n                // すべてのasyncを待つ\r\n                deferred.await()\r\n            }\r\n        // ファイルを結合\r\n        val resultFile = multipleFileToOneFile(fileName)\r\n        // ファイルを移動させて完成\r\n        val uri = insertFileToDownloadFolder(fileName)\r\n        if (uri != null) {\r\n            moveFile(resultFile, uri)\r\n            // おしまい\r\n            _progressLiveData.postValue(100)\r\n            println(\"おわり\")\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`MainActivity`の方も書き換えます\r\n\r\n```kotlin\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val viewBinding by lazy { ActivityMainBinding.inflate(layoutInflater) }\r\n\r\n    private val viewModel by viewModels<MainActivityViewModel>()\r\n\r\n    /** URL */\r\n    private val URL = \"\"\r\n\r\n    /** ファイル名 */\r\n    private val FILE_NAME = \"download.mp4\"\r\n\r\n    /** Activity Result API コールバック */\r\n    private val callback = registerForActivityResult(ActivityResultContracts.CreateDocument()) { uri ->\r\n        if (uri != null) {\r\n            // ViewModelに書いたダウンロード関数を呼ぶ\r\n            // viewModel.start(URL, FILE_NAME)\r\n        }\r\n    }\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(viewBinding.root)\r\n\r\n        viewBinding.startButton.setOnClickListener {\r\n            // ダウンロードする\r\n            // callback.launch(FILE_NAME)\r\n            viewModel.start(URL, FILE_NAME)\r\n\r\n        }\r\n\r\n        // 進捗\r\n        viewModel.progressLiveData.observe(this) { progress ->\r\n            println(progress)\r\n            viewBinding.progressBar.progress = progress\r\n            if (progress == 100) {\r\n                Toast.makeText(this, \"おわり\", Toast.LENGTH_SHORT).show()\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n# おわりに\r\nつかれた。ソースコード置いておきますね。  \r\n\r\nhttps://github.com/takusan23/OkHttpRangeDownload"},{"title":"2020年まとめ","link":"/posts/omisoka_2020/","markdown":"\r\n冬休み短くね？\r\n\r\n# たちみどろいど\r\n2020年12月31日 17時48分 現在、releaseブランチ（ストアにリリースしたコード、masterは開発ブランチ）の情報です。\r\n\r\n## 行数\r\n`Intelij IDEA`のプラグイン、[Statistic](https://plugins.jetbrains.com/plugin/4509-statistic)で計測しました。\r\n\r\nimport含め **29,991行**\r\n\r\nimportなし **20,294行**\r\n\r\nimportなしの状態でレポート用紙(一枚34行)換算すると：**596枚**ぐらい？（20294/34）\r\n\r\n### コメント文の行数\r\n多分これのせいで余計にカウントされてる。というわけでコメントの行数を見ていこう。\r\n\r\nコメント **6,669行**\r\n\r\nレポート用紙(一枚34行)で換算すると：**196枚**ぐらい？(6669/34)\r\n\r\n### コミット回数\r\n\r\nターミナルで叩くと出てくると思います。\r\n\r\n```\r\n$ git rev-list --count HEAD --since=\"Jan 01 2020\" --before=\"Dec 31 2020\"\r\n```\r\n\r\n参考：https://stackoverflow.com/questions/36079884/count-git-commits-per-period\r\n\r\n**552**コミットでした。(コロナで休校長かったしまあ？)  \r\n\r\n## その他\r\n\r\n- Qiita消して自作ブログ(Nuxt.js)に乗り換えた\r\n    - でもなんか検索にのらないことが多い\r\n\r\n- コロナカレンダー作りました\r\n    - https://tokyo-covid19-calendar.netlify.app/\r\n    - Netlify + GitHub Actions + Nuxt  製です。\r\n    - https://github.com/takusan23/tokyo_covid19_calendar\r\n\r\nんじゃ紅白見てくるわ"},{"title":"2022年まとめ","link":"/posts/omisoka_2022/","markdown":"\r\n2021はなぜかありません。\r\n\r\nあと10分ぐらいで年越しなので。\r\n\r\n# （よく）聞いたエロゲソング\r\nなんだかんだCD集めてました\r\n\r\n![Imgur](https://imgur.com/iuDE8vI.png)\r\n\r\n# すまほ\r\n手持ちXperiaがSIMフリーのになった  \r\n回線`docomo`の他、楽天モバイルがなくなって、`povo`と`linemo`が新たに加わりました（`NewRadioSupporter`デュアルSIM化により端末と回線を新調）  \r\n安く本家回線が手に入ります（本家回線なのかな？）\r\n\r\n# Git\r\nあんまりコミットできませんでした。\r\n\r\n# 記事\r\n2022年書いた記事です。\r\n\r\n[NewRadioSupporterがデュアルSIM対応に対応しました](/posts/android_new_radio_supporter_dual_sim_update/)  \r\n[2022年まとめ](/posts/omisoka_2022/)  \r\n[WindowsAppSDK の WinUI 3 に入門したら日本語が文字化けして出鼻をくじかれた話](/posts/windows_winui3_xml_charset/)  \r\n[AndroidのARCoreでGitHubの草(skyline)を表示させるまで。without Sceneform時代のARCoreを試す。](/posts/android_ar_core_github_skyline/)  \r\n[Next.js 13 にした (しただけ)](/posts/next_js_13_migration/)  \r\n[Wear OS からスマホのブラウザを開く](/posts/android_wear_os_open_smartphone_browser/)  \r\n[Wear OS のコンプリケーションを作りたい](/posts/android_wear_os_complication/)  \r\n[WebMを攻略する](/posts/video_webm_spec/)  \r\n[JavaScriptでパソコンの画面録画とMPEG-DASHでライブ配信](/posts/javascript_webm_livestreaming/)  \r\n[Android単体でWebMとMPEG-DASHを使ったライブストリーミング](/posts/android_standalone_webm_livestreaming/)  \r\n[ブラウザへAndroidの画面をミラーリングできるアプリ、ぜろみらーを作った](/posts/android_zero_mirror/)  \r\n[Androidアプリ側でキーボードの学習機能を無効にしたい](/posts/android_disable_keybord_learning/)  \r\n[Node.jsのプロジェクトをGitHubで開いたら脆弱性があると言われたとき](/posts/node_js_github_dependencies/)  \r\n[自作Androidライブラリを Maven Central へ公開する](/posts/android_library_publish_to_maven_central/)  \r\n[Hello Android 13。懐中電灯編](/posts/android_13_camera_flash_torch_level/)  \r\n[AndroidのMediaCodecを利用して複数の動画を繋げて一つの動画にする](/posts/android_mediacodec_merge_video/)  \r\n[Jetpack Compose の TextField でカーソルの位置変更](/posts/android_jc_textfield_cursor/)  \r\n[Hello Android 13。ダイナミックカラーのアイコン編 (Android 12もあるよ)](/posts/android_13_dynamic_color_icon/)  \r\n[Androidアプリのビルドした日付をアプリ側から取得できるようにする](/posts/android_build_date_resource/)  \r\n[MUIのGridを使って残りを埋めたり真ん中においたり](/posts/react_material_ui_responsive/)  \r\n[GitHub Actions で AndroidのリリースAPK作成](/posts/github_actions_android_release_apk/)  \r\n[Android Studio Bumblebee でトップレベルの build.gradle の書き方が変わったみたい](/posts/android_gradle_bumblebee/)  \r\n[JetpackComposeで親のコンポーネントでもクリックイベントがほしい](/posts/android_jc_parent_component_click/)  \r\n[Android Studio Bumblebee にアップデートしたら ADB が起動しない（ずっと Loading Devices... ）](/posts/android_studio_bumblebee_not_start_adb/)  \r\n[Next.jsへGoogleアナリティクスのGA4とUAを共存させる](/posts/next_js_google_analytics_ua_ga4/)  \r\n[Next.jsでブログ作り直したのでその際に大変だったこと](/posts/taihendattakoto_next_js_blog/)  \r\n\r\n# 以上です。また来年"},{"title":"PlayStoreへアプリを公開する","link":"/posts/play_store_upload/","markdown":"神様になった日の幼馴染かわいい。んだけど忙しいから見る時間がない。\n\n# 本題\nPlayConsoleを使い、PlayStoreへアプリを公開する方法を書きます。  \n\n# <span style=\"color:red\">取り返しのつかないことまとめ</span>\nとそのまえに、取り返しのつかないことを書いておきます。覚えてる範囲で\n- 公開するとアプリケーションIDの変更ができない\n    - 他と被らないようにドメインを使う例が多いけど別に**被らなければ何でもいいと思う**\n- aab生成時(apkもそう)に使うKeyStoreってやつ（署名鍵）、あれをなくすと公開できなくなる。\n    - アップロード時の本人確認でこの署名鍵で署名されたかどうかで使ってるそう。\n    - でもなんか Google Play App Signing ってやつを使っていれば署名鍵を再度登録してもらえるとか \n        - Google先生と要相談\n- **KeyStore作成時に書いたCertificateは見ようと思えば見れる**\n    - **本名**とか**住所**を入れる欄があるけど、入れるとまずい可能性がある\n    - 見られたくなければ空白にできるのでそれでいい\n- 一度公開すると消せない\n    - いやインターネットである以上避けれんやろｗｗｗって話ではある\n        - Twitterならツイ消しで一応消すことは出来ますが、Playストアに関しては少し違います。\n        - **Playストアからアプリを消した際の挙動**\n            - 一度もアプリを入れたことのないユーザー\n                - **URLから直接開いても見つけることが出来ない**\n            - 一度インストールしたことがあるユーザー\n                - **URLから直接開けばインストールできる**\n                - このせいで完全に消すことが出来ない。\n    - なんか知らんうちにapkがよくわからんところで配信される\n        - なんかめっちゃあやしい\n\n# PlayConsoleを利用できるようにする\n25ドル払ってください。確かKyashで払えた気がします。  \n私が払った時は2863円でした。今調べたら2583円らしいです。大統領選のせい？か知りませんが円高になってますね。\n\n# 署名鍵を作成する - Android Studioでの作業\nメニューバーのここです。\n\n![Imgur](https://imgur.com/SbJfYuR.png)\n\nそしたら、aabの方を選んでください。  \n\n![Imgur](https://imgur.com/AdgEBP6.png)\n\n## 署名鍵があれば\nKeyStore作成時に設定した値\n- Key store password\n- Key alias\n- Key password\nを入れて、\n\n![Imgur](https://imgur.com/9Ax3dPK.png)\n\n<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">Next</span>を押して次へ進みます。\n\n## 署名鍵が無い時は作成\n<span style=\"border: solid 1px gray;padding:2px;border-radius:5px\">Create new...</span>を押してください。\n\n![Imgur](https://imgur.com/k67IYmO.png)\n\nこんな画面が出るので、項目を埋めていきましょう。\n\n![Imgur](https://imgur.com/d8FPCip.png)\n\n必須項目は以下です。\n\n| 名前                | 詳細                                                                                              |\n|---------------------|---------------------------------------------------------------------------------------------------|\n| Key store path      | 署名鍵の保存先です。プロジェクトに入れるとGitHubへ公開されちゃいそうな気がするので気をつけて。    |\n| Password            | パスワード。6文字以上                                                                             |\n| Confirm             | もう一回パスワード入力                                                                            |\n|                     |                                                                                                   |\n| Key                 |                                                                                                   |\n| Alias               | 署名鍵の名前？                                                                                    |\n| Password            | さっき作成したパスワードでも特にエラーは出なかったけど、Androidは違うパスワードを推奨してるっぽい |\n| Confirm             | もう一回パスワード入力                                                                            |\n| Validity            | 25年以上                                                                                          |\n|                     |                                                                                                   |\n| Certificate         | 注意：見ようと思えば以下の項目は見ることが出来ます。                                              |\n| First and Last Name | 鍵の所有者情報。これだけ必須項目                                                                  |\n\n忘れると二回目以降公開できなくなるので十分気をつけましょう。\n\n![Imgur](https://imgur.com/gX7vYDI.png)\n\n入力できたら、OKを押しましょう。なんか<span style=\"color:red\">推奨していません</span>みたいなメッセージが出るけど、そのまま閉じればおｋです。\n\n<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">Next</span>を押して次へ進みます。\n\n![Imgur](https://imgur.com/9Ax3dPK.png)\n\n最後、releaseを選択して、<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">Finish</span>を押して.aabを生成します。\n\n![Imgur](https://imgur.com/UPqzNgi.png)\n\nこれでaabファイルを用意できました。次はブラウザでの作業です。\n\n# PlayConsoleへ登録\nUIが変わりましたね（）\n\n## アプリを作成\nを押します。\n\n![Imgur](https://imgur.com/4MVCOH6.png)\n\nそしたら項目を埋めていきましょう。\n\n![Imgur](https://imgur.com/CodMVOr.png)\n\n## 米国輸出法 #とは\nよく知らないけど、  \n**Google Play Storeはアメリカにあってアプリを入れること それは アメリカから日本へアプリを輸出している 事と同じ！**  \nと解釈されるらしく、違反していないことにチェックを入れる必要があります。  \n\n英語：https://www.bis.doc.gov/index.php/policy-guidance/encryption\n\n\n<details>\n<summary>（多分）読む必要がないので折りたたんでおく</summary>\n\n<h3>こっから合ってるかわからん</h3>\n法律わからん上に英語なので詰んでる。専門家とかじゃなく、ただの学生だからそれでもよければ。\n\nで、米国輸出法ってのはどうやら暗号化技術についての話らしく、  \nインターネットを扱う場合はHTTPSがもれなく暗号化技術に当たる。\n\n<h3>EARのサイトを見てみる</h3>\n有志?の日本語版をお借りして見ていきましょう。\n\nhttps://www009.web.fc2.com/cipher5/Encryption_0.htm\n\n**EARの対象とならない暗号品目**を開いてみる\n\nhttps://www009.web.fc2.com/cipher5/notEAR.htm\n\n<p style=\"border: solid 1px red;\">\n・　例えば、スマートフォン又はコンピュータ用に作成されたアプリであって、マスマーケット基準（カテゴリー5 パート2の注3で規定される基準）を満たすもののうち、無料で入手可能とされるものは、\"一般に入手できる\"とみなされます。 この場合、あなたは、自己番号分類報告要件を伴う5D992.cとしての自己番号分類（又はBISへの番号分類請求の提出）により、740.17 (b)(1)又は(b)(3)に基づくマスマーケット要求事項を最初に一度だけ順守しなければなりません。 その後、当該品目が一般に入手可能とされた場合（例えば、無料のダウンロード）、それ以降はEARの対象でないとみなされます。\n</p>\n\n例あるやんけ！  \n第5編注3に記載を見てみる\nhttps://www009.web.fc2.com/EAR_J/J774-5-2.pdf#Note3\n\n<p style=\"border: solid 1px red\">\n・鍵長が 64 ビット超の対称アルゴリズム<br>\n・鍵長が 768 ビット超の非対称アルゴリズム<br>\n・鍵長が 128 ビット超の楕円暗号アルゴリズム<br>\nこれらに該当する場合は、<span style=\"color:red\">番号分類請求又は自己番号分類報告</span>を提出しないといけない\n</p>\n\n何のことだかさっぱりですが、HTTPSは該当する模様。よって年次自己分類報告書を提出する必要がある模様。初耳（）\n\n参考ページ\n- https://docs.microsoft.com/ja-jp/windows/uwp/security/export-restrictions-on-cryptography\n- https://support.google.com/googleplay/android-developer/answer/113770?hl=ja\n- https://www.bis.doc.gov/index.php/policy-guidance/encryption/1-encryption-items-not-subject-to-the-ear\n- http://tmurakam.hatenablog.com/?page=1318328575\n\n</details>\n<br>\n\n**iOSのAppStoreではHTTPS使ってんなら「年次自己分類報告書」書けよな**って言われてるらしいので、  \nAndroidでもHTTPSを利用したなら書かないといけないっぽいです。やべーそんなこと一回もやったこと無いぞ\n\n提出方法の有志？日本語版はこちらに：https://www009.web.fc2.com/cipher5/Howto_file_selfClassify.htm\n\n詳しくは各自調べてください。\n\nとりあえずチェックをいれてアプリを作成しましょう(今回のアプリではインターネット使ってない)\n\n![Imgur](https://imgur.com/9XNAAk7.png)\n\n# 初期設定\n\n~~前のUIだと入力が終わるとナビゲーションドロワーにチェックマークがついたんだけど新UIには引き継がれなかったか~~昔の話は置いておいて手順を踏んでいきましょう。\n\n![Imgur](https://imgur.com/McE3Wxk.png)\n\n## ストアの設定\nで、PlayStoreで公開されるメアドを入力する必要があるので、公開されてもいいメアドを用意しておきましょう。\n\n## メインのストアの掲載情報\nPlayストアに表示する情報ですね。ここに売り文句を書いていきましょう。  \n\nアイコンの画像ですが、`Android Studio`でアイコンを設定した際に、`src/main/ic_launcher-playstore.png`に生成されてると思うのでそれを使えばいいと思います。  \nもしアイコンを描く際、角を丸くする加工はPlayストアでやってくれるので四角い画像で作成しましょう。  \n\n### フィーチャー グラフィック\nはどこで使ってるのかよくわかりません。少し前のPlayストアならTwitterのヘッダーみたいに表示されてた気がしますが、いつの間にかなくなってたので私は適当に作って入れてます。\n\n![Imgur](https://imgur.com/et7Q7WJ.png)\n\n### スクリーンショット\n私はAndroid StudioのAndroidエミュレータを使ってます。  \n端末には**Pixel 2**を使ってます。Pixel 3 XL だとなんかサイズが合わなくてアップロード弾かれた。\n\nそういえばGoogleフォトの無料無制限アップロードがなくなるそうですね。SDカードの時代復活？\n\nあと7インチタブレット、10インチタブレット用のスクリーンショットを要求されてるように見えますが、最低限スマホ用のスクショがあれば通ります。\n\n# アプリ公開\n早速製品版として公開しましょう！。ナビゲーションドロワーの中から製品版を探して選んでください。\n\n![Imgur](https://imgur.com/7NQDgPs.png)\n\n<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">新しいリリースを作成</span>をえらんでaabをアップロードする画面へ進みます。  \n\n## Google Play アプリ署名\n\n<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">次へ</span>を選んでこの機能を有効にしましょう。  \n- aab形式でアプリを提出する際はこれを有効にしておく必要がある模様。\n- **一番最初に作ったKeyStoreとは別物で、こっち(Google Play アプリ署名)に関してはこれ以降触ることはないです**\n    - 開発者がaabをアップロードする際の本人確認として使うのが、`一番最初に作ったKeyStore`。\n    - ユーザーがアプリの更新の際に開発元が同じかどうかの証明に使うのが、`Google Play アプリ署名`。\n        - Googleが管理するので私達は気にする必要なし\n    - aab提出時に使う署名とアプリをダウンロードする際の署名がそれぞれ違うので、万が一`KeyStore`を紛失してもGoogle先生と相談すればリセットしてもらえるし、既存ユーザーはそのままアップデートを受け取れる。\n    - (多分こんな感じだと思う)\n\n![Imgur](https://imgur.com/jTJaRTX.png)\n\nそしたら、**App Bundle と APK**の欄に`app-release.aab`をドラッグアンドドロップさせます。\n\n![Imgur](https://imgur.com/MBEp94q.png)\n\n\n### もしバージョンアップ(二回目以降の提出)させる場合は\n`app`フォルダ内にある`build.gradle`を開き、\n\n```gradle\ndefaultConfig {\n    applicationId \"io.github.takusan23.countdownwidgetlist\"\n    minSdkVersion 21\n    targetSdkVersion 30\n    versionCode 1\n    versionName \"1.0\"\n    testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n}\n```\n\nこの中の\n- `versionCode`\n    - 提出の度に1足す（インクリメント）しないとだめです。\n- `versionName`(一応)\n    - `1.0.1` みたいな感じのバージョンはここで指定します。\n\nこの2つを書き換えておきましょう\n\n\n### リリースノート\n更新内容ですね。最初のバージョンなのでとりあえず初回版とか書いておけばいいと思います。\n\n![Imgur](https://imgur.com/cV2PKiJ.png)\n\nできたら 保存 → リリースのレビュー を押します。\n\n![Imgur](https://imgur.com/xmZcl8M.png)\n\nなんか設定忘れてたっぽいので設定しましょう。\n\n# 国/地域\n製品版の中にあります。\n\n![Imgur](https://imgur.com/Au6CsEq.png)\n\n`国 / 地域を追加`を押して、一覧の中の一番上に有る`国 / 地域`にチェックを入れることですべての国で使えるようになります。多分大丈夫だと思います。(実は他の国でアプリが公開できなくなった事がある)\n\nこれでアプリの公開ができるようになったはずです。\n\n\n<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">製品版として公開を開始</span>を押して出てきたダイアログの<span style=\"padding:2px;border-radius:5px;background:dodgerblue;color:white;\">公開</span>を押すことで審査が始まります。  \nスマホに`PlayConsole`アプリを入れておくことで公開された際にプッシュ通知が行きますよーいくいく。\n\n![Imgur](https://imgur.com/6lr58tu.png)\n\nあとは公開されるのを待つだけです。たのしみ～  \n\n# 追記\n2020年11月14日の19時33分に公開されたとPlayConsoleアプリが通知を飛ばしてきました。"},{"title":"ラズパイに最新版Node.jsを入れる","link":"/posts/raspi-nodejs/","markdown":"\r\nメモ代わり\r\n\r\nURLはバージョン次第で変わると思う（v12.xなら`https://deb.nodesource.com/setup_12.x`になる）\r\n\r\n```terminal\r\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\r\n```\r\n\r\n↓\r\n\r\n```terminal\r\nsudo apt-get install -y nodejs\r\n```\r\n\r\n↓\r\n\r\n```terminal\r\nnode -v\r\n```\r\n\r\nした結果が `v14.9.0`(狙ったバージョン) になって入ればおｋ\r\n\r\n# おわりに\r\n`sudo apt upgrade`←こいつ長すぎ\r\n\r\n# 参考にしました\r\nhttps://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions-enterprise-linux-fedora-and-snap-packages\r\n\r\nhttps://github.com/nodesource/distributions/blob/master/README.md"},{"title":"MUIのGridを使って残りを埋めたり真ん中においたり","link":"/posts/react_material_ui_responsive/","markdown":"どうもこんばんわ。  \r\nViewを目一杯広げる場合Androidだと`weight=\"1\"`なのに、HTMLになると急に意味がわからなくなる。  \r\n自分用メモ\r\n\r\n# 環境\r\n\r\n`MUI`できればいいので`Next.js`使う必要はないと思います。\r\n\r\n| なまえ                        | あたい     |\r\n|-------------------------------|------------|\r\n| 言語                          | TypeScript |\r\n| React                         | 17         |\r\n| Next.js (多分Reactだけでいい) | 12         |\r\n| MUI                           | 5.4.0      |\r\n\r\n# 残りを埋める\r\nこれだけで埋めてくれます、CSS何も分からんからくっそ便利\r\n\r\n## 横\r\n\r\n```tsx\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <Box>\r\n      <Grid container >\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.blue[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs>\r\n          <Card sx={{ backgroundColor: colors.red[100] }}>\r\n            <p>ここは目一杯使ってほしい</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.blue[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\n![Imgur](https://imgur.com/ih47IOr.png)\r\n\r\n`xs=\"auto\"`を付けることで必要最低限は確保してくれます。  \r\n残りは`xs`を付けた要素が使ってくれます。\r\n\r\n詳しくは：  \r\n\r\nhttps://mui.com/components/grid/#auto-layout\r\n\r\n## 縦\r\n\r\n多分`height`の指定が必要だと思う\r\n\r\n```tsx\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <Box>\r\n      <Grid\r\n        container\r\n        direction=\"column\"\r\n        sx={{ minHeight: \"100vh\" }}\r\n      >\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.blue[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs>\r\n          <Card sx={{\r\n            height: \"100%\",\r\n            backgroundColor: colors.yellow[100]\r\n          }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.red[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\n![Imgur](https://imgur.com/JBSInFU.png)\r\n\r\n\r\n# 真ん中\r\n\r\nthx!!!  \r\nhttps://stackoverflow.com/questions/50766693/how-to-center-a-component-in-mui-and-make-it-responsive\r\n\r\n## 横\r\n\r\n```tsx\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <Box>\r\n      <Grid\r\n        container\r\n        direction=\"row\"\r\n        alignContent=\"center\"\r\n        justifyContent=\"center\"\r\n        sx={{ minHeight: \"100vh\" }}\r\n      >\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.blue[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.yellow[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.red[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\n![Imgur](https://imgur.com/PzIUYF0.png)\r\n\r\n## 縦\r\n\r\n```tsx\r\nconst Home: NextPage = () => {\r\n  return (\r\n    <Box>\r\n      <Grid\r\n        container\r\n        direction=\"column\"\r\n        alignContent=\"center\"\r\n        justifyContent=\"center\"\r\n        sx={{ minHeight: \"100vh\" }}\r\n      >\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.blue[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.yellow[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n        <Grid item xs=\"auto\">\r\n          <Card sx={{ backgroundColor: colors.red[100] }}>\r\n            <p>ここは最低限あればいいのよ</p>\r\n          </Card>\r\n        </Grid>\r\n\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default Home\r\n```\r\n\r\n![Imgur](https://imgur.com/b0aJ2Fd.png)"},{"title":"TypeScript+nuxt/contentでこのサイトを作り直している","link":"/posts/remake_ziyuutyou/","markdown":"ここの内容もNext.jsに移行したので関係なくなります。\r\n\r\n[Next.jsで移行したメモはこちら](/posts/taihendattakoto_next_js_blog/)\r\n\r\n\r\n# 本題\r\n`TypeScript`+`nuxt/content`でこのブログを作り直す。  \r\nそこで躓いたところなどを書いていこうと思う。\r\n\r\n# nuxt/content とは\r\nブログを作るときに使える（というか使った）。  \r\n`content`フォルダにマークダウンファイルを置いておけば使える。  \r\n\r\n以下は`content/posts`フォルダの中身を取得するTypeScriptです。\r\n```typescript\r\n// 記事一覧を取り出す\r\nasync asyncData({ $content, params }) {\r\n  const blogItems = await $content(`posts`)\r\n    .sortBy(\"created_at\", \"desc\") // 投稿日時順に並び替える\r\n    .skip((parseInt(params.id) - 1) * 10) // 指定した分飛ばす。今回は表示ページから１引いて１０掛けた答え分飛ばす。（例:2ページ目の場合は(2-1)*10 = 10記事飛ばす）\r\n    .limit(10) // 10記事取得する\r\n    .fetch();\r\n  return { blogItems };\r\n},\r\n```\r\n\r\nこれで`processmd`を使うことはなくなりました。\r\n\r\n# Vuexってのも使った。\r\nVue.js（これはNuxt.jsだけど）全体で管理したい値を扱う場合は`Vuex`ってのを使うそうですよ。  \r\nこのサイトではどこで使っているかと言うとタイトルバーのタイトルを変更するときに使っています。  \r\n今までは`document.getElementById`で無理やり変更してたのでマシになった。  \r\n\r\nコンポーネントを超えて値を管理したいときに使うようです。\r\n\r\n以下はタイトルを入れておくVuexストア例(`store/index.js`)。  \r\nここはTypeScriptではない\r\n```js\r\n// Vue全体で管理したい値。今回はタイトルバーのテキスト\r\nexport const state = () => ({\r\n    barTitle: \"たくさんの自由帳\"\r\n})\r\n\r\n// Vuexの値はここで変更する。\r\nexport const mutations = {\r\n    setBarTitle(state, title) {\r\n        state.barTitle = title\r\n    }\r\n}\r\n```\r\n  \r\nVuexストアから値を取得する例。`this.$store.state.barTitle`ってのがそれ（なんかWARNが消えないけど）\r\n```vue\r\n<!-- タイトル -->\r\n<v-toolbar-title v-show=\"!drawer\" id=\"title\" v-text=\"this.$store.state.barTitle\" />\r\n```\r\n\r\n入れるのはこう。以下例\r\n```typescript\r\n// Vuexてやつでバーのタイトルを変更している。\r\nthis.$store.commit(\"setBarTitle\", \"記事一覧\");\r\n```\r\n\r\n# 大変だったこと\r\n\r\n## TypeScriptわからん問題\r\n記事表示ページでタイトルを取得しようとして、以下のように打つと怒られます。  \r\n解決方法がありそうな気がしますが、とりあえずは`this as any`で黙らせようと思います。  \r\n\r\n```typescript\r\n// エラーでちゃうからanyで。解決方法ある？\r\nconst title = (this as any).article.title;\r\n```\r\n\r\n## created_at vs createdAt 問題\r\nマークダウンの先頭に、わざわざ`created_at`って書いて今すが、実は`nuxt/content`側でも`createdAt`ってのを用意してくれてました。  \r\nただおま環のせいかうまく行かなかったので引き続き`created_at`を書こうと思います。\r\n\r\nあとはまた思い出したら書きたいと思います。\r\n\r\n# よかったところ\r\n\r\n## 更新が早い\r\n更新が早いです。すぐに反映されます。\r\n\r\n```\r\ni Updated .\\content/posts\\remake_ziyuutyou.md                                                           @nuxt/content 20:29:55\r\ni Updated .\\content/posts\\remake_ziyuutyou.md                                                           @nuxt/content 20:29:59\r\ni Updated .\\content/posts\\remake_ziyuutyou.md                                                           @nuxt/content 20:30:14\r\n```\r\n\r\n# HTMLが書ける\r\n\r\n<span style=\"color:red;box-shadow:5px\">htmlが書ける</span>  \r\n<span style=\"color:blue\">以下のようにHTMLを書いてもちゃんと読み込んでくれます</span>\r\n\r\n```html\r\n<span style=\"color:red\">HTMLを理解できる</span>\r\n```\r\n\r\n<span style=\"border: solid 2px green;padding:2px;border-radius:10px\">囲い文字はこんな感じに</span>\r\n\r\n```html\r\n<span style=\"border: solid 2px skyblue;padding:2px;border-radius:10px\">CSSも理解してくれる</span>\r\n```\r\n\r\n\r\n以上です。またなんかあれば書きます"},{"title":"Google Search Consoleにこのサイトのインデックス化してもらおう","link":"/posts/search_console/","markdown":"\r\nちょっと前の記憶から書きます\r\n\r\n# 本題\r\nGoogleの検索にこのサイトを載せてほしい。  \r\nそのために`Google Search Console`を使うといいらしい\r\n\r\n# Google Search Console とは\r\n- Google検索でサイトを発見できるかどうか\r\n    - クローラー？GoogleBot？を弾いてないかとか\r\n- サイトマップを登録して明示的にサイトを登録してもらうとか\r\n    - 今回はこれ\r\n\r\n# Google Search Consoleに登録する\r\n\r\nhttps://search.google.com/search-console/welcome?hl=ja\r\n\r\nを開いて、`URL プレフィックス`の方にURLを入力します。\r\n\r\nで、本来は認証のためにいくつか作業が必要そうですが、**なんかGoogle Domainsでドメインを取ったおかげか自動で認証されました。**\r\n\r\n![Imgur](https://imgur.com/DFjFW8r.png)\r\n\r\n# サイトマップを書き出す\r\n## Nuxt.js での作業\r\n参考にしました：https://ninebolt.net/articles/nuxt-content-sitemap/\r\n\r\n\r\n(前提：`nuxt/content`を利用していること)\r\n\r\nまずは`@nuxt/sitemap`を入れます\r\n\r\n```\r\nnpm install @nuxtjs/sitemap\r\n```\r\n\r\nそしたら、`nuxt.config.js`を開いて、\r\n\r\n\r\n`modules`の配列に足します。\r\n```js\r\n  /*\r\n  ** Nuxt.js modules\r\n  */\r\n  modules: [\r\n    '@nuxt/content',\r\n    '@nuxtjs/sitemap'\r\n  ],\r\n\r\n```\r\n\r\nそうしたら、その下の方に以下のようなコードを書きます。  \r\n私の場合は記事が`posts`に入っていますが、ここは各自書き換えてください。\r\n\r\n```js\r\n  /**\r\n   * サイトマップ書き出し\r\n   */\r\n  sitemap: {\r\n    hostname: 'https://takusan.negitoro.dev',\r\n    routes: async () => {\r\n      const { $content } = require('@nuxt/content')\r\n      const posts = await $content('posts').only(['path']).fetch()\r\n      return posts.map(post => post.path)      \r\n    }\r\n  }\r\n```\r\n\r\n全部くっつけるとこんな感じ\r\n\r\n```js\r\nexport default {\r\n  \r\n  // --- 省略 ---\r\n  \r\n  /*\r\n  ** Nuxt.js modules\r\n  */\r\n  modules: [\r\n    '@nuxtjs/pwa',\r\n    '@nuxtjs/markdownit',\r\n    '@nuxt/content',\r\n    '@nuxtjs/sitemap'\r\n  ],\r\n\r\n  // --- 省略 ---\r\n  \r\n  /**\r\n   * サイトマップ書き出し\r\n   */\r\n  sitemap: {\r\n    hostname: 'https://takusan.negitoro.dev',\r\n    routes: async () => {\r\n      const { $content } = require('@nuxt/content')\r\n      const posts = await $content('posts').only(['path']).fetch()\r\n      return posts.map(post => post.path)      \r\n    }\r\n  }\r\n}\r\n```\r\n\r\n書き足せたら、`localhost:なんとか/sitemap.xml`とブラウザのアドレス欄へ入力してみると、xmlファイルみたいなのが出てくると思います。\r\n\r\nこんなの↓\r\n\r\n```xml\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\r\n<url>\r\n<loc>https://takusan.negitoro.dev/posts/search_console</loc>\r\n</url>\r\n<url>\r\n```\r\n\r\n確認できたら、`nuxt generate`して、NetlifyなりGitHub Pagesなりに公開しましょう。\r\n\r\n(`nuxt generete`すると勝手に`/sitemap.xml`も生成されるそうです)\r\n\r\n## Google Search Console での作業\r\n\r\nナビゲーションドロワーの中から`サイトマップ`を選んで、`新しいサイトマップの追加`にURLを入れます。\r\n\r\n![Imgur](https://imgur.com/szoUpIE.png)\r\n\r\nあとは数日待てばいいらしい。\r\n\r\n# URL 検査 # とは\r\nURLを入れるとoogle検索で見つけることができるか(登録済みかどうか)を確認できる機能です。\r\n\r\n![Imgur](https://imgur.com/7PXFURn.png)\r\n\r\nでもなんか見つからなかった\r\n\r\n# site:サイトのURL でも代替できる\r\n\r\nこんな感じに\r\n\r\n![Imgur](https://imgur.com/sr3hFm3.png)\r\n\r\n# なんかリンクがおかしい\r\n\r\n`URL 検査`のカバレッジを眺めてみると、なんかURLが違うんですよね\r\n\r\n![Imgur](https://imgur.com/N7eo5oE.png)\r\n\r\nこれどうやら`<link data-n-head=\"ssr\" rel=\"canonical\" href=\"\">`が悪さをしているっぽいですね。  \r\n\r\nこれなんか相対パスが勝手に入ってる（私が知らんうちにやってた？）んですが、これ絶対パス入れないとおかしくなるっぽいですね。\r\n\r\nというわけでちゃんと指定するように、`head{ }`を変更してきました。\r\n\r\n```js\r\n  // タイトル変更に使う\r\n  head() {\r\n    // エラーでちゃうからanyで。解決方法ある？\r\n    const title = (this as any).article.title;\r\n    const url = `https://takusan.negitoro.dev/posts/${(this as any).article.slug}`;\r\n    return {\r\n      title: title,\r\n      meta: [\r\n        { hid: \"og:url\", property: \"og:url\", content: url },\r\n        { hid: \"og:title\", property: \"og:title\", content: title },\r\n      ],\r\n      link: [{ rel: \"canonical\", href: url }],\r\n    };\r\n  },\r\n```\r\n\r\nところで`as any`直したいんだけど、TypeScriptの`class`と`interface`どっちがいいですか？  \r\nとか調べてたら`type`とかいう概念もあってよくわからなくなった。"},{"title":"SMBCデビットで利用制限対象取引になったので電話で解除してもらった","link":"/posts/smbc_debit_error/","markdown":"\r\nタイトル通りで、3Dセキュアすら通ったのに、**利用制限対象取引**に分類され決済できなかった時の話。  \r\n電話すると解除してもらえます。翌日には払えるようにしてくれるらしいので払えたら追記します。  \r\n\r\nちなみにカードの裏に書いてあるなんとかデスクには繋がらなったです（予約を勧めてくる）。\r\n\r\n解除するためには多分電話するしかないのですが、  \r\n電話をこっちがかける訳ではなく、予め予約してかけてきて貰う必要があります。\r\n\r\nが、電話予約ページなのですが、どうやら普通に検索してリンクを辿っていくだけじゃ見つからないらしく（クエリパラメータをつけると電話予約のボタンが出るっぽい）、URLを教えて貰う必要があります。  \r\n（流石にここにURLを貼るわけには行かないので...）\r\n\r\nで、URLですが、デビットカード裏面のなんとかデスクにかけて、音声ガイドに従って（おそらく）`2`？を押します  \r\nその後お決まりの混み合っています、予約する場合は～って案内されるで、`1`？を押します  \r\n\r\nすると携帯電話のSMSにリンクが来る（これがクエリパラメータ付きのURL）ので、後は電話予約ボタンを押して予約して電話を待ちます。  \r\n私の場合はお昼ごろだったので当日の次の時間帯とかで対応してくれました。\r\n\r\n電話はあっさりですぐに終わりました。\r\n\r\n決済できたら追記します。以上です。\r\n\r\nできました。もしかしたら電話して一日経たずに決済できるかもしれないです。"},{"title":"夏休み企画　Mi 11 Lite 5G の赤外線送信機能を使ってシーリングライトを操作","link":"/posts/summer_vacation_android_ir/","markdown":"\r\nどうもこんばんわ。  \r\nハジラブ -Making*Lovers- 攻略しました。  \r\n桜子ちゃんが可愛かったです。無印版もやりたいと思います。    \r\n![Imgur](https://imgur.com/Dm9TXuI.png)　　\r\n\r\nあと別にこのゲームに限った話じゃないけど他のヒロイン攻略するのしんどくなるやつわかる人いますかね？\r\n\r\n![Imgur](https://imgur.com/ZqkR7Qw.png)\r\n\r\n好きな娘からやればいいと思いますがおすすめは初穂さんを最後にやるといいかも？\r\n\r\n# 本題\r\nなんかBLU出来るらしいから買った`Xiaomi Mi 11 Lite 5G`、この子`Mi Remote`っていうプリインアプリで赤外線を送信して家電操作ができるんですね。  \r\nでもこのアプリ、シーリングライトが何故か用意されてません。  \r\n\r\n赤外線通信、懐かしい響きなんですかね？。スマホ世代だからわからん  \r\n(iモード？、着せ替えツール？、フルブラウザ？、ネットワーク暗証番号？、センター問い合わせ？、富士通のプライバシーモード？、パケ・ホーダイ？)\r\n\r\n# MIUI初体験\r\nなんかUSBデバッグとは別にUSB経由のアプリインストールの設定があって、これ`SIMカード`刺さないとONに出来ないので注意。\r\n\r\n# 赤外線送信するためには\r\n- 赤外線送信ができて、`ConsumerIrManager#hasIrEmitter()`が`true`を返す端末\r\n    - 今回は`Xiaomi Mi 11 Lite 5G`を利用。33W充電めっちゃ早くて怖いまである。\r\n- 赤外線のパターンを取得出来る環境\r\n    - 今回はラズパイと赤外線受信モジュールで取得\r\n    - Nature Remo(エアコンや照明を外出先からONに出来るやつ)を持っている場合はいらないかもしれない\r\n        - 後述。なお私は持っていない。誰か確かめてみてくれ。\r\n\r\n# 環境\r\n\r\n| なまえ               | あたい                    |\r\n|----------------------|---------------------------|\r\n| 端末                 | Xiaomi Mi 11 Lite 5G      |\r\n| 言語                 | Kotlin                    |\r\n| UI                   | Jetpack Compose           |\r\n| Raspberry Pi         | 2 Model B                 |\r\n| 赤外線受信モジュール | OSRB38C9AA (秋月で買えた) |\r\n\r\nUI作るのだるいので、Jetpack Composeを使います。\r\n\r\n# 赤外線のパターン取得編\r\n\r\n今回は`NEC`のシーリングライトの赤外線パターンを取得したいと思います。NECって昔ゲーム作ってたってマジ？  \r\nRaspberry Piと赤外線受信モジュールをGPIOで接続して取得するんですが、残念ながらこの辺は詳しくないので先人に乗っかります。この辺詳しくなくても出来るので先人GJ  \r\n\r\n## どんなデータ？\r\nこんな感じの配列。本当はもっと長い。\r\n\r\n```json\r\n[\r\n    8925, 4540, 514, 626, 514,\r\n]\r\n```\r\n\r\n## ラズパイとか持ってないよ\r\n赤外線のパターンが手に入ればいいので、`Nature Remo`をお持ちの方は、`Nature Remo 赤外線データ`とかで調べるとそれっぽいパターンを取得できるそうですよ（そもそも持ってたらこんな事する必要すらないけどな）\r\n\r\n## Raspberry Pi に 赤外線受信モジュール を接続する\r\n先人に乗っかります。ラズパイのセットアップは各自。ディスプレイつないで初期設定終わらせておいてね。  \r\n\r\nhttps://qiita.com/takjg/items/e6b8af53421be54b62c9#%E8%B5%A4%E5%A4%96%E7%B7%9A%E3%82%92%E5%8F%97%E4%BF%A1%E3%81%99%E3%82%8B%E5%9B%9E%E8%B7%AF\r\n\r\n受光部を正面にした場合、右から「3.3V」「グラウンド」「データ」線をつなぎます。\r\n\r\n```\r\n+-+\r\n|●|\r\n+-+\r\n|||\r\n\r\n321\r\n```\r\n\r\n```\r\n3. データ線     GPIO 18 (ピン番号12)\r\n2. グラウンド   ピン番号 9 (GNDならどこでもおｋ)\r\n1. 3.3V        ピン番号 1 (3.3Vならどこでもおｋ)\r\n```\r\n\r\n以下結線例です。\r\n\r\n![Imgur](https://imgur.com/jmBtlwx.png)\r\n\r\n## Raspberry PiにSSH接続する\r\nSSH接続ってのはラズパイにあるターミナル（Windowsでいうコマンドプロンプト）を他PCから操作するときに使うやつです。リモートデスクトップでコマンドプロンプト操作してるみたいな感じだと思う。\r\n\r\nRaspberry Piにリモートで入ります。別にラズパイにつないだディスプレイとキーボードで操作してもいいんだけど、赤外線のパターンを母艦（開発環境があるPC）にコピーするのが面倒なのでリモートで入ります。  \r\nところで母艦って死語？\r\n\r\nなんか最近はディスプレイなしでもファイル作ってラズパイと有線LANで繋げば初回起動からSSHに入れるそうですね？\r\n\r\nSSHの有効化は省略させてもらいます。ごめんね。`TeraTerm`か`PowerShellのssh`でラズパイのターミナル画面が出るところまで用意しておいてください。\r\n\r\nWi-Fiの場合もLANの場合も`mDNS`？のおかげでホストの欄に`pi@raspberrypi.local`って入れれば接続できます。固定IPにしていない場合でもわざわざ調べに行かなくていいのでとても便利。\r\n\r\nちなみに以下の画像は関係ないです。\r\n\r\n![Imgur](https://imgur.com/3sOhTFh.png)\r\n\r\n## 赤外線パターンを手に入れる\r\n\r\n### 必要なパッケージをラズパイへインストール\r\n黒い画面に入れていきます\r\n\r\n```\r\nsudo apt install pigpio python3-pigpio\r\nsudo systemctl enable pigpiod.service\r\nsudo systemctl start pigpiod\r\n```\r\n\r\n### GPIOの設定\r\n赤外線モジュールのデータ線を`GPIO 18`に繋いだのでその旨を教えてあげます。\r\n\r\n```\r\necho 'm 18 r    pud 18 u' > /dev/pigpio\r\n```\r\n\r\n### 赤外線パターン入手プログラムをダウンロード\r\n\r\n```\r\ncurl http://abyz.me.uk/rpi/pigpio/code/irrp_py.zip | zcat > irrp.py\r\n```\r\n\r\n### 赤外線パターンを取得\r\n先程ダウンロードしたプログラムを実行すると赤外線パターンを入手出来ます。  \r\n以下のコマンドを実行した後、リモコンを赤外線受信モジュールへ向けてボタンを押します。\r\n\r\n```\r\npython3 irrp.py -r -g18 -f codes light_on --no-confirm --post 130\r\n```\r\n\r\n成功すると`Okey`まで出ます。\r\n\r\n```\r\nRecording\r\nPress key for 'light_on'\r\nOkay\r\n```\r\n\r\n赤外線パターンは`codes`というファイルに保存されます。\r\n\r\n### 赤外線パターンを見る\r\n以下のコマンドを打ち込むと赤外線パターンを記載したファイルを見ることが出来ます。\r\n\r\n```\r\ncat codes\r\n```\r\n\r\n![Imgur](https://imgur.com/kvgL2CS.png)\r\n\r\n`[`から`]`で囲われてる数値を控えておきます。  \r\n画像の例では`8953`から`]`の前まで。以下例\r\n\r\n```\r\n8953, 4544, 463, 730, 463, 1730, 463, 1730, 463, 586, 549, 586, 549, 586, 463, 586, 463, 586, 463, 1730, 463, 1730, 549, 586, 463, 586, 463, 586, 549, 1730, 463, 730, 463, 1730, 549, 586, 463, 586, 463, 730, 463, 586, 463, 1730, 549, 1730, 463, 1730, 463, 586, 549, 586, 463, 586, 463, 586, 463, 586, 463, 730, 463, 1730, 463, 1730, 463, 1730, 463, 41143, 8953, 2224, 463\r\n```\r\n\r\n**赤外線パターンの中身知りたい方は`NECフォーマットだけですが`適当にまとめたのでどうぞ：**[赤外線のNECフォーマットまとめ？](/posts/ir_nec_format/)  \r\n別に見なくても分からなくても作れます。\r\n\r\n# Xiaomi Mi 11 Lite 5G で送信\r\n\r\n## テスト用アプリ用意しておきました。\r\n\r\n赤外線のパターンを入れて送信できるか試せるアプリです。\r\n\r\n![Imgur](https://imgur.com/WaXQlJj.png)\r\n\r\nソースコード：https://github.com/takusan23/IrSenDroid\r\n\r\nAPKダウンロード：https://github.com/takusan23/IrSenDroid/releases/tag/1.0\r\n\r\n## AndroidManifest\r\n\r\n適当にComposeプロジェクトを作成します。  \r\nできたら、赤外線を使うので権限を`Manifest`に書き足します。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"io.github.takusan23.irsendroid\">\r\n\r\n    <uses-permission android:name=\"android.permission.TRANSMIT_IR\"/>\r\n\r\n```\r\n\r\n## 送信用関数の用意\r\n\r\n`IrSendTool.kt`を作成して、以下をコピペ  \r\n\r\n`LIGHT_OFF_DATA`と`LIGHT_ON_DATA`の配列は各自取得したパターンを入れてください。\r\n\r\n```kotlin\r\nobject IrSendTool {\r\n\r\n    /** NECのシーリングライトの 消灯ボタン を押したときに送信される赤外線のパターン */\r\n    val LIGHT_OFF_DATA = listOf(\r\n        8925, 4540, 514, 626, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 626, 514\r\n    )\r\n\r\n    /** NECのシーリングライトの 全灯ボタン を押したときに送信される赤外線のパターン */\r\n    val LIGHT_ON_DATA = listOf(\r\n        8925, 4540, 514, 626, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 1730, 514, 626, 514, 1730, 514, 1730, 514, 626, 514, 626, 514, 626, 514, 626, 514, 626, 514, 1730, 514, 626, 514\r\n    )\r\n\r\n    /**\r\n     * 赤外線送信\r\n     * @param context Context\r\n     * @param pattern 赤外線パターン\r\n     * */\r\n    fun sendIr(context: Context, pattern: List<Int>) {\r\n        val consumerIrManager = context.getSystemService(Context.CONSUMER_IR_SERVICE) as ConsumerIrManager\r\n        // 赤外線利用可能かどうか\r\n        if (consumerIrManager.hasIrEmitter()) {\r\n            // 利用可能なら送信\r\n            consumerIrManager.transmit(38_000, pattern.toIntArray())\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n使うときはこんな風に\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        IrSendTool.sendIr(this, IrSendTool.LIGHT_ON_DATA)\r\n\r\n    }\r\n}\r\n```\r\n\r\n## ComposeでちゃちゃっとUIを作る\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            IrSenDroidTheme {\r\n                Surface(color = MaterialTheme.colors.background) {\r\n                    HomeScreen()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Preview(backgroundColor = 0xFFFFFF, showBackground = true)\r\n@Composable\r\nfun HomeScreenPrev() {\r\n    HomeScreen()\r\n}\r\n\r\n@Composable\r\nfun HomeScreen() {\r\n    Column(\r\n        modifier = Modifier.fillMaxSize(),\r\n        verticalArrangement = Arrangement.Center,\r\n        horizontalAlignment = Alignment.CenterHorizontally,\r\n    ) {\r\n        RoomLightOnButton()\r\n        RoomLightOffButton()\r\n    }\r\n}\r\n\r\n@Composable\r\nfun RoomLightOnButton() {\r\n    val context = LocalContext.current\r\n\r\n    Button(\r\n        modifier = Modifier.padding(10.dp),\r\n        onClick = { IrSendTool.sendIr(context, IrSendTool.LIGHT_ON_DATA) }\r\n    ) {\r\n        Text(text = \"照明ON\")\r\n    }\r\n}\r\n\r\n@Composable\r\nfun RoomLightOffButton() {\r\n    val context = LocalContext.current\r\n\r\n    Button(\r\n        modifier = Modifier.padding(10.dp),\r\n        onClick = { IrSendTool.sendIr(context, IrSendTool.LIGHT_OFF_DATA) }\r\n    ) {\r\n        Text(text = \"照明OFF\")\r\n    }\r\n}\r\n```\r\n\r\nこれで`Xiaomi Mi 11 Lite 5G`があればシーリングライト操作し放題です。やったね。\r\n\r\n# 終わりに\r\n赤外線送信付いてるのおもろいな。  \r\n休日終わるの早すぎな～～～"},{"title":"夏休みの自由研究 通常版とカラオケ版トラックを使ってボーカルだけの音楽を作る","link":"/posts/summer_vacation_music_vocal_only/","markdown":"\r\nどうもこんばんわ。  \r\n今でも 8/31 まで夏休みあるんですかね？\r\n\r\n# 本題\r\nノイズキャンセリングって、周りの音を逆位相にして周囲の音を打ち消しているらしいんですよね。  \r\n\r\nで、それを使えば音楽の通常版とカラオケ版トラックを使いカラオケ版トラックを逆位相にすることで、カラオケ版の逆、つまりボーカルだけのトラックが作れる  \r\n\r\n昔からあるやつなので、普通は`Audacity`とかでやればいいと思うんですけど、今回は`Android`でやります！！！\r\n\r\n# ながれ\r\n\r\n- 音声ファイルを用意する\r\n    - 通常版とカラオケ版トラックを用意する\r\n- 音声ファイルを未圧縮状態にする（デコード）\r\n    - 後述\r\n    - PCM とかいうやつですね\r\n- 通常版トラックと逆位相カラオケ版トラックを足し算して、ボーカルだけにする\r\n    - 正確には通常版からカラオケ版トラックを引く\r\n        - 音は波なので、そのまま足したり引いたりできる\r\n        - 逆位相にして合成するのとやってることは変わらんはず\r\n- 未圧縮状態のデータなので、このままだとファイルサイズが大きいままなので、圧縮する（エンコード）\r\n    - 未圧縮状態だと多分音楽プレイヤーでも再生できない\r\n    - `ffplay`とか`Audacity`でパラメータ合わせれば再生できるかもしれん\r\n\r\n## 未圧縮状態にする\r\n`CD`とかで取り込むと、既にエンコードされている状態で保存されますよね。（`.mp3`、`.flac`、`.aac`）  \r\nエンコードされているということは、圧縮されている状態なので、音声データを加工したい場合はまず圧縮を元に戻す必要があります。デコードと呼ばれる作業ですね。  \r\n（`zip`を解凍しないと中身いじれない感じで）  \r\n\r\n動画/音楽プレイヤーが圧縮されている音声を再生できるのは、デコードと呼ばれる作業をし、元の音声ファイルに戻しているからなんですね。  \r\n`Audacity`のファイルが大きいのは編集のために未圧縮状態で持っておく必要があるからなんですね\r\n\r\n## 音声を支える技術\r\n\r\n- MediaCodec\r\n    - このブログでも何回か取り上げているくせ者\r\n        - https://takusan.negitoro.dev/posts/tag/MediaCodec/\r\n    - 映像や音声のエンコード、デコードをするクラス\r\n        - `Media3 (ExoPlayer)`が動画を再生できるのは、くせ者`MediaCodec`を使っているからなんですね\r\n    - 最終的にはC言語とかで書かれた処理に到達する、エラーが何もわからない\r\n    - `H.264`、`H.265`、`VP9`とか`AAC`とか、コーデックと呼ばれるやつをやってくれる\r\n    - くせ者\r\n- MediaExtractor\r\n    - `mp4`や`aac`などのファイルから、`MediaCodec`へ渡すためのデータを取り出してくれるクラス\r\n        - `mp4`とか`aac`には実際のデータ以外にもメタデータを持っている（動画の縦横サイズ、ビットレート、fps など）ので、メタデータと実際のデータをそれぞれ分けて取り出してくれる\r\n    - `mp4`とか`aac`はコンテナフォーマットとかいうやつですね\r\n    - くせ者\r\n- MediaMuxer\r\n    - `MediaCodec`から出てきたデータを`mp4`とかに保存するためのクラス、`MediaExtractor`の逆をする\r\n        - コンテナフォーマットって難しいんですね...\r\n    - くせ者\r\n\r\n# 環境\r\n\r\n| なまえ           | あたい                                                                                                 |\r\n|------------------|--------------------------------------------------------------------------------------------------------|\r\n| Windows          | 10 Pro                                                                                                 |\r\n| Android Studio   | Android Studio Giraffe                                                                                 |\r\n| たんまつ         | Google Pixel 6 Pro                                                                                     |\r\n| 使う音声ファイル | `flac`（多分`AAC`でもいいはず）/ サンプリング周波数 44.1 kHz / ビットレート 1 Mbps / チャンネル数 2 ch |\r\n\r\n音声ファイルは、通常版とカラオケ版で、サンプリング周波数（ビットレートも？？）が同じじゃないとダメだと思う（CDから入れれば同じ設定だと思いますが...）\r\n\r\n![Imgur](https://imgur.com/taTzKxx.png)\r\n\r\n# 作る\r\n\r\nつくります\r\n\r\n## 適当にプロジェクトを作成\r\n`Jetpack Compose`でいきます！もう`レイアウトのxml`一生書きたくない！\r\n\r\nついに！`build.gradle.kts`がデフォルトで作れるようになりましたね！！！  \r\n長かったけどまぁ旨味あんまりないから`build.gradle`から移行するほどではなさそう\r\n\r\n![Imgur](https://imgur.com/FWVEz3f.png)\r\n\r\n## 音楽を選ぶためのUI\r\nファイルピッカーを開いて、音声ファイルを選ぶ処理を書きます。  \r\n適当にボタンを置きます。  \r\n\r\n本当は`HomeScreen`は別ファイルのほうが良さそうですがまぁ単発企画なのでこのままで行きます\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            VocalOnlyDroidTheme {\r\n                HomeScreen()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun HomeScreen() {\r\n    val context = LocalContext.current\r\n\r\n    // 音声ファイルの Uri\r\n    val normalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n    val instrumentalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n\r\n    // ファイルピッカー\r\n    val normalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { normalTrackUri.value = it }\r\n    val instrumentalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { instrumentalTrackUri.value = it }\r\n\r\n    Scaffold(\r\n        topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) }\r\n    ) {\r\n        Column(\r\n            modifier = Modifier.padding(it),\r\n            verticalArrangement = Arrangement.spacedBy(5.dp)\r\n        ) {\r\n\r\n            Button(\r\n                onClick = { normalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = normalTrackUri.value?.toString() ?: \"通常版の選択\") }\r\n\r\n            Button(\r\n                onClick = { instrumentalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = instrumentalTrackUri.value?.toString() ?: \"カラオケ版の選択\") }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nファイルピッカーの返り値は`Uri`で、**これはファイルパスではないです。**  \r\nもちろんちゃんと`Uri`からデータを取り出したり、書き込んだりする方法があります（`InputStream / OutputStream`が開けます）。  \r\n\r\nはぁ～？？？って感じですよね、、、なんでだよファイルパスよこせよって話ですが、この方法だとファイルパスを持たないアプリからデータを受け取れるんですよね。  \r\nつまりどういうことかというと、`Google ドライブ`や`Google フォト`などの、端末内には無いファイルもファイルピッカーで選択することができます。（端末内に無いのでファイルパスを持ってません...）  \r\n（もちろん、上記のアプリから端末外にあるファイルを選んだ場合、一時的には端末内にダウンロードされるとは思いますが）\r\n\r\nあと`Uri`はプロセスが生きている間（アプリが動いている間）のみ有効みたいな話だったはず、、、ちょっと思い出せない  \r\n\r\n選んだら`normalTrackUri / instrumentalTrackUri`にそれぞれ入れます。\r\n\r\n![Imgur](https://imgur.com/91Z4HfD.png)\r\n\r\n## 実行ボタンともろもろを書く\r\n\r\nまずは UI に状態を通知するため、状態一覧を書きます。  \r\n`WWDC 2023`で久しぶりに出た`One more thing...`、`iPhone X`の発表以来使ってないんじゃないと思って調べたら`Apple Silicon`で使ったのか\r\n\r\n```kotlin\r\nprivate enum class ProgressStatus {\r\n    /** 実行可能 */\r\n    IDLE,\r\n\r\n    /** デコード中 */\r\n    DECODE,\r\n\r\n    /** 音声の加工中 */\r\n    EDIT,\r\n\r\n    /** エンコード中 */\r\n    ENCODE,\r\n\r\n    /** あとしまつ */\r\n    ONE_MORE_THING\r\n}\r\n```\r\n\r\nそして実行ボタンを設置しました、`HomeScreen`だけです以外は変えてないです。\r\n\r\n```kotlin\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun HomeScreen() {\r\n    val context = LocalContext.current\r\n    val scope = rememberCoroutineScope()\r\n\r\n    // 音声ファイルの Uri\r\n    val normalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n    val instrumentalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n\r\n    // ファイルピッカー\r\n    val normalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { normalTrackUri.value = it }\r\n    val instrumentalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { instrumentalTrackUri.value = it }\r\n    \r\n    val progressStatus = remember { mutableStateOf(ProgressStatus.IDLE) }\r\n    \r\n    // 処理内容\r\n    fun start() {\r\n        // TODO このあとすぐ！\r\n    }\r\n\r\n    Scaffold(\r\n        topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) }\r\n    ) {\r\n        Column(\r\n            modifier = Modifier.padding(it),\r\n            verticalArrangement = Arrangement.spacedBy(5.dp)\r\n        ) {\r\n\r\n            Button(\r\n                onClick = { normalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = normalTrackUri.value?.toString() ?: \"通常版の選択\") }\r\n\r\n            Button(\r\n                onClick = { instrumentalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = instrumentalTrackUri.value?.toString() ?: \"カラオケ版の選択\") }\r\n\r\n            // 実行中は実行ボタンを出さない\r\n            if (progressStatus.value == ProgressStatus.IDLE) {\r\n                Button(\r\n                    onClick = { start() }\r\n                ) { Text(text = \"処理を始める\") }\r\n            } else {\r\n                CircularProgressIndicator()\r\n                Text(text = \"処理中です：${progressStatus.value}\")\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 音声を編集する処理を書く\r\n`MediaCodec`とかのくせ者をここから使っていくわけですが...  \r\n今回は前私が書いたやつがあるのでそれをパクることにします。ありがとう過去の私\r\n\r\nhttps://github.com/takusan23/AkariDroid/tree/master/akari-core/src/main/java/io/github/takusan23/akaricore/common\r\n\r\n## AudioEncoder / AudioDecoder\r\n以下のクラスを作ってください...  \r\n\r\nやってることは\r\n- `MediaCodec`を初期化する\r\n    - ビットレートとかコーデックとか入れる\r\n- 終わりまでデータを`MediaCodec`に流す\r\n    - 圧縮したデータ or 未圧縮データ が出てくる\r\n\r\n```kotlin\r\n/**\r\n * 音声エンコーダー\r\n * MediaCodecを使いやすくしただけ\r\n *\r\n * 生（意味深）の音声（PCM）送られてくるので、 AAC / Opus にエンコードして圧縮する。\r\n */\r\nclass AudioEncoder {\r\n\r\n    /** MediaCodec エンコーダー */\r\n    private var mediaCodec: MediaCodec? = null\r\n\r\n    /**\r\n     * エンコーダーを初期化する\r\n     *\r\n     * @param codec コーデック。[MediaFormat.MIMETYPE_AUDIO_AAC]など\r\n     * @param sampleRate サンプリングレート\r\n     * @param channelCount チャンネル数\r\n     * @param bitRate ビットレート\r\n     * @param\r\n     */\r\n    fun prepareEncoder(\r\n        codec: String = MediaFormat.MIMETYPE_AUDIO_AAC,\r\n        sampleRate: Int = 44_100,\r\n        channelCount: Int = 2,\r\n        bitRate: Int = 192_000,\r\n    ) {\r\n        val audioEncodeFormat = MediaFormat.createAudioFormat(codec, sampleRate, channelCount).apply {\r\n            setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC)\r\n            setInteger(MediaFormat.KEY_BIT_RATE, bitRate)\r\n        }\r\n        // エンコーダー用意\r\n        mediaCodec = MediaCodec.createEncoderByType(codec).apply {\r\n            configure(audioEncodeFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * エンコーダーを開始する。同期モードを使うのでコルーチンを使います（スレッドでも良いけど）\r\n     *\r\n     * @param onRecordInput ByteArrayを渡すので、音声データを入れて、サイズを返してください\r\n     * @param onOutputBufferAvailable エンコードされたデータが流れてきます\r\n     * @param onOutputFormatAvailable エンコード後のMediaFormatが入手できる\r\n     */\r\n    suspend fun startAudioEncode(\r\n        onRecordInput: suspend (ByteArray) -> Int,\r\n        onOutputBufferAvailable: suspend (ByteBuffer, MediaCodec.BufferInfo) -> Unit,\r\n        onOutputFormatAvailable: suspend (MediaFormat) -> Unit,\r\n    ) = withContext(Dispatchers.Default) {\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n        mediaCodec!!.start()\r\n\r\n        try {\r\n            while (isActive) {\r\n                // もし -1 が返ってくれば configure() が間違ってる\r\n                val inputBufferId = mediaCodec!!.dequeueInputBuffer(TIMEOUT_US)\r\n                if (inputBufferId >= 0) {\r\n                    // AudioRecodeのデータをこの中に入れる\r\n                    val inputBuffer = mediaCodec!!.getInputBuffer(inputBufferId)!!\r\n                    val capacity = inputBuffer.capacity()\r\n                    // サイズに合わせて作成\r\n                    val byteArray = ByteArray(capacity)\r\n                    // byteArrayへデータを入れてもらう\r\n                    val readByteSize = onRecordInput(byteArray)\r\n                    if (readByteSize > 0) {\r\n                        // 書き込む。書き込んだデータは[onOutputBufferAvailable]で受け取れる\r\n                        inputBuffer.put(byteArray, 0, readByteSize)\r\n                        mediaCodec!!.queueInputBuffer(inputBufferId, 0, readByteSize, System.nanoTime() / 1000, 0)\r\n                    } else {\r\n                        // もうない！\r\n                        break\r\n                    }\r\n                }\r\n                // 出力\r\n                val outputBufferId = mediaCodec!!.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId >= 0) {\r\n                    val outputBuffer = mediaCodec!!.getOutputBuffer(outputBufferId)!!\r\n                    if (bufferInfo.size > 1) {\r\n                        if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0) {\r\n                            // ファイルに書き込む...\r\n                            onOutputBufferAvailable(outputBuffer, bufferInfo)\r\n                        }\r\n                    }\r\n                    // 返却\r\n                    mediaCodec!!.releaseOutputBuffer(outputBufferId, false)\r\n                } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                    // MediaFormat、MediaMuxerに入れるときに使うやつ\r\n                    // たぶんこっちのほうが先に呼ばれる\r\n                    onOutputFormatAvailable(mediaCodec!!.outputFormat)\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        } finally {\r\n            // リソースを開放する\r\n            try {\r\n                mediaCodec?.stop()\r\n                mediaCodec?.release()\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        /** MediaCodec タイムアウト */\r\n        private const val TIMEOUT_US = 10_000L\r\n    }\r\n}\r\n```\r\n\r\n```kotlin\r\n/**\r\n * 音声エンコーダー\r\n * MediaCodecを使いやすくしただけ\r\n *\r\n * 生（意味深）の音声（PCM）送られてくるので、 AAC / Opus にエンコードして圧縮する。\r\n */\r\nclass AudioDecoder {\r\n    /** MediaCodec デコーダー */\r\n    private var mediaCodec: MediaCodec? = null\r\n\r\n    /**\r\n     * 初期化する\r\n     * デコーダーならパラメーター持ってるはず...\r\n     *\r\n     * @param mediaFormat [android.media.MediaExtractor]から出てきたMediaFormat\r\n     */\r\n    fun prepareDecoder(mediaFormat: MediaFormat) {\r\n        val mimeType = mediaFormat.getString(MediaFormat.KEY_MIME)!!\r\n        mediaCodec = MediaCodec.createDecoderByType(mimeType).apply {\r\n            configure(mediaFormat, null, null, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * デコーダーを開始する\r\n     *\r\n     * @param readSampleData ByteArrayを渡すので、音声データを入れて、サイズと再生時間（マイクロ秒）を返してください\r\n     * @param onOutputBufferAvailable デコードされたデータが流れてきます\r\n     */\r\n    suspend fun startAudioDecode(\r\n        readSampleData: (ByteBuffer) -> Pair<Int, Long>,\r\n        onOutputBufferAvailable: (ByteArray) -> Unit,\r\n    ) = withContext(Dispatchers.Default) {\r\n        val bufferInfo = MediaCodec.BufferInfo()\r\n        mediaCodec!!.start()\r\n\r\n        try {\r\n            while (isActive) {\r\n                // もし -1 が返ってくれば configure() が間違ってる\r\n                val inputBufferId = mediaCodec!!.dequeueInputBuffer(TIMEOUT_US)\r\n                if (inputBufferId >= 0) {\r\n                    // Extractorからデータを読みだす\r\n                    val inputBuffer = mediaCodec!!.getInputBuffer(inputBufferId)!!\r\n                    // 書き込む。書き込んだデータは[onOutputBufferAvailable]で受け取れる\r\n                    val (size, presentationTime) = readSampleData(inputBuffer)\r\n                    if (size > 0) {\r\n                        mediaCodec!!.queueInputBuffer(inputBufferId, 0, size, presentationTime, 0)\r\n                    } else {\r\n                        // データなくなった場合は終了フラグを立てる\r\n                        mediaCodec!!.queueInputBuffer(inputBufferId, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)\r\n                        // おわり\r\n                        break\r\n                    }\r\n                }\r\n                // 出力\r\n                val outputBufferId = mediaCodec!!.dequeueOutputBuffer(bufferInfo, TIMEOUT_US)\r\n                if (outputBufferId >= 0) {\r\n                    // デコード結果をもらう\r\n                    val outputBuffer = mediaCodec!!.getOutputBuffer(outputBufferId)!!\r\n                    val outData = ByteArray(bufferInfo.size)\r\n                    outputBuffer.get(outData)\r\n                    onOutputBufferAvailable(outData)\r\n                    // 返却\r\n                    mediaCodec!!.releaseOutputBuffer(outputBufferId, false)\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        } finally {\r\n            // リソースを開放する\r\n            try {\r\n                mediaCodec?.stop()\r\n                mediaCodec?.release()\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n\r\n    companion object {\r\n\r\n        /** MediaCodec タイムアウト */\r\n        private const val TIMEOUT_US = 10_000L\r\n    }\r\n}\r\n```\r\n\r\n## 音声ファイルをデコードして、一時的にファイルに書き込む\r\n`aac`や`flac`はエンコードされている（圧縮されている）ので、まずはデコードして未圧縮状態のデータに戻す必要があると言いました、それをします。  \r\nで出来た、未圧縮状態のデータをファイルに書き込みます。  \r\n\r\n雑にコメントに書いたので何してるか見たい方はどうぞ。  \r\n一点、`Uri`からデータを取り出すのに`InputStream`みたいなのを使おうとしたんですけど、それ自体は渡せなさそうで、`FileDescriptor`とかいうやつを経由してデータを取り出すようにするようにしました。よく分かりません\r\n\r\nあ！、もう一点、  \r\n出力先ファイルが`File クラス`になってたりしますが、これはこの下のどっかで話すと思う\r\n\r\n```kotlin\r\n/** ボーカルだけ取り出す処理を行う */\r\nobject VocalOnlyProcessor {\r\n\r\n    /**\r\n     * 音声ファイルをデコードする\r\n     *\r\n     * @param fileDescriptor [android.content.ContentResolver.openFileDescriptor]\r\n     * @param outputFile 出力先ファイル\r\n     */\r\n    suspend fun decode(\r\n        fileDescriptor: FileDescriptor,\r\n        outputFile: File\r\n    ) = withContext(Dispatchers.Default) {\r\n        // コンテナフォーマットからデータを取り出すやつ\r\n        val extractor = MediaExtractor().apply {\r\n            setDataSource(fileDescriptor)\r\n        }\r\n        // 音声トラックを見つける\r\n        // 音声ファイルなら、音声トラックしか無いはずなので、0 決め打ちでも良さそう\r\n        val audioTrackIndex = (0 until extractor.trackCount)\r\n            .first { extractor.getTrackFormat(it).getString(MediaFormat.KEY_MIME)?.startsWith(\"audio/\") == true }\r\n        // デコーダーにメタデータを渡す\r\n        val audioDecoder = AudioDecoder().apply {\r\n            prepareDecoder(extractor.getTrackFormat(audioTrackIndex))\r\n        }\r\n        extractor.selectTrack(audioTrackIndex)\r\n        // ファイルに書き込む準備\r\n        outputFile.outputStream().use { outputStream ->\r\n            // デコードする\r\n            audioDecoder.startAudioDecode(\r\n                readSampleData = { byteBuffer ->\r\n                    // データを進める\r\n                    val size = extractor.readSampleData(byteBuffer, 0)\r\n                    extractor.advance()\r\n                    size to extractor.sampleTime\r\n                },\r\n                onOutputBufferAvailable = { bytes ->\r\n                    // データを書き込む\r\n                    outputStream.write(bytes)\r\n                }\r\n            )\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 通常版とカラオケ版を使って、ボーカルだけを取り出す処理\r\n冒頭に言った通り、未圧縮状態のデータなので、足し算・引き算が出来ます。  \r\n未圧縮状態のデータのバイト配列の同じ位置同士を足したり引いたりすれば良いはずです...！\r\n\r\n`readNBytes`とかいう、指定サイズの`ByteArray`を作って読み出して返してくれるやつがあるんですけど、古い`Android`をターゲットにするなら使えなさそう...\r\nhttps://developer.android.com/reference/java/io/InputStream#readNBytes(int)\r\n\r\n流石に3つも`use { }`すると分かりにくい気がしてきた...でも自動で閉じてくれるの便利なんだよな\r\n\r\n```kotlin\r\n/**\r\n * 通常版からカラオケ版を引いてボーカルだけ取り出す\r\n *\r\n * @param normalTrackFile 通常版のデコード済みデータ\r\n * @param instrumentalTrackFile カラオケ版のデコード済みデータ\r\n * @param resultFile 保存先\r\n */\r\nsuspend fun extract(\r\n    normalTrackFile: File,\r\n    instrumentalTrackFile: File,\r\n    resultFile: File\r\n) = withContext(Dispatchers.IO) {\r\n    resultFile.outputStream().use { resultOutputStream ->\r\n        normalTrackFile.inputStream().use { normalTrackInputStream ->\r\n            instrumentalTrackFile.inputStream().use { instrumentalTrackInputStream ->\r\n                // データが無くなるまで\r\n                while (isActive) {\r\n                    // ちょっとずつ取り出して、音の加工をしていく\r\n                    // 一気に読み取るのは多分無理\r\n                    val normalTrackByteArray = ByteArray(BYTE_ARRAY_SIZE).also { byteArray -> normalTrackInputStream.read(byteArray) }\r\n                    val instrumentalTrackByteArray = ByteArray(BYTE_ARRAY_SIZE).also { byteArray -> instrumentalTrackInputStream.read(byteArray) }\r\n                    \r\n                    // 通常版からカラオケ版を引く処理\r\n                    val size = max(normalTrackByteArray.size, instrumentalTrackByteArray.size)\r\n                    val vocalOnlyByteArray = (0 until size)\r\n                        .map { index -> (normalTrackByteArray[index] - instrumentalTrackByteArray[index]).toByte() }\r\n                        .toByteArray()\r\n\r\n                    // ファイルに書き込む\r\n                    resultOutputStream.write(vocalOnlyByteArray)\r\n                    // どちらかのファイルが読み込み終わったら、無限ループを抜ける\r\n                    if (normalTrackInputStream.available() == 0 || instrumentalTrackInputStream.available() == 0) {\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate const val BYTE_ARRAY_SIZE = 8192\r\n```\r\n\r\n## エンコードする処理\r\nはい。こっちもコメントに書いたので見てね  \r\n`MediaMuxer`を開始するには、`MediaCodec`を開始した後に取得できる`MediaFormat`を待つ必要があります...\r\n\r\n```kotlin\r\n/**\r\n * エンコードする\r\n * \r\n * @param rawFile 圧縮していないデータ\r\n * @param resultFile エンコードしたデータ\r\n */\r\nsuspend fun encode(\r\n    rawFile: File,\r\n    resultFile: File\r\n) = withContext(Dispatchers.Default) {\r\n    // エンコーダーを初期化\r\n    val audioEncoder = AudioEncoder().apply {\r\n        prepareEncoder(\r\n            codec = MediaFormat.MIMETYPE_AUDIO_AAC,\r\n            sampleRate = 44_100,\r\n            channelCount = 2,\r\n            bitRate = 192_000\r\n        )\r\n    }\r\n    // コンテナフォーマットに保存していくやつ\r\n    val mediaMuxer = MediaMuxer(resultFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)\r\n    var trackIndex = -1\r\n    rawFile.inputStream().use { inputStream ->\r\n        audioEncoder.startAudioEncode(\r\n            onRecordInput = { bytes ->\r\n                // データをエンコーダーに渡す\r\n                inputStream.read(bytes)\r\n            },\r\n            onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                // 無いと思うけど MediaMuxer が開始していなければ追加しない\r\n                if (trackIndex != -1) {\r\n                    mediaMuxer.writeSampleData(trackIndex, byteBuffer, bufferInfo)\r\n                }\r\n            },\r\n            onOutputFormatAvailable = {\r\n                // フォーマットが確定したら MediaMuxer を開始する\r\n                trackIndex = mediaMuxer.addTrack(it)\r\n                mediaMuxer.start()\r\n            }\r\n        )\r\n    }\r\n    mediaMuxer.stop()\r\n}\r\n```\r\n\r\n## 出来た音声ファイルを端末の音楽フォルダに移動させる\r\n最後！  \r\n完成品したファイルを端末の音声フォルダに移動する処理を書きます！  \r\nというのも、作業のためにすべてのファイルを`Context#getExternalFilesDir`で返される保存先に書き込んでいたわけですが、（`Java`の`File`クラスが使えるので一時的にフォルダ作るのに良い）  \r\nこの保存先というのはアプリ固有ストレージとか言われていて、他のアプリからアクセスできないんですよね...  \r\n（ちなみに`sdcard/Android/data/{applicationId}`みたいな保存先パスになるはず）\r\n\r\nというわけで、`MediaStore (ContentResolver ?)`に音楽データ追加を依頼して、そっちにデータを移動させます！  \r\nこれで他のアプリから参照できるはずです！！！\r\n\r\n`new File(\"sdcard/Music/VocalOnly\")`みたいなコードは動かないので、大人しくドキュメントどおりにしましょう...  \r\nhttps://developer.android.com/training/data-storage/shared/media\r\n\r\n```kotlin\r\n/**\r\n * 音楽ファイルを端末の音声フォルダにコピーする\r\n *\r\n * @param context [Context]\r\n * @param fileName ファイル名\r\n * @param targetFile 音楽ファイル\r\n */\r\nsuspend fun copyToAudioFolder(\r\n    context: Context,\r\n    fileName: String,\r\n    targetFile: File\r\n) = withContext(Dispatchers.IO) {\r\n    val contentResolver = context.contentResolver\r\n    // 名前とか\r\n    val contentValues = contentValuesOf(\r\n        MediaStore.Audio.Media.DISPLAY_NAME to fileName,\r\n        // ディレクトリを掘る場合\r\n        MediaStore.Audio.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_MUSIC}/VocalOnlyTrack\"\r\n    )\r\n    // 追加する\r\n    val uri = contentResolver.insert(\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) MediaStore.Video.Media.getContentUri(MediaStore.VOLUME_EXTERNAL) else MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\r\n        contentValues\r\n    ) ?: return@withContext\r\n    // ファイルをコピーする\r\n    targetFile.inputStream().use { inputStream ->\r\n        contentResolver.openOutputStream(uri)?.use { outputStream ->\r\n            // Kotlin 拡張関数でコピー 一発\r\n            inputStream.copyTo(outputStream)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Uri からファイル名をクエリする\r\n * \r\n * @param uri [Uri]\r\n * @param context [Context]\r\n * @return ファイル名\r\n */\r\nsuspend fun getFileNameFromUri(\r\n    context: Context,\r\n    uri: Uri\r\n) = withContext(Dispatchers.IO) {\r\n    // DISPLAY_NAME を SELECT する\r\n    context.contentResolver.query(uri, arrayOf(MediaStore.Audio.Media.DISPLAY_NAME), null, null, null)?.use { cursor ->\r\n        // DB の先頭に移動して、\r\n        cursor.moveToFirst()\r\n        cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DISPLAY_NAME))\r\n    }\r\n}\r\n```\r\n\r\n## ここまでのコード\r\n\r\nつぎはこれらをUIから呼び出していきます...\r\n\r\n```kotlin\r\n/** ボーカルだけ取り出す処理を行う */\r\n/** ボーカルだけ取り出す処理を行う */\r\nobject VocalOnlyProcessor {\r\n\r\n    /**\r\n     * 音声ファイルをデコードする\r\n     *\r\n     * @param fileDescriptor [android.content.ContentResolver.openFileDescriptor]\r\n     * @param outputFile 出力先ファイル\r\n     */\r\n    suspend fun decode(\r\n        fileDescriptor: FileDescriptor,\r\n        outputFile: File\r\n    ) = withContext(Dispatchers.Default) {\r\n        // コンテナフォーマットからデータを取り出すやつ\r\n        val extractor = MediaExtractor().apply {\r\n            setDataSource(fileDescriptor)\r\n        }\r\n        // 音声トラックを見つける\r\n        // 音声ファイルなら、音声トラックしか無いはずなので、0 決め打ちでも良さそう\r\n        val audioTrackIndex = (0 until extractor.trackCount)\r\n            .first { extractor.getTrackFormat(it).getString(MediaFormat.KEY_MIME)?.startsWith(\"audio/\") == true }\r\n        // デコーダーにメタデータを渡す\r\n        val audioDecoder = AudioDecoder().apply {\r\n            prepareDecoder(extractor.getTrackFormat(audioTrackIndex))\r\n        }\r\n        extractor.selectTrack(audioTrackIndex)\r\n        // ファイルに書き込む準備\r\n        outputFile.outputStream().use { outputStream ->\r\n            // デコードする\r\n            audioDecoder.startAudioDecode(\r\n                readSampleData = { byteBuffer ->\r\n                    // データを進める\r\n                    val size = extractor.readSampleData(byteBuffer, 0)\r\n                    extractor.advance()\r\n                    size to extractor.sampleTime\r\n                },\r\n                onOutputBufferAvailable = { bytes ->\r\n                    // データを書き込む\r\n                    outputStream.write(bytes)\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 通常版からカラオケ版を引いてボーカルだけ取り出す\r\n     *\r\n     * @param normalTrackFile 通常版のデコード済みデータ\r\n     * @param instrumentalTrackFile カラオケ版のデコード済みデータ\r\n     * @param resultFile 保存先\r\n     */\r\n    suspend fun extract(\r\n        normalTrackFile: File,\r\n        instrumentalTrackFile: File,\r\n        resultFile: File\r\n    ) = withContext(Dispatchers.IO) {\r\n        resultFile.outputStream().use { resultOutputStream ->\r\n            normalTrackFile.inputStream().use { normalTrackInputStream ->\r\n                instrumentalTrackFile.inputStream().use { instrumentalTrackInputStream ->\r\n                    // データが無くなるまで\r\n                    while (isActive) {\r\n                        // ちょっとずつ取り出して、音の加工をしていく\r\n                        // 一気に読み取るのは多分無理\r\n                        val normalTrackByteArray = ByteArray(BYTE_ARRAY_SIZE).also { byteArray -> normalTrackInputStream.read(byteArray) }\r\n                        val instrumentalTrackByteArray = ByteArray(BYTE_ARRAY_SIZE).also { byteArray -> instrumentalTrackInputStream.read(byteArray) }\r\n\r\n                        // 通常版からカラオケ版を引く処理\r\n                        val size = max(normalTrackByteArray.size, instrumentalTrackByteArray.size)\r\n                        val vocalOnlyByteArray = (0 until size)\r\n                            .map { index -> (normalTrackByteArray[index] - instrumentalTrackByteArray[index]).toByte() }\r\n                            .toByteArray()\r\n                        // ファイルに書き込む\r\n                        resultOutputStream.write(vocalOnlyByteArray)\r\n\r\n                        // どちらかのファイルが読み込み終わったら、無限ループを抜ける\r\n                        if (normalTrackInputStream.available() == 0 || instrumentalTrackInputStream.available() == 0) {\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * エンコードする\r\n     *\r\n     * @param rawFile 圧縮していないデータ\r\n     * @param resultFile エンコードしたデータ\r\n     */\r\n    suspend fun encode(\r\n        rawFile: File,\r\n        resultFile: File\r\n    ) = withContext(Dispatchers.Default) {\r\n        // エンコーダーを初期化\r\n        val audioEncoder = AudioEncoder().apply {\r\n            prepareEncoder(\r\n                codec = MediaFormat.MIMETYPE_AUDIO_AAC,\r\n                sampleRate = 44_100,\r\n                channelCount = 2,\r\n                bitRate = 192_000\r\n            )\r\n        }\r\n        // コンテナフォーマットに保存していくやつ\r\n        val mediaMuxer = MediaMuxer(resultFile.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)\r\n        var trackIndex = -1\r\n        rawFile.inputStream().use { inputStream ->\r\n            audioEncoder.startAudioEncode(\r\n                onRecordInput = { bytes ->\r\n                    // データをエンコーダーに渡す\r\n                    inputStream.read(bytes)\r\n                },\r\n                onOutputBufferAvailable = { byteBuffer, bufferInfo ->\r\n                    // 無いと思うけど MediaMuxer が開始していなければ追加しない\r\n                    if (trackIndex != -1) {\r\n                        mediaMuxer.writeSampleData(trackIndex, byteBuffer, bufferInfo)\r\n                    }\r\n                },\r\n                onOutputFormatAvailable = {\r\n                    // フォーマットが確定したら MediaMuxer を開始する\r\n                    trackIndex = mediaMuxer.addTrack(it)\r\n                    mediaMuxer.start()\r\n                }\r\n            )\r\n        }\r\n        mediaMuxer.stop()\r\n    }\r\n\r\n    /**\r\n     * 音楽ファイルを端末の音声フォルダにコピーする\r\n     *\r\n     * @param context [Context]\r\n     * @param fileName ファイル名\r\n     * @param targetFile 音楽ファイル\r\n     */\r\n    suspend fun copyToAudioFolder(\r\n        context: Context,\r\n        fileName: String,\r\n        targetFile: File\r\n    ) = withContext(Dispatchers.IO) {\r\n        val contentResolver = context.contentResolver\r\n        // 名前とか\r\n        val contentValues = contentValuesOf(\r\n            MediaStore.Audio.Media.DISPLAY_NAME to fileName,\r\n            // ディレクトリを掘る場合\r\n            MediaStore.Audio.Media.RELATIVE_PATH to \"${Environment.DIRECTORY_MUSIC}/VocalOnlyTrack\"\r\n        )\r\n        // 追加する\r\n        val uri = contentResolver.insert(\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) MediaStore.Audio.Media.getContentUri(MediaStore.VOLUME_EXTERNAL) else MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\r\n            contentValues\r\n        ) ?: return@withContext\r\n        // ファイルをコピーする\r\n        targetFile.inputStream().use { inputStream ->\r\n            contentResolver.openOutputStream(uri)?.use { outputStream ->\r\n                // Kotlin 拡張関数でコピー 一発\r\n                inputStream.copyTo(outputStream)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uri からファイル名をクエリする\r\n     *\r\n     * @param uri [Uri]\r\n     * @param context [Context]\r\n     * @return ファイル名\r\n     */\r\n    suspend fun getFileNameFromUri(\r\n        context: Context,\r\n        uri: Uri\r\n    ) = withContext(Dispatchers.IO) {\r\n        // DISPLAY_NAME を SELECT する\r\n        context.contentResolver.query(uri, arrayOf(MediaStore.Audio.Media.DISPLAY_NAME), null, null, null)?.use { cursor ->\r\n            // DB の先頭に移動して、\r\n            cursor.moveToFirst()\r\n            cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DISPLAY_NAME))\r\n        }\r\n    }\r\n\r\n    private const val BYTE_ARRAY_SIZE = 8192\r\n\r\n}\r\n```\r\n\r\n## つなぎ合わせる\r\n`UI`からさっき作った関数を呼び出していきます。  \r\n本当は`UI`ではなく、`フォアグラウンドサービス`なんかで`Activity`を破棄した後でも動くようにすべきです  \r\n\r\nというわけで UI のコード全部張ります！どーーーん\r\n\r\nやってることはコメントに書いてるので見てください（全投げ\r\n\r\n```kotlin\r\nclass MainActivity : ComponentActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContent {\r\n            VocalOnlyDroidTheme {\r\n                HomeScreen()\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun HomeScreen() {\r\n    val context = LocalContext.current\r\n    val scope = rememberCoroutineScope()\r\n\r\n    // 音声ファイルの Uri\r\n    val normalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n    val instrumentalTrackUri = remember { mutableStateOf<Uri?>(null) }\r\n\r\n    // ファイルピッカー\r\n    val normalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { normalTrackUri.value = it }\r\n    val instrumentalTrackFilePicker = rememberLauncherForActivityResult(contract = ActivityResultContracts.OpenDocument()) { instrumentalTrackUri.value = it }\r\n\r\n    val progressStatus = remember { mutableStateOf(ProgressStatus.IDLE) }\r\n\r\n    // 処理内容\r\n    fun start() {\r\n        scope.launch(Dispatchers.Default) {\r\n\r\n            // 作業用の仮フォルダを作る\r\n            val tempFolder = context.getExternalFilesDir(null)?.resolve(\"temp_work\")!!.apply {\r\n                mkdir()\r\n            }\r\n\r\n            // 音声ファイルをデコードする\r\n            progressStatus.value = ProgressStatus.DECODE\r\n            val (normalRawFile, instrumentalRawFile) = listOf(normalTrackUri.value!!, instrumentalTrackUri.value!!)\r\n                .mapIndexed { index, uri ->\r\n                    // 並列でデコードしてファイルを返す\r\n                    async {\r\n                        context.contentResolver.openFileDescriptor(uri, \"r\")!!.use {\r\n                            val rawFile = File(tempFolder, \"audio_$index.raw\").apply { createNewFile() }\r\n                            VocalOnlyProcessor.decode(\r\n                                fileDescriptor = it.fileDescriptor,\r\n                                outputFile = rawFile\r\n                            )\r\n                            return@use rawFile\r\n                        }\r\n                    }\r\n                }\r\n                // 並列で実行した処理を待ち合わせる\r\n                .map { it.await() }\r\n\r\n            // ボーカルだけ取り出す\r\n            progressStatus.value = ProgressStatus.EDIT\r\n            val vocalRawFile = tempFolder.resolve(\"audio_vocal.raw\").apply { createNewFile() }\r\n            VocalOnlyProcessor.extract(\r\n                normalTrackFile = normalRawFile,\r\n                instrumentalTrackFile = instrumentalRawFile,\r\n                resultFile = vocalRawFile\r\n            )\r\n\r\n            // 生データをエンコードする\r\n            progressStatus.value = ProgressStatus.ENCODE\r\n            val encodeVocalFile = tempFolder.resolve(\"audio_vocal.aac\").apply { createNewFile() }\r\n            VocalOnlyProcessor.encode(\r\n                rawFile = vocalRawFile,\r\n                resultFile = encodeVocalFile\r\n            )\r\n\r\n            // ファイルを音楽フォルダにコピーする\r\n            progressStatus.value = ProgressStatus.ONE_MORE_THING\r\n            val fileName = VocalOnlyProcessor.getFileNameFromUri(context, normalTrackUri.value!!)!!\r\n            VocalOnlyProcessor.copyToAudioFolder(\r\n                context = context,\r\n                fileName = \"$fileName.aac\",\r\n                targetFile = encodeVocalFile\r\n            )\r\n\r\n            // 後始末\r\n            tempFolder.deleteRecursively()\r\n            progressStatus.value = ProgressStatus.IDLE\r\n        }\r\n    }\r\n\r\n    Scaffold(\r\n        topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.app_name)) }) }\r\n    ) {\r\n        Column(\r\n            modifier = Modifier.padding(it),\r\n            verticalArrangement = Arrangement.spacedBy(5.dp)\r\n        ) {\r\n\r\n            Button(\r\n                onClick = { normalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = normalTrackUri.value?.toString() ?: \"通常版の選択\") }\r\n\r\n            Button(\r\n                onClick = { instrumentalTrackFilePicker.launch(arrayOf(\"audio/*\")) }\r\n            ) { Text(text = instrumentalTrackUri.value?.toString() ?: \"カラオケ版の選択\") }\r\n\r\n            // 実行中は実行ボタンを出さない\r\n            if (progressStatus.value == ProgressStatus.IDLE) {\r\n                Button(\r\n                    onClick = { start() }\r\n                ) { Text(text = \"処理を始める\") }\r\n            } else {\r\n                CircularProgressIndicator()\r\n                Text(text = \"処理中です：${progressStatus.value}\")\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate enum class ProgressStatus {\r\n    /** 実行可能 */\r\n    IDLE,\r\n\r\n    /** デコード中 */\r\n    DECODE,\r\n\r\n    /** 音声の加工中 */\r\n    EDIT,\r\n\r\n    /** エンコード中 */\r\n    ENCODE,\r\n\r\n    /** あとしまつ */\r\n    ONE_MORE_THING\r\n}\r\n```\r\n\r\n# 使ってみた\r\n多分実行できるはず。  \r\n起動したらそれぞれファイルを選んで処理を開始します\r\n\r\n![Imgur](https://imgur.com/9A2ASVs.png)\r\n\r\n![Imgur](https://imgur.com/HRmVKQ8.png)\r\n\r\n保存先はここになります！！\r\n\r\n![Imgur](https://imgur.com/gRoaKrP.png)\r\n\r\n# 感想\r\n\r\n- うまくボーカルだけ取れる パターン\r\n- 若干ボーカル以外も入ってる パターン\r\n- 失敗しちゃう パターン（音割れ）\r\n\r\nいくつか試しましたが結構な確率で失敗しちゃいますね。  \r\n原因はおそらく、音声の波が通常版とカラオケ版で若干ずれてることがあるんですよね、、、（オフセットがある？）  \r\n`Audacity`で逆位相にして同時再生する方法でも、まずは波を合わせる作業をする必要がある場合がが多く、  \r\n今回のようにそのままカラオケ版トラックを逆位相にして（通常版から引き算して）同時再生してもうまく抜けません。\r\n\r\nなかなか難しい...うまく抜けるとほんとにボーカルしか聞こえなくて感動ものなのですが...\r\n\r\n# そーすこーど\r\nどうぞ  \r\n最新の Android Studio で実行できるはずです。\r\n\r\nhttps://github.com/takusan23/VocalOnlyDroid\r\n\r\n# おわりに\r\n8月も終わりますね...\r\n\r\n全然話変わるんだけど、三井住友銀行さんさあ...メール普通にビビるからやめてほしい\r\n\r\n![Imgur](https://imgur.com/eWb136O.png)\r\n\r\n展開するとちゃんとウソであることが書いてある\r\n\r\n![Imgur](https://imgur.com/GGsYLqt.png)"},{"title":"夏休み企画　秋葉原の中古エロゲショップめぐり","link":"/posts/summer_vacation_r3_akiba_used_eroge/","markdown":"\nちなみに私は社会人なので夏休みありません。  \n学生各位は楽しんで（まあ高校生以下はこの記事読んでも実践できないな...）\n\n# 本題\n知ってる限り中古エロゲを扱ってるお店を紹介します。  \nエロゲサウンドトラックの取り扱いも分かる範囲で。Kyash（Kyash Card Liteの方）が使えるかどうかも買ったことがある店舗だったら書いておきます。  \n本当はXiaomi Mi 11 Lite 5Gの記事を書こうと思いましたが予定変更。\n\n# 今回行くお店\n\n- [ソフマップAKIBA ソフト館](#ソフマップAKIBAソフト館)\n    - HP：https://www.sofmap.com/tenpo/contents/?id=shops&sid=akiba_soft\n    - 二階が新作、三階が中古\n\n- トレーダー (本店、2、3号店)\n    - HP：http://www.e-trader.jp/shop/akiba01.html\n    - [本店](#トレーダー本店)\n        - エロゲコーナーは5階\n        - CDは4階\n    - [2号店](#トレーダー2号店)\n        - エロゲコーナーは2階\n    - [3号店](#トレーダー3号店)\n        - エロゲコーナーは4階\n        - CDは1階\n\n- [駿河屋（秋葉原本館）](#駿河屋)\n    - HP：https://www.suruga-ya.jp/feature/akihabara_main/index.html\n    - エロゲコーナーは7階\n\n- [まんだらけ（コンプレックス）](#まんだらけ)\n    - HP：https://www.mandarake.co.jp/dir/cmp/\n    - エロゲコーナーは4階\n    - CDも4階においてあった\n\n- [らしんばん](#らしんばん)\n    - https://www.lashinbang.com/store/13/\n    - エロゲコーナーは2階ののれんかかってるところ\n    - CDはCDコーナーにあった（のれんのところじゃない）\n\n- ムーラン（本店、中央通り店）\n    - HP：http://www.mooran.co.jp/\n    - [本店](#ムーラン本店)\n        - エロゲコーナーは2階\n    - [中央通り店](#ムーラン中央通り店)\n        - エロゲコーナーは4階\n\n- [K-Books（秋葉原本館）](#K-Books)\n    - HP：https://k-books.co.jp/shop/akihabara_honkan\n    - エロゲコーナーは3階\n    - CDも3階\n    - どっちかっていうとグッズがメインな雰囲気\n\n# おすすめの順番？\n最初にソフマップ目指して、あとは駅に戻る感じで私はいつもしてる。      \nあとトレーダーの3号店は中央通りを横断する（ビックカメラの方）必要があるのでどうするかな。  \n`トレーダー 2号店`と`ムーラン 本店`は近い。ちょっと歩けば`らしんばん`と`ムーラン 中央通り店`にも行ける。  \n`駿河屋`と`まんだらけ`も近い。\n\n# 行く前に\n年齢確認できるやつを持っていこう。  \n~~今までで一回だけ聞かれた事がある~~\n\n# <span id=\"ソフマップAKIBAソフト館\">ソフマップAKIBA ソフト館</span>\n~~写真撮りそこねたので4月の写真を代わりに（次行ったとき取り直してくる）~~ 取り直してきました。ついでに予約してきた。かわいい  \nリニューアル前を知らないので少し残念。\n\n![Imgur](https://imgur.com/dYNQqBD.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d12960.043336936349!2d139.771178!3d35.701351!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0xec9b4fc028069b57!2z44K944OV44Oe44OD44OXIEFLSUJBIOOCveODleODiOmkqA!5e0!3m2!1sja!2sjp!4v1627226250763!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nずっと歩いて、サイゼのあるところを曲がれば行ける。  \n新作は2階、中古は3階においてあります。  \nKyash使えました。  \n\n新作の取り扱いに関しては一番だと思います。ハジラブはソフマップで予約した。  \n中古はちょっと値段高めな気がする。  \nとりあえず`ソフマップ`とこの後紹介する`トレーダー`行けばお目当てが見つかると思う。  \n\n# <span id=\"トレーダー本店\">トレーダー 本店</span>\n写真はMi 11 Lite 5Gで撮影したけど、サイズがでかすぎたのでGIMPで品質を半分にした画像を貼ります。\n\n![Imgur](https://imgur.com/flkYYZp.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d3240.029730098827!2d139.771296!3d35.700886!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0xf44917d603081bf7!2z44OI44Os44O844OA44O8IOacrOW6lw!5e0!3m2!1sja!2sjp!4v1627226235931!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\n新品、中古問わずエロゲコーナーは5階です。  \nCDは4階にあります。  \nKyash使えました。\n\nこのお店に限らずトレーダーは品揃えがいい感じ。  \n本店はちと狭い。    \nトレーダーの中でも本店だけ？大手のメーカーはメーカー別に並んでいるので奥まで進んでみてね。\n\n# <span id=\"トレーダー2号店\">トレーダー 2号店</span>\n\n~~写真は取りそこねました。覚えていれば次行ったとき撮ってきます。~~ 撮ってきました。\n\n![Imgur](https://imgur.com/gClfuuz.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d3240.1229465748465!2d139.77038!3d35.698592!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0xd9fcac2ce87d746d!2z44OI44Os44O844OA44O8IOeni-iRieWOnzLlj7flupc!5e0!3m2!1sja!2sjp!4v1627226930875!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\n新品、中古問わずエロゲコーナーは2階です。\n\nおなじトレーダーでも値段が違うことがある。。かも？\n\n# <span id=\"トレーダー3号店\">トレーダー 3号店</span>\n\n![Imgur](https://imgur.com/xyZvjei.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d3240.059963038522!2d139.771644!3d35.700142!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0x72c850c866fa53e8!2z44OI44Os44O844OA44O8IOeni-iRieWOnzPlj7flupc!5e0!3m2!1sja!2sjp!4v1627227197765!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\n新品、中古問わずエロゲコーナーは4階です。  \nCDは1階においてありました。\n\n秋葉原エロゲショップの中でも店の中が広い。  \nビックカメラの隣の方にある。ので横断歩道を渡る必要がある。ちょいめんどい\n\n# <span id=\"駿河屋\">駿河屋 秋葉原本店</span>\n写真取るの下手くそかよ\n\n![Imgur](https://imgur.com/vgjRTvc.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d1620.0201883535572!2d139.770562!3d35.700624!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1dcb95431f%3A0x762fbb4675087d94!2z44CSMTAxLTAwMjEg5p2x5Lqs6YO95Y2D5Luj55Sw5Yy65aSW56We55Sw77yT5LiB55uu77yR77yR4oiS77yT!5e0!3m2!1sja!2sjp!4v1627227496352!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\n新作、中古問わずエロゲコーナーは7階です。階段で上がるのは結構しんどい  \n\n品揃えもいいと思います。  \n値段は普通？\n\n## CDは 駿河屋 秋葉原駅前店\nCDは駿河屋 秋葉原駅前店に置いてありました。  \n駅から近いけど（ラジオ会館のお隣）、他のエロゲショップからは遠い。\n\n![Imgur](https://imgur.com/nvF5bEf.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d810.0393001366185!2d139.77159982922305!3d35.697748998761924!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1d4da05555%3A0x6222da3b1962b0eb!2z6ae_5rKz5bGLIOeni-iRieWOn-mnheWJjeW6lw!5e0!3m2!1sja!2sjp!4v1630768780832!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nゲームCDは二階の奥の隅っこにありました。  \nKyash Card Lite使えました。\n\n# <span id=\"まんだらけ\">まんだらけ コンプレックス</span>\n\n![Imgur](https://imgur.com/9AAeVOJ.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d6480.101558869009!2d139.770513!3d35.700368!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x0%3A0x8c537b9b72799bd3!2z44G-44KT44Gg44KJ44GR44Kz44Oz44OX44Os44OD44Kv44K5!5e0!3m2!1sja!2sjp!4v1627228337141!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nエロゲコーナーは4階の奥の方。多分中古だけ。  \n\nCDは、\n\n- 6階のゲームCDコーナー。奥の方。\n- エロゲコーナーの隣\n\nのどっちかにあると思います。エロゲコーナーの隣は初回特典で付いてきたCDとかがメインなので、CD目的の場合は6階行ってください。\n\n品揃えは少なめです。だけど値段が安い。\n\nここはKyash Card Liteが使えなかったはず。このお店は暗証番号に対応しているカードじゃないと決済できないと思う。(つまりICチップが付いてるカードじゃないとだめ)  \niDとか代替決済手段があるので心配する必要はないと思う。\n\n\n# <span id=\"らしんばん\">らしんばん</span>\n\n![Imgur](https://imgur.com/Uf2CEDE.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m14!1m8!1m3!1d6480.1704760139655!2d139.770391!3d35.69952000000001!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1dacbd172f%3A0x6abc12977417ce04!2z44KJ44GX44KT44Gw44KT56eL6JGJ5Y6f5bqX5paw6aSo!5e0!3m2!1sja!2sus!4v1627228711576!5m2!1sja!2sus\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nエロゲコーナーは2階ののれんがかかってるところ。多分中古だけ。  \nCDは2階のCDコーナーに普通に並んであります。のれんかかってない  \n\n(ショーケースの中にもあるっちゃあるけど、ショーケースの中なのでお察し)\n\n品揃えは少ないですが、値段が安い。  \n`Sugar*Style`が2200円だったので買っちゃった。\n\nKyash使えました。\n\n# <span id=\"ムーラン本店\">ムーラン 本店</span>\n写真もっとうまく撮れや\n\n![Imgur](https://imgur.com/ALzjSpH.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d810.0300042318594!2d139.7692180292248!3d35.6986640987619!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1cf98b4049%3A0xe6fc2d9a47b85b6e!2z6LK35Y-W6LKp5aOy5biC5aC044Og44O844Op44OzQUtJQkHmnKzlupc!5e0!3m2!1sja!2sjp!4v1627229573133!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nトレーダー 2号店がある高架下にあります。そのまま奥に進んでいけばおｋ。  \nエロゲコーナーは2階にあります。AVばっかで迷子になりますが、真ん中らへんにありました？  \nこちらも値段が安い。品揃えはちょっと多い方？。  \nKyash使えました。\n\nここではOP、ED共に名曲の`ちいさな彼女の小夜曲`を買いました。**feng生き返れ...。** 値段が1800円で買う予定なかったけど安かったので購入した。  \n\n![Imgur](https://imgur.com/xbNjp65.png)\n\n# <span id=\"ムーラン中央通り店\">ムーラン 中央通り店</span>\n\n![Imgur](https://imgur.com/BXGqPQZ.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d25920.96056003467!2d139.75225560007613!3d35.698662792538094!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1d08f1b007%3A0x85ae0041177e526a!2z6LK35Y-W6LKp5aOy5biC5aC044Og44O844Op44OzQUtJQkHkuK3lpK7pgJrjgorlupc!5e0!3m2!1sja!2sus!4v1627229846365!5m2!1sja!2sus\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nエロゲコーナーは3階です。  \n品揃えは多めだと思う。CDは一番奥の棚の端っこにある。\n\n# <span id=\"K-Books\">K-Books 秋葉原本店</span>  \n↓この建物の3階\n\n![Imgur](https://imgur.com/qq3wdGa.png)\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3240.1504602823316!2d139.76976841526525!3d35.69791488019043!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1d4ec94be1%3A0xe8781a5ca3d62bed!2z44CSMTAxLTAwMjEg5p2x5Lqs6YO95Y2D5Luj55Sw5Yy65aSW56We55Sw77yR5LiB55uu77yR77yV4oiS77yR77yWIOODqeOCuOOCquS8mumkqA!5e0!3m2!1sja!2sjp!4v1627230502940!5m2!1sja!2sjp\" width=\"80%\" height=\"450\" style=\"border:0;\" allowfullscreen=\"\" loading=\"lazy\"></iframe>\n\nエロゲコーナーは3階の奥の方です。ここはどっちかっていうとグッズがメインなのでエロゲあんまりなかった。  \nCDもエロゲコーナーの隣にありました。他よりCDは多いと思う。\n\nてかいつの間にかヤマダ電機なくなってた。ヤマダ電機跡地のとなりです。\n\n![Imgur](https://imgur.com/YVZ5gth.png)\n\nちなみにヤマダ電機の前はサトームセンが入っていたらしい。知らんけど\n\n<div>\n<script type=\"application/javascript\" src=\"https://embed.nicovideo.jp/watch/sm4163864/script?w=640&h=360&from=45\"></script><noscript><a href=\"https://www.nicovideo.jp/watch/sm4163864\">家電量販店CMソング等有名部分の詰め合わせ</a></noscript>\n</div>\n\n# おまけ 値段比較\n\nちゃんと見てないので（安くなっている理由とかよく見てないし、未開封で高くなってたりするかもしれない）のであんま参考にしないで\n\n|        エロゲタイトル        | ソフマップ | トレーダー | 駿河屋 | まんだらけ | らしんばん | ムーラン |\n|:----------------------------:|:----------:|:----------:|:------:|:----------:|:----------:|:--------:|\n| ハッピーライヴ ショウアップ! |     -      |    4480    |  5200  |    4400    |     -      |   4546   |\n|      夢と色でできている      |    5808    |    5480    |  7480  |     -      |    4620    |   4000   |\n|         Sugar*Style          |    2508    |    3180    |  2800  |    2700    |    2200    |    -     |\n|     ゆびさきコネクション     |    5808    |    5780    |   -    |    4400    |     -      |   4091   |\n|       放課後シンデレラ       |    6578    |    6380    |  6400  |    5600    |     -      |    -     |\n\n# 終わりに\nフルプライスのエロゲってやっぱパッケージ版が欲しいよね？。~~DL版だとなんか損した気持ちに？~~\n\nパッケージ版が欲しい、初回限定版(初回豪華版？)が欲しいって方は行ってみてください。DL版のセールよりも安くなっているときがよくある（**なお交通費**）\n\nなんかいいお店あればこのブログのIssueでもTwitterでもいいのでどうぞ。\n\nあと話変わるんだけど、`GitHub Copilot`君に結構助けられてる。GitHub、GJ  \n↓補充が有能すぎる。なんでこれから入力しようとしてること分かんだよこえーよ  \n\n![Imgur](https://imgur.com/u0YKTxt.png)"},{"title":"Surface Pro7 修理(交換)に出した","link":"/posts/surface_pro7_repair/","markdown":"画面がちらついてたので~~修理に出す~~。交換機と取り替えてもらった。  \r\nこれ法人向けでOfficeなしモデルだから参考にならないかもしれない。\r\n\r\n# 修理出すまで\r\n\r\n## MSアカウントとSurfaceデバイスを紐付ける\r\nシリアルを登録します。\r\n\r\n## 修理を注文する\r\n\r\n何が悪いのか書いて\r\n\r\n![Imgur](https://imgur.com/Bmhd1o6.png)\r\n\r\n保証を選びます。  \r\nよく見てなかったけどここにちゃんと交換機と交換って書いてあるじゃん。\r\n\r\n![Imgur](https://imgur.com/8mbGPQ5.png)\r\n\r\n今回はゆうパックで送ります。\r\n\r\n![Imgur](https://imgur.com/QDbjtMv.png)\r\n\r\n数十分後にアカウントのデバイス画面から修理の進捗と、メールが届きます。  \r\n\r\n![Imgur](https://imgur.com/unjDtYs.png)\r\n\r\n\r\n![Imgur](https://imgur.com/q5P9qcL.png)\r\n\r\n## Surfaceのデータを消す\r\n消します。  \r\nデータを逃したい場合は今がチャンス。\r\n\r\n## 壊れてるSurfaceを送る\r\n日が経ったのであんま覚えてないけど、ご注文番号が発行されてると思います。メールとかで来ると思う。  \r\nそしたら箱に詰めます。多分ゆうパックで送れるサイズのダンボールにSurfaceが動かないよう緩衝材を入れればいいと思います。  \r\n充電器とかタイプカバーは送りません。SDカード差してる場合は抜いてね。\r\n\r\n↓ 法人向けモデルのせいなのかダンボールに入っていたのでそのまましまって送った。\r\n\r\n![Imgur](https://imgur.com/LZQfv2m.png)\r\n\r\n## 郵便局ヘ行く\r\n窓口で**着払いのゆうパックで送りたいんですけど**って言えば伝票をくれますので、台で必須項目を書きます。  \r\n住所、郵便番号は修理申し込みをしたときに来るメールの下の方に`送付先住所`として書いてあるので、書き写します。\r\n\r\n商品の欄は `PC` + `注文番号` を書きます。  \r\nもしかしたら`タブレットPC`って書いたほうがいいかもしれない。\r\n\r\n書いたら伝票を貼らずに窓口に持っていった。正攻法なのかは知らない。\r\n\r\n## 進捗がメールで来る\r\nマイクロソフトに荷物が渡ったあとは割と早かった気がする。  \r\n\r\n## 交換機到着\r\n日本郵便で送ってくれます。\r\n\r\n![Imgur](https://imgur.com/VPbKjZM.png)\r\n\r\n![Imgur](https://imgur.com/v9nnkNx.png)\r\n\r\n![Imgur](https://imgur.com/BtfEQQq.png)\r\n\r\nWindows 10が入ってました。  \r\nひたすらWindows Update (反射やば)\r\n\r\n![Imgur](https://imgur.com/FaWnEyj.png)\r\n\r\n以上です。  \r\nファンがないのでエロゲやるのに便利ですね。\r\n\r\n# 終わりに\r\nWindows 10までは右端から中央へスワイプすれば全画面時でもアプリ切り替えが出来たのに、  \r\nWindows 11から出来なくなって劣化してんじゃん！！って思ったんですけど、  \r\n**下から3本指タッチしながら上スワイプ**で切り替えできました。すいません。"},{"title":"タグのページ作った","link":"/posts/taglist/","markdown":"\r\nタグのページ作りました。  \r\n**まだタグ一覧は作ってませんが**、タグが含まれている記事の一覧表示ならできるようになりました\r\n\r\n試しにChipを押してみてね。  \r\n\r\n**あとページネーション(二ページ目みたいなやつ)付けてないから多分大変なことになる**\r\n\r\n## 技術的な話\r\n\r\n`posts/tag/自作ブログ/index.html` みたいなファイルが生成されるようになりました。  \r\n\r\n```js\r\n/** タグが含まれている記事一覧のパス配列生成関数。 */\r\nconst generateTagPageRoutesList = () => {\r\n  // 記事オブジェクト一覧配列を生成する。キーだけの配列にしてmapで取り出す\r\n  const blogItems = Object.keys(postsJSON.fileMap).map(key => postsJSON.fileMap[key])\r\n  // タグだけの配列を作る\r\n  const allTagItems = blogItems.map(blog => blog.tags).flat()\r\n  // 被りを消す。new Set()でいいらしい\r\n  const tagList = [...new Set(allTagItems)]\r\n  // パス生成。こんな感じの→ /posts/tag/自作ブログ みたいな感じに\r\n  const pathList = tagList.map(tagName => `/posts/tag/${tagName}`)\r\n  return pathList\r\n}\r\n// 省略\r\n/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */\r\nconst generateRoutes = callback => {\r\n  callback(null, [generateTagPageRoutesList()].flat())\r\n}\r\n```\r\n\r\nJavaScriptの配列、被りを消す方法にこんな方法があったんですね。  \r\n```js\r\nconsole.log([...new Set([1,2,1])]) // [1,2]\r\n```\r\n\r\nちなみにKotlinだと`array()#distinct()`があります。超便利\r\n\r\n以上です（？）  \r\n久々の学校はまあまあ楽しかったです。帰り陽キャが絡んできたのが減点ポイントですね。  \r\n\r\nあと2m確保とが無理じゃね？"},{"title":"これ作るのに大変だったこと","link":"/posts/taihendattakoto/","markdown":"\r\n**[TypeScript(nuxt/content)化に伴いこの記事は古くなり、ここに書いてある内容も（ほぼ）関係なくなっています](/posts/remake_ziyuutyou)**\r\n\r\nHexoってすごいんだなって。  \r\nなお完成はいつになるかわかりません。いつ出来上がるんだこれ？  \r\n完成までに思ったことを書いていくと思う。\r\n\r\n~~あとドメインが欲しい。買ったこと無いけどどうなんですかね？~~\r\n\r\n[取りました](/posts/domain_katta)\r\n\r\n## これ作るのに大変だったこと\r\n書く。\r\n\r\n### Vuetifyが`<code>`に色つける。\r\n\r\nVuetifyくんが勝手に色を付けてくれます。が、なんかいまいちなので頑張ってCSS書いて直したいんですが、  \r\nVuetifyくんが許してくれません。？  \r\nしかたないので`!important`で黙らせました。    \r\n\r\nassets/css/styles.css\r\n```css\r\n/* VuetifyのせいでCodeタグに勝手にCSS適用されるので強制上書き */\r\n\r\n.v-application code {\r\n    box-shadow: initial !important;\r\n    border: 1px solid gray;\r\n    border-radius: 5px !important;\r\n    font-family: 'Koruri Regular';\r\n    margin: 10px;\r\n}\r\n\r\n.v-application code, .v-application kbd {\r\n    font-weight: initial !important;\r\n}\r\n```\r\n\r\nついでに`highlight.js`のCSS、`vs2015.css`を入れてコードにシンタックスハイライトをつけようとしたんですけど、これもうまく動かなかったので`vs2015.css`に`!important`付けて対応しました。\r\n\r\n### CSS\r\nCSSよくわがんね。\r\n\r\n```css\r\n/* ほばー */\r\n.titleHover:hover {\r\n    color: #5870cb;\r\n    transition: color 0.5s;\r\n}\r\n```\r\n\r\nこれは記事一覧のタイトルをマウスオーバーするとジワーッと色が変わるCSSです。  \r\n\r\n### Processmdくんが時系列順に並べてくれない\r\n\r\nこれはおま環境かもしれないけど、時系列順に並んでくれません。  \r\n流石に時系列順にならないのはきついので、JavaScriptで時系列に並び替えるコードを書きました。sort関数あったし。\r\n\r\n```js\r\n// なんかしらんけど並び順が新しい順とは限らないらしい？\r\nconst sortedKeyList = Object.keys(fileMap);\r\nsortedKeyList.sort(function(a, b) {\r\n  const aDate = new Date(fileMap[a].created_at).getTime();\r\n  const bDate = new Date(fileMap[b].created_at).getTime();\r\n  if (aDate > bDate) return -1;\r\n  if (aDate < bDate) return 1;\r\n  return 0;\r\n});\r\n```\r\n\r\nKotlinの`sortBy{}`とは使い方が違っててちょっと迷った。\r\n\r\nあとprocessmdくん、/posts/jsonに消した記事が残ってるんですがそれは、、\r\n\r\n### ページネーション\r\n\r\n追記（2020/06/27）：もしかしたらこれ書く必要ないと思う（`_id.vue`ファイルは必要だと思う）  \r\n詳細→ [Nuxt.jsを2.13に上げた時の話](/posts/nuxt_2_13_sugoi)\r\n\r\n次のページ、前のページを付けることを、ページネーションって言うそうですよ。  \r\nこれ付けないと記事が増えたときのスクロールがとんでもないことになる。  \r\n\r\n記事一覧はこんな感じに静的に出してほしいので（postsに置くとタイトル被りそうなのでpageフォルダがある。）\r\n```js\r\n/posts/page/1\r\n```\r\n\r\n特に需要はなさそうですが一応必要なページ数に合わせて`posts/page`の配列を返す関数置いときますね。\r\n\r\n```js\r\n/** 次のページ機能をつける。そうしないと記事一覧にどばーってなってスクロール大変になる */\r\nconst generatePagenationRoutesList = () => {\r\n  // 何ページ必要か計算する（10で割ればいいっしょ）。ただ1ページ目は最低限必要なので1足す\r\n  const calc = Math.floor(postsJSON.sourceFileArray.length / PAGE_LIMIT) + 1\r\n  // ページ分だけ動的ルーティングの配列出す？\r\n  const dynamicRouterPathList = []\r\n  // console.log(`ページ数：${calc} / 記事数：${postsJSON.sourceFileArray.length}`)\r\n  // ページ生成。1ページ目から作るので1からスタート\r\n  for (let i = 1; i <= calc; i++) {\r\n    dynamicRouterPathList.push(`/posts/page/${i}`)\r\n  }\r\n  return dynamicRouterPathList\r\n}\r\n\r\n// 省略\r\n\r\n/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */\r\nconst generateRoutes = callback => {\r\n  callback(null, [generatePagenationRoutesList()].flat())\r\n}\r\n\r\n```\r\n\r\nこれ動かすには`postsフォルダ`に`pageフォルダ`を作って中に、`_id.vue`を置いておく必要があります。\r\n\r\nこれで`posts/page/1`などが生成されるようになります（多分）\r\n\r\n~~この記事書いてる途中でなんでこれ動いてんのかよくわからなくなったのは内緒~~←やっぱり生成できてなかったので直しました。（2020/06/03）\r\n\r\n### `<v-card>`が遅い？→いつの間にか直った？\r\n何故か知りませんが、VuetiryのCardコンポーネントがおそい。というかページ遷移がこいつのせいで遅くなる。  \r\n\r\nせっかくの静的サイトで遅いのは辛いので直したい。（しかも記事一覧に戻った時にワンテンポ遅れるとか見てられない）\r\n\r\nで、なぜか`<v-card>`を`<v-sheet>`に置き換えることで解決しました。  \r\n\r\nなんで？\r\n\r\n### 記事一覧を再読み込みした後記事を開くと404\r\n\r\nなんかしらんけどF5するとURLの後ろに`/`が入ります。  \r\n最後に`/`が入っていないのが前提で作っているので、最後に入ると **`../`(一個前に戻る)** がおかしな場所を指すようになります。\r\n\r\n---追記---\r\n\r\n**別に`../`使わなくても良いことに気付いたのでこの問題は解決しました。**  \r\n**`to='/posts/first'`みたいな感じで別に戻る必要ありませんでした。**\r\n\r\n---追記おわり---\r\n\r\nというかこれは私の作り方（ファイル構成）が悪いですね、なんで戻ったりしないといけないんだ。\r\n\r\n- pages\r\n  - pages（固定ページ。今回は省略）\r\n  - posts（ブログ）\r\n    - page\r\n      - _id.vue（記事一覧）\r\n    - tag\r\n      - _id.vue（タグ検索結果）\r\n    - index.vue（本来ここに記事一覧が有るべき？）\r\n    - _slug.vue（記事。ここに居るので一覧から来たら戻らないといけない。）\r\n\r\n\r\n今回は`nuxt.config.js`を開き、URLの最後に`/`を入れる設定を付けました。おかげて修正が必要になりましたが。\r\n\r\n```js\r\nexport.default {\r\n  // 省略\r\n  router: {\r\n    base: '/Ziyuutyou/',\r\n    trailingSlash: true // ←これ\r\n  }\r\n}\r\n```\r\n\r\n### `sw.js`がよくわからんけどバージョン管理対象外になってて**ホーム画面に追加**が消えてた\r\n\r\nGitHubのリポジトリ開いて`/docs`開いたら見事にServiceWorkerだけ抜けてました。なんで？\r\n\r\n### Hexoと違ってリアルタイムで記事の内容が反映されない\r\n\r\nHexoって書いてる途中でも、リロードすれば記事の内容が更新されてどんな感じに見れてるか確認できるんですけど、processmdくんデフォルトだとできないっぽい？  \r\n`processmd`見る感じ、ファイルの中身を監視する`--watch`オプションが存在するのでそれ使えばよさそうです、  \r\nそれで適当に`package.json`の`scripts`の中に実行とprocessmdの監視オプション付きを同時に実行する様に書いたんですけど、  \r\n**nuxt起動から先に進みません！そりゃnuxtもファイルを監視してるからそこで止まりますよね。**\r\n\r\nそれでどうすれば同時に（並列に）起動できるかって話ですが、`npm-run-all`ってのを使えば並列実行ができそうです。  \r\nただ、これ使っても更新できるのは記事の中身だけで記事一覧(summary.json)は更新できないっぽいです。(nuxt起動時にsummary.jsonが空っぽだぞって怒られる。どうやら一度消えるらしい？)  \r\n\r\nでも記事の中身がリアルタイムで反映されるようになったので満足です。VSCode半分にしなくて済むし。  \r\n参考程度の`package.json`のscript\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"dev\": \"nuxt --port 11451\",\r\n    \"build\": \"nuxt build\",\r\n    \"start\": \"nuxt start\",\r\n    \"generate\": \"nuxt generate\",\r\n    \"markdown\": \"npm run post && npm run page\",\r\n    \"page\": \"processmd contents/pages/**/*.md --stdout --outputDir contents/pages/json > contents/pages/summary.json --markdownOptions.linkify\",\r\n    \"post\": \"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json --markdownOptions.linkify\",\r\n    \"pagewatch\": \"processmd contents/pages/**/*.md --outputDir contents/pages/json --markdownOptions.linkify --watch\",\r\n    \"postwatch\": \"processmd contents/posts/**/*.md --outputDir contents/posts/json --markdownOptions.linkify --watch\",\r\n    \"all\": \"npm-run-all markdown --parallel dev postwatch\"\r\n  },\r\n}\r\n```\r\n\r\n`npm run all`を実行すると\r\n- markdownファイルがJSON形式に変換される\r\n- nuxt起動\r\n- nuxt起動と同時にprocessmdの監視を始める\r\n  - `--stdout`オプションは外してあるので、記事一覧は更新されない。\r\n\r\n`--parallel`のあとに指定したスクリプトが並列で実行され、その前に書いてあるスクリプトは直列で実行されます。\r\n\r\nちなみにprocessmdくんがJSONファイルを書き換えるとnuxtのファイル変更監視に引っかかるので自動で更新されるようになります。すげえ\r\n\r\n~~たまにundefinedになるけどしゃーない~~\r\n\r\n### マークダウンに書いたURLがリンクにならない\r\n\r\nprocessmdくんのオプションに`--markdownOptions.linkify`をくっつけて実行すればいいです。\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"post\": \"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json --markdownOptions.linkify\"\r\n  }\r\n}\r\n```\r\n\r\n### ~~しれっと~~Netlifyにお引越ししたりした。\r\n\r\nGitHubPagesより良いのかはしらんけどお試しで引っ越してみた。これ勝手にメアド公開したりしないよな？  \r\n[Netlify へデプロイするには？](https://ja.nuxtjs.org/faq/netlify-deployment/)ってのが有るのでそれに沿ってやればできると思います。\r\n\r\nじゃあなんで**大変だったこと**に書いてんだよって話ですが、っぱコケるんですね。\r\n\r\n<iframe src=\"https://best-friends.chat/@takusan_23/104330325427830329/embed\" class=\"mastodon-embed\" style=\"max-width: 100%; border: 0; height:200px\" width=\"400\" allowfullscreen=\"allowfullscreen\"></iframe><script src=\"https://best-friends.chat/embed.js\" async=\"async\"></script>\r\n\r\nあーJSだからしゃーないのかなーなんて思ってとりあえず検索すると、`Chromeのバージョン的に対応していない`とか出てきたのでワンちゃんNode.jsくんのバージョンがおかしいのではないかと考えました。  \r\n\r\nNetlifyにNode.jsのバージョンを指定する方法ですが、検索したらありました。 [参考元](https://qiita.com/n0bisuke/items/8bddad87610b01c90003)\r\n\r\n`.nvmrc`というファイルを置いて、中にNode.jsのバージョンを書くだけで解決しました。\r\n\r\n`v12.14.1`\r\n\r\nこれだけ。これで成功しました。\r\n\r\nちなみサイト作成時のステップ３で、ビルドコマンドに`npm run generate`、ディレクトリを`docs(GitHubPagesの名残)`すれば、コミット+プッシュ時に勝手に`npm run genreate`して公開してくれます。らく\r\n\r\n### 実は静的サイト書き出しできてなかった\r\nこれは別に記事に書いた→ [Nuxtの静的サイトジェネレートはモードをuniversalにしよう](/posts/nuxt_universal)\r\n\r\n読みたくない方向け→`nuxt.config.js`の`mode:`を`universal`にすればHTMLに書き出してくれます。  \r\n`spa`だとHTMLのbody見てもscriptタグが何個か有るだけで、内容はJS実行されるまで表示されませんでした。  \r\n`universal`ならHTMLに書き出してくれるのでJS切っても見れます。\r\n\r\n### (本当かわからんけど)開発時(localhost)の時は別のタブで開けない？\r\n\r\n記事を別のタブで開くと永遠に読み込んでたりするんだけどもしかして別のタブで開くことできない？\r\n\r\n## 特に大変じゃなかったこと\r\n\r\n### PWA\r\n\r\nPWAってめんどいんですよ。アイコン画像を用意するのがね！！！。  \r\n192x192だったり512x512だったりいっぱい要求してくるんですけど、  \r\n`@nuxt/pwa`は指定がない場合、`static/icon.png`を使ってくれるので、512x512のpngを置いておくだけで終わりました。PWA RTA行けそう（は？）  \r\n\r\n一応`nuxt.config.js`の`manifest`置いておきますね。\r\n\r\n```js\r\n/** \r\n * PWA manifest.json\r\n */\r\nmanifest: {\r\n  name: 'たくさんの自由帳',\r\n  title: 'たくさんの自由帳',\r\n  'og:title': 'たくさんの自由帳',\r\n  lang: 'ja',\r\n  theme_color: '#8c9eff',\r\n  background_color: '#5870cb',\r\n  display: 'standalone',\r\n}\r\n```\r\n\r\n### ダークモード\r\n\r\nVuetifyなら  \r\n```js\r\n$vuetify.theme.dark = true\r\n```  \r\nで終わります。Vuetifyすげー\r\n\r\nダークモード切り替えスイッチの例置いときますね。\r\n\r\n```js\r\n<!-- ダークモードスイッチ -->\r\n<v-switch\r\n  class=\"text-center ma-2\"\r\n  :append-icon=\"`${$vuetify.theme.dark ? 'mdi-weather-night' : 'mdi-weather-sunny'}`\"\r\n  v-model=\"$vuetify.theme.dark\"\r\n  label=\"テーマ切り替え\"\r\n></v-switch>\r\n```\r\n\r\n三項演算子使うの初めてかもしれない（まずKotlinにはないし）  \r\n\r\nところで$←これなに？\r\n\r\n### 端末がダークモードかどうか\r\n\r\n以下のJSでダークモードかどうかを監視して、Vuetifyのモードを変更するようにできます。  \r\n[参考：StackOverflow](https://stackoverflow.com/questions/56393880/how-do-i-detect-dark-mode-using-javascript)\r\n\r\n```js\r\nwindow\r\n      .matchMedia(\"(prefers-color-scheme: dark)\")\r\n      .addEventListener(\"change\", e => {\r\n        const isDeviceDarkModeEnabled = e.matches;\r\n        // Vuetify切り替える\r\n        this.$vuetify.theme.dark = isDeviceDarkModeEnabled\r\n      });\r\n```\r\n\r\n**StackOverflow**先生の回答では`e.matches`に`darkかlight`が入ってるっぽいんですが、私のChromeくんでは`trueかfalse`でした。先生の回答ちょっと古かったのかな。\r\n\r\n~~まあダークモードなんてあんま使わないんですけどね（は？）~~\r\n\r\n## おわりに\r\n学校始まるわ。早起きつっら  \r\nあと画像貼る方法確立してない。imgur使うか？"},{"title":"Next.jsでブログ作り直したのでその際に大変だったこと","link":"/posts/taihendattakoto_next_js_blog/","markdown":"\r\nどうもこんばんわ。\r\n\r\nNext.jsへ移行したらなんか読み込みが早くなった気がする。TypeScriptのサポートがいいね！\r\n  \r\nInternet Explorer 11 でも見れなくはないですね。  \r\n先人が頑張ってPolyfillしたんかな、、、お疲れ様です\r\n\r\n## Nuxt.js からの移行\r\n- URLの末尾にスラッシュを付ける\r\n    - 知らんけどONにしておく\r\n\r\n### nuxt/content で使ってた機能\r\n- 記事書いてるときのリアルタイム更新\r\n    - いらないと言えばいらないかも...\r\n\r\n## remark() と rehype() \r\n- remark\r\n    - Markdown処理系\r\n- rehype\r\n    - Html処理系\r\n\r\n```ts\r\n// マークダウン -> unified -> HTML \r\nconst remarkParser = await unified()\r\n    .use(remarkParse)\r\n    .use(remarkRehype, { allowDangerousHtml: true })\r\n    .use(rehypeRaw)\r\n    .use(remarkGfm)\r\n    .use(rehypeStringify)\r\n    .use(rehypeHighlight, {\r\n        // 利用できない言語の場合はエラー出さずに無視\r\n        ignoreMissing: true\r\n    })\r\n    .process(matterResult.content)\r\nconst markdownToHtml = remarkParser.toString()\r\n```\r\n\r\n### Markdownのテーブル（表）、打ち消し線、URLの自動リンク機能は標準機能ではない！\r\n\r\nすべて有志の拡張機能だったんですね。  \r\nというわけで、`remark-gfm`を入れます。\r\n\r\n```\r\nnpm i remark-gfm\r\n```\r\n\r\nあと表には CSS を当てないと見ずらいですね。\r\n\r\n```css\r\ntable {\r\n    border-collapse: collapse;\r\n    border-spacing: 0;\r\n    width: 100%;\r\n    margin: 10px;\r\n}\r\n\r\ntable tr {\r\n    border-bottom: solid 1px #000;\r\n}\r\n\r\ntable td {\r\n    padding: 10px;\r\n    text-align: center;\r\n}\r\n```\r\n\r\n### Markdownに埋め込んだHTMLも対応させる\r\n\r\n`npm i rehype-raw`で対応できます\r\n\r\n## getStaticPaths と getStaticProps の動的ルーティング\r\n\r\n`[ここの名前].tsx`←ここの名前 の部分がキーになります。注意して下さい\r\n\r\n\r\n```ts\r\n// getStaticPaths\r\n\r\nconst pathIdList = []\r\nfor (let i = 0; i < requirePageCount; i++) {\r\n    // この場合はキーが page になるけどこれはファイル名によって変わる（[page].tsxだから）\r\n    pathIdList.push({ params: { page: `${i}` } })\r\n}\r\nreturn {\r\n    paths: pathIdList,\r\n    fallback: false\r\n}\r\n```\r\n\r\n```ts\r\n// getStaticProps\r\nexport const getStaticProps: GetStaticProps<BlogListPageProps> = async context => {\r\n    // posts/page/<ここ> を取得\r\n    const pageId = parseInt(context.params[\"page\"] as string) //[page].tsx だから page\r\n    // 省略...\r\n```\r\n\r\n## ReactのJSX(TSX)の中で条件付きレンダリング\r\nこれ使っていいのか知らんけど面白いので使ってます。  \r\n`Jetpack Compose`と違って、returnでJSXを返す必要があるんだけどJSX内ではifが書けない。  \r\n代わりに`&&`を使って左側がtrueの場合は右側に進むことを利用した方法でかける。かしこい！\r\n\r\nhttps://ja.reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator\r\n\r\n```tsx\r\nconst ExpandedText = () => {\r\n    const [isExpanded, setExpanded] = useState(false)\r\n\r\n    return (\r\n        <>\r\n            <p>Hello</p>\r\n            {\r\n                isExpanded && <p>World</p>\r\n            }\r\n            <Button onClick={()=> setExpanded(!isExpanded)}>\r\n                Open!\r\n            </Button>\r\n        </p>\r\n    )\r\n}\r\n```\r\n\r\n## ダークモード\r\n`MUI`の機能でできます。  \r\n一応色置いておきます。\r\n\r\n```tsx\r\nconst useCustomTheme = (isDarkmode: boolean) => {\r\n    // isDarkmode が変わったときだけ再計算されるはず\r\n    return React.useMemo(\r\n        () => createTheme({\r\n            palette: {\r\n                mode: isDarkmode ? 'dark' : 'light',\r\n                primary: {\r\n                    main: isDarkmode ? '#b6c4ff' : '#4559a9', // md_theme_light_primary\r\n                },\r\n                secondary: {\r\n                    main: '#006c49',\r\n                },\r\n                error: {\r\n                    main: '#ba1b1b',\r\n                },\r\n                background: {\r\n                    default: isDarkmode ? '#000000' : '#dce1ff', // md_theme_light_primaryContainer\r\n                    paper: isDarkmode ? '#1b1b1f' : '#fefbff', // md_theme_light_surface : md_theme_dark_surface\r\n                }\r\n            },\r\n            typography: {\r\n                fontFamily: [\r\n                    'Koruri Regular'\r\n                ].join(','),\r\n            }\r\n        }),\r\n        [isDarkmode]\r\n    )\r\n}\r\n\r\nexport default useCustomTheme\r\n```\r\n\r\nダークモードスイッチのイベントは`Props`でスイッチの切り替えバケツリレーしてます。  \r\n正攻法はわからん。頻繁に使うもんじゃないしいいんじゃね？\r\n\r\nついでにシステム設定のダークモードも反映させるようにしました。Win10で確認した\r\n\r\n```tsx\r\n// _app.tsx\r\n\r\n/**\r\n * Androidで言うところのActivity。この中でPages(AndroidでいうとFragment)を切り替える\r\n */\r\nconst App = ({ Component, pageProps }) => {\r\n    // ダークモードスイッチ\r\n    const [isDarkmode, setDarkmode] = useState(false)\r\n    // テーマ。カスタムフック？何もわからん\r\n    const theme = useCustomTheme(isDarkmode)\r\n\r\n    // システム設定がダークモードならダークモードにする。Win10で確認済み\r\n    const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)')\r\n    // システム設定のダークモード切り替え時にテーマも切り替え\r\n    useEffect(() => {\r\n        setDarkmode(prefersDarkMode)\r\n    }, [prefersDarkMode])\r\n\r\n    return (\r\n        <>\r\n            <ThemeProvider theme={theme}>\r\n                {/* ナビゲーションドロワーとタイトルバーをAppで描画する。各Pageでは描画しない */}\r\n                <Layout\r\n                    isDarkmode={isDarkmode}\r\n                    onDarkmodeChange={() => setDarkmode(!isDarkmode)}\r\n                >\r\n                    {/* 各Pageはここで切り替える。これでタイトルバー等は共通化される */}\r\n                    <Component {...pageProps} />\r\n                </Layout>\r\n            </ThemeProvider>\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n## Android 12 みたいなスイッチ\r\nここに例があります。thx!!!\r\n\r\nhttps://mui.com/components/switches/#customization\r\n\r\n## SVG画像の色を簡単に変えられると思ってた\r\nAndroidだと`ImageView#setTint() だっけ？`できるけどCSSにはそういう機能無いらしい。  \r\nなのでこういうCSSをかけばいいと思います。私もよく知らないので詳しくは 属性セレクター とかで検索してください。  \r\n`!important`を追記すればsvg内のpath、circleの色も上書き出来ます。使っていいのかは知らんけど\r\n\r\n```html\r\n<svg className=\"svg_color\">\r\n\r\n</svg>\r\n```\r\n\r\n```css\r\n.svg_color path {\r\n    stroke: red;\r\n}\r\n.svg_color circle[style*=\"fill:none\"] {\r\n    stroke: red;\r\n}\r\n.svg_color circle[style*=\"stroke:none\"] {\r\n    fill: red;\r\n}\r\n```\r\n\r\n`pages/404.tsx`参照\r\n\r\n\r\n## サイトマップ\r\n\r\nhttps://github.com/iamvishnusankar/next-sitemap \r\n\r\nを利用することで簡単に作成できます。  \r\n\r\nいれて\r\n\r\n`npm install --save-dev next-sitemap`\r\n\r\n`package.json`があるフォルダに`next-sitemap.config.js`を作成します。  \r\n公式では`next-sitemap.js`を作れと言ってますが、Windowsの場合は駄目だと思います。\r\n\r\n(Windowsだとどうやら 環境変数 よりも フォルダ内ファイル が優先されるらしい)\r\n\r\nあとはビルド時に生成するように`package.json`に追記すればおk\r\n\r\n```\r\n\"scripts\": {\r\n  \"dev\": \"next dev\",\r\n  \"build\": \"next build\",\r\n  \"start\": \"next start\",\r\n  \"postbuild\": \"next-sitemap --config next-sitemap.config.js\",\r\n  \"deploy\": \"npm run build && npm run postbuild && npm run export\"\r\n},\r\n```\r\n\r\n## Google Analytics 4 を入れる\r\nGoogleさんが定期的にメールで GA4いかが・・ ってメールで送ってくるので対応した。  \r\n\r\nというか`GA4`、これ今までの`UA`を置き換えるやつかと思ってたんだけど、どうやら違うみたい？  \r\nなんかユニバーサルアナリティクスで集めてた時代のデータは引き継いでくれないっぽいし何やねん・・・\r\n\r\n```\r\nGA4 設定アシスタント ウィザードでは、作成した GA4 プロパティが過去のデータに基づきバックフィルされることはありません。GA4 プロパティに保存されるのは、設定後に発生したデータのみです。過去のデータを参照する際は、ユニバーサル アナリティクス プロパティのレポートを使用してください。\r\n```\r\n\r\n<https://support.google.com/analytics/answer/9744165?hl=ja&utm_id=ad#zippy=%2Cご自身またはウェブ-デベロッパーがウェブページに手動でタグを設定する場合>\r\n\r\nというわけで、今のところは`GA4`と`UA`の両方で集計するようにしてあります。\r\n\r\n![Imgur](https://imgur.com/4bkbzPv.png)\r\n\r\n`head`内に`GA4`のJavaScriptを差し込むようにすればいいです。\r\n`GA_TRACKING_ID`には**GA4の測定ID**、`UA_TRACKING_ID`には**UAのトラッキングコード**を変数に入れておいて下さい。  \r\n多分`Google アナリティクス 4 プロパティの設定アシスタント`を利用しないと駄目かも？\r\n\r\n```tsx\r\n<Head>\r\n    <script async src={`https://www.googletagmanager.com/gtag/js?id=${GA_TRACKING_ID}`}></script>\r\n    <script dangerouslySetInnerHTML={{\r\n        __html: `\r\n            window.dataLayer = window.dataLayer || [];\r\n            function gtag(){dataLayer.push(arguments);}\r\n            gtag('js', new Date());\r\n            gtag('config', '${UA_TRACKING_ID}');\r\n            gtag('config', '${GA_TRACKING_ID}');\r\n        `}}\r\n    />\r\n</Head>\r\n```\r\n\r\nなんか調べてると`next/script`でいい感じに読み込む書き方をしてる例がありますが私の環境では重複して送信されたので辞めました。\r\n\r\n## Material-UIのアイコンを書くときの注意点\r\n名前付きインポートだと開発環境の読み込みが遅くなります。  \r\n\r\n```tsx\r\nimport { AndroidOutlined } from '@mui/icons-material' // これだと重くなる\r\n```\r\n\r\n```tsx\r\nimport AndroidOutlined from '@mui/icons-material/AndroidOutlined'\r\n```\r\n\r\n詳しくは：https://takusan.negitoro.dev/posts/next_js_mui_material_icon_build_speed/\r\n\r\n今回はBabelの設定せずに個別にインポートするようにしてます。\r\n\r\nちなみにこれはKotlinで該当のJavaScriptを渡すと変換してくれるコード。\r\n\r\n```kotlin\r\nfun main() {\r\n\r\n    val javaScriptCode = \"\"\"\r\n        \r\nimport { BookOutlined } from \"@mui/icons-material\"\r\n\r\n    \"\"\".trimIndent()\r\n\r\n    // \"@mui/icons-material\" の部分を取得する正規表現\r\n    val packageRegex = \"\\\"(.*?)\\\"\".toRegex()\r\n    val packageName = packageRegex.find(javaScriptCode)!!.groupValues[1]\r\n\r\n    // { BookOutlined } の部分を取得する正規表現\r\n    val namedImportRegex = \"\\\\{(.*?)}\".toRegex()\r\n    val namedImportCode = namedImportRegex.find(javaScriptCode)!!.groupValues[1]\r\n    // 複数インポートされているか\r\n    val namedImportList = if (namedImportCode.contains(\",\")) {\r\n        namedImportCode\r\n            .split(\",\")\r\n            .map { it.replace(\" \", \"\") }\r\n    } else {\r\n        listOf(namedImportCode.replace(\" \", \"\"))\r\n    }\r\n\r\n    namedImportList.forEach { name ->\r\n        println(\"\"\"import $name from \"${packageName}/${name}\" \"\"\")\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Netlifyでホスティングする際は\r\nSSGモードの場合はプラグインをOFFにする必要があります。\r\n\r\nNetlifyのサイトの設定から、Build & Deployを開いて、環境変数に追加します。\r\n\r\n![Imgur](https://imgur.com/9u5rplE.png)\r\n\r\nちなみにビルドコマンドと公開するフォルダは\r\n\r\nBuild commands：`npm run build && npm run export`  \r\nPublish directory：`out`\r\n\r\nになります～\r\n\r\nhttps://docs.netlify.com/configure-builds/common-configurations/"},{"title":"Tailwind CSS で作り直そうとしている","link":"/posts/tailwind_css_migration/","markdown":"\r\nどうもこんばんわ。  \r\n最近ずっとこれ聞いてる  \r\n\r\n![Imgur](https://imgur.com/2MaMBpB.png)\r\n\r\n*「偶然」で片付けたくない 運命にしたい*\r\n\r\nゲームやってないけどCDだけ買った。！！！\r\n\r\n![Imgur](https://imgur.com/9DUoKCH.png)\r\n\r\n# 本題\r\n`Material-UI`をやめて、`Tailwind CSS`にしようと思います...\r\n\r\n![Imgur](https://imgur.com/ZgnivHu.png)\r\n\r\n![Imgur](https://imgur.com/MSVr7MU.png)\r\n\r\n![Imgur](https://imgur.com/mcZbOGN.png)\r\n\r\n![Imgur](https://imgur.com/9iXlLFM.png)\r\n\r\n最近の`Android`というか、`Material 3`というかを真似てみました。  \r\n角を結構丸くしたり、リストとか。\r\n\r\n## 移行前\r\n移行前の`main ブランチ`のコードを`material_ui`ブランチに切ってあります。  \r\nhttps://github.com/takusan23/ziyuutyou-next/tree/material_ui\r\n\r\n引き続き参照可能です。\r\n\r\n# Tailwind CSS\r\n賛否両論。わたしはすき、  \r\nというか`Webフロント`よく知らないので、`Next.js`に入ってるやつ（いつの間にか選択できるようになったらしい）を大人しく使う。  \r\n\r\n```tsx\r\n/** RoundedCornerBox へ渡すデータ */\r\ntype RoundedCornerBoxProps = {\r\n    /** どれだけ丸くするか */\r\n    rounded?: 'small' | 'medium' | 'large'\r\n    /** Tailwind CSS のクラス名 */\r\n    className?: string\r\n    /** 子要素 */\r\n    children: ReactNode\r\n}\r\n\r\n/** 角丸なBox */\r\nexport default function RoundedCornerBox({ className, rounded, children }: RoundedCornerBoxProps) {\r\n    // 変数埋め込みとかは使えない\r\n    // https://tailwindcss.com/docs/content-configuration#class-detection-in-depth\r\n    const colorOrDefault = className ?? 'bg-container-primary-light dark:bg-container-primary-dark'\r\n    let roundedClassName: string\r\n    switch (rounded ?? 'small') {\r\n        case 'small':\r\n            roundedClassName = 'rounded-md'\r\n            break\r\n        case 'medium':\r\n            roundedClassName = 'rounded-xl'\r\n            break\r\n        case 'large':\r\n            roundedClassName = 'rounded-3xl'\r\n            break\r\n    }\r\n\r\n    return (\r\n        <div className={`${roundedClassName} ${colorOrDefault}`}>\r\n            {children}\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n# なんで\r\n時代は`RSC ( React Server Components )`に突入したらしい。ブラウザ側で実行される`JavaScript`を減らす時代がやってきた！！！  \r\n理由ですが...\r\n\r\n- `CSS`絶対書きたくないから`Material-UI`入れたんだけど、`Tailwind CSS`が結構良さそうだった\r\n    - これなら書きたい\r\n        - なんか`.css`書きたくないし...\r\n        - `scoped`な`css`とか`vue ?`にあった気がするけどあんまり使いこなせなかった...（私のせい\r\n    - よく使うやつがすぐ使える`flex-row`/`flex-col`とか\r\n        - 角を丸くするとか\r\n        - `px-`/`py-`とか便利\r\n            - `space-x-2 `これも\r\n    - コンポーネントごとに区切ってるのでそんなに`class`長くてもそこまで、、、って感じな気がする\r\n- ダークモードや、レスポンシブデザイン、テーマ機能がある\r\n    - 現状使っているので必要\r\n    - この辺も`CSS`をそのまま書くのは、、、うーんやりたくないかなあ\r\n- 賛否両論あるけど特に困ってない！！！\r\n    - （代替案を使ったこと無いので）\r\n\r\n以上です。  \r\nあと、`Tailwind CSS`関係なく、ブログ（静的サイト）なので、リッチな UI より読み込みが早いほうが良いかなあってのもあります。  \r\n（`ゼロランタイム CSS`とかいうやつ）\r\n\r\nただ、ここで`RSC`や`Tailwind CSS`に**賭けて良い**のかは分からない、、、`Webフロントエンド`ってなんか流行の移り変わりが早すぎる。  \r\n\r\nちなみに`App Router`で動く`Material-UI`のサポートは入ったらしい。これでひたすら`\"use client\"`しなくても済むのかな？  \r\nhttps://github.com/mui/material-ui/releases/tag/v5.14.0\r\n\r\nあとは、移行したときに良いなと思ったこととかをつらつらと...\r\n\r\n# 良かった点\r\n\r\n## サーバーコンポーネント、クライアントコンポーネント どっちでも書ける\r\n（最終的には`CSS`が吐き出される？）のが良さそう  \r\n`クライアントコンポーネント`しか無いなら他のスタイリングを選んだほうがいいのか・・・も？  \r\nただ、ぶっちゃけ`サーバーコンポーネント`もよくわからない、、、けど面白そうだし試している\r\n\r\n## リセット CSS\r\nhttps://tailwindcss.com/docs/preflight\r\n\r\nこれ、`h1`、`h2`、、の大きさはすべて同じ大きさに揃えられます。  \r\n`ul`や`p`に`margin`がデフォルトでかかっていません。  \r\n`aタグ`の色もかかってません！！！  \r\n\r\n`aタグ`だけはリセットされないようにするため、なんか初期値に戻せ！みたいな`CSS`を書きました。  \r\n大人しくスタイリングしても良かったかもしれない。\r\n\r\n```css\r\n/* Tailwind CSS で aタグ の色が消えてしまったので、もとに戻す */\r\na {\r\n    color: revert;\r\n    text-decoration: revert;\r\n}\r\n```\r\n## VSCode に Tailwind CSS 拡張機能を入れよう\r\nこれです  \r\nhttps://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss\r\n\r\n快適すぎて草、クラス名の補充や、自前で定義したプライマリカラーとかの色まで見れるの強すぎやろ\r\n\r\n![Imgur](https://imgur.com/ZOB8AxT.png)\r\n\r\n最終的な`CSS`も見れる。すごい\r\n\r\n## peer-checked が便利\r\nマテリアルコンポーネントにもある`Switch()`を作ろうと思います。  \r\nスイッチを押したらつまみ（`Thumb`）を右側へ移動するための`JavaScript`を書こうと思ってたんですけど、これ`JS`なしで再現できるんですね！！\r\n\r\n以下が該当のコードですが、チェック状態を保持しておくための`<input>`をユーザーに見えない形で置いておきます。  \r\n`<label>`で囲っているので、囲っている`<div>`や`<span>`を押したときにも、`<input>`にチェックが入ります（上記の通り見えませんが）  \r\n\r\nで、ここからです。  \r\n`<input>`の後の要素のクラス名に`peer-checked:`を先頭につけると、その`<input>`にチェックが付いたかどうかでスタイルを切り替えることが出来ます。  \r\nこの方法を使い、チェックがついてないときは左へ`justify-start`、`<input>`にチェックが入ったら右へ`peer-checked:justify-end`することが出来ます。`CSS`だけで完結！！！\r\n\r\n```tsx\r\nexport default function DarkmodeSwitch() {\r\n    const [isDarkmode, setDarkmode] = useState(false)\r\n\r\n    return (\r\n        <label className=\"flex flex-row items-center select-none cursor-pointer p-2\">\r\n            {/* peer をつけておくと、チェック true / false 時にそれぞれ指定する CSS をセットできる（ JS で動的に className を変化させる必要がない ） */}\r\n            <input\r\n                className=\"sr-only peer\"\r\n                type=\"checkbox\"\r\n                checked={isDarkmode}\r\n                onChange={(ev) => setDarkmode(ev.target.checked)} />\r\n            <span className=\"text-content-text-light dark:text-content-text-dark flex grow\">\r\n                ダークモード\r\n            </span>\r\n            {/* チェックが付いたら左に寄せる、丸を大きくする（peer-checked:justify-end） */}\r\n            <div className=\"h-8 w-14 flex flex-row items-center rounded-full border-content-primary-light dark:border-content-primary-dark border-2 p-1.5 peer-checked:p-0.5 justify-start peer-checked:justify-end\">\r\n                <div className=\"h-full aspect-square bg-content-primary-light dark:bg-content-primary-dark rounded-full\" />\r\n            </div>\r\n        </label>\r\n    )\r\n}\r\n```\r\n\r\nいや、公式の説明のがわかりやすかったわ、`JS`なしで表示・非表示を切り替えてる  \r\nhttps://tailwindcss.com/docs/hover-focus-and-other-states#styling-based-on-sibling-state\r\n\r\n# つまずく点\r\n\r\n## 動的な値はできない\r\nつまり、こういう文字列に変数を埋め込むとかは出来ないです。\r\n\r\n```tsx\r\nconst isEnable = true\r\nconst width = isEnable ? 100 : 50\r\nconst className = `w-${width}`\r\n\r\nreturn (<div className={className}/>)\r\n```\r\n\r\nもし、状態によって切り替えたい場合は、完全なクラス名としてソースコードに記述する必要があります。\r\n\r\n```tsx\r\nconst isEnable = true\r\nconst className = isEnable ? \"w-100\" : \"w-50\"\r\n\r\nreturn (<div className={className}/>)\r\n```\r\n\r\nというのも、`Tailwind CSS`は文字列を探して`CSS`を生成する、結構シンプルな仕組みで動いているらしい？ので、文字列として存在しないといけないんですよね。\r\nhttps://tailwindcss.com/docs/content-configuration#class-detection-in-depth\r\n\r\n動的な値は取れないので、あらかじめいくつかパターンを用意しておく必要があるわけですね。\r\n\r\n```tsx\r\nlet roundedClassName: string\r\nswitch (rounded ?? 'small') {\r\n    case 'small':\r\n        roundedClassName = 'rounded-md'\r\n        break\r\n    case 'medium':\r\n        roundedClassName = 'rounded-xl'\r\n        break\r\n    case 'large':\r\n        roundedClassName = 'rounded-3xl'\r\n        break\r\n}\r\n```\r\n（`Kotlin`の`when`というか式ほしい...このためだけに`let`にするのなんか負けた感あってくやしい）\r\n\r\n## Material-UIみたいに Ripple Effect みたいなのはなくなっちゃった\r\n押してる！！！感はなくなっちゃった\r\n\r\n## アイコン\r\nマテリアルアイコンは自分で`svg`を持ってくる必要があります、もしくは`npm`からよしなにライブラリを入れるかです。\r\n\r\n# そのほか\r\n\r\n## Mastodon / Misskey シェアボタン を置いた\r\n\r\n`Twitter`の代わりに`Mastodon / Misskey`でシェアできるボタンを置きました。  \r\n`TweetDeck`なくなってから`Twitter`あんまり見なくなっちゃった、、、  \r\n\r\n![Imgur](https://imgur.com/UAZIBg8.png)\r\n\r\n![Imgur](https://imgur.com/XSabwQI.png)\r\n\r\n![Imgur](https://imgur.com/uKDj4hr.png)\r\n\r\n`Misskey`も`Mastodon`も以下のような`URL`でそれぞれのインスタンスの共有画面を出せるので、それを使っています。  \r\n\r\n`https://{serverName}/share?text={シェアしたい文字}`\r\n\r\n`TypeScript / JavaScript`でやる場合はこんな感じです多分\r\n\r\n```ts\r\n// インスタンス名\r\nconst serverName = 'diary.negitoro.dev'\r\n// シェアしたい文字\r\nconst shareText = encodeURIComponent('シェアしたい文字')\r\n// 新しいタブで開く\r\nconst shareUrl = `https://${serverName}/share?text=${shareText}`\r\nwindow.open(shareUrl, '__blank')\r\n```\r\n\r\n`Nuxt.js`のときは置いてたんですが、、、、`Next.js`に移行した際に`Twitter`に置き換えちゃったんですよね。  \r\n`Twitter`改悪により`Mastodon / Misskey シェア`再実装です\r\n\r\n![Imgur](https://imgur.com/YXwrVJt.png)\r\n\r\n![Imgur](https://imgur.com/cAh2Ntz.png)\r\n\r\n（奇跡的に`Nuxt.js`のときのビルド成果物が残ってたので起動してみた）\r\n\r\n# 本番に投入する\r\n\r\nきたきた\r\n\r\n![Imgur](https://imgur.com/A5v58C4.png)\r\n\r\n今回も差分大きいというか影響大きいので`Pull Request`作ってみました。  \r\n\r\nhttps://github.com/takusan23/ziyuutyou-next/pull/2\r\n\r\n差分ですが、`npm install`した時とかに自動で更新される`package-lock.json`とかも差分に入ってしまったので、私が書き足したのはそこまでではないと思う・・・\r\n\r\n![Imgur](https://imgur.com/Gx7fnFn.png)\r\n\r\nまーじします！うおおおお！\r\n\r\n![Imgur](https://imgur.com/dvWOWHn.png)\r\n\r\n`GitHub Actions`が終わるのを見守ります\r\n\r\n![Imgur](https://imgur.com/G8nI44X.png)\r\n\r\n\r\n## Material-UI → Tailwind CSS\r\nま、まぁ、、あんまり`Material-UI`のコンポーネント使ってたわけじゃないので、もっといろんなコンポーネントを使ってればもっと増えてたのかも\r\n\r\n### Material-UI\r\n```plaintext\r\nRoute (app)                                   Size     First Load JS\r\n┌ ○ /                                         4.96 kB         124 kB\r\n├ ○ /_not-found                               0 B                0 B\r\n├ ○ /favicon.ico                              0 B                0 B\r\n├ ○ /icon.png                                 0 B                0 B\r\n├ ● /pages/[page]                             1.36 kB         112 kB\r\n├   └ /pages/about\r\n├ ● /posts/[blog]                             5 kB            124 kB\r\n├   ├ /posts/akashic_engine_pwa_cache\r\n├   ├ /posts/android11_devicecontrol\r\n├   ├ /posts/android11_release_devicecontrol\r\n├   └ [+135 more paths]\r\n├ ● /posts/page/[page]                        4.28 kB         120 kB\r\n├   ├ /posts/page/1\r\n├   ├ /posts/page/2\r\n├   ├ /posts/page/3\r\n├   └ [+11 more paths]\r\n├ ● /posts/tag/[tag]                          2.46 kB         119 kB\r\n├   ├ /posts/tag/Android\r\n├   ├ /posts/tag/Kotlin\r\n├   ├ /posts/tag/JetpackCompose\r\n├   └ [+96 more paths]\r\n├ ○ /posts/tag/all_tags                       616 B           117 kB\r\n└ ○ /sitemap.xml                              0 B                0 B\r\n+ First Load JS shared by all                 96.2 kB\r\n  ├ chunks/681-35cd67eb9c939efc.js            18.5 kB\r\n  ├ chunks/698-43273f17e9c681c8.js            25.2 kB\r\n  ├ chunks/bce60fc1-0593c640cdea54db.js       50.5 kB\r\n  ├ chunks/main-app-67d9599d5de0ee24.js       213 B\r\n  └ chunks/webpack-47c91c3dea7cfcb6.js        1.73 kB\r\n```\r\n\r\n### Tailwind CSS\r\n```plaintext\r\nRoute (app)                                   Size     First Load JS\r\n┌ ○ /                                         3.57 kB        87.2 kB\r\n├ ○ /_not-found                               0 B                0 B\r\n├ ○ /favicon.ico                              0 B                0 B\r\n├ ○ /icon.png                                 0 B                0 B\r\n├ ● /pages/[page]                             3.44 kB          87 kB\r\n├   └ /pages/about\r\n├ ● /posts/[blog]                             3.44 kB          87 kB\r\n├   ├ /posts/akashic_engine_pwa_cache\r\n├   ├ /posts/android11_devicecontrol\r\n├   ├ /posts/android11_release_devicecontrol\r\n├   └ [+135 more paths]\r\n├ ● /posts/page/[page]                        764 B          84.4 kB\r\n├   ├ /posts/page/1\r\n├   ├ /posts/page/2\r\n├   ├ /posts/page/3\r\n├   └ [+11 more paths]\r\n├ ● /posts/tag/[tag]                          764 B          84.4 kB\r\n├   ├ /posts/tag/Android\r\n├   ├ /posts/tag/Kotlin\r\n├   ├ /posts/tag/JetpackCompose\r\n├   └ [+96 more paths]\r\n├ ○ /posts/tag/all_tags                       624 B          84.2 kB\r\n├ ○ /search                                   3.26 kB        86.9 kB\r\n└ ○ /sitemap.xml                              0 B                0 B\r\n+ First Load JS shared by all                 77.8 kB\r\n  ├ chunks/698-0d5add4b5e93c16b.js            25.2 kB\r\n  ├ chunks/bce60fc1-33201d061f5d18d8.js       50.5 kB\r\n  ├ chunks/main-app-67d9599d5de0ee24.js       213 B\r\n  └ chunks/webpack-6989dea18b00da7b.js        1.8 kB\r\n```\r\n\r\n# おわりに\r\n`Netlify`だと日本からのアクセスが遅いので、つぎはホスティングサービスを移行したい・・！  "},{"title":"WebMを攻略する","link":"/posts/video_webm_spec/","markdown":"どうもこんばんわ。  \r\n最近ずっと フルスロットルHeart っていう曲聞いてる、、掛け合いめっちゃよい\r\n\r\n# 本題\r\nコンテナフォーマットの一つ、`WebM`を解析したり、組み立てたりするコードを書けるようになりましょう。（？）  \r\nこれ https://github.com/takusan23/ZeroMirror の中の WebMへ書き込む処理 https://github.com/takusan23/ZeroMirror/tree/master/zerowebm を作ってる際に調査したやつ\r\n\r\n## 環境\r\n`Kotlin`で書きます。  \r\nあと 2/10/16進数 の変換ができる電卓が必要です（Windows 10 の最初から入ってる電卓のプログラマーモードでOKです）\r\n\r\n# ざっくり WebM\r\n`WebM`ってのは音声と映像を一つのファイルに保存する技術の名前で、`mp4`、`mpeg2-ts`とかの仲間です（`H.264`/`H.265`/`VP8`/`VP9`等のコーデックの仲間ではないです。コーデックでエンコードしたデータを保存する技術です）  \r\n（`Android`では`MediaMuxer`を使えばらくらく保存できるのですが、ストリーミングできる`WebM`を作りたかったので）\r\n\r\n動画ファイルの拡張子が`mp4`以外だったときランキングで、三番目ぐらいに居座ってそう。（avi,mov の次くらい？、iPhoneが mov らしいのよね）\r\n\r\n`WebM`は`Matroska`のサブセットになってます。ので仕様書なんかは`Matroska`のを見るのが良いと思う。  \r\nコーデックは`VP8`/`VP9`/`Opus`などが対応しています。保存方法には`EBML`を使ってます（`Matroska`がそう）。\r\n\r\n## WebM を見るアプリ\r\nMKVToolNix ってのがあります。これが神レベルで使いやすい。\r\nDLしたら mkvtoolnix-gui.exe を起動して、`infoツール`にして`webm`をドラッグアンドドロップすれば見れます。\r\n\r\nhttps://mkvtoolnix.download/\r\n\r\n![Imgur](https://imgur.com/mJvsTSm.png)\r\n\r\n## ざっくり EBML\r\nよく `xml` と言われてますが、`xml`にはある終了タグや属性などはないのでどっちかというと `yml (yaml)` が近いと思います。  \r\n終了タグが無いので、タグの後についてる長さを見て子要素、データを取り出していきます。  \r\n\r\nこんな感じで入ってる（かなり端折った\r\n\r\n```yml\r\n- EBML\r\n    - EBML version\r\n        - Data size 1\r\n        - Data 1\r\n    - EBML read version\r\n        - Data size 1\r\n        - Data 1\r\n    - Maximum EBML ID Length\r\n        - Data size 1\r\n        - Data 4\r\n- Segment\r\n    - Info\r\n        - Timestamp scale\r\n            - Data size 4\r\n            - Data 1000000\r\n        - Writing app\r\n            - Data size 10\r\n            - Data zeromirror\r\n    - Tracks\r\n        - Track\r\n            - Track number\r\n                - Data size 1\r\n                - Data 1\r\n            - Track type\r\n                - Data size 1\r\n                - Data 1\r\n            - Codec id\r\n                - Data size 5\r\n                - Data V_VP9\r\n```\r\n\r\n## バイナリを見る\r\n実際のバイナリを見ながら、もう少し解説を  \r\nちなみに以下のバイナリは最適化してない（難しそうだったので、後述）ので本来であればもっと短くなります。\r\n\r\n```\r\n 1A 45 DF A3 10 00 00 34 42 86 10 00 00 01 01 42\r\n F7 10 00 00 01 01 42 F2 10 00 00 01 04 42 F3 10\r\n 00 00 01 08 42 82 10 00 00 04 77 65 62 6D 42 87\r\n 10 00 00 01 02 42 85 10 00 00 01 02 18 53 80 67\r\n 01 FF FF FF FF FF FF FF 15 49 A9 66 10 00 00 34\r\n 2A D7 B1 10 00 00 04 00 0F 42 40 4D 80 10 00 00\r\n 13 7A 65 72 6F 6D 69 72 72 6F 72 5F 7A 65 72 6F\r\n 77 65 62 6D 57 41 10 00 00 0A 7A 65 72 6F 6D 69\r\n 72 72 6F 72 16 54 AE 6B 10 00 00 87 AE 10 00 00\r\n 32 D7 10 00 00 01 01 73 C5 10 00 00 01 01 86 10\r\n 00 00 05 56 5F 56 50 39 83 10 00 00 01 01 E0 10\r\n 00 00 10 B0 10 00 00 03 00 05 00 BA 10 00 00 03\r\n 00 02 D0 AE 10 00 00 4B D7 10 00 00 01 02 73 C5\r\n 10 00 00 01 02 86 10 00 00 06 41 5F 4F 50 55 53\r\n 83 10 00 00 01 02 63 A2 10 00 00 13 4F 70 75 73\r\n 48 65 61 64 01 02 00 00 80 BB 00 00 00 00 00 E1\r\n 10 00 00 0F B5 10 00 00 04 47 3B 80 00 9F 10 00\r\n 00 01 02 1F 43 B6 75 01 FF FF FF FF FF FF FF E7\r\n 10 00 00 04 00 00 00 00\r\n```\r\n\r\n### バイナリのレイアウト\r\n\r\nこんなのがずっっっと続いてます。\r\n\r\n|                                     |                                     |                                      |\r\n|-------------------------------------|-------------------------------------|--------------------------------------|\r\n| ID                                  | Data size                           | Data                                 |\r\n| なんのデータかを示します            | Data のサイズです                   | データです。数値/ASCII/バイナリ など |\r\n| サイズは可変長 (後述)、Max 4バイト? | サイズは可変長  (後述)、Max 8バイト | Data size の値                       |\r\n\r\nたとえば...\r\n\r\n```\r\n57 41 10 00 00 0a 7a 65 72 6f 6d 69 72 72 6f 72\r\n```\r\n\r\nの場合は\r\n\r\n| バイナリ | 0x57 0x41   | 0x10 0x00 0x00 0x0A | 0x7A 0x65 0x72 0x6F 0x6D 0x69 0x72 0x72 0x6F 0x72 |\r\n|----------|-------------|---------------------|---------------------------------------------------|\r\n| なに？   | ID          | Data size           | Data                                              |\r\n| あたい   | Writing App | 10                  | zeromirror                                        |\r\n\r\nになります！（なんでこうなるのかをこれから書きます）\r\n\r\n### バイナリの読み方 ID編\r\nIDの一覧はこれです：https://www.matroska.org/technical/elements.html\r\n\r\nまずは ID から。`ID`はその名の通りデータが何なのかを示すものです。  \r\nで、IDなのですが、**これ賢くて**、2進数にした後に左から何ビット目に1が立っているかでIDの長さが分かっちゃう用になってます！。  \r\n例えば上記の `Writing App` の `0x57 0x41` を2進数にした場合\r\n\r\n| 16進数    | 2進数               |\r\n|-----------|---------------------|\r\n| 0x57 0x41 | 0101 0111 0100 0001 |\r\n\r\nこうなります（`5`を2進にすると`101`ですが、4桁に合わせるため先頭に`0`を入れてます）\r\n\r\nで、`1`が左から2ビット目に立ってますよね？すると上記のIDは **2バイト分** になります！！！  \r\n2バイト取り出した`0x57 0x41`をID一覧と見比べると`Writing App`であるとわかりますね！\r\n\r\nこれを **VINT** というらしいですよ？（データのサイズを含めつつ、ちゃんと目印としても使える）\r\n\r\n他に例をもう一個、 `Cluster` のIDを見てみると\r\n\r\n| 16進数              | 2進数                                   |\r\n|---------------------|-----------------------------------------|\r\n| 0x1F 0x43 0xB6 0x75 | 0001 1111 0100 0011 1011 0110 0111 0101 |\r\n\r\nこうなりますね？（変換後は`1 1111 0100 0011 1011 0110 0111 0101`になりますが、4桁揃えにするため `0001 1111 0100 0011 1011 0110 0111 0101`にしてます）\r\n\r\n![Imgur](https://imgur.com/1Snu6co.png)\r\n\r\nで、`1`が左から4番目に立ってますので、IDは**4バイト分**と判断できるわけです。  \r\n4バイト取り出した `0x1F 0x43 0xB6 0x75` をID一覧から探すと `Cluster` であるとわかりますね。\r\n\r\n多分最大 4バイト までだと思います。  \r\n\r\nあ、VINTのわかりやすい表があったので貼っておきますね\r\n\r\nhttps://github.com/ietf-wg-cellar/ebml-specification/blob/master/specification.markdown#vint-examples\r\n\r\n### バイナリの読み方 Data size 編\r\n実際に`Data size`で合ってるのかはわからない...（`Content size`説？  \r\nこれは Data が何バイト分かを示すものです。で、こいつ自信も可変長です。\r\n\r\n例え行きましょう。上記の`Writing App`で\r\n\r\n| 16進数              | 2進数                                   |\r\n|---------------------|-----------------------------------------|\r\n| 0x10 0x00 0x00 0x0A | 0001 0000 0000 0000 0000 0000 0000 1010 |\r\n\r\nここでやらないといけないのは、`Data size 自身の長さ`と`Data の長さ`を出すことです。  \r\n`Data size`自身の長さは ID のときと同じように、左から1が何ビット目に立っているかで判断できます。  \r\nただ、IDと違って`Data size`は最大8バイトまであります。  \r\n今回は`1`が左から4バイト目に立っているため、`Data size`自身は4バイトあることがわかります。  \r\n\r\nで、2進数にした後に左から`1`を抜いたあと10進数にした値が、`Data`の長さになります。  \r\n`0001 0000 0000 0000 0000 0000 0000 1010` -> `0000 0000 0000 0000 0000 0000 0000 1010` -> 2進数を10進数にした`10`\r\n\r\n`Data`は10バイトです！\r\n\r\nこれもわかりやすい表があったので貼っておきますね\r\n\r\nhttps://www.matroska.org/technical/notes.html#ebml-lacing\r\n\r\n### バイナリの読み方 Data 編\r\n`Data size`で出した長さだけあります。  \r\nそのデータが 数値 / ASCII / バイナリ / 入れ子 など何のデータかはIDの一覧から見て下さい。多分IDだけだとわからないはず。。。\r\n\r\nElement type でわかるはず\r\n\r\n![Imgur](https://imgur.com/GrMHZLY.png)\r\n\r\n#### 番外編 なんで賢いのか\r\nなんで賢いのかというと、IDが知らない/対応していない場合にスキップして次のデータを読み取れるからなんですね。  \r\nだってIDの長さ知らないけど、IDの長さは 2進数にして1が何ビット目に立ってるか を計算していけば ID分からん未知のデータ として解析できるわけです。  \r\n\r\nもし IDに長さが含まれなかった 場合、パース前に予めIDと長さの対応表みたいなのを持っておく必要がある上、未知のIDが来た場合に解析ができなくなります。  \r\n\r\n# WebMで必要な値\r\nWebMに話を戻します。  \r\n多分以下の値が必要です。\r\n\r\nんなもん分からんわって方はこっちのほうが正しいです：https://www.matroska.org/technical/diagram.html\r\n\r\n```yml\r\n- EBML\r\n    - EBMLVersion\r\n    - EBMLReadVersion\r\n    - EBMLMaxIDLength\r\n    - EBMLMaxSizeLength\r\n    - DocType\r\n    - DocTypeVersion\r\n    - DocTypeReadVersion\r\n- Segment\r\n    - Info\r\n        - Timestamp scale\r\n        - Duration\r\n        - Multiplexing application\r\n        - Writing application\r\n    - Tracks\r\n        - Track\r\n            - Track number\r\n            - Track Uid\r\n            - Codec id\r\n            - Track type\r\n            - Video\r\n                - Pixel width\r\n                - Pixel height\r\n        - Track\r\n            - Track number\r\n            - Track Uid\r\n            - Codec id\r\n            - Codec private data\r\n            - Audio\r\n                - Sampling frequency\r\n                - Channels\r\n    - Cues\r\n        - CuePoint\r\n            - Cue time\r\n            - Cue track position\r\n                - Cue track\r\n                - Cue cluster position\r\n- Cluster\r\n    - Cluster timestamp\r\n    - SimpleBlock\r\n    - SimpleBlock\r\n    - ...\r\n```\r\n\r\nこれらはさっき話した、EBMLの仕組みに沿ってバイナリを入れていけばいいのですが、、、  \r\nEBMLだけ知っていればできるわけではなく、以下の要素は別に説明しないとと思うのでします。\r\n\r\n- Codec private data\r\n- SimpleBlock\r\n\r\n## ざっくり何が入ってるか\r\nその前に何に何が入ってるかざっくり\r\n\r\n- EBML\r\n    - おまじないみたいなの\r\n    - ファイルが WebM だよ みたいなの\r\n- Segment\r\n    - 映像や音声の実際データを除いたデータが有る\r\n- Info\r\n    - 動画の長さとか書き込みアプリケーションが何かとかをいれる\r\n    - 動画の長さが入ってないとシークバーが使えない\r\n- Tracks\r\n    - 音声と映像の`Track`を入れます\r\n- Track\r\n    - 音声なら、サンプリングレート、チャンネル数、コーデックの種類を入れます\r\n    - 映像なら、動画の高さや幅、コーデックの種類を入れます\r\n    - トラック番号もここで入れます\r\n- Cue\r\n    - なんかシークする際の目印を入れるらしい\r\n- Cluster\r\n    - SimpleBlockを入れる\r\n    - 最初に時間を入れる、その次に SimpleBlock の時間を相対時間で入れる（2バイトで）\r\n    - 0xFF 0xFF を超える場合は Cluster を作り直す\r\n- SimpleBlock\r\n    - エンコードしたデータを入れます\r\n\r\n## Codec private data\r\nここでは音声コーデックが`Opus`のときの話。\r\n\r\nこれは音声トラックに必要なデータです。  \r\n`Track`に定義されていない値を入れるのに使う、本当にプライベートなデータです。  \r\n\r\nおそらく `Opus` を利用している場合は入れる必要があり、プライベートなデータなため`EBML`の仕組みにも乗っかってません！！！\r\n\r\n### Opus の Codec private data\r\nまずはこれ見て下さい。\r\n\r\nhttps://wiki.xiph.org/OggOpus#ID_Header\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc7845#section-5\r\n\r\nはい、完全に`EBML`じゃないですね。デコーダーに追加情報を渡すために必要なようです。\r\n\r\n```\r\n0x4F 0x70 0x75 0x73 0x48 0x65 0x61 0x64 0x01 0x02 0x00 0x00 0x80 0xBB 0x00 0x00 0x00 0x00 0x00\r\n```\r\n\r\n#### 中身\r\n\r\nまず先頭から8バイト分は、`OpusHead`をASCIIにしたものになります。\r\n\r\n| 0x4F | 0x70 | 0x75 | 0x73 | 0x48 | 0x65 | 0x61 | 0x64 |\r\n|------|------|------|------|------|------|------|------|\r\n| O    | p    | u    | s    | H    | e    | a    | d    |\r\n\r\nそして次の1バイトはバージョンですが、0x01でいいそうです。\r\n\r\n| 0x01        |\r\n|-------------|\r\n| 0x01 で固定 |\r\n\r\nその次の1バイトはチャンネル数です。モノラルなら`0x01`、ステレオなら`0x02`でしょう。\r\n\r\n| 0x02         |\r\n|--------------|\r\n| チャンネル数 |\r\n\r\nその次の2バイト分はわかりません。`Pre-skip`って書いてあるけど知らん\r\n\r\n| 0x00     | 0x00 |\r\n|----------|------|\r\n| Pre-skip |      |\r\n\r\nその次の4バイト分はサンプリングレートです。なんと**リトルエンディアン**です\r\n\r\n`0x80 0xBB 0x00 0x00`\r\n\r\nリトルエンディアンなので電卓にそのまま突っ込んでも多分変な値になります。ちなみに正解は10進数で`48000`になるべきです。\r\n\r\n![Imgur](https://imgur.com/I14Pec7.png)\r\n\r\nさらに`Java (JVM で動く Kotlin も)`もビッグエンディアンなのでおかしくなると思います。\r\n\r\n電卓で正しい値を出すためには(Windowsの電卓はビッグエンディアンっぽい？)、バイトを逆順にする必要があります。なので、\r\n\r\n`0x80 0xBB 0x00 0x00` を `0x00 0x00 0xBB 0x80` にした後に電卓に入れると正しい値になると思います。\r\n\r\n![Imgur](https://imgur.com/g8UjMba.png)\r\n\r\n最後の3バイトはわからん、使わなそうなので`0x00`で埋めてます\r\n\r\n| 0x00 | 0x00 | 0x00 |\r\n|------|------|------|\r\n| ?    | ?    | ?    |\r\n\r\n音声の`Track`に入れる`Codec private data`は以上です。\r\n\r\n### SampleBlock\r\nこれもちょっと特殊で、`Data`の先頭4バイトに値を入れる必要があります。\r\n\r\n#### 最初に入れる内容\r\n\r\n```\r\n0x81 0x00 0x00 0x80\r\n```\r\n\r\n最初の1バイトはトラック番号です。TracksにTrackを追加する際に指定すると思います。それです（音声なのか映像なのか）  \r\n次の2バイトは時間です。 0xFF 0xFF までしか時間が追加出来ないです（Short.MAX_VALUE ?）（多分ミリ秒になるので、32秒ぐらいかな）  \r\n0xFF 0xFF を超える場合は、`Cluster`を作り直すところからやる必要があります。(後述)\r\n\r\n最後の1バイトはキーフレームかどうかです。キーフレームなら`0x80`、そうでなければ`0x00`だと思います。\r\n\r\nおわりです。\r\n\r\n# WebMパーサーを書こう\r\nはいここまで来たらかけますね、書きましょう\r\n\r\n## 流れ\r\n\r\n- EBMLを読み出す\r\n- Segmentの入れ子になってる要素を読み出す\r\n    - Info / Tracks / Cue など\r\n- Clusterを読み出す\r\n\r\n## Kotlinで書く\r\n\r\n適当にプロジェクトを作って下さい。\r\n\r\n## 列挙型\r\n\r\n適当に\r\n\r\n```kotlin\r\n/** MatroskaのIDたち */\r\nenum class MatroskaTags(val byteArray: ByteArray) {\r\n    EBML(byteArrayOf(0x1A.toByte(), 0x45.toByte(), 0xDF.toByte(), 0xA3.toByte())),\r\n    EBMLVersion(byteArrayOf(0x42.toByte(), 0x86.toByte())),\r\n    EBMLReadVersion(byteArrayOf(0x42.toByte(), 0xF7.toByte())),\r\n    EBMLMaxIDLength(byteArrayOf(0x42.toByte(), 0xF2.toByte())),\r\n    EBMLMaxSizeLength(byteArrayOf(0x42.toByte(), 0xF3.toByte())),\r\n    DocType(byteArrayOf(0x42.toByte(), 0x82.toByte())),\r\n    DocTypeVersion(byteArrayOf(0x42.toByte(), 0x87.toByte())),\r\n    DocTypeReadVersion(byteArrayOf(0x42.toByte(), 0x85.toByte())),\r\n\r\n    Segment(byteArrayOf(0x18.toByte(), 0x53.toByte(), 0x80.toByte(), 0x67.toByte())),\r\n    SeekHead(byteArrayOf(0x11.toByte(), 0x4D.toByte(), 0x9B.toByte(), 0x74.toByte())),\r\n    Seek(byteArrayOf(0x4D.toByte(), 0xBB.toByte())),\r\n    SeekID(byteArrayOf(0x53.toByte(), 0xAB.toByte())),\r\n    SeekPosition(byteArrayOf(0x53.toByte(), 0xAC.toByte())),\r\n\r\n    Info(byteArrayOf(0x15.toByte(), 0x49.toByte(), 0xA9.toByte(), 0x66.toByte())),\r\n    Duration(byteArrayOf(0x44.toByte(), 0x89.toByte())),\r\n    SegmentUUID(byteArrayOf(0x73.toByte(), 0xA4.toByte())),\r\n    TimestampScale(byteArrayOf(0x2A.toByte(), 0xD7.toByte(), 0xB1.toByte())),\r\n    MuxingApp(byteArrayOf(0x4D.toByte(), 0x80.toByte())),\r\n    WritingApp(byteArrayOf(0x57.toByte(), 0x41.toByte())),\r\n\r\n    Tracks(byteArrayOf(0x16.toByte(), 0x54.toByte(), 0xAE.toByte(), 0x6B.toByte())),\r\n    Track(byteArrayOf(0xAE.toByte())),\r\n    TrackNumber(byteArrayOf(0xD7.toByte())),\r\n    TrackUID(byteArrayOf(0x73.toByte(), 0xC5.toByte())),\r\n    FlagLacing(byteArrayOf(0x9C.toByte())),\r\n    Language(byteArrayOf(0x22.toByte(), 0xB5.toByte(), 0x9C.toByte())),\r\n    TrackType(byteArrayOf(0x83.toByte())),\r\n    DefaultDuration(byteArrayOf(0x23.toByte(), 0xE3.toByte(), 0x83.toByte())),\r\n    TrackTimecodeScale(byteArrayOf(0x23.toByte(), 0x31.toByte(), 0x4F.toByte())),\r\n    CodecID(byteArrayOf(0x86.toByte())),\r\n    CodecPrivate(byteArrayOf(0x63.toByte(), 0xA2.toByte())),\r\n    CodecName(byteArrayOf(0x25.toByte(), 0x86.toByte(), 0x88.toByte())),\r\n    VideoTrack(byteArrayOf(0xE0.toByte())),\r\n    PixelWidth(byteArrayOf(0xB0.toByte())),\r\n    PixelHeight(byteArrayOf(0xBA.toByte())),\r\n    FrameRate(byteArrayOf(0x23.toByte(), 0x83.toByte(), 0xE3.toByte())),\r\n    AudioTrack(byteArrayOf(0xE1.toByte())),\r\n    SamplingFrequency(byteArrayOf(0xB5.toByte())),\r\n    Channels(byteArrayOf(0x9F.toByte())),\r\n    BitDepth(byteArrayOf(0x62.toByte(), 0x64.toByte())),\r\n\r\n    Cues(byteArrayOf(0x1C.toByte(), 0x53.toByte(), 0xBB.toByte(), 0x6B.toByte())),\r\n    CuePoint(byteArrayOf(0xBB.toByte())),\r\n    CueTime(byteArrayOf(0xB3.toByte())),\r\n    CueTrackPositions(byteArrayOf(0xB7.toByte())),\r\n    CueTrack(byteArrayOf(0xF7.toByte())),\r\n    CueClusterPosition(byteArrayOf(0xF1.toByte())),\r\n\r\n    Cluster(byteArrayOf(0x1F.toByte(), 0x43.toByte(), 0xB6.toByte(), 0x75.toByte())),\r\n    Timestamp(byteArrayOf(0xE7.toByte())),\r\n    SimpleBlock(byteArrayOf(0xA3.toByte())),\r\n\r\n    Void(byteArrayOf(0xEC.toByte())),\r\n}\r\n```\r\n\r\n## パーサーを書く\r\n\r\n### ID\r\n\r\nとりあえず VInt を計算するやつ書きますか、あの1がとこに立ってるかのやつ\r\n\r\n書きました。`downTo`いいね、もうKotlinしかできない\r\n\r\n```kotlin\r\n/**\r\n * VIntを出す\r\n * 後続バイトの長さを返します。失敗したら -1 を返します\r\n */\r\nfun Byte.getVIntSize(): Int {\r\n    // JavaのByteは符号付きなので、UIntにする必要がある。AND 0xFF すると UInt にできる\r\n    val int = this.toInt().andFF()\r\n    // 以下のように\r\n    // 1000_0000 -> 1xxx_xxxx\r\n    // 0100_0000 -> 01xx_xxxx_xxxx_xxxx\r\n    for (i in 7 downTo 0) {\r\n        if ((int and (1 shl i)) != 0) {\r\n            return 8 - i\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n/** ByteをIntに変換した際に、符号付きIntになるので、AND 0xFF するだけの関数 */\r\nfun Int.andFF() = this and 0xFF\r\n```\r\n\r\nJavaだと、Byteは符号付きになるので、`AND 0xFF`をしないとだめです。多分  \r\n\r\n\r\nこんな感じでわかるはず\r\n\r\n```kotlin\r\n// 例である\r\n\r\nprintln(0x81.toByte().getVIntSize()) // return 1\r\nprintln(0x42.toByte().getVIntSize()) // return 2\r\nprintln(0x2A.toByte().getVIntSize()) // return 3\r\nprintln(0x18.toByte().getVIntSize()) // return 4\r\nprintln(0x82.toByte().getVIntSize()) // return 1\r\n```\r\n\r\n### DataSize\r\n\r\n`Data`の長さを表す`DataSize`です。  \r\n左から数えて最初の1を消した後の16進数がそうです。\r\n\r\n```kotlin\r\n/** DataSizeの長さが不定の場合 */\r\nprivate val DATASIZE_UNDEFINED = byteArrayOf(0x1F.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte())\r\n\r\n/**\r\n * DataSizeを計算する。\r\n * だたし、長さ不定の場合（[MatroskaTags.Segment]、[MatroskaTags.Cluster]）の場合、[-1]を返す\r\n *\r\n * 例\r\n * 0x82 -> 0x02\r\n * 0x42 0x10 -> 0x02 0x10\r\n */\r\nfun ByteArray.toDataSize(): Int {\r\n    var first = first().toInt().andFF()\r\n    // 例外で、 01 FF FF FF FF FF FF FF のときは長さが不定なので...\r\n    // Segment / Cluster の場合は子要素の長さを全部足せば出せると思うので、、、\r\n    if (contentEquals(DATASIZE_UNDEFINED)) {\r\n        return -1\r\n    }\r\n    // 左から数えて最初の1ビット を消す処理\r\n    // 例\r\n    // 0b1000_0000 なら 0b1xxx_xxxx の x の範囲が数値になる\r\n    // break したかったので for\r\n    for (i in 0..8) {\r\n        if ((first and (1 shl (8 - i))) != 0) {\r\n            // 多分\r\n            // 0b1000_1000 XOR 0b0000_1000 みたいなのをやってるはず\r\n            first = first xor (1 shl (8 - i))\r\n            break\r\n        }\r\n    }\r\n    return (byteArrayOf(first.toByte()) + this.drop(1)).toInt()\r\n}\r\n\r\n/** ByteArray から Int へ変換する。ByteArray 内にある Byte は符号なしに変換される。 */\r\nfun ByteArray.toInt(): Int {\r\n    // 先頭に 0x00 があれば消す\r\n    val validValuePos = kotlin.math.max(0, this.indexOfFirst { it != 0x00.toByte() })\r\n    var result = 0\r\n    // 逆にする\r\n    // これしないと左側にバイトが移動するようなシフト演算？になってしまう\r\n    // for を 多い順 にすればいいけどこっちの方でいいんじゃない\r\n    drop(validValuePos).reversed().also { bytes ->\r\n        for (i in 0 until bytes.count()) {\r\n            result = result or (bytes.get(i).toInt().andFF() shl (8 * i))\r\n        }\r\n    }\r\n    return result\r\n}\r\n```\r\n\r\nByteArray から Int はこちらを参考にしました、ありがとうございます。  \r\nhttps://gist.github.com/groovelab/38d381a943556299f205b47307bf60d7\r\n\r\n多分左側へビットを動かしてIntにしてるんだと思います、\r\n\r\n`[ 0x10, 0x20, 0x30 ]` だったら...\r\n\r\n|                   |      |      |          |\r\n|-------------------|------|------|----------|\r\n| 左側へ2バイト移動 | 0x10 | 0x00 | 0x00     |\r\n| 左側へ1バイト移動 |      | 0x20 | 0x00     |\r\n| 左側へ0バイト移動 |      |      | 0x30     |\r\n| XOR する          |      |      | 0x102030 |\r\n\r\nそれと、 `0x01 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF`の場合のことを考えないといけないんですよね。  \r\nこれは長さが不明の場合に指定されています。`JavaScript`の`MediaRecorder API`で録画したデータがまさに長さ不定になります。  \r\nただ、子要素には長さが入っているため、これを全部足せばいいと思いました。\r\n\r\n\r\n### Data\r\n`DataSize`分取り出すだけなので特筆することはないかと\r\n\r\n## 組み合わせる\r\n\r\nこれらの拡張関数を呼び出すと一つの要素をパースできるようになります。\r\n\r\nと、その前にパース結果を入れるデータクラスを作りましょう。\r\n\r\n```kotlin\r\n/**\r\n * EBMLの要素を表すデータクラス\r\n *\r\n * @param tag [MatroskaTags]\r\n * @param elementSize 要素の合計サイズ\r\n * @param data 実際のデータ\r\n */\r\ndata class MatroskaElement(\r\n    val tag: MatroskaTags,\r\n    val data: ByteArray,\r\n    val elementSize: Int,\r\n)\r\n```\r\n\r\n要素をパースする関数はこちら。`Data size`が不定`0x01 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF`の場合は動かないと思います。先頭から見ていってもいいけどさあ...\r\n\r\n```kotlin\r\n/**\r\n * EBMLをパースする\r\n *\r\n * @param byteArray [ByteArray]\r\n * @param startPos 読み出し開始位置\r\n */\r\nfun parseElement(byteArray: ByteArray, startPos: Int): MatroskaElement {\r\n    var readPos = startPos\r\n    val idLength = byteArray[readPos].getVIntSize()\r\n    // IDのバイト配列\r\n    val idBytes = byteArray.copyOfRange(readPos, readPos + idLength)\r\n    val idElement = MatroskaTags.find(idBytes)!!\r\n    readPos += idBytes.size\r\n    // DataSize部\r\n    val dataSizeLength = byteArray[readPos].getVIntSize()\r\n    val dataSizeBytes = byteArray.copyOfRange(readPos, readPos + dataSizeLength)\r\n    val dataSize = dataSizeBytes.toDataSize()\r\n    readPos += dataSizeBytes.size\r\n    // Dataを読み出す。\r\n    // 長さが取得できた場合とそうじゃない場合で...\r\n    return if (dataSize != -1) {\r\n        // Data部\r\n        val dataBytes = byteArray.copyOfRange(readPos, readPos + dataSize)\r\n        readPos += dataSize\r\n        MatroskaElement(idElement, dataBytes, readPos - startPos)\r\n    } else {\r\n        // もし -1 (長さ不定)の場合は全部取得するようにする\r\n        // ただし全部取得すると壊れるので、直さないといけない\r\n        val dataBytes = byteArray.copyOfRange(readPos, byteArray.size)\r\n        readPos += dataBytes.size\r\n        MatroskaElement(idElement, dataBytes, readPos - startPos)\r\n    }\r\n}\r\n```\r\n\r\n後はこれを再帰的に呼び出せばすべての要素が取り出せるはずです！\r\n\r\n## 再帰的に呼び出す\r\n\r\n入れ子になってるタグの場合は再度`parseElement`を呼び出すようにしています。  \r\nそうじゃない場合は配列に入る。\r\n\r\n```kotlin\r\n/**\r\n * 子要素をパースする\r\n *\r\n * @param byteArray バイナリ\r\n */\r\nfun parseChildElement(byteArray: ByteArray): List<MatroskaElement> {\r\n    val childElementList = arrayListOf<MatroskaElement>()\r\n    var readPos = 0\r\n    while (byteArray.size > readPos) {\r\n        val element = parseElement(byteArray, readPos)\r\n        // 親要素があれば子要素をパースしていく\r\n        when (element.tag) {\r\n            MatroskaTags.SeekHead -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.Info -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.Tracks -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.Track -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.VideoTrack -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.AudioTrack -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.Cues -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.CuePoint -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.CueTrackPositions -> childElementList += parseChildElement(element.data)\r\n            MatroskaTags.Cluster -> childElementList += parseChildElement(element.data)\r\n            // 親要素ではなく子要素の場合は配列に入れる\r\n            else -> childElementList += element\r\n        }\r\n        readPos += element.elementSize\r\n    }\r\n    return childElementList\r\n}\r\n```\r\n\r\n最後にこれを`main関数`で呼び出すなりすればいいと思います。  \r\nもしかするとここまでのコードで Javaの機能 を使ってないので他のプラットフォームでも動くかもしれないです。  \r\n\r\n以下の例では `Java の File API` を呼び出してるので`JVM`のみですが、他のプラットフォームでも `Kotlin の ByteArray` が取得できれば使えるかもしれないです。  \r\n\r\n**あ！ちなみに JS の MediaRecorder API だと 長さ不定 (0x01 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF) の WebM を出力するのでこのままでは使えません終わりです。**\r\n\r\n```kotlin\r\nfun main() {\r\n    // 適当にWebMのパスを\r\n    val bytes = File(\"\"\"C://Users/takusan23/Desktop/demo.webm\"\"\").readBytes()\r\n    val elementList = arrayListOf<MatroskaElement>()\r\n    // トップレベルのパース位置\r\n    // EBML Segment Cluster など\r\n    var topLevelReadPos = 0\r\n\r\n    // EBMLを読み出す\r\n    val ebmlElement = parseElement(bytes, 0)\r\n    topLevelReadPos += ebmlElement.elementSize\r\n    elementList.addAll(parseChildElement(ebmlElement.data))\r\n\r\n    // Segmentを読み出す\r\n    val segmentElement = parseElement(bytes, topLevelReadPos)\r\n    topLevelReadPos += segmentElement.elementSize\r\n    elementList.addAll(parseChildElement(segmentElement.data))\r\n\r\n    // 結果を出力\r\n    elementList.forEach {\r\n        println(\"${it.tag} = ${it.data.take(10).toByteArray().toHexString()}\")\r\n    }\r\n}\r\n\r\n/** 16進数に変換するやつ */\r\nprivate fun ByteArray.toHexString() = this.joinToString(separator = \" \") { \"%02x\".format(it) }\r\n```\r\n\r\nこんな感じになるはず。\r\n\r\n```\r\nEBMLVersion = ...\r\nEBMLReadVersion = ...\r\nEBMLMaxIDLength = ...\r\nEBMLMaxSizeLength = ...\r\nDocType = ...\r\nDocTypeVersion = ...\r\nDocTypeReadVersion = ...\r\nSeek = ...\r\nSeek = ...\r\nSeek = ...\r\nVoid = ...\r\nDuration = ...\r\nTimestampScale = ...\r\nMuxingApp = ...\r\nWritingApp = ...\r\nTrackNumber = ...\r\nTrackUID = ...\r\nFlagLacing = ...\r\nLanguage = ...\r\nCodecID = ...\r\nTrackType = ...\r\nChannels = ...\r\nSamplingFrequency = ...\r\nCodecPrivate = ...\r\nTrackNumber = ...\r\nTrackUID = ...\r\nFlagLacing = ...\r\nLanguage = ...\r\nCodecID = ...\r\nTrackType = ...\r\nPixelWidth = ...\r\nPixelHeight = ...\r\n```\r\n\r\n## サイズが不明な Clsuter ...\r\n\r\n`JS`の`MediaRecoder API`を使ったできた動画って、`DataSize`が`0x01 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF`になっていて、おそらく子要素を次のClusterが来るまでなめていくしか無いです。  \r\nというわけで こちらのコード\r\n\r\n```kotlin\r\n/**\r\n * DataSize が 0x01 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF だった場合にサイズを出す。算出方法は以下。多分 Cluster 以外では動かない\r\n * Cluster のそれぞれの子要素にはサイズが入っているため、次のClusterが現れるまで足していくことでサイズが分かる。\r\n */\r\nfun ByteArray.calcUnknownElementSize(): Int {\r\n    val byteSize = this.size\r\n    var totalReadPos = 0\r\n    while (true) {\r\n        // 子要素を順番に見て、長さだけ足していく\r\n\r\n        var readPos = totalReadPos\r\n\r\n        val idLength = this[readPos].getVIntSize()\r\n        // IDのバイト配列\r\n        val idBytes = this.copyOfRange(readPos, readPos + idLength)\r\n        val idElement = MatroskaTags.find(idBytes)!!\r\n        readPos += idLength\r\n\r\n        // トップレベル要素？別のClusterにぶつかったらもう解析しない\r\n        if (idElement == MatroskaTags.Cluster) {\r\n            break\r\n        }\r\n\r\n        // DataSize部\r\n        val dataSizeLength = this[readPos].getVIntSize()\r\n        val dataSizeBytes = this.copyOfRange(readPos, readPos + dataSizeLength)\r\n        val dataSize = dataSizeBytes.toDataSize()\r\n        readPos += dataSizeLength\r\n        readPos += dataSize\r\n\r\n        totalReadPos = readPos\r\n\r\n        // もしかしたら他のブラウザでもなるかもしれないけど、\r\n        // Chromeの場合、WebMのファイル分割は SimpleBlock の途中だろうとぶった切ってくるらしく、中途半端にデータが余ることがある\r\n        // 例：タグの A3 で終わるなど\r\n        // その場合にエラーにならないように、この後3バイト（ID / DataSize / Data それぞれ1バイト）ない場合はループを抜ける\r\n        if (byteSize < totalReadPos + 3) {\r\n            break\r\n        }\r\n\r\n    }\r\n    return totalReadPos\r\n}\r\n```\r\n\r\n次の`Cluster`が見つかるまで子要素の長さを足していく関数です。  \r\nこれを、`parseChildElement`関数に組み込めば...、多分長さがわからない`Cluster`も解析できるようになるはずです。  \r\n長さ不明、パースしんどいな...\r\n\r\n```kotlin\r\n/**\r\n * EBMLをパースする\r\n *\r\n * @param byteArray [ByteArray]\r\n * @param startPos 読み出し開始位置\r\n */\r\nfun parseElement(byteArray: ByteArray, startPos: Int): MatroskaElement {\r\n    var readPos = startPos\r\n    val idLength = byteArray[readPos].getVIntSize()\r\n    // IDのバイト配列\r\n    val idBytes = byteArray.copyOfRange(readPos, readPos + idLength)\r\n    val idElement = MatroskaTags.find(idBytes)!!\r\n    readPos += idBytes.size\r\n    // DataSize部\r\n    val dataSizeLength = byteArray[readPos].getVIntSize()\r\n    val dataSizeBytes = byteArray.copyOfRange(readPos, readPos + dataSizeLength)\r\n    val dataSize = dataSizeBytes.toDataSize()\r\n    readPos += dataSizeBytes.size\r\n    // Dataを読み出す。\r\n    // 長さが取得できた場合とそうじゃない場合で...\r\n    return if (dataSize != -1) {\r\n        // Data部\r\n        val dataBytes = byteArray.copyOfRange(readPos, readPos + dataSize)\r\n        readPos += dataSize\r\n        MatroskaElement(idElement, dataBytes, readPos - startPos)\r\n    } else {\r\n        // もし -1 (長さ不定)の場合\r\n        val unknownDataSize = if (idElement == MatroskaTags.Cluster) {\r\n            // Clusterの場合は、次のClusterまでの子要素の合計サイズを出す\r\n            readPos + byteArray.copyOfRange(readPos, byteArray.size).calcUnknownElementSize()\r\n        } else {\r\n            // Segmentの場合はすべて取得\r\n            byteArray.size\r\n        }\r\n        val dataBytes = byteArray.copyOfRange(readPos, unknownDataSize)\r\n        readPos += dataBytes.size\r\n        MatroskaElement(idElement, dataBytes, readPos - startPos)\r\n    }\r\n}\r\n```\r\n\r\n# ソースコード\r\nhttps://github.com/takusan23/ZeroWebM\r\n\r\n# ブラウザの挙動？\r\n\r\n- Chrome は 要素の途中だろうとぶった切ってくる？\r\n    - なので`DataSize`分データがあるか怪しい（え？？？）\r\n    - Clusterのパースの際はお気をつけて\r\n    - コードあってるけどデータが良くない時があった；；\r\n        - `ArrayIndexOutOfBoundsException: Index 56492651 out of bounds for length 56492651`\r\n        - これ自分が書いたコードが悪いようにみえるじゃん...\r\n- Firefox はぱっと見要素の終わりに揃えていそう\r\n\r\n# そのほか\r\n\r\n- Opusの場合、常にキーフレームかもしれないです\r\n    - Android の ExoPlayer では Opus の SimpleBlock は全部キーフレームにしないと再生できませんでした；；\r\n\r\n# おまけ 書き込み作る\r\nどっちかというとこっち本題にしたかったけどもう疲れた ~~上に気分がPixel Watch に傾いてるのでもう無理~~ \r\n\r\n## 流れ\r\n\r\n- ID要素をバイト配列にする\r\n    - まあこれはパースの際に用意したのを使います\r\n- DataSizeを計算する\r\n    - めんどそう\r\n    - 長さ不明はパーサーがかわいそうなのでちゃんとしようね\r\n- ID要素のバイト配列、DataSizeのバイト配列、Dataの配列をくっつける\r\n- これを全部繰り返す\r\n\r\nパースよりやさしそう\r\n\r\n## 一つの要素を表すデータクラス\r\n今回は楽するために、`DataSize`が常に4バイトになります；；。4バイトを超えたら対応できないので各自いい感じに...  \r\nこの記事の冒頭の最適化してないの話はここにつながるわけですね。。\r\n\r\n```kotlin\r\n/**\r\n * EBML要素を作成する\r\n *\r\n * @param tagId タグ\r\n * @param byteArray 実際のデータ\r\n * @param dataSize DataSize。エンコード済み\r\n */\r\ndata class MatroskaBuildElement(\r\n    val tagId: MatroskaTags,\r\n    val byteArray: ByteArray,\r\n    val dataSize: ByteArray = byteArray.calcDataSize(),\r\n) {\r\n\r\n    /** [tagId] + [dataSize] + [byteArray] を繋げたバイト配列を返す */\r\n    fun concat() = tagId.byteArray + dataSize + byteArray\r\n\r\n    override fun equals(other: Any?): Boolean {\r\n        if (this === other) return true\r\n        if (javaClass != other?.javaClass) return false\r\n\r\n        other as MatroskaBuildElement\r\n\r\n        if (tagId != other.tagId) return false\r\n        if (!byteArray.contentEquals(other.byteArray)) return false\r\n        if (!dataSize.contentEquals(other.dataSize)) return false\r\n\r\n        return true\r\n    }\r\n\r\n    override fun hashCode(): Int {\r\n        var result = tagId.hashCode()\r\n        result = 31 * result + byteArray.contentHashCode()\r\n        result = 31 * result + dataSize.contentHashCode()\r\n        return result\r\n    }\r\n\r\n}\r\n\r\n/** [ByteArray]の長さを求めて、DataSizeを作成する */\r\nprivate fun ByteArray.calcDataSize(): ByteArray {\r\n    // IntをByteArrayにする\r\n    // TODO これだと 1 でも 0x00 0x00 0x00 0x01 と無駄なパディングが入ってしまう\r\n    val dataSizeByteArray = this.size.toByteArray()\r\n    val first = dataSizeByteArray.first()\r\n    // データサイズ自体も可変長なので、何バイト分がデータサイズなのか記述する\r\n    // V_INT とかいうやつで、1が先頭から何番目に立ってるかで残りのバイト数が分かるようになってる\r\n    // 1000 0000 -> 7 ビット ( 1xxx xxxx )\r\n    // 0100 0000 -> 14 ビット ( 01xx xxxx xxxx xxxx )\r\n    val dataSizeBytesSize = when (dataSizeByteArray.size) {\r\n        1 -> 0b1000_0000\r\n        2 -> 0b0100_0000\r\n        3 -> 0b0010_0000\r\n        4 -> 0b0001_0000\r\n        5 -> 0b0000_1000\r\n        6 -> 0b0000_0100\r\n        7 -> 0b0000_0010\r\n        else -> 0b0000_0001\r\n    }\r\n    // データサイズのバイトの先頭に V_INT のやつを OR する\r\n    val dataSize = dataSizeByteArray.apply {\r\n        this[0] = (dataSizeBytesSize or first.toInt()).toByte()\r\n    }\r\n    return dataSize\r\n}\r\n\r\n/** [Int]を[ByteArray]に変換する */\r\nprivate fun Int.toByteArray() = byteArrayOf(\r\n    (this shr 24).toByte(),\r\n    (this shr 16).toByte(),\r\n    (this shr 8).toByte(),\r\n    this.toByte(),\r\n)\r\n```\r\n\r\nmain関数とかで呼び出すようにすればいいと思います  \r\n例えばこれで `EBMLヘッダー` を作れます、\r\n\r\n```kotlin\r\n/** WebMライター */\r\n\r\nfun main() {\r\n    // WebMファイルの先頭にある EBML Header を作る\r\n    // 子要素を作成する\r\n    val ebmlVersion = MatroskaBuildElement(MatroskaTags.EBMLVersion, byteArrayOf(0x01))\r\n    val readVersion = MatroskaBuildElement(MatroskaTags.EBMLReadVersion, byteArrayOf(0x01))\r\n    val maxIdLength = MatroskaBuildElement(MatroskaTags.EBMLMaxIDLength, byteArrayOf(0x04))\r\n    val maxSizeLength = MatroskaBuildElement(MatroskaTags.EBMLMaxSizeLength, byteArrayOf(0x08))\r\n    val docType = MatroskaBuildElement(MatroskaTags.DocType, \"webm\".toAscii())\r\n    val docTypeVersion = MatroskaBuildElement(MatroskaTags.DocTypeVersion, byteArrayOf(0x02))\r\n    val docTypeReadVersion = MatroskaBuildElement(MatroskaTags.DocTypeReadVersion, byteArrayOf(0x02))\r\n\r\n    // EBML Header 要素\r\n    val children = ebmlVersion.concat() + readVersion.concat() + maxIdLength.concat() + maxSizeLength.concat() + docType.concat() + docTypeVersion.concat() + docTypeReadVersion.concat()\r\n    val ebmlHeader = MatroskaBuildElement(MatroskaTags.EBML, children)\r\n    // ファイルに書き出す\r\n    File(\"ebmlHeader.webm\").writeBytes(ebmlHeader.concat())\r\n}\r\n\r\n/** 文字列を ASCII のバイト配列に変換する */\r\nprivate fun String.toAscii() = this.toByteArray(charset = Charsets.US_ASCII)\r\n```\r\n\r\nちゃんとパーサーに認識されてました\r\n\r\n![Imgur](https://imgur.com/lAcMljf.png)\r\n\r\n## 他の要素も作ろう\r\n\r\n疲れたので全カットで。  \r\n注意点としては、`Tracks > Track`で音声トラックを追加する場合、`AudioTrack`の`Sampling frequency`が`Float`なので注意して下さい。  \r\nKotlinなら`Int.toBits()`を呼び出すだけかも？`// TODO`ばっかで使えたもんじゃないな\r\n\r\n```kotlin\r\n/*\r\n * Kotlinのシフト演算子\r\n * [shl] <<\r\n * [shr] >>\r\n */\r\n\r\n/** サイズが不明 */\r\nprivate val UNKNOWN_SIZE = byteArrayOf(0x01, 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte())\r\n\r\n/** TrackType が Video */\r\nprivate const val VIDEO_TRACK_TYPE = 1\r\n\r\n/** TrackType が Audio */\r\nprivate const val AUDIO_TRACK_TYPE = 2\r\n\r\n/** キーフレームなら */\r\nprivate const val SIMPLE_BLOCK_FLAGS_KEYFRAME = 0x80\r\n\r\n/** キーフレームじゃない */\r\nprivate const val SIMPLE_BLOCK_FLAGS = 0x00\r\n\r\n/** WebMライター */\r\n\r\nfun main() {\r\n    val ebmlHeader = createEbmlHeader()\r\n\r\n    val info = createInfo()\r\n    val tracks = createTracks()\r\n    val cluster = createStreamingCluster()\r\n    val segment = MatroskaBuildElement(MatroskaTags.Segment, info.concat() + tracks.concat() + cluster.concat())\r\n\r\n    // EBML Header + Segment 書き込み\r\n    File(\"empty.webm\").apply {\r\n        appendBytes(ebmlHeader.concat())\r\n        appendBytes(segment.concat())\r\n    }\r\n}\r\n\r\n/** EBMLヘッダーを作成する */\r\nprivate fun createEbmlHeader(): MatroskaBuildElement {\r\n    // WebMファイルの先頭にある EBML Header を作る\r\n    // 子要素を作成する\r\n    val ebmlVersion = MatroskaBuildElement(MatroskaTags.EBMLVersion, byteArrayOf(0x01))\r\n    val readVersion = MatroskaBuildElement(MatroskaTags.EBMLReadVersion, byteArrayOf(0x01))\r\n    val maxIdLength = MatroskaBuildElement(MatroskaTags.EBMLMaxIDLength, byteArrayOf(0x04))\r\n    val maxSizeLength = MatroskaBuildElement(MatroskaTags.EBMLMaxSizeLength, byteArrayOf(0x08))\r\n    val docType = MatroskaBuildElement(MatroskaTags.DocType, \"webm\".toAscii())\r\n    val docTypeVersion = MatroskaBuildElement(MatroskaTags.DocTypeVersion, byteArrayOf(0x02))\r\n    val docTypeReadVersion = MatroskaBuildElement(MatroskaTags.DocTypeReadVersion, byteArrayOf(0x02))\r\n\r\n    // EBML Header 要素\r\n    val children = ebmlVersion.concat() + readVersion.concat() + maxIdLength.concat() + maxSizeLength.concat() + docType.concat() + docTypeVersion.concat() + docTypeReadVersion.concat()\r\n    return MatroskaBuildElement(MatroskaTags.EBML, children)\r\n}\r\n\r\n/** Infoを作成する */\r\nprivate fun createInfo(): MatroskaBuildElement {\r\n    val timestampScale = MatroskaBuildElement(MatroskaTags.TimestampScale, 1_000_000.to4ByteArray())\r\n    val multiplexingAppName = MatroskaBuildElement(MatroskaTags.MuxingApp, \"ZeroWebM\".toAscii())\r\n    val writingAppName = MatroskaBuildElement(MatroskaTags.WritingApp, \"ZeroWebM\".toAscii())\r\n    val children = timestampScale.concat() + multiplexingAppName.concat() + writingAppName.concat()\r\n    return MatroskaBuildElement(MatroskaTags.Info, children)\r\n}\r\n\r\n/** Track要素を作成する */\r\nprivate fun createTracks(\r\n    videoTrackId: Int = 1,\r\n    videoCodec: String = \"V_VP9\",\r\n    videoWidth: Int = 1280,\r\n    videoHeight: Int = 720,\r\n    audioTrackId: Int = 2,\r\n    audioCodec: String = \"O_OPUS\",\r\n    audioSamplingRate: Float = 48_000.0f, // Floatなの！？\r\n    audioChannelCount: Int = 2,\r\n): MatroskaBuildElement {\r\n\r\n    // 動画トラック情報\r\n    val videoTrackNumber = MatroskaBuildElement(MatroskaTags.TrackNumber, videoTrackId.toByteArray())\r\n    val videoTrackUid = MatroskaBuildElement(MatroskaTags.TrackUID, videoTrackId.toByteArray())\r\n    val videoCodecId = MatroskaBuildElement(MatroskaTags.CodecID, videoCodec.toAscii())\r\n    val videoTrackType = MatroskaBuildElement(MatroskaTags.TrackType, VIDEO_TRACK_TYPE.toByteArray())\r\n    val pixelWidth = MatroskaBuildElement(MatroskaTags.PixelWidth, videoWidth.toByteArray())\r\n    val pixelHeight = MatroskaBuildElement(MatroskaTags.PixelHeight, videoHeight.toByteArray())\r\n    val videoTrack = MatroskaBuildElement(MatroskaTags.VideoTrack, pixelWidth.concat() + pixelHeight.concat())\r\n    val videoTrackEntryChildren = videoTrackNumber.concat() + videoTrackUid.concat() + videoCodecId.concat() + videoTrackType.concat() + videoTrack.concat()\r\n    val videoTrackEntry = MatroskaBuildElement(MatroskaTags.Track, videoTrackEntryChildren)\r\n\r\n    // 音声トラック情報\r\n    val audioTrackNumber = MatroskaBuildElement(MatroskaTags.TrackNumber, audioTrackId.toByteArray())\r\n    val audioTrackUid = MatroskaBuildElement(MatroskaTags.TrackUID, audioTrackId.toByteArray())\r\n    val audioCodecId = MatroskaBuildElement(MatroskaTags.CodecID, audioCodec.toAscii())\r\n    val audioTrackType = MatroskaBuildElement(MatroskaTags.TrackType, AUDIO_TRACK_TYPE.toByteArray())\r\n    // Segment > Tracks > Audio の CodecPrivate に入れる中身\r\n    // OpusHeaderをつくる\r\n    // https://www.rfc-editor.org/rfc/rfc7845\r\n    // Version = 0x01\r\n    // Channel Count = 0x02\r\n    // Pre-Skip = 0x00 0x00\r\n    // Input Sample Rate ( little endian ) 0x80 0xBB 0x00 0x00 . Kotlin は Big endian なので反転する\r\n    // Output Gain 0x00 0x00\r\n    // Mapping Family 0x00\r\n    // ??? 0x00 0x00\r\n    val opusHeader = \"OpusHead\".toAscii() + byteArrayOf(1.toByte()) + byteArrayOf(audioChannelCount.toByte()) + byteArrayOf(0x00.toByte(), 0x00.toByte()) + audioSamplingRate.toInt().toByteArray().reversed() + byteArrayOf(0x00.toByte(), 0x00.toByte(), 0x00.toByte(), 0x00.toByte(), 0x00.toByte())\r\n    val codecPrivate = MatroskaBuildElement(MatroskaTags.CodecPrivate, opusHeader)\r\n    // Float を ByteArray にするにはひと手間必要\r\n    val sampleFrequency = MatroskaBuildElement(MatroskaTags.SamplingFrequency, audioSamplingRate.toBits().to4ByteArray())\r\n    val channels = MatroskaBuildElement(MatroskaTags.Channels, audioChannelCount.toByteArray())\r\n    val audioTrack = MatroskaBuildElement(MatroskaTags.AudioTrack, channels.concat() + sampleFrequency.concat())\r\n    val audioTrackEntryValue = audioTrackNumber.concat() + audioTrackUid.concat() + audioCodecId.concat() + audioTrackType.concat() + codecPrivate.concat() + audioTrack.concat()\r\n    val audioTrackEntry = MatroskaBuildElement(MatroskaTags.Track, audioTrackEntryValue)\r\n\r\n    // Tracks を作る\r\n    return MatroskaBuildElement(MatroskaTags.Tracks, videoTrackEntry.concat() + audioTrackEntry.concat())\r\n}\r\n\r\n/**\r\n * Clusterの中に入れるSimpleBlockを作る\r\n *\r\n * @param trackNumber トラック番号、映像なのか音声なのか\r\n * @param simpleBlockTimescale エンコードしたデータの時間\r\n * @param byteArray エンコードされたデータ\r\n * @param isKeyFrame キーフレームの場合は true\r\n */\r\nprivate fun createSimpleBlock(\r\n    trackNumber: Int,\r\n    simpleBlockTimescale: Int,\r\n    byteArray: ByteArray,\r\n    isKeyFrame: Boolean,\r\n): MatroskaBuildElement {\r\n    val vIntTrackNumberBytes = trackNumber.toVInt()\r\n    val simpleBlockBytes = simpleBlockTimescale.toByteArray()\r\n    // flags。キーフレームかどうかぐらいしか入れることなさそう\r\n    val flagsBytes = byteArrayOf((if (isKeyFrame) SIMPLE_BLOCK_FLAGS_KEYFRAME else SIMPLE_BLOCK_FLAGS).toByte())\r\n    // エンコードしたデータの先頭に、\r\n    // トラック番号、時間、キーフレームかどうか を付け加える\r\n    val simpleBlockValue = vIntTrackNumberBytes + simpleBlockBytes + flagsBytes + byteArray\r\n\r\n    return MatroskaBuildElement(MatroskaTags.SimpleBlock, simpleBlockValue)\r\n}\r\n\r\n/**\r\n * ストリーミング可能な Cluster を作成する。\r\n * データサイズが不定になっている。\r\n *\r\n * @param timescaleMs 開始時間。ミリ秒\r\n */\r\nprivate fun createStreamingCluster(timescaleMs: Int = 0): MatroskaBuildElement {\r\n    val timescaleBytes = timescaleMs.to4ByteArray()\r\n    val timescale = MatroskaBuildElement(MatroskaTags.Timestamp, timescaleBytes)\r\n    val clusterValue = timescale.concat()\r\n\r\n    return MatroskaBuildElement(MatroskaTags.Cluster, clusterValue, UNKNOWN_SIZE)\r\n}\r\n\r\n/** 数値を V_INT でエンコードする */\r\nprivate fun Int.toVInt(): ByteArray {\r\n    val valueByteArray = this.toByteArray()\r\n    val valueSize = when (valueByteArray.size) {\r\n        1 -> 0b1000_0000\r\n        2 -> 0b0100_0000\r\n        3 -> 0b0010_0000\r\n        4 -> 0b0001_0000\r\n        5 -> 0b0000_1000\r\n        6 -> 0b0000_0100\r\n        7 -> 0b0000_0010\r\n        else -> 0b0000_0001\r\n    }\r\n    return valueByteArray.apply {\r\n        // TODO これだと多分よくない（立てたい位置にすでに 1 が立っている場合に数値がおかしくなる）\r\n        this[0] = (valueSize or this[0].toInt()).toByte()\r\n    }\r\n}\r\n\r\n/** 文字列を ASCII のバイト配列に変換する */\r\nprivate fun String.toAscii() = this.toByteArray(charset = Charsets.US_ASCII)\r\n\r\n/** [Int]を[ByteArray]に変換する。2バイト */\r\nprivate fun Int.toByteArray() = byteArrayOf(\r\n    (this shr 8).toByte(),\r\n    this.toByte(),\r\n)\r\n\r\n/** [Int]を[ByteArray]に変換する。4バイト */\r\nprivate fun Int.to4ByteArray() = byteArrayOf(\r\n    (this shr 24).toByte(),\r\n    (this shr 16).toByte(),\r\n    (this shr 8).toByte(),\r\n    this.toByte(),\r\n)\r\n```\r\n\r\nまぁ動いているのでヨシ！  \r\n`writing app`好きな文字列にできるのいいな（すごくどうでもいい）\r\n\r\n![Imgur](https://imgur.com/Od6yGsP.png)\r\n\r\n# ソースコード\r\n再掲\r\n\r\nhttps://github.com/takusan23/ZeroWebM\r\n\r\n# おわりに\r\nPixel Watch はよ来い！！！！  \r\ndocomoでもセルラー通信できたら WearOS でもLTEバンド取得できるのか試してみたかったんだけどな、、、\r\n\r\nKotlinの便利機能ばっかり使ったのであんまり参考にならなそう。  \r\n\r\n# 参考にしました\r\nたすかります！！！\r\n\r\n- https://www.slideshare.net/mganeko/inside-webm\r\n- https://www.slideshare.net/mganeko/media-recorder-and-webm\r\n- https://qiita.com/ryiwamoto/items/0ff451da6ab76b4f4064\r\n- https://qiita.com/legokichi/items/83871e1f034331222fd2\r\n- https://scrapbox.io/unarist/MediaRecorderAPIで作ったwebmをseekableにしたい"},{"title":"Windows 11で生まれ変わったMicrosoft Storeに従来(WPF/Win32)のアプリを公開してみた話","link":"/posts/windows_11_win32_app_publish_ms_store/","markdown":"\nどうもこんばんわ。  \nD.C.4 Plus Harmony ～ダ・カーポ4～ プラスハーモニー 攻略しました。ちよ子ちゃんかわいいかったです。ぜひ本校Verの制服姿を...！\n\n![Imgur](https://imgur.com/7qdoxiM.png)\n\nこの子の個別ルート短かった気がするんだけど多分気のせいだよね。きっと時間がすぎるのが早かっただけや ~~（サブヒロインだからとか言わない）~~\n\n![Imgur](https://imgur.com/VovF7Lj.png)\n\n↑髪の毛おろしてるのかわいい\n\nちなみにこの子、`生主`なんですね。`配信者`じゃなくて`生主`って表現してる。購入決定では？  \n\n![Imgur](https://imgur.com/eeRt9fl.png)\n\nあとしいしい先輩ルートも良かったです。リードされてえなあ私もなあ\n\n![Imgur](https://imgur.com/VMQ4WAU.png)\n\n↑このボイスほんとすき\n\nちなみに過去作はやってないです（直接的には繋がってないって噂だったから予約した）。やってないけど過去作のCDだけ買った。  \nWindowsはまともな音楽アプリ作ってくれ。\n\n![Imgur](https://imgur.com/bfuXRTl.png)\n\n今作の`恋するMODE`とか名曲なのでCD欲しいなと思ったんだけど、全年齢版の続編（しかもお高い豪華版）にしかついてないっぽいね？。CIRCUSだから多分続編もR18版で出るんだろうしそのときに期待してもいいんだけどそうすっかなー\n\n# 本題\nWindows 11で生まれ変わったMicrosoft StoreにWPFアプリを公開します。\n\n## Windows 11\nWindows 11おめでとうございます。  \nウィンドウの角が丸くなったり、スタートボタンが真ん中に移動したり（変更可能）、そもそもスタートメニューがシンプルになったりしました。  \n個人的にはWindows 10のタイルでグループ分けしてたのでそれが使えないのはちょっと困った？（まぁ開発で使ってるPCはストレージの空きがない（それ以外は満たしてる）ので当分はWin11にしないと思う。）  \n\n![Imgur](https://imgur.com/VllzUu6.png)\n\nついにタスクバーのDeskBand APIがついに廃止？になったので、BatteryBarとか使ってる方は困るかも。  \nタスクバーにPC情報を表示する`zhongyang219/TrafficMonitor`ってのがあるけどあれは対応済みの模様。C++とかMFCの知識が無いので動いてる理由はわからんかった。けどあれ多分DeskBand API使ってなさそう。\n\nちなみにWindows 10にあった隠しテーマ`Aero Lite`、Windows 11にもありました。やっぱ閉じるボタンは赤くないとね！  \n\n![Imgur](https://imgur.com/NIVge7P.png)\n\nあとなんか問題になってた`TPM 2.0`が必須もなんか公式がバイパス手段を公開してるみたいですね。  \nあとでやってみようかな。\n\n## 生まれ変わった Microsoft Store\nイマイチ流行らなかったMS Storeがリニューアルしました。  \nこれからは`UWP（MSIX形式）`の他に`Win32（MSI / EXE 形式）`が公開できます。  \n\n# 今回作ったアプリ\n\n- Microsoft Storeのリンク\n    - Windows 11以降じゃないと開けません\n    - <a href=\"ms-windows-store://pdp/?productid=XP8BZ1XV93S6X1\">ms-windows-store://pdp/?productid=XP8BZ1XV93S6X1</a>\n- winget\n    - winget、Microsoft Storeのアプリもダウンロードできるっぽい？\n    - これならWindows 10でもダウンロードできる\n    - `winget install いたかーそる`\n- ソースコード\n    - https://github.com/takusan23/ItaCursor\n\n\n疑似カーソルと疑似トラックパッドを追加して、タブレットでもマウス操作っぽいのができるアプリ。`WPFと.NET 5`で出来てます。  \n微妙に使いにくい。  \n**Windows 11から仮想トラックパッドが追加されたのでわざわざ入れる必要はないと思います。**  \nおまけとして音量コントローラーとスクリーンショットボタンを追加しました。\n\n![Imgur](https://imgur.com/FpFLBXC.png)\n\n↑ちなみにWindowsタブレット買った。\n\nこのアプリを作ったときに大変だった話とかそもそもの仕組みなんかをそのうち書きたいと思います。\n\n# WPFなどの従来のアプリを公開するまで\nまず開発者登録が必要です。**クレカ**で19ドル払う必要があります。一回払えばいいです。  \n**クレカ**じゃないとだめってMSは言ってるんですが、なんかKyash Cardで通りました。ちょっと前に`Kyash Card`限定でサブスクの支払いに使えるようになったっぽいからそれかも？  \nあと今見たんですけどなんか円安ですね。  \n\n登録が済んだら、Win32アプリを公開できるように申請をします。  \n現状、Win32アプリを公開する機能は一般に開放さているわけではなくプレビュー段階です。（2021/10/12段階）  \nプレビュー段階なのですが、申請をすればWin32アプリを公開する権限を貰えます。\n\n申請が通ったら、公開できるようになります。多分インストーラーのみが登録できます（インストール不要のタブルクリックで起動するアプリは無理？）  \n\n# 開発者登録\nhttps://developer.microsoft.com/ja-jp/microsoft-store/register/\n\n19ドル払います。クレカ持ってない人はどうすればいいんだろ。私の場合は`Kyash Card`が何故か通った。\n\n![Imgur](https://imgur.com/v6hnFJt.png)\n\n# Win32アプリの公開プレビュープログラムに申請する\nこっからです。  \n\nhttps://aka.ms/storepreviewwaitlist\n\n私は 9/27 に申し込んで、10/7 に通りました。  \nなんか`CrystalDiskInfo`の開発者が2ヶ月待ったとか言ってて覚悟してたけどそうでもなかった。  \nhttps://youtu.be/0Oks2zpolGU?t=8299\n\n質問内容ですが、そんな難しくないです。  \nインストーラーをどっかインターネット上に公開して（今回はGitHubのRelease）、翻訳片手にれっつごー\n\n- What is your Seller ID in Partner Center? \n    - https://partner.microsoft.com/ja-jp/dashboard/account/v3/organization/legalinfo#developer\n    - 法的情報 -> 販売者IDの部分を入れればいいです\n- What is the app name that you want to reserve and bring to Store?\n    - アプリ名\n- Does this app replace an existing app in Store?\n    - 既に公開してるアプリを置き換えるか。置きかえないので No\n- Please provide email address of the person responsible for submitting the traditional desktop app. \n    - メアド\n- Choose the package type of your app.\n    - インストーラーの形式。msiで\n- Provide HTTPS-based URL pointing to your downloadable Windows installer binary. \n    - インストーラーを公開するURL。今回はGitHubのReleaseに置いたインストーラーのURLを入れました。\n    - 例：`https://github.com/takusan23/ItaCursor/releases/download/1.0.0/ItaCursorInstaller.msi`\n- A versioned URL is required at the time of submission of your application to Store. Will you be able to provide it?\n    - バージョンごとのURLを用意できるか？ってこと？。今回は行けるのでYesで\n- Does the above URL support unauthenticated (anonymous) download of installer binary?\n    - ダウンロードに認証（制限？）をかけてない（会員限定でダウンロード！みたいなことだと思う）かどうか？\n- Is your app binary signed with a certificate?\n    - 署名してないのでNo\n- Do you plan to provide standalone installer?\n    - おそらくインストーラー単体で完結するか聞かれてます。そりゃそうだろって思うんですが、多分インターネットから追加のファイルをダウンロードしたりすることなく完結するか聞いてます。多分ね。\n- Does your app support silent installation experience?\n    - サイレントインストールできるか。GUIの表示無しでしれっとインストールできるかってことだと。\n    - `msi`の場合は`コマンドプロンプト`を使い、`インストーラー.msi /passive`でサイレントインストールが可能なので、  \n    - `App supports silent install by providing installer parameters`を選ぶ。（ただし管理者権限（UAC）を求められる）\n- Does your app have any dependency on non-Microsoft drivers or NT services?\n    - Micorosftが認めてないドライバーとかを使っているか。使ってないから`No`\n- Let us know the reasons for above dependency on non-Microsoft drivers or NT services if applicable.\n    - さっきの質問でYes答えた場合は何を使っているのか書く\n- Does your install package include any bundleware? \n    - 追加のアプリが含まれているか？どゆこと？多分No\n- What is the total size of your app install package binary?\n    - インストーラーのサイズを答える\n\n# 審査が通ると？\n`Microsoft Store Preview program`みたいな件名のメールが来ます。  \n公開ページから`EXE または MSI アプリ`が選べるようになってます。\n\n![Imgur](https://imgur.com/IWPnvlz.png)\n\n# Win32アプリを公開する\n\n必要なものは\n\n- アイコンの画像\n    - 1080x1080\n- スクリーンショット\n    - 多分サイズは自由\n\n## 値段と市場\nアプリの値段と配布する国を決めます。  \n記入が終わったら保存して次へ行きます。勝手に保存してくれるわけではない模様。\n\n![Imgur](https://imgur.com/KrTOLMN.png)\n\n## プロパティ\nアプリのカテゴリなど\n\n![Imgur](https://imgur.com/KiSIjHa.png)\n\n### テスターに提供する情報\n`製品の公表`と`認定の注意書き`には、アプリの動作に必要なフレームワークと、必要な条件を書く必要があります。\nちなみにスクリーンショットには**Microsoft 以外のドライバーまたは**のところにチェックが入っていますが、ドライバーに依存してないので外しました。  \nこのアプリはタブレット端末と、`.NET 5以上`が必要なのでそう書きました。\n\n![Imgur](https://imgur.com/opucXfI.png)\n\n下にも`システム要件`の項目があるのでそこでもタッチスクリーンが必要にチェック <input type=\"checkbox\" checked=\"true\"/> を入れておきます。\n\n## 年齢\nGoogle Playと似たようなことが聞かれます。\n\n![Imgur](https://imgur.com/keQEUIU.png)\n\n## パッケージ\nここでアプリのインストーラーを設定します。  \nインストーラーの作成は前書いので参考にしてね。→[.NET 5で出来たWPFアプリを配布するインストーラーを作成する](/posts/windows_dot_net5_wpf_making_installer/)  \n\n![Imgur](https://imgur.com/0MzXa9d.png)\n\n### パッケージURL\nインストーラーは、`Microsoft Store`にアップロードする方式ではなく、`ダウンロードリンク`を開発者が用意する形になってます。    \n`Windows 11`は`64ビット`しか無いですが、アプリが`32ビット用`の場合のためか`x86`も選べます。  \n`msi`のインストーラーなら、`/passive`をつけることでサイレントインストール（インストーラーGUIが出ない）が出来ます。\nなので、`インストーラー パラメータ`に`/passive`を入れます\n\n![Imgur](https://imgur.com/OvNoC3V.png)\n\nあとなんか日本語が2つあるんだけど、よくわからん（多分英語の`en-us`と同じ流れで`ja-jp`を作ったんだと思うけどどうなんだろう）\n\n## ストアの公開情報\n\n![Imgur](https://imgur.com/1fz1VOj.png)\n\n書いていきます。  \nアイコンサイズは`1080 x 1080`なので気をつけてください。\n\n![Imgur](https://imgur.com/HNUlAgR.png)\n\n### ライセンス条項\nこれは...ソースコードのライセンスと同じでいいんかな。\n\n![Imgur](https://imgur.com/sbyUcQe.png)\n\n## ここまで終わると\n公開ボタンが押せるようになります。  \nというわけで公開ポチッと\n\n![Imgur](https://imgur.com/OygFoG5.png)\n\nあとは待つだけ。楽しみですね\n\n![Imgur](https://imgur.com/K8fa4R7.png)\n\n## リジェクト（却下された）\n審査が通っても、リジェクトされてもメールで通知が来ます。  \n\n- Win32アプリのインストーラーはスタンドアロン（単体）で、オフラインインストールが必須ですよ\n    - 実は`.NET 5`がインストールされていない場合はインストール前に`.NET 5`のインストールを促すダイアログを出すように設定してたんだけど、規約には「**必要なファイルをダウンロードするダウンローダーであってはいけません**」と書いてあります。 \n    - 仕方ないので、アプリ説明欄に「**.NET 5を予め入れておいてください**」の文章を入れることで解決しました。果たして読んでくれるのだろうか...\n    - `.NET 5`には、`.NET 5のランタイムを含めたexe`を吐き出す機能があるんだけど、インストーラーのサイズが大きすぎちゃうのでちょっと無理なんだよね。確実性を求めるならこれなんだけどさ。\n\n修正したら審査通りました。  \nなんなら`.NET 5`も`Microsoft Store`で公開してほしい。てかその方が良くないですかMicrosoftさん。\n\n審査が通ると`Congratulations! Your submission has passed all tests`ってメールが来ます。\n\nいつの間にか検索でも見つかるようになってました。\n\n![Imgur](https://imgur.com/HF2g8tZ.png)\n\n# インストールボタンを押して見る\nちなみに、現状のMicrosoft Storeでは、インストール済みかどうかまでは見ていないので、インストールが終了したあと、再度ストアでアプリの詳細画面を開くとまた**インストールボタンが押せます**。こればっかりは仕方ないのかな。  \n\n![Imgur](https://imgur.com/ES3yXhJ.png)\n\n# なんか Microsoft Store 以外に winget からも落とせる\n`winget search <アプリ名>`で検索すると見つかります。  \n公開直後は見つかりませんが、これもいつの間にか見つかるようになってました。\n\n![Imgur](https://imgur.com/Hr15yyH.png)\n\nwingetなら`Windows 10`でも落とせます。落とせるけど**アプリ名が日本語**なので入力めんどい\n\n![Imgur](https://imgur.com/6o6xqNK.png)\n\n# 終わりに\nストア、流行るといいですね。  \nあとAndroidアプリ動作楽しみ。"},{"title":".NET 5で出来たWPFアプリを配布するインストーラーを作成する","link":"/posts/windows_dot_net5_wpf_making_installer/","markdown":"どうもこんばんわ。  \r\nアインシュタインより愛を込めて APOLLOCRISIS 入手した。箱が二回りぐらい大きいな？  \r\n今やってるゲーム終わらせたらやりたいです。\r\n\r\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">アインシュタインより愛を込めて APOLLOCRISIS 入手した <a href=\"https://t.co/m6r8Jop7Ae\">pic.twitter.com/m6r8Jop7Ae</a></p>&mdash; たくさん (@takusan__23) <a href=\"https://twitter.com/takusan__23/status/1442148489471819783?ref_src=twsrc%5Etfw\">September 26, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\r\n\r\n# 本題\r\nWPFなアプリの配布用にインストーラーを作成します。  \r\n\r\n## なぜ？\r\nきたるWindows11の Microsoft Store でのexe(msi)(従来のソフトウェア)配信機能に備えて...  \r\nそういえばHomeエディションではローカルアカウント作れないってま？\r\n\r\n## ちなみに\r\n`.NET 5`なら`単一exe`ファイルを吐き出す機能がありますので、インストーラーが必要ない場合は単一バイナリをばらまくのがいいです。\r\n\r\n[単一exe作成](/posts/dotnet_wpf/)\r\n\r\n# 環境\r\n\r\n| なまえ        | あたい                                     |\r\n|---------------|--------------------------------------------|\r\n| Visual Studio | 2019 Community Edition                     |\r\n| Windows       | 10 Pro                                     |\r\n| .NET          | 5                                          |\r\n| 拡張機能      | Microsoft Visual Studio Installer Projects |\r\n\r\n\r\n# Microsoft Visual Studio Installer Projects\r\nってのを使います。Wixってのもあるらしいけどよく知らん\r\n\r\n# 配布予定のWPFアプリを作成する\r\nまぁ頑張って作ってくれ\r\n\r\n# 配布予定のWPFアプリのソリューションを開く\r\nここにインストーラーをプロジェクトとして追加します。\r\n\r\n# 拡張機能を入れる\r\nこっから入れられます。  \r\n\r\n![Imgur](https://imgur.com/Rnu4RDm.png)\r\n\r\nそしたら、これを入れます。\r\n\r\n![Imgur](https://imgur.com/B2g8gdN.png)\r\n\r\n# インストーラープロジェクトを追加する\r\nここから追加できます。\r\n\r\n![Imgur](https://imgur.com/aLKGMS4.png)\r\n\r\n開いたら、検索ボックスに`setup`とか入れて出てくる、`Setup Project`を選択します。  \r\n名前とかは各自\r\n\r\n![Imgur](https://imgur.com/E9BHzvU.png)\r\n\r\n![Imgur](https://imgur.com/rhQkKNR.png)\r\n\r\nこの画面が開けてればおｋ\r\n\r\n![Imgur](https://imgur.com/p8lJmcT.png)\r\n\r\n## .NET 5 で出来たWPFアプリを配布対象にする\r\n\r\nそのためにはまず、ソリューションエクスプローラーの、配布したいWPFアプリを選んで右クリックして、発行を押します。  \r\n\r\n![Imgur](https://imgur.com/UgmCf4M.png)\r\n\r\n開いたら、フォルダーに発行するようにします。\r\n\r\n![Imgur](https://imgur.com/QAJaykP.png)\r\n\r\n設定とかはそのままで完了を押せばいいです。\r\n\r\nそうしたら、一応配布するexeを一つにまとめるため、`すべての設定を表示`から、ターゲットランタイムを`win-x64`へ、ファイルの公開オプションから、`単一ファイルの作成`にチェックを入れます。  \r\nこれでインストール先に置くファイルの数を減らせます。（まぁインストール先なんてどうでもいいが）\r\n\r\n![Imgur](https://imgur.com/QLd15ZC.png)\r\n\r\n# インストーラーで.NET 5なアプリを配布するには\r\n\r\n参考：https://docs.microsoft.com/en-us/visualstudio/deployment/installer-projects-net-core?view=vs-2019\r\n\r\nまずはさっきのインストーラープロジェクト作成直後の画面を出します。  \r\n`File System`ってタブのやつですね。こっから出せます。\r\n\r\n![Imgur](https://imgur.com/Ds6RPPp.png)\r\n\r\nそしたら、ソリューションエクスプローラーのレンチマークを押してプロパティも開きます。  \r\n\r\n![Imgur](https://imgur.com/oULsYpT.png)\r\n\r\nそうしたら、`File System`の`Application Folder`を右クリックして、`Add` -> `プロジェクト出力`へ進みます。\r\n\r\n![Imgur](https://imgur.com/Rbk7i3M.png)\r\n\r\nそうしたら、プロジェクトのところが配布したいWPFプロジェクトになっているか確認して、`項目の公開`を選択して、構成をそのままにして、`OK`を押します。\r\n\r\n![Imgur](https://imgur.com/HIlAKOJ.png)\r\n\r\n## 項目の公開 の プロパティ を開きます\r\nソリューションエクスプローラーから、項目の公開 (ry を右クリックしてプロパティを開きます。\r\n\r\n![Imgur](https://imgur.com/fvFI1ep.png)\r\n\r\nそしたら、`公開するWPFプロジェクト`の、`Properties > PublishProperties > FolderProfile.pubxml`を右クリックして、完全パスをコピーします。\r\n\r\n![Imgur](https://imgur.com/q4zscnz.png)\r\n\r\nそうしたら、メモ帳とかに貼り付けて、`Properties/PublishProperties/...`の部分をコピーします。\r\n\r\n![Imgur](https://imgur.com/B5fc2pV.png)\r\n\r\nそうしたら、Visual Studioへ戻り、項目の公開のプロパティの、`PublishProfilePath`にさっきコピーした値を入れます。\r\n\r\n![Imgur](https://imgur.com/Ted2UBZ.png)\r\n\r\n以上です。ソリューションエクスプローラーからインストーラープロジェクトを右クリックして、`ビルド`を選択しましょう。\r\n\r\n![Imgur](https://imgur.com/qOKgwn5.png)\r\n\r\nこれで生成できる..はず？\r\n\r\n![Imgur](https://imgur.com/de47Xx4.png)\r\n\r\n## 生成できない\r\n\r\nhttps://stackoverflow.com/questions/339106/unrecoverable-build-error-on-any-msi-setup-project\r\n\r\n管理者権限でコマンドプロンプトを開いて、以下のコマンドを叩いてPC再起動で治るとか？\r\n\r\n```cmd\r\nregsvr32 \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\MSI Tools\\mergemod.dll\"\r\nregsvr32 ole32.dll\r\n```\r\n\r\n## targeting 'x64' is not compatible with the project's target platform 'x86'\r\n\r\n`win-x64`を選んだ影響ですね。インストーラープロジェクトのプロパティから、`TargetPlatform`を`x64`にすればこの警告を消せます。\r\n\r\n# インストーラーの名前とかインストール先のフォルダ名とか\r\n\r\nインストーラープロジェクトから変更可能です。`Another`、`ProductName`、`Title`、`Manufactor`あたりを変更すればいいと思います。\r\n\r\n![Imgur](https://imgur.com/uvnRSwV.png)\r\n\r\nしっかりアンインストールも出来ます。\r\n\r\n![Imgur](https://imgur.com/5p67hQ4.png)\r\n\r\n## スタートメニューに追加\r\nインストーラーの利点といえばこれか？\r\n\r\n`File System`から、`User's Programs Menu`を選択して、`新しいショートカットを作成`を押します。\r\n\r\n![Imgur](https://imgur.com/yGi6hgN.png)\r\n\r\nそしたら、`Application Folder`を選択して、`項目の公開 (以下略`を押して`OK`を押します。\r\n\r\n![Imgur](https://imgur.com/0I1uXxU.png)\r\n\r\nそしたら、プロパティを選んで、`(Name)`をアプリ名に変更します。\r\n\r\n![Imgur](https://imgur.com/Usk7A9x.png)\r\n\r\nできたら再度ビルドします。\r\n\r\nこれでスタートに登録も出来ましたね。\r\n\r\n![Imgur](https://imgur.com/tgdofmk.png)\r\n\r\n以上です。\r\n\r\n# 追記：2021/10/07 アイコンを設定する場合\r\n\r\n`128 x 128`じゃないとだめです。ソース：https://stackoverflow.com/questions/2041291/how-to-change-windows-applicatoins-default-icon-in-setup-project\r\n\r\nただ、これと別に生まれ変わった`Win11`の`Microsoft Store`では`1080 x 1080`のサイズのアイコンが必要なので、`svg`で作っておくと幸せになれると思います。\r\n\r\n![Imgur](https://imgur.com/KXDs6Ws.png)\r\n\r\n今回は`InkScape`で作りました。`128 x 128`で`png`に書き出して、`GIMP`で`ico`形式に変更します。\r\n\r\n## アイコンを追加\r\nプロジェクトのプロパティから、リソースを開いて、`ico`ファイルをドラッグアンドドロップします。\r\n\r\n![Imgur](https://imgur.com/6t2Weuj.png)\r\n\r\nできたら、`Resources`フォルダに追加されるので、`Resources`フォルダ内にある`ico`のプロパティを開いて、`ビルドアクション`を`リソース`にします。必要かどうかはわかりませんが。\r\n\r\n![Imgur](https://imgur.com/vGsX36c.png)\r\n\r\n## WPFのアイコンを設定\r\nプロジェクトのプロパティを開いて、アプリケーションを押して、`リソース`の中の`アイコン`を変更します。\r\n\r\n![Imgur](https://imgur.com/ofWqAxV.png)\r\n\r\n## インストーラーにアイコンを追加\r\nインストーラープロジェクトを開いて、ここから追加できます。\r\n\r\n![Imgur](https://imgur.com/VkyAMB5.png)\r\n\r\n## スタートのショートカットのアイコンを設定\r\n`User's Programs Menu`にあるショートカットのプロパティを開いて、Iconを選んで`Browse`を押します。\r\n\r\n![Imgur](https://imgur.com/KAw566a.png)\r\n\r\nそしたら、`Browse`を押して\r\n\r\n![Imgur](https://imgur.com/TxgRhwN.png)\r\n\r\nさっき追加したアイコンを選びます。\r\n\r\n![Imgur](https://imgur.com/5X0Guhe.png)\r\n\r\nそしたら、`Current icon`に追加されるので、選択して`OK`を押せば終了です。  \r\nあとはビルドして完成。\r\n\r\n## バージョンアップ？\r\nバージョンの番号をあげます。インストーラーとWPFのアプリそれぞれ変更する必要があります。   \r\nインストーラーの方はバージョンを変更すると`ProductCode`も生成し直すか聞かれるので生成し直します。\r\n\r\n![Imgur](https://imgur.com/aZmk39I.png)\r\n\r\nそれから、`RemovePreviousVersions`を`True`にすると既存のバージョンをアンインストールしてくれるようになります。\r\n\r\n# ソースコード\r\n\r\nhttps://github.com/takusan23/ItaCursor\r\n\r\nたぶん作れます。\r\n\r\n### メモ\r\n\r\n`.sln`をプロジェクトからソリューションのフォルダに移したい\r\n\r\n-> 空のソリューションを作成して、既存のプロジェクトを追加することで解決"},{"title":"WinUI 3 で出来たアプリを配布する（インストーラー / zip を作る）","link":"/posts/windows_winui3_installer_and_virtual_desktop/","markdown":"\r\nどうもこんばんわ。  \r\nサブディスプレイが壊れてしまった（なんかしばらくしないと画面が付かなくなってしまった・・・）ため、仮想デスクトップを使ってみているのですが、  \r\n**仮想デスクトップの切り替えショートカットキーが覚えられません・・・！**、なんか色々組み合わせを確かめていると正解に当たったりする。\r\nトラックパッドの場合はなんか直感的なジェスチャーがあってまぁいいかと感じなんですけどね。    \r\n\r\nうーんでも新しい`Xperia`欲しいしディスプレイ買う金ないです・・（てか高すぎ）  \r\nちなみに`Surface`をサブディスプレイとして使う方法もあるみたいですが、やっぱ遅延がなあ～～～\r\n\r\n# 本題\r\nというわけで仮想デスクトップの切り替えショートカットキーを押してくれるアプリを作りました。  \r\n`Windowsキー`長押しするとすりガラスなウィンドウが出てきて、トラックパッドのように線を描くと描いた向きに切り替わります（？）\r\n\r\n![Imgur](https://imgur.com/7XOcwZf.png)\r\n\r\nで、今気付いたのですが、長押しだと`Windowsキー`を使うショートカットキーが**動かなくなってしまった**ので、`Win+Ctrl`長押しで起動するように直しました。  \r\n`スクリーンショット`が取れなくなったのが一番でかい・・・\r\n\r\n# ソースコード\r\nhttps://github.com/takusan23/DesktopLine  \r\nhttps://github.com/takusan23/DesktopLine/releases  \r\n\r\n# 本題2\r\nたまに`WinUI 3`を使いたくなる未来の私のために、**`WinUI 3`のプロジェクトを作り、インストーラーを作る**ところまでを記録にしておこうと思います。  \r\n`UWP`みたいな`UI` ( Windows 11 のUIコンポーネント ) が使えるのですが、これは`UWP`ではない（むしろ`WPF`で`UWP`のコンポーネントが使えるイメージ）ので、  \r\n`Windowsのアプリストア`を使わずに、`インストーラー`や`zipファイル`にして普通に配布出来ます。  \r\n`P/Invoke`も普通にできます（`WPF`と同じだね）。`WPF`より機能はまだ無いかもだけど`WinUI 3`のデザインが（ここ最近のWindowsの中で）とてもいい（気がする）！！！\r\n\r\nどんなコンポーネントが使えるのかというと、以下のアプリを入れて見てみてください。すりガラス（Acrylic / Mica）なんかが少し書くだけで？使えるようになっています。  \r\n- WinUI 3 Gallery\r\n    - https://www.microsoft.com/store/productId/9P3JFPWWDZRC\r\n\r\n\r\n# 環境\r\n\r\n| なまえ          | あたい                                                    |\r\n|-----------------|-----------------------------------------------------------|\r\n| Windows         | 10 Pro ( 11 の場合は部分的に違うかも？ )                  |\r\n| Visual Studio   | 2022 Community                                            |\r\n| .NET            | 6 ( 7 でもいいはずです )                                  |\r\n| Windows App SDK | 1.2.220902.1-preview1  ( 最新版にしても問題ないはずです ) |\r\n\r\n`Visual Studio`と`.NET 6`のインストールはやっておいてください。\r\n\r\n# インストーラー vs zipファイル\r\nインストーラーだと、スタートメニューとかデスクトップに自動でショートカット追加出来たり、あと`.NET`が入ってない場合はインストールさせる機能がありますね。  \r\nzipファイルをばらまく場合は配布が楽ですね。インストーラーの機能がいらない場合はありだと思う。\r\n\r\n# Visual Studio で Windows App SDK を使う準備をする\r\nごめんなさい。。。覚えてないです。  \r\n`Visual Studio Installer`で、`.NET`のところの`Windows アプリSDK`のところにチェックマークをいれてダウンロードすればいいのかなあ。。。\r\n\r\n![Imgur](https://imgur.com/LvLMmX1.png)\r\n\r\n# Visual Studio 2022 で新しいプロジェクトを作る\r\n多分、これを選べばいいと思います。\r\n\r\n![Imgur](https://imgur.com/wpJhCk6.png)\r\n\r\nで、保存先とかをお好みで変更したあと、一番下の`ソリューションとプロジェクトを同じディレクトリに配置する`のチェックを外しておきます。  \r\nこうしておくことで以下のようなファイル構成で行くことが出来ます。  \r\n\r\n- ソリューション\r\n    - プロジェクト ( `Windows App SDK` ( WinUI 3 ) アプリケーション )\r\n        - MainWindow.xaml\r\n        - ...\r\n    - プロジェクト ( インストーラー )\r\n\r\nインストーラーは新しいプロジェクトとしてソリューションに追加する必要があるのですが（多分・・？）、チェックを入れたままだと入れる場所がないんですよね、、  \r\n\r\n- ソリューション\r\n    - プロジェクト ( `Windows App SDK` ( WinUI 3 ) アプリケーション )\r\n        - MainWindow.xaml\r\n        - プロジェクト ( インストーラー ) ← 気持ち悪いけどここに入れるしか無い？。gitとかでバージョン管理する場合は・・・\r\n\r\n（zip で配信したい場合は逆にチェックマークを入れたほうがシンプルな構成になるかも？？）\r\n\r\n![Imgur](https://imgur.com/5IB4MMp.png)\r\n\r\nあとはこれで作って、実行ボタンを押せば起動できるはず\r\n\r\n![Imgur](https://imgur.com/KEal94T.png)\r\n\r\n# MainWindow.xaml にワナがある （文字コード変更）\r\n`WinUI 3 Gallery`を見てもらえるとわかるのですが、最初からきれいなコンポーネントがあるんですよね。  \r\nこんな風に少し書くだけできれいなUIが作れます。\r\n\r\n```xml\r\n<!-- Copyright (c) Microsoft Corporation. All rights reserved. -->\r\n<!-- Licensed under the MIT License. See LICENSE in the project root for license information. -->\r\n\r\n<Window\r\n    x:Class=\"ExampleWinUI3.MainWindow\"\r\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\r\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\r\n    xmlns:local=\"using:ExampleWinUI3\"\r\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n    mc:Ignorable=\"d\">\r\n\r\n\r\n    <NavigationView x:Name=\"nvSample\">\r\n        <NavigationView.MenuItems>\r\n            <NavigationViewItem Icon=\"Play\" Content=\"再生\" />\r\n            <NavigationViewItem Icon=\"Save\" Content=\"保存\" />\r\n            <NavigationViewItem Icon=\"Refresh\" Content=\"リロード\" />\r\n            <NavigationViewItem Icon=\"Download\" Content=\"ダウンロード\" />\r\n        </NavigationView.MenuItems>\r\n\r\n        <StackPanel Orientation=\"Vertical\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\r\n            <Button Padding=\"10\" x:Name=\"myButton\" Click=\"myButton_Click\">Click Me</Button>\r\n            <ProgressRing Padding=\"10\" IsActive=\"True\" Background=\"LightGray\"/>\r\n            <ToggleSwitch Padding=\"10\" AutomationProperties.Name=\"simple ToggleSwitch\"/>\r\n        </StackPanel>\r\n\r\n    </NavigationView>\r\n</Window>\r\n```\r\n\r\nなんですけど、設定を変えないと日本語が文字化けしてしまいます・・・\r\n\r\n![Imgur](https://imgur.com/FqAaL6S.png)\r\n\r\n修正方法は前にも書いたのですが、`MainWindow.xaml`を`BOM付き UTF-8`にすれば修正可能です。  \r\n名前をつけて保存を選んで\r\n\r\n![Imgur](https://imgur.com/xjXabZk.png)\r\n\r\nエンコード付きで保存を押します\r\n\r\n![Imgur](https://imgur.com/zvD3bXm.png)\r\n\r\n`UTF-8 シグネチャ付き`を選びます\r\n\r\n![Imgur](https://imgur.com/dww7gDo.png)\r\n\r\nこれで治りました。やったー\r\n\r\n![Imgur](https://imgur.com/G28D8dh.png)\r\n\r\n# インストーラー / zipファイル を作る\r\n配布する前まで頑張って作ってください。。  \r\nで、ここからは配布の話を残して置こうと思います\r\n\r\n## 参考\r\nthx!!!!!\r\n\r\nhttps://learn.microsoft.com/ja-jp/windows/apps/package-and-deploy/self-contained-deploy/deploy-self-contained-apps\r\nhttps://www.ipentec.com/document/csharp-winui3-create-self-contained-executables-application\r\n\r\n## その前に exe で配信できる形式にする\r\n~~どうやらMSは未だに`MSIX`に強いこだわりがあるらしく？~~ デフォルトだと`exe`にできません。  \r\n`dotnet publish`を使ったとしても、設定を変更しないと起動できない`exe`が生成されてしまいます。。困った！\r\n\r\n```plaintext\r\n障害バケット 1463075854298809095、種類 4\r\nイベント名: APPCRASH\r\n応答: 使用不可\r\nCab ID: 0\r\n\r\n問題の署名:\r\nP1: ExampleWinUI3.exe\r\n...\r\n```\r\n\r\n![Imgur](https://imgur.com/MS2hqyu.png)\r\n\r\n（`Windows`だとアプリが起動できないログが`イベントビューアー`というアプリに保存されます。）\r\n\r\nこれを治すためには、プロジェクトを押して、`プロジェクト ファイルの編集`を押します。\r\n\r\n![Imgur](https://imgur.com/04nGhnM.png)\r\n\r\nそしたら、以下の二行を`<PropertyGroup>`の中に足します。以下のように\r\n\r\n```xml\r\n<WindowsAppSDKSelfContained>true</WindowsAppSDKSelfContained>\r\n<WindowsPackageType>None</WindowsPackageType>\r\n```\r\n\r\n![Imgur](https://imgur.com/JnyEk77.png)\r\n\r\nまた、これを記述したあとは、以下の`Unpackaged`の方を実行する必要があります。\r\n\r\n![Imgur](https://imgur.com/8d1lZOc.png)\r\n\r\n## zip で配布する\r\nお手軽ですが、スタートメニューに自動で追加とかは出来ません。（インストーラーが必要です。）  \r\nソリューションを右クリックして、発行を押します。\r\n\r\n![Imgur](https://imgur.com/vIOvS6i.png)\r\n\r\n`x64`でいいはず。\r\n\r\n![Imgur](https://imgur.com/krNSydi.png)\r\n\r\n`すべての設定を表示`を押して、構成を `Release | x64`、配置モードを`フレームワーク依存`、ファイルの公開オプションを開き、`単一ファイルの作成`へチェックマークを入れるといいと思います。  \r\n自己完結だと`.NET`が`exe`の中に入るため、`.NET`がインストールされてなくても起動できる一方、バイナリサイズがとても大きくなってしまいます。  \r\n`単一ファイル`にチェックすることで、`WPF`の時は`exe一個`にまとめることが出来たのですが、`WindowsAppSDK`ではなんか出来ないっぽいです。。。が一応チェックを入れています。\r\n\r\n![Imgur](https://imgur.com/vxJUHwY.png)\r\n\r\nあとは`発行を押します`\r\n\r\n![Imgur](https://imgur.com/x3VuimK.png)\r\n\r\n終わったら開いてみましょう。どうですか？開けましたか！？！？！？\r\n\r\n![Imgur](https://imgur.com/uBW8rkA.png)\r\n\r\nわーい 🎉🎉🎉\r\n\r\n`zip`ファイルで配布する場合は、`exe`があるフォルダを全部圧縮して、適当なところで公開すればいいと思います。  \r\n\r\n![Imgur](https://imgur.com/6NQwLow.png)\r\n\r\n## インストーラーで配布する\r\n`WPF`版もあります : https://takusan.negitoro.dev/posts/windows_dot_net5_wpf_making_installer/\r\n\r\n`Visual Studio`に拡張機能を入れます。  \r\nhttps://marketplace.visualstudio.com/items?itemName=VisualStudioClient.MicrosoftVisualStudio2022InstallerProjects  \r\n\r\n![Imgur](https://imgur.com/fyrpu84.png)\r\n\r\n### インストーラーを作ります\r\nソリューションを右クリックしてプロジェクトを追加します。\r\n\r\n![Imgur](https://imgur.com/WkmA5P8.png)\r\n\r\n`Setup Project`を押します\r\n\r\n![Imgur](https://imgur.com/Orx43SZ.png)\r\n\r\n名前をよしなに変えて done\r\n\r\n![Imgur](https://imgur.com/PHXDCzf.png)\r\n\r\nこんな感じになるはず\r\n\r\n![Imgur](https://imgur.com/ZKho35D.png)\r\n\r\n### 配布設定をする\r\nここの手順は`zipファイル`で配布するのと同じですね。  \r\n`WinUI 3`プロジェクトを右クリックして`発行`を押します。\r\n\r\n![Imgur](https://imgur.com/lbXgO7x.png)\r\n\r\n`x64`にします（最近はほとんど`x64`でいいはず）\r\n\r\n![Imgur](https://imgur.com/HmD4hpN.png)\r\n\r\n`すべての設定を表示`から、以下のように変更します。\r\n\r\n- 構成\r\n    - `Release | x64`\r\n- 配置モード\r\n    - `フレームワーク依存`\r\n        - `自己完結`だと`.NET`が`.exe`の中に入るため、バイナリサイズがデカくなります。が、`.NET`を入れなくても起動できるメリットがあります。\r\n- ファイルの構成オプション の 単一ファイルの作成\r\n    - どっちでもいいはず？\r\n\r\n![Imgur](https://imgur.com/eH7On5E.png)\r\n\r\n出来たら`保存`してください。\r\n\r\n### インストーラーに配布するファイルを設定する\r\n参考：https://learn.microsoft.com/en-us/visualstudio/deployment/installer-projects-net-core?view=vs-2019\r\n\r\nソリューションエクスプローラーから、さっきつくったインストーラーを右クリックして、`File System`を開きます。\r\n\r\n![Imgur](https://imgur.com/ZajMDN9.png)\r\n\r\n`Application Folder`を選び、`プロジェクト出力`を押します。\r\n\r\n![Imgur](https://imgur.com/hd4UGFL.png)\r\n\r\n`項目の公開`、を選んで`OK`します\r\n\r\n![Imgur](https://imgur.com/JRzkQ1W.png)\r\n\r\n### 項目の公開と WinUI 3 の成果物を紐付ける\r\nソリューションエクスプローラーから、さっきつくった`項目の公開`を右クリックして`プロパティ`を押します。\r\n\r\n![Imgur](https://imgur.com/O4IOuOp.png)\r\n\r\n`プロパティ`の中の`PublishProperties`のドロップダウンメニューを押すと、なんか3つくらいでてくると思うので、`x64`と書いてある方を選びます。\r\n\r\n![Imgur](https://imgur.com/xTWghXF.png)\r\n\r\n\r\n### その他の値もセットする\r\nソリューションエクスプローラーで、インストーラープロジェクトをクリックし、下のプロパティから、  \r\n`TargetPlatform`を`x64`にします。\r\n\r\n![Imgur](https://imgur.com/Zr71CAO.png)\r\n\r\nまた、以下の値も変えておくと良いでしょう。\r\n- ProductName\r\n    - アプリの名前\r\n- Another\r\n    - 作者\r\n- Title\r\n    - インストーラーの名前\r\n- Manufactor\r\n    - 作者？\r\n\r\n![Imgur](https://imgur.com/b9f5lva.png)\r\n\r\n### インストーラーをつくる\r\nやる必要があるのか知りませんが、実行ボタンの隣りにあるドロップダウンメニュー、`Release`と`x64`にしておきました。\r\n\r\n![Imgur](https://imgur.com/mZnQnBB.png)\r\n\r\nあとは、ソリューションエクスプローラーのインストーラープロジェクトを右クリックして、`ビルド`を押すことで開始できます。\r\n\r\n![Imgur](https://imgur.com/rbTE2Do.png)\r\n\r\nはい！！！\r\n\r\n![Imgur](https://imgur.com/5ILfBZx.png)\r\n\r\nこんな感じにインストーラーが出来ているはず  \r\n\r\n![Imgur](https://imgur.com/qekx5gU.png)\r\n\r\n`UAC`たまによく気付かないんだけど私だけ？\r\n\r\n![Imgur](https://imgur.com/B16QsQt.png)\r\n\r\nちゃんとアンインストールもできます。\r\n\r\n![Imgur](https://imgur.com/IQqIjOT.png)\r\n\r\n### スタートメニューに表示させる\r\n`File System`から、`User's Programs Menu`を押し右クリックして`新しいショートカットの作成`を押します。  \r\n\r\n![Imgur](https://imgur.com/clwg7Je.png)\r\n\r\n`Application Folder`から、`項目の公開`を選び`OK`します。\r\n\r\n![Imgur](https://imgur.com/OHIRIP2.png)\r\n\r\n名前はプロジェクトから変えることが出来ます。\r\n\r\n![Imgur](https://imgur.com/wg5lRo8.png)\r\n\r\nこれでスタートメニューに出てくるはず\r\n\r\n![Imgur](https://imgur.com/8cmpOjR.png)\r\n\r\n### アイコン変更\r\n`WPF`のときとほぼ同じですが・・・  \r\n`GIMP`とかを使って`128x128`の`ico`ファイルを作ってください。\r\n\r\n![Imgur](https://imgur.com/cDPEUYA.png)\r\n\r\n`WinUI 3`のプロジェクトを右クリックして、`プロパティ`に進みます。  \r\n\r\n![Imgur](https://imgur.com/KCKXOsQ.png)\r\n\r\nリソースを押して、まだ作っていない場合は`作成する/開く`を押します\r\n\r\n![Imgur](https://imgur.com/YEWbgAl.png)\r\n\r\nそしたらここに`.ico`を投げ込みます。\r\n\r\n![Imgur](https://imgur.com/X0gNVt9.png)\r\n\r\n![Imgur](https://imgur.com/ZwthLDj.png)\r\n\r\nまた、ソリューションエクスプローラーから、先程追加した`ico`のプロパティを開き、`ビルドアクション`を`リソース`にします。\r\n\r\n![Imgur](https://imgur.com/6lwQMAv.png)\r\n\r\n#### アプリ自体のアイコン\r\n\r\nアプリのアイコンの設定は、さっきの`WinUI 3`のプロパティのここです。\r\n\r\n![Imgur](https://imgur.com/20ir0jH.png)\r\n\r\n変わってるはず？\r\n\r\n![Imgur](https://imgur.com/PKdTDUs.png)\r\n\r\nこっちを変更するのはまた別に `C#` コードを書かないといけないそうです・・・  \r\n参考 : https://github.com/microsoft/WindowsAppSDK/issues/1914\r\n\r\n![Imgur](https://imgur.com/8IsyRHI.png)\r\n\r\n#### ショートカットのアイコン\r\nインストーラープロジェクトの`File System`より、`Application Folder`を右クリックして、`ファイル`を押します。\r\n\r\n![Imgur](https://imgur.com/W6meUvY.png)\r\n\r\nあとはさっき追加した`ico`を探して追加します。\r\n\r\n![Imgur](https://imgur.com/7RNmmUA.png)\r\n\r\nそのあと、`User's Programs Menu`より先程作ったショートカットを選び、プロパティの`Icon`にあるドロップダウンメニューをおし、`Browse...`を押します。\r\n\r\n![Imgur](https://imgur.com/LbhjU4e.png)\r\n\r\nでてきたら、`Application Folder`にさっき追加した`ico`があると思うので、それを選べばOKです！\r\n\r\n![Imgur](https://imgur.com/UVG2J8a.png)\r\n\r\nこれで再度ビルドしてみて、実際にインストールするとこうなるはず！  \r\nどうでしょう？？？？\r\n\r\n![Imgur](https://imgur.com/FjY3IWb.png)\r\n\r\n# おわりに\r\nここまでのソースコードです。  \r\n`zip`でも`インストーラー`でも作れると思います。\r\n\r\nhttps://github.com/takusan23/ExampleWinUI3Installer\r\n\r\nと、、思ったんですけど`.pubxm`が追跡対象外だった...\r\n\r\n![Imgur](https://imgur.com/GXxdRWt.png)\r\n\r\n# おわりに\r\nマウスのショートカットキー割り当て機能でよくない？？？？ってインストーラー作ってるときに思いました。\r\n\r\n# おわりに2\r\n`Next.js`の`App Router`移行をそろそろやりたいなと思っています。"},{"title":"WindowsAppSDK の WinUI 3 に入門したら日本語が文字化けして出鼻をくじかれた話","link":"/posts/windows_winui3_xml_charset/","markdown":"\r\nどうもこんばんわ  \r\n記事冒頭のゲーム感想で使うスクリーンショットを取るアプリを作ろうと思い、  \r\nせっかくなら現代風なUIを使いたいと思い`WinUI 3`を触ったら、  \r\n日本語が文字化けしてなかなか原因がわからなかった話です。\r\n\r\n![Imgur](https://imgur.com/h7DbjBj.png)\r\n\r\n# 解決方法\r\nGitHubのIssueにもそれっぽいのがなく、ふと`VSCode`で`.xaml`開いた際に気付きました。  \r\n**UTF-8 with BOM**の文字を！！！！！！！！\r\n\r\nというわけで、`MainWindow.xaml`を`BOM付きの UTF-8`で保存すると文字化けを直せます！！！  \r\nなんと最初から入っている`MainWindow.xaml`は`BOM無し UTF-8`で保存されていました！は？\r\n\r\n名前をつけて保存を選びます\r\n\r\n![Imgur](https://imgur.com/9AZxQFd.png)\r\n\r\n保存先は変えずに、ドロップダウンメニューの、`エンコード付きで保存`を選択します。\r\n\r\n![Imgur](https://imgur.com/YebTS2W.png)\r\n\r\nあとは`BOM付き UTF-8`にすればいいです。  \r\n`UTF-8 シグネチャ付き`ってやつを選べばいいです。\r\n\r\n![Imgur](https://imgur.com/1oImZWV.png)\r\n\r\nこれで文字化けが直っているはずです。よかったよかった\r\n\r\n![Imgur](https://imgur.com/xi02yQq.png)\r\n\r\n以上です。"},{"title":"WPFのViewModelのメモ","link":"/posts/windows_wpf_viewmodel_memo/","markdown":"どうもこんにちわ。  \nD.C.4 PH攻略してますが曲がいいですね。OP曲のCDはよ  \n\n# 本題\nWPFでViewModelを使ったときにハマったメモ。  \nWindows 11のアプリストアではexeが提出できるようになるらしいですよ？(なお開発者登録にクレカが必要)  \n**Windows 11 tmp 2.0 bypass で検索検索ぅ**\n\n# 環境\n\n| なまえ | あたい |\n|--------|--------|\n| .NET   | 5      |\n\n## ViewからViewModelへ。ボタン押したときの処理をViewModelでする場合\n\nViewModel、レイアウトは以下のようにします。\n\n```xml\n<Window x:Class=\"WPFViewModel.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WPFViewModel\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n\n    <Window.DataContext>\n        <local:MainWindowViewModel/>\n    </Window.DataContext>\n\n    <StackPanel Orientation=\"Vertical\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\n        <Button>Googleを開く</Button>\n    </StackPanel>\n</Window>\n```\n\n```cs\nnamespace WPFViewModel\n{\n    class MainWindowViewModel\n    {\n\n\n    }\n}\n```\n\nボタン押したときの処理をViewModelに書く場合はまず、  \n`ICommand`を実装したクラスを用意する必要があります。ViewModel内のメソッドを直接指定みたいなことは出来ない模様。  \n`ICommand`の中に処理を書いてしまうと、他で使えなくなってしまうので、押したときに呼ばれる処理（関数）をクラス作成時のコンストラクタに取ります。  \n\n```cs\nusing System;\nusing System.Windows.Input;\n\nnamespace WPFViewModel\n{\n    class ViewModelButtonClick : ICommand\n    {\n        public event EventHandler CanExecuteChanged;\n\n        private Action _click;\n\n        public ViewModelButtonClick(Action click)\n        {\n            _click = click;\n        }\n\n        public bool CanExecute(object parameter)\n        {\n            return true;\n        }\n\n        public void Execute(object parameter)\n        {\n            _click();\n        }\n    }\n}\n```\n\nそしたら、ViewModel、レイアウトを書きます。`{ get; }`を書き忘れないようにしてください。\n\n```cs\nusing System.Diagnostics;\n\nnamespace WPFViewModel\n{\n    class MainWindowViewModel\n    {\n\n        /// <summary>\n        /// ボタンを押したとき\n        /// </summary>\n        public ViewModelButtonClick OpenGoogle { get; } = new ViewModelButtonClick(() =>\n        {\n            // 押したときに呼ばれる\n            ProcessStartInfo psi = new ProcessStartInfo\n              {\n                  FileName = \"https://google.com\",\n                  UseShellExecute = true\n              };\n              Process.Start(psi);\n        });\n\n    }\n}\n```\n\n```xml\n<Window x:Class=\"WPFViewModel.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WPFViewModel\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n\n    <Window.DataContext>\n        <local:MainWindowViewModel/>\n    </Window.DataContext>\n\n    <StackPanel Orientation=\"Vertical\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\n        <Button Command=\"{Binding OpenGoogle}\">Googleを開く</Button>\n    </StackPanel>\n</Window>\n```\n\nこれで実行すると、Googleがブラウザで開くと思います。\n\n# ViewModelからViewへ。値の変更を通知する場合\nAndroidのLiveData的な。  \n\nレイアウト、ViewModelは以下のように\n\n```xml\n<Window x:Class=\"WPFViewModel.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WPFViewModel\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n\n    <Window.DataContext>\n        <local:MainWindowViewModel/>\n    </Window.DataContext>\n\n    <StackPanel Orientation=\"Vertical\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\n        <TextBlock Text=\"\" TextAlignment=\"Center\" />\n        <Button Command=\"\">カウントアップ</Button>\n    </StackPanel>\n</Window>\n```\n\n```cs\nnamespace WPFViewModel\n{\n    class MainWindowViewModel\n    {\n\n        \n    }\n}\n```\n\nこれもまず`InotifyProrertyChanged`を実装したクラスを作成します。  \n`<T>`ってのはジェネリクスってやつで、`<>`の中に入れるべき型をインスタンス生成時に決定する機能です（？？？）  \n`<string>`と書いてしまうと、今度数値を扱うときに別にクラスを作成しないといけないですよね？。それを回避する機能です。まぁコピペして使えばいいと思うよ。\n\n```cs\nnamespace WPFViewModel\n{\n    class ViewModelValueChanged<T> : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        private void RaisePropertyChanged([CallerMemberName] string propertyName = null)\n        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n\n        private T _value;\n\n        public T value\n        {\n            get => _value;\n            set\n            {\n                _value = value;\n                RaisePropertyChanged();\n                RaisePropertyChanged(nameof(_value));\n            }\n        }\n\n        public ViewModelValueChanged(T value)\n        {\n            _value = value;\n        }\n\n    }\n}\n```\n\nそれから、ボタンを押したときの処理をViewModelに書きたいので、`ICommand`を実装したクラスを用意します。これはさっきのを使いまわします。\n\nできたらViewModel、レイアウトは以下のように。\n\n```cs\nnamespace WPFViewModel\n{\n    class MainWindowViewModel\n    {\n\n        /// <summary>\n        /// カウンター\n        /// </summary>\n        public ViewModelValueChanged<int> Count { get; } = new ViewModelValueChanged<int>(0);\n\n        /// <summary>\n        /// カウントアップボタンを押したとき\n        /// </summary>\n        public ViewModelButtonClick Countup { get; }\n\n        public MainWindowViewModel()\n        {\n            Countup = new ViewModelButtonClick(() =>\n            {\n                Count.value++;\n            });\n        }\n\n    }\n}\n```\n\n```xml\n<Window x:Class=\"WPFViewModel.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:local=\"clr-namespace:WPFViewModel\"\n        mc:Ignorable=\"d\"\n        Title=\"MainWindow\" Height=\"450\" Width=\"800\">\n\n    <Window.DataContext>\n        <local:MainWindowViewModel/>\n    </Window.DataContext>\n\n    <StackPanel Orientation=\"Vertical\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\n        <TextBlock Text=\"{Binding Count.value ,UpdateSourceTrigger=PropertyChanged}\" TextAlignment=\"Center\" />\n        <Button Command=\"{Binding Countup}\">カウントアップ</Button>\n    </StackPanel>\n</Window>\n```\n\n以上です。\n\n![Imgur](https://imgur.com/1ybF5lI.png)\n\n# おわりに\nソースコード置いておきます。  \n\nhttps://github.com/takusan23/WPFViewModel"},{"title":"Xperia Z5 Compact 海外版にカスタムROMを入れるまで","link":"/posts/xperia_z5_compact_root/","markdown":"夜勤しんど\r\n\r\n# 本題\r\nE5823(Xperia Z5 Compact 海外版)へカスタムROMを入れて遊ぶ。  \r\nワールドモバイルで三千円ぐらいだった\r\n\r\n# 環境\r\n先人に乗っかっていく\r\n\r\nhttps://abc10946.hateblo.jp/entry/2020/07/12/234733\r\n\r\n# TAパーティションのバックアップ\r\nカメラの画質が落ちるらしい。メイン機にはならないし、どうでもいい気がするけど一応バックアップを取っておく。\r\n\r\n## Androidのダウングレード\r\nLollipop(5)へ戻す必要があるみたいなので、`ftfファイル`をXDAからダウンロードしてきます。  \r\n\r\nhttps://forum.xda-developers.com/t/how-to-backup-restore-ta-partition-and-root-the-device-detailed-guide.3479532/\r\n\r\nそれと並行して\r\n\r\n## FlashToolをダウンロード\r\nトレントが使えるならトレント経由でDLしたほうがいいと思います。\r\n\r\nダウンロードできたら、（保存先変えてなければ）Cドライブの中に`Flashtool`フォルダがあるので、その中の`drivers`フォルダ内にある`Flashtool-drivers.exe`を起動してドライバを入れるんだけど、  \r\n署名がないドライバはそのままではインストールできないので、Windowsの設定→更新とセキュリティ→回復→PCの起動をカスタマイズするにある「今すぐ再起動」をおして、  \r\nトラブルシューティング→詳細オプション→スタートアップ設定  \r\nへ進み、  \r\n再起動で立ち上がったら`7`を選んでWindowsを起動させると、ドライバの署名を無視してドライバを入れることができるようになります。\r\n\r\n## ﾌﾗｯｼｭ!\r\n`FlashTool`を起動して、稲妻マークを押し\r\n\r\n![Imgur](https://imgur.com/oR720C9.png)\r\n\r\n`Flashmode`を選んで`Ok`を押します。\r\n\r\n![Imgur](https://imgur.com/UPAuB13.png)\r\n\r\nそうするとこんなウィンドウが出るので、`Source folder`にはダウンロードした`tftファイル`が置いてあるフォルダを指定して、  \r\nあと`Wipe`には全部チェックを入れます。  \r\n\r\n![Imgur](https://imgur.com/rR8kPW9.png)\r\n\r\nできたら`Flash`をおして準備を始めます。\r\n\r\nこの画面に進めたら、\r\n\r\n![Imgur](https://imgur.com/qPr31lK.png)\r\n\r\nXperia（Sony風に言うなら機器）の電源を切って、ボリュームダウンキーを押しながらUSBケーブルでPCとつなぎます。\r\n\r\nあとは待機です。\r\n\r\n`INFO  - Flashing finished.`と出れば成功です。  \r\n私は一回目はなんか失敗してデバイスを選ぶダイアログが出て、その後もう一度やると出来たのでまあよくわからん。\r\n\r\n![Imgur](https://imgur.com/zmAeUhj.png)\r\n\r\n成功したらUSBケーブルを外して起動して見ましょう。多分長い。\r\n\r\n## TAパーティションのバックアップ\r\n\r\nhttps://forum.xda-developers.com/t/need-iovyroot-v0-3-or-v0-4-please.3526743/\r\n\r\nここからダウンロードできるらしいので使わせてもらいます。\r\n\r\nダウンロードしたら解凍して、`tabackup.bat`を実行します。  \r\nなんかUSBデバッグを付けたら`imgファイル`が手に入りました。はい  \r\nファイルサイズは`2MB`らしいよ。\r\n\r\n## ブートローダーのアンロック\r\n- 開発者向けオプションのOEMロック解除を有効にします。\r\n- https://developer.sony.com/develop/open-devices/get-started/unlock-bootloader/\r\n    - ここを開きます\r\n- 一番下までスクロールして、デバイスをZ5C、IMEIを入力します。\r\n\r\nできたら、解除コードが払い出されるのでコピーして、コマンドプロンプトを開きます。\r\n\r\n開いたら、スマホとパソコンをボリューム**アップキー**を押しながらUSBでつないで、通知ランプが青色に光ることを確認してください。\r\n\r\nコマンドプロンプトで、`fastboot devices`を叩くと値が帰ってくることも確認してください。\r\n\r\n接続できたら、  \r\n\r\n```\r\nfastboot oem unlock 0x解除コード\r\n```\r\n\r\nをコマンドプロンプトへ入力します。解除コードの前に`0x`を入力しておく必要があるので注意してください。\r\n\r\n```\r\nOKAY [  0.693s]\r\nFinished. Total time: 0.695s\r\n```\r\n\r\nこれで解除できました。DRMキー消失。\r\n\r\n## TWRPの導入\r\n\r\nここからが楽しいところなんだけど、ここで躓いたので記事を書いている。  \r\n結論を言うと、Android 7にアップデートしたあとにTWRPを導入する必要があるみたいなのですが、  \r\nなぜか`Xperifirm`が4んでいて`tft`が落とせなくなっています。  \r\n\r\n### Android 7へアップデート\r\nじゃあアップデートすればいいじゃんって話なんですが、BLUするとOTAでのアップデートが出来なくなるそうです。  \r\nなので有志が上げているAndroid 7の`tft`を持ってきます。  \r\n\r\nhttps://forum.xda-developers.com/t/ftf-newest-android-7-1-1-for-xperia-z5c-e5823-32-4-a-0-160.3628734/\r\n\r\nダウンロードしたら、`tft`をFlashtoolで焼きます。\r\n\r\n### TWRPの導入\r\n\r\nこれで`TWRP`が導入できるようになります。  \r\nつい最近？公開された`TWRP`があるので導入しましょう。  \r\n\r\nhttps://forum.xda-developers.com/t/recovery-unofficial-twrp-3-5-2-for-the-xperia-z5-compact-suzuran.4213077/\r\n\r\nダウンロードしたら、Xperiaの電源を切って、ボリュームアップキーを押しながらUSBを指すことで通知LEDが青色に光ります。  \r\n\r\nこの状態でコマンドプロンプトを立ち上げ、以下のコマンドを入れます。  \r\n\r\n```\r\nfastboot flash recovery TWRP_3.5.2_9-0-recovery_suzuran_2021-04-11.img\r\n```\r\n\r\n導入できたらUSBを外して、電源ボタンとボリュームダウンキーをバイブが振動するまで押すことでカスタムリカバリへ入ることが出来ます。\r\n\r\n## これでおしまい\r\n\r\nあとは好きなカスタムROMを入れればいいと思います。  \r\n今回はこれでも  \r\n\r\nhttps://forum.xda-developers.com/t/rom-11-x-havoc-os-4-3-unofficial-suzuran.4249577/\r\n\r\nROM本体と、PlayStoreが必要なら`Gapps`、あとRootが欲しければ`Magisk`をそれぞれPCにダウンロードしておきます。  \r\n\r\n(もしAndroid11で、64ビットなSoCなら(たしかSnapdragon810以降は64ビット))Gappsはここから https://sourceforge.net/projects/opengapps/files/arm64/test/20210130/  \r\n最低限入ってるpicoを選んでおけばいいでしょう。むしろ欲張るとなんか失敗しそう（小並感）\r\n\r\nMagiskは https://github.com/topjohnwu/Magisk/releases からAPKをダウンロードして、その後拡張子を`apk`から`zip`に変えておきます。  \r\n\r\n用意できたら、カスタムリカバリへ入って、`Wipe`を選び、`Format Data`をしておきます。`yes`と入力することで始まります。\r\n\r\n次にダウンロードしたファイルをXperiaへ転送します。ホーム画面に戻り、`Mount`を選び`Enable MTP`を選びパソコンと接続します。\r\n\r\nそうしたらWindowsのエクスプローラーからファイルを転送できるようになるので各Zipを転送します。\r\n\r\n![Imgur](https://imgur.com/EEH5Rfa.png)\r\n\r\n終わったら最後、ホーム画面へ戻り、`Install`を押して、  \r\n- ROMのインストール\r\n- Gappsのインストール\r\n- Magiskのインストール\r\n\r\nをします。Android楽しい。3つダウンロードできたら、`Reboot system`を選んでシステムを起動させちゃいましょう！\r\n\r\n起動できれば成功です。お疲れさまでした。\r\n\r\nPlayStoreでGoogleアプリを入れておけばGoogle DiscoverとかAt a Glanceが使えるようになると思いますので入れておけばいいと思います。\r\n\r\n以上です。\r\n\r\n# 終わりに\r\nXperia Z5Cの背面すべすべ？しててすき  "}]